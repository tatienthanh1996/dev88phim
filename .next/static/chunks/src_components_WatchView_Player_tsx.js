/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["src_components_WatchView_Player_tsx"],{

/***/ "./node_modules/hls.js/dist/hls.js":
/*!*****************************************!*\
  !*** ./node_modules/hls.js/dist/hls.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("typeof window !== \"undefined\" &&\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_562__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_562__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_562__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_562__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_562__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_562__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_562__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_562__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_562__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_562__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_562__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_562__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_562__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_562__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_562__.p = \"/dist/\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_562__(__nested_webpack_require_562__.s = \"./src/hls.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/eventemitter3/index.js\":\n/*!*********************************************!*\\\n  !*** ./node_modules/eventemitter3/index.js ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/url-toolkit/src/url-toolkit.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/url-toolkit/src/url-toolkit.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// see https://tools.ietf.org/html/rfc1808\n\n(function (root) {\n  var URL_REGEX =\n    /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n  var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n\n  var URLToolkit = {\n    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n    // E.g\n    // With opts.alwaysNormalize = false (default, spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n    // With opts.alwaysNormalize = true (not spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n    buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n      opts = opts || {};\n      // remove any remaining space and CRLF\n      baseURL = baseURL.trim();\n      relativeURL = relativeURL.trim();\n      if (!relativeURL) {\n        // 2a) If the embedded URL is entirely empty, it inherits the\n        // entire base URL (i.e., is set equal to the base URL)\n        // and we are done.\n        if (!opts.alwaysNormalize) {\n          return baseURL;\n        }\n        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n        if (!basePartsForNormalise) {\n          throw new Error('Error trying to parse base URL.');\n        }\n        basePartsForNormalise.path = URLToolkit.normalizePath(\n          basePartsForNormalise.path\n        );\n        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n      }\n      var relativeParts = URLToolkit.parseURL(relativeURL);\n      if (!relativeParts) {\n        throw new Error('Error trying to parse relative URL.');\n      }\n      if (relativeParts.scheme) {\n        // 2b) If the embedded URL starts with a scheme name, it is\n        // interpreted as an absolute URL and we are done.\n        if (!opts.alwaysNormalize) {\n          return relativeURL;\n        }\n        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n        return URLToolkit.buildURLFromParts(relativeParts);\n      }\n      var baseParts = URLToolkit.parseURL(baseURL);\n      if (!baseParts) {\n        throw new Error('Error trying to parse base URL.');\n      }\n      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n        baseParts.netLoc = pathParts[1];\n        baseParts.path = pathParts[2];\n      }\n      if (baseParts.netLoc && !baseParts.path) {\n        baseParts.path = '/';\n      }\n      var builtParts = {\n        // 2c) Otherwise, the embedded URL inherits the scheme of\n        // the base URL.\n        scheme: baseParts.scheme,\n        netLoc: relativeParts.netLoc,\n        path: null,\n        params: relativeParts.params,\n        query: relativeParts.query,\n        fragment: relativeParts.fragment,\n      };\n      if (!relativeParts.netLoc) {\n        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n        // (if any) of the base URL.\n        builtParts.netLoc = baseParts.netLoc;\n        // 4) If the embedded URL path is preceded by a slash \"/\", the\n        // path is not relative and we skip to Step 7.\n        if (relativeParts.path[0] !== '/') {\n          if (!relativeParts.path) {\n            // 5) If the embedded URL path is empty (and not preceded by a\n            // slash), then the embedded URL inherits the base URL path\n            builtParts.path = baseParts.path;\n            // 5a) if the embedded URL's <params> is non-empty, we skip to\n            // step 7; otherwise, it inherits the <params> of the base\n            // URL (if any) and\n            if (!relativeParts.params) {\n              builtParts.params = baseParts.params;\n              // 5b) if the embedded URL's <query> is non-empty, we skip to\n              // step 7; otherwise, it inherits the <query> of the base\n              // URL (if any) and we skip to step 7.\n              if (!relativeParts.query) {\n                builtParts.query = baseParts.query;\n              }\n            }\n          } else {\n            // 6) The last segment of the base URL's path (anything\n            // following the rightmost slash \"/\", or the entire path if no\n            // slash is present) is removed and the embedded URL's path is\n            // appended in its place.\n            var baseURLPath = baseParts.path;\n            var newPath =\n              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +\n              relativeParts.path;\n            builtParts.path = URLToolkit.normalizePath(newPath);\n          }\n        }\n      }\n      if (builtParts.path === null) {\n        builtParts.path = opts.alwaysNormalize\n          ? URLToolkit.normalizePath(relativeParts.path)\n          : relativeParts.path;\n      }\n      return URLToolkit.buildURLFromParts(builtParts);\n    },\n    parseURL: function (url) {\n      var parts = URL_REGEX.exec(url);\n      if (!parts) {\n        return null;\n      }\n      return {\n        scheme: parts[1] || '',\n        netLoc: parts[2] || '',\n        path: parts[3] || '',\n        params: parts[4] || '',\n        query: parts[5] || '',\n        fragment: parts[6] || '',\n      };\n    },\n    normalizePath: function (path) {\n      // The following operations are\n      // then applied, in order, to the new path:\n      // 6a) All occurrences of \"./\", where \".\" is a complete path\n      // segment, are removed.\n      // 6b) If the path ends with \".\" as a complete path segment,\n      // that \".\" is removed.\n      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n      // complete path segment not equal to \"..\", are removed.\n      // Removal of these path segments is performed iteratively,\n      // removing the leftmost matching pattern on each iteration,\n      // until no matching pattern remains.\n      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n      // complete path segment not equal to \"..\", that\n      // \"<segment>/..\" is removed.\n      while (\n        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length\n      ) {}\n      return path.split('').reverse().join('');\n    },\n    buildURLFromParts: function (parts) {\n      return (\n        parts.scheme +\n        parts.netLoc +\n        parts.path +\n        parts.params +\n        parts.query +\n        parts.fragment\n      );\n    },\n  };\n\n  if (true)\n    module.exports = URLToolkit;\n  else {}\n})(this);\n\n\n/***/ }),\n\n/***/ \"./node_modules/webworkify-webpack/index.js\":\n/*!**************************************************!*\\\n  !*** ./node_modules/webworkify-webpack/index.js ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_20895__) {\n\nfunction webpackBootstrapFunc (modules) {\n/******/  // The module cache\n/******/  var installedModules = {};\n\n/******/  // The require function\n/******/  function __nested_webpack_require_21073__(moduleId) {\n\n/******/    // Check if module is in cache\n/******/    if(installedModules[moduleId])\n/******/      return installedModules[moduleId].exports;\n\n/******/    // Create a new module (and put it into the cache)\n/******/    var module = installedModules[moduleId] = {\n/******/      i: moduleId,\n/******/      l: false,\n/******/      exports: {}\n/******/    };\n\n/******/    // Execute the module function\n/******/    modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_21073__);\n\n/******/    // Flag the module as loaded\n/******/    module.l = true;\n\n/******/    // Return the exports of the module\n/******/    return module.exports;\n/******/  }\n\n/******/  // expose the modules object (__webpack_modules__)\n/******/  __nested_webpack_require_21073__.m = modules;\n\n/******/  // expose the module cache\n/******/  __nested_webpack_require_21073__.c = installedModules;\n\n/******/  // identity function for calling harmony imports with the correct context\n/******/  __nested_webpack_require_21073__.i = function(value) { return value; };\n\n/******/  // define getter function for harmony exports\n/******/  __nested_webpack_require_21073__.d = function(exports, name, getter) {\n/******/    if(!__nested_webpack_require_21073__.o(exports, name)) {\n/******/      Object.defineProperty(exports, name, {\n/******/        configurable: false,\n/******/        enumerable: true,\n/******/        get: getter\n/******/      });\n/******/    }\n/******/  };\n\n/******/  // define __esModule on exports\n/******/  __nested_webpack_require_21073__.r = function(exports) {\n/******/    Object.defineProperty(exports, '__esModule', { value: true });\n/******/  };\n\n/******/  // getDefaultExport function for compatibility with non-harmony modules\n/******/  __nested_webpack_require_21073__.n = function(module) {\n/******/    var getter = module && module.__esModule ?\n/******/      function getDefault() { return module['default']; } :\n/******/      function getModuleExports() { return module; };\n/******/    __nested_webpack_require_21073__.d(getter, 'a', getter);\n/******/    return getter;\n/******/  };\n\n/******/  // Object.prototype.hasOwnProperty.call\n/******/  __nested_webpack_require_21073__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n/******/  // __webpack_public_path__\n/******/  __nested_webpack_require_21073__.p = \"/\";\n\n/******/  // on error function for async loading\n/******/  __nested_webpack_require_21073__.oe = function(err) { console.error(err); throw err; };\n\n  var f = __nested_webpack_require_21073__(__nested_webpack_require_21073__.s = ENTRY_MODULE)\n  return f.default || f // try to call default if defined to also support babel esmodule exports\n}\n\nvar moduleNameReqExp = '[\\\\.|\\\\-|\\\\+|\\\\w|\\/|@]+'\nvar dependencyRegExp = '\\\\(\\\\s*(\\/\\\\*.*?\\\\*\\/)?\\\\s*.*?(' + moduleNameReqExp + ').*?\\\\)' // additional chars when output.pathinfo is true\n\n// http://stackoverflow.com/a/2593661/130442\nfunction quoteRegExp (str) {\n  return (str + '').replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&')\n}\n\nfunction isNumeric(n) {\n  return !isNaN(1 * n); // 1 * n converts integers, integers as string (\"123\"), 1e3 and \"1e3\" to integers and strings to NaN\n}\n\nfunction getModuleDependencies (sources, module, queueName) {\n  var retval = {}\n  retval[queueName] = []\n\n  var fnString = module.toString()\n  var wrapperSignature = fnString.match(/^function\\s?\\w*\\(\\w+,\\s*\\w+,\\s*(\\w+)\\)/)\n  if (!wrapperSignature) return retval\n  var webpackRequireName = wrapperSignature[1]\n\n  // main bundle deps\n  var re = new RegExp('(\\\\\\\\n|\\\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')\n  var match\n  while ((match = re.exec(fnString))) {\n    if (match[3] === 'dll-reference') continue\n    retval[queueName].push(match[3])\n  }\n\n  // dll deps\n  re = new RegExp('\\\\(' + quoteRegExp(webpackRequireName) + '\\\\(\"(dll-reference\\\\s(' + moduleNameReqExp + '))\"\\\\)\\\\)' + dependencyRegExp, 'g')\n  while ((match = re.exec(fnString))) {\n    if (!sources[match[2]]) {\n      retval[queueName].push(match[1])\n      sources[match[2]] = __nested_webpack_require_20895__(match[1]).m\n    }\n    retval[match[2]] = retval[match[2]] || []\n    retval[match[2]].push(match[4])\n  }\n\n  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3\n  var keys = Object.keys(retval);\n  for (var i = 0; i < keys.length; i++) {\n    for (var j = 0; j < retval[keys[i]].length; j++) {\n      if (isNumeric(retval[keys[i]][j])) {\n        retval[keys[i]][j] = 1 * retval[keys[i]][j];\n      }\n    }\n  }\n\n  return retval\n}\n\nfunction hasValuesInQueues (queues) {\n  var keys = Object.keys(queues)\n  return keys.reduce(function (hasValues, key) {\n    return hasValues || queues[key].length > 0\n  }, false)\n}\n\nfunction getRequiredModules (sources, moduleId) {\n  var modulesQueue = {\n    main: [moduleId]\n  }\n  var requiredModules = {\n    main: []\n  }\n  var seenModules = {\n    main: {}\n  }\n\n  while (hasValuesInQueues(modulesQueue)) {\n    var queues = Object.keys(modulesQueue)\n    for (var i = 0; i < queues.length; i++) {\n      var queueName = queues[i]\n      var queue = modulesQueue[queueName]\n      var moduleToCheck = queue.pop()\n      seenModules[queueName] = seenModules[queueName] || {}\n      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue\n      seenModules[queueName][moduleToCheck] = true\n      requiredModules[queueName] = requiredModules[queueName] || []\n      requiredModules[queueName].push(moduleToCheck)\n      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)\n      var newModulesKeys = Object.keys(newModules)\n      for (var j = 0; j < newModulesKeys.length; j++) {\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])\n      }\n    }\n  }\n\n  return requiredModules\n}\n\nmodule.exports = function (moduleId, options) {\n  options = options || {}\n  var sources = {\n    main: __nested_webpack_require_20895__.m\n  }\n\n  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId)\n\n  var src = ''\n\n  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {\n    var entryModule = 0\n    while (requiredModules[module][entryModule]) {\n      entryModule++\n    }\n    requiredModules[module].push(entryModule)\n    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'\n    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\\n'\n  })\n\n  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '}))(self);'\n\n  var blob = new window.Blob([src], { type: 'text/javascript' })\n  if (options.bare) { return blob }\n\n  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL\n\n  var workerUrl = URL.createObjectURL(blob)\n  var worker = new window.Worker(workerUrl)\n  worker.objectURL = workerUrl\n\n  return worker\n}\n\n\n/***/ }),\n\n/***/ \"./src/config.ts\":\n/*!***********************!*\\\n  !*** ./src/config.ts ***!\n  \\***********************/\n/*! exports provided: hlsDefaultConfig, mergeConfig, enableStreamingMode */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_28606__) {\n\n\"use strict\";\n__nested_webpack_require_28606__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_28606__.d(__webpack_exports__, \"hlsDefaultConfig\", function() { return hlsDefaultConfig; });\n/* harmony export (binding) */ __nested_webpack_require_28606__.d(__webpack_exports__, \"mergeConfig\", function() { return mergeConfig; });\n/* harmony export (binding) */ __nested_webpack_require_28606__.d(__webpack_exports__, \"enableStreamingMode\", function() { return enableStreamingMode; });\n/* harmony import */ var _controller_abr_controller__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_28606__(/*! ./controller/abr-controller */ \"./src/controller/abr-controller.ts\");\n/* harmony import */ var _controller_audio_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_28606__(/*! ./controller/audio-stream-controller */ \"./src/controller/audio-stream-controller.ts\");\n/* harmony import */ var _controller_audio_track_controller__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_28606__(/*! ./controller/audio-track-controller */ \"./src/controller/audio-track-controller.ts\");\n/* harmony import */ var _controller_subtitle_stream_controller__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_28606__(/*! ./controller/subtitle-stream-controller */ \"./src/controller/subtitle-stream-controller.ts\");\n/* harmony import */ var _controller_subtitle_track_controller__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_28606__(/*! ./controller/subtitle-track-controller */ \"./src/controller/subtitle-track-controller.ts\");\n/* harmony import */ var _controller_buffer_controller__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_28606__(/*! ./controller/buffer-controller */ \"./src/controller/buffer-controller.ts\");\n/* harmony import */ var _controller_timeline_controller__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_28606__(/*! ./controller/timeline-controller */ \"./src/controller/timeline-controller.ts\");\n/* harmony import */ var _controller_cap_level_controller__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_28606__(/*! ./controller/cap-level-controller */ \"./src/controller/cap-level-controller.ts\");\n/* harmony import */ var _controller_fps_controller__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_28606__(/*! ./controller/fps-controller */ \"./src/controller/fps-controller.ts\");\n/* harmony import */ var _controller_eme_controller__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_28606__(/*! ./controller/eme-controller */ \"./src/controller/eme-controller.ts\");\n/* harmony import */ var _controller_cmcd_controller__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_28606__(/*! ./controller/cmcd-controller */ \"./src/controller/cmcd-controller.ts\");\n/* harmony import */ var _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_28606__(/*! ./utils/xhr-loader */ \"./src/utils/xhr-loader.ts\");\n/* harmony import */ var _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_28606__(/*! ./utils/fetch-loader */ \"./src/utils/fetch-loader.ts\");\n/* harmony import */ var _utils_cues__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_28606__(/*! ./utils/cues */ \"./src/utils/cues.ts\");\n/* harmony import */ var _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_28606__(/*! ./utils/mediakeys-helper */ \"./src/utils/mediakeys-helper.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_28606__(/*! ./utils/logger */ \"./src/utils/logger.ts\");\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// If possible, keep hlsDefaultConfig shallow\n// It is cloned whenever a new Hls instance is created, by keeping the config\n// shallow the properties are cloned, and we don't end up manipulating the default\nvar hlsDefaultConfig = _objectSpread(_objectSpread({\n  autoStartLoad: true,\n  // used by stream-controller\n  startPosition: -1,\n  // used by stream-controller\n  defaultAudioCodec: undefined,\n  // used by stream-controller\n  debug: false,\n  // used by logger\n  capLevelOnFPSDrop: false,\n  // used by fps-controller\n  capLevelToPlayerSize: false,\n  // used by cap-level-controller\n  ignoreDevicePixelRatio: false,\n  // used by cap-level-controller\n  initialLiveManifestSize: 1,\n  // used by stream-controller\n  maxBufferLength: 30,\n  // used by stream-controller\n  backBufferLength: Infinity,\n  // used by buffer-controller\n  maxBufferSize: 60 * 1000 * 1000,\n  // used by stream-controller\n  maxBufferHole: 0.1,\n  // used by stream-controller\n  highBufferWatchdogPeriod: 2,\n  // used by stream-controller\n  nudgeOffset: 0.1,\n  // used by stream-controller\n  nudgeMaxRetry: 3,\n  // used by stream-controller\n  maxFragLookUpTolerance: 0.25,\n  // used by stream-controller\n  liveSyncDurationCount: 3,\n  // used by latency-controller\n  liveMaxLatencyDurationCount: Infinity,\n  // used by latency-controller\n  liveSyncDuration: undefined,\n  // used by latency-controller\n  liveMaxLatencyDuration: undefined,\n  // used by latency-controller\n  maxLiveSyncPlaybackRate: 1,\n  // used by latency-controller\n  liveDurationInfinity: false,\n  // used by buffer-controller\n  liveBackBufferLength: null,\n  // used by buffer-controller\n  maxMaxBufferLength: 600,\n  // used by stream-controller\n  enableWorker: true,\n  // used by demuxer\n  enableSoftwareAES: true,\n  // used by decrypter\n  manifestLoadingTimeOut: 10000,\n  // used by playlist-loader\n  manifestLoadingMaxRetry: 1,\n  // used by playlist-loader\n  manifestLoadingRetryDelay: 1000,\n  // used by playlist-loader\n  manifestLoadingMaxRetryTimeout: 64000,\n  // used by playlist-loader\n  startLevel: undefined,\n  // used by level-controller\n  levelLoadingTimeOut: 10000,\n  // used by playlist-loader\n  levelLoadingMaxRetry: 4,\n  // used by playlist-loader\n  levelLoadingRetryDelay: 1000,\n  // used by playlist-loader\n  levelLoadingMaxRetryTimeout: 64000,\n  // used by playlist-loader\n  fragLoadingTimeOut: 20000,\n  // used by fragment-loader\n  fragLoadingMaxRetry: 6,\n  // used by fragment-loader\n  fragLoadingRetryDelay: 1000,\n  // used by fragment-loader\n  fragLoadingMaxRetryTimeout: 64000,\n  // used by fragment-loader\n  startFragPrefetch: false,\n  // used by stream-controller\n  fpsDroppedMonitoringPeriod: 5000,\n  // used by fps-controller\n  fpsDroppedMonitoringThreshold: 0.2,\n  // used by fps-controller\n  appendErrorMaxRetry: 3,\n  // used by buffer-controller\n  loader: _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n  // loader: FetchLoader,\n  fLoader: undefined,\n  // used by fragment-loader\n  pLoader: undefined,\n  // used by playlist-loader\n  xhrSetup: undefined,\n  // used by xhr-loader\n  licenseXhrSetup: undefined,\n  // used by eme-controller\n  licenseResponseCallback: undefined,\n  // used by eme-controller\n  abrController: _controller_abr_controller__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  bufferController: _controller_buffer_controller__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n  capLevelController: _controller_cap_level_controller__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\n  fpsController: _controller_fps_controller__WEBPACK_IMPORTED_MODULE_8__[\"default\"],\n  stretchShortVideoTrack: false,\n  // used by mp4-remuxer\n  maxAudioFramesDrift: 1,\n  // used by mp4-remuxer\n  forceKeyFrameOnDiscontinuity: true,\n  // used by ts-demuxer\n  abrEwmaFastLive: 3,\n  // used by abr-controller\n  abrEwmaSlowLive: 9,\n  // used by abr-controller\n  abrEwmaFastVoD: 3,\n  // used by abr-controller\n  abrEwmaSlowVoD: 9,\n  // used by abr-controller\n  abrEwmaDefaultEstimate: 5e5,\n  // 500 kbps  // used by abr-controller\n  abrBandWidthFactor: 0.95,\n  // used by abr-controller\n  abrBandWidthUpFactor: 0.7,\n  // used by abr-controller\n  abrMaxWithRealBitrate: false,\n  // used by abr-controller\n  maxStarvationDelay: 4,\n  // used by abr-controller\n  maxLoadingDelay: 4,\n  // used by abr-controller\n  minAutoBitrate: 0,\n  // used by hls\n  emeEnabled: false,\n  // used by eme-controller\n  widevineLicenseUrl: undefined,\n  // used by eme-controller\n  drmSystemOptions: {},\n  // used by eme-controller\n  requestMediaKeySystemAccessFunc: _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_14__[\"requestMediaKeySystemAccess\"],\n  // used by eme-controller\n  testBandwidth: true,\n  progressive: false,\n  lowLatencyMode: true,\n  cmcd: undefined,\n  enableDateRangeMetadataCues: true,\n  enableEmsgMetadataCues: true,\n  enableID3MetadataCues: true\n}, timelineConfig()), {}, {\n  subtitleStreamController:   true ? _controller_subtitle_stream_controller__WEBPACK_IMPORTED_MODULE_3__[\"SubtitleStreamController\"] : 0,\n  subtitleTrackController:   true ? _controller_subtitle_track_controller__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : 0,\n  timelineController:   true ? _controller_timeline_controller__WEBPACK_IMPORTED_MODULE_6__[\"TimelineController\"] : 0,\n  audioStreamController:   true ? _controller_audio_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"default\"] : 0,\n  audioTrackController:   true ? _controller_audio_track_controller__WEBPACK_IMPORTED_MODULE_2__[\"default\"] : 0,\n  emeController:   true ? _controller_eme_controller__WEBPACK_IMPORTED_MODULE_9__[\"default\"] : 0,\n  cmcdController:   true ? _controller_cmcd_controller__WEBPACK_IMPORTED_MODULE_10__[\"default\"] : 0\n});\n\nfunction timelineConfig() {\n  return {\n    cueHandler: _utils_cues__WEBPACK_IMPORTED_MODULE_13__[\"default\"],\n    // used by timeline-controller\n    enableWebVTT: true,\n    // used by timeline-controller\n    enableIMSC1: true,\n    // used by timeline-controller\n    enableCEA708Captions: true,\n    // used by timeline-controller\n    captionsTextTrack1Label: 'English',\n    // used by timeline-controller\n    captionsTextTrack1LanguageCode: 'en',\n    // used by timeline-controller\n    captionsTextTrack2Label: 'Spanish',\n    // used by timeline-controller\n    captionsTextTrack2LanguageCode: 'es',\n    // used by timeline-controller\n    captionsTextTrack3Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack3LanguageCode: '',\n    // used by timeline-controller\n    captionsTextTrack4Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack4LanguageCode: '',\n    // used by timeline-controller\n    renderTextTracksNatively: true\n  };\n}\n\nfunction mergeConfig(defaultConfig, userConfig) {\n  if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {\n    throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n  }\n\n  if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n  }\n\n  if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n  }\n\n  return _extends({}, defaultConfig, userConfig);\n}\nfunction enableStreamingMode(config) {\n  var currentLoader = config.loader;\n\n  if (currentLoader !== _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__[\"default\"] && currentLoader !== _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_11__[\"default\"]) {\n    // If a developer has configured their own loader, respect that choice\n    _utils_logger__WEBPACK_IMPORTED_MODULE_15__[\"logger\"].log('[config]: Custom loader detected, cannot enable progressive streaming');\n    config.progressive = false;\n  } else {\n    var canStreamProgressively = Object(_utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__[\"fetchSupported\"])();\n\n    if (canStreamProgressively) {\n      config.loader = _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__[\"default\"];\n      config.progressive = true;\n      config.enableSoftwareAES = true;\n      _utils_logger__WEBPACK_IMPORTED_MODULE_15__[\"logger\"].log('[config]: Progressive streaming enabled, using FetchLoader');\n    }\n  }\n}\n\n/***/ }),\n\n/***/ \"./src/controller/abr-controller.ts\":\n/*!******************************************!*\\\n  !*** ./src/controller/abr-controller.ts ***!\n  \\******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_42274__) {\n\n\"use strict\";\n__nested_webpack_require_42274__.r(__webpack_exports__);\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_42274__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _utils_ewma_bandwidth_estimator__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_42274__(/*! ../utils/ewma-bandwidth-estimator */ \"./src/utils/ewma-bandwidth-estimator.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_42274__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_42274__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_42274__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_42274__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_42274__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\n\n\n\n\n\nvar AbrController = /*#__PURE__*/function () {\n  function AbrController(hls) {\n    this.hls = void 0;\n    this.lastLoadedFragLevel = 0;\n    this._nextAutoLevel = -1;\n    this.timer = void 0;\n    this.onCheck = this._abandonRulesCheck.bind(this);\n    this.fragCurrent = null;\n    this.partCurrent = null;\n    this.bitrateTestDelay = 0;\n    this.bwEstimator = void 0;\n    this.hls = hls;\n    var config = hls.config;\n    this.bwEstimator = new _utils_ewma_bandwidth_estimator__WEBPACK_IMPORTED_MODULE_1__[\"default\"](config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);\n    this.registerListeners();\n  }\n\n  var _proto = AbrController.prototype;\n\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_LOADING, this.onFragLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, this.onError, this);\n  };\n\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_LOADING, this.onFragLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, this.onError, this);\n  };\n\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.clearTimer(); // @ts-ignore\n\n    this.hls = this.onCheck = null;\n    this.fragCurrent = this.partCurrent = null;\n  };\n\n  _proto.onFragLoading = function onFragLoading(event, data) {\n    var frag = data.frag;\n\n    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_5__[\"PlaylistLevelType\"].MAIN) {\n      if (!this.timer) {\n        var _data$part;\n\n        this.fragCurrent = frag;\n        this.partCurrent = (_data$part = data.part) != null ? _data$part : null;\n        this.timer = self.setInterval(this.onCheck, 100);\n      }\n    }\n  };\n\n  _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n    var config = this.hls.config;\n\n    if (data.details.live) {\n      this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);\n    } else {\n      this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);\n    }\n  }\n  /*\n      This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load\n      quickly enough to prevent underbuffering\n    */\n  ;\n\n  _proto._abandonRulesCheck = function _abandonRulesCheck() {\n    var frag = this.fragCurrent,\n        part = this.partCurrent,\n        hls = this.hls;\n    var autoLevelEnabled = hls.autoLevelEnabled,\n        config = hls.config,\n        media = hls.media;\n\n    if (!frag || !media) {\n      return;\n    }\n\n    var stats = part ? part.stats : frag.stats;\n    var duration = part ? part.duration : frag.duration; // If loading has been aborted and not in lowLatencyMode, stop timer and return\n\n    if (stats.aborted) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].warn('frag loader destroy or aborted, disarm abandonRules');\n      this.clearTimer(); // reset forced auto level value so that next level will be selected\n\n      this._nextAutoLevel = -1;\n      return;\n    } // This check only runs if we're in ABR mode and actually playing\n\n\n    if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {\n      return;\n    }\n\n    var requestDelay = performance.now() - stats.loading.start;\n    var playbackRate = Math.abs(media.playbackRate); // In order to work with a stable bandwidth, only begin monitoring bandwidth after half of the fragment has been loaded\n\n    if (requestDelay <= 500 * duration / playbackRate) {\n      return;\n    }\n\n    var levels = hls.levels,\n        minAutoLevel = hls.minAutoLevel;\n    var level = levels[frag.level];\n    var expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.maxBitrate / 8));\n    var loadRate = Math.max(1, stats.bwEstimate ? stats.bwEstimate / 8 : stats.loaded * 1000 / requestDelay); // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the entire fragment\n\n    var fragLoadedDelay = (expectedLen - stats.loaded) / loadRate;\n    var pos = media.currentTime; // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer\n\n    var bufferStarvationDelay = (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].bufferInfo(media, pos, config.maxBufferHole).end - pos) / playbackRate; // Attempt an emergency downswitch only if less than 2 fragment lengths are buffered, and the time to finish loading\n    // the current fragment is greater than the amount of buffer we have left\n\n    if (bufferStarvationDelay >= 2 * duration / playbackRate || fragLoadedDelay <= bufferStarvationDelay) {\n      return;\n    }\n\n    var fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;\n    var nextLoadLevel; // Iterate through lower level and try to find the largest one that avoids rebuffering\n\n    for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {\n      // compute time to load next fragment at lower level\n      // 0.8 : consider only 80% of current bw to be conservative\n      // 8 = bits per byte (bps/Bps)\n      var levelNextBitrate = levels[nextLoadLevel].maxBitrate;\n      fragLevelNextLoadedDelay = duration * levelNextBitrate / (8 * 0.8 * loadRate);\n\n      if (fragLevelNextLoadedDelay < bufferStarvationDelay) {\n        break;\n      }\n    } // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing\n    // to load the current one\n\n\n    if (fragLevelNextLoadedDelay >= fragLoadedDelay) {\n      return;\n    }\n\n    var bwEstimate = this.bwEstimator.getEstimate();\n    _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].warn(\"Fragment \" + frag.sn + (part ? ' part ' + part.index : '') + \" of level \" + frag.level + \" is loading too slowly and will cause an underbuffer; aborting and switching to level \" + nextLoadLevel + \"\\n      Current BW estimate: \" + (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(bwEstimate) ? (bwEstimate / 1024).toFixed(3) : 'Unknown') + \" Kb/s\\n      Estimated load time for current fragment: \" + fragLoadedDelay.toFixed(3) + \" s\\n      Estimated load time for the next fragment: \" + fragLevelNextLoadedDelay.toFixed(3) + \" s\\n      Time to underbuffer: \" + bufferStarvationDelay.toFixed(3) + \" s\");\n    hls.nextLoadLevel = nextLoadLevel;\n    this.bwEstimator.sample(requestDelay, stats.loaded);\n    this.clearTimer();\n\n    if (frag.loader) {\n      this.fragCurrent = this.partCurrent = null;\n      frag.loader.abort();\n    }\n\n    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_LOAD_EMERGENCY_ABORTED, {\n      frag: frag,\n      part: part,\n      stats: stats\n    });\n  };\n\n  _proto.onFragLoaded = function onFragLoaded(event, _ref) {\n    var frag = _ref.frag,\n        part = _ref.part;\n\n    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_5__[\"PlaylistLevelType\"].MAIN && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(frag.sn)) {\n      var stats = part ? part.stats : frag.stats;\n      var duration = part ? part.duration : frag.duration; // stop monitoring bw once frag loaded\n\n      this.clearTimer(); // store level id after successful fragment load\n\n      this.lastLoadedFragLevel = frag.level; // reset forced auto level value so that next level will be selected\n\n      this._nextAutoLevel = -1; // compute level average bitrate\n\n      if (this.hls.config.abrMaxWithRealBitrate) {\n        var level = this.hls.levels[frag.level];\n        var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;\n        var loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;\n        level.loaded = {\n          bytes: loadedBytes,\n          duration: loadedDuration\n        };\n        level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);\n      }\n\n      if (frag.bitrateTest) {\n        var fragBufferedData = {\n          stats: stats,\n          frag: frag,\n          part: part,\n          id: frag.type\n        };\n        this.onFragBuffered(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_BUFFERED, fragBufferedData);\n        frag.bitrateTest = false;\n      }\n    }\n  };\n\n  _proto.onFragBuffered = function onFragBuffered(event, data) {\n    var frag = data.frag,\n        part = data.part;\n    var stats = part ? part.stats : frag.stats;\n\n    if (stats.aborted) {\n      return;\n    } // Only count non-alt-audio frags which were actually buffered in our BW calculations\n\n\n    if (frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_5__[\"PlaylistLevelType\"].MAIN || frag.sn === 'initSegment') {\n      return;\n    } // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;\n    // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch\n    // is used. If we used buffering in that case, our BW estimate sample will be very large.\n\n\n    var processingMs = stats.parsing.end - stats.loading.start;\n    this.bwEstimator.sample(processingMs, stats.loaded);\n    stats.bwEstimate = this.bwEstimator.getEstimate();\n\n    if (frag.bitrateTest) {\n      this.bitrateTestDelay = processingMs / 1000;\n    } else {\n      this.bitrateTestDelay = 0;\n    }\n  };\n\n  _proto.onError = function onError(event, data) {\n    // stop timer in case of frag loading error\n    switch (data.details) {\n      case _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorDetails\"].FRAG_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorDetails\"].FRAG_LOAD_TIMEOUT:\n        this.clearTimer();\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  _proto.clearTimer = function clearTimer() {\n    self.clearInterval(this.timer);\n    this.timer = undefined;\n  } // return next auto level\n  ;\n\n  _proto.getNextABRAutoLevel = function getNextABRAutoLevel() {\n    var fragCurrent = this.fragCurrent,\n        partCurrent = this.partCurrent,\n        hls = this.hls;\n    var maxAutoLevel = hls.maxAutoLevel,\n        config = hls.config,\n        minAutoLevel = hls.minAutoLevel,\n        media = hls.media;\n    var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n    var pos = media ? media.currentTime : 0; // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as\n    // if we're playing back at the normal rate.\n\n    var playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;\n    var avgbw = this.bwEstimator ? this.bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate; // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.\n\n    var bufferStarvationDelay = (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].bufferInfo(media, pos, config.maxBufferHole).end - pos) / playbackRate; // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all\n\n    var bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor);\n\n    if (bestLevel >= 0) {\n      return bestLevel;\n    }\n\n    _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].trace((bufferStarvationDelay ? 'rebuffering expected' : 'buffer is empty') + \", finding optimal quality level\"); // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering\n    // if no matching level found, logic will return 0\n\n    var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;\n    var bwFactor = config.abrBandWidthFactor;\n    var bwUpFactor = config.abrBandWidthUpFactor;\n\n    if (!bufferStarvationDelay) {\n      // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test\n      var bitrateTestDelay = this.bitrateTestDelay;\n\n      if (bitrateTestDelay) {\n        // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value\n        // max video loading delay used in  automatic start level selection :\n        // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +\n        // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )\n        // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration\n        var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;\n        maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;\n        _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].trace(\"bitrate test took \" + Math.round(1000 * bitrateTestDelay) + \"ms, set first fragment max fetchDuration to \" + Math.round(1000 * maxStarvationDelay) + \" ms\"); // don't use conservative factor on bitrate test\n\n        bwFactor = bwUpFactor = 1;\n      }\n    }\n\n    bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor);\n    return Math.max(bestLevel, 0);\n  };\n\n  _proto.findBestLevel = function findBestLevel(currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor) {\n    var _level$details;\n\n    var fragCurrent = this.fragCurrent,\n        partCurrent = this.partCurrent,\n        currentLevel = this.lastLoadedFragLevel;\n    var levels = this.hls.levels;\n    var level = levels[currentLevel];\n    var live = !!(level !== null && level !== void 0 && (_level$details = level.details) !== null && _level$details !== void 0 && _level$details.live);\n    var currentCodecSet = level === null || level === void 0 ? void 0 : level.codecSet;\n    var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n\n    for (var i = maxAutoLevel; i >= minAutoLevel; i--) {\n      var levelInfo = levels[i];\n\n      if (!levelInfo || currentCodecSet && levelInfo.codecSet !== currentCodecSet) {\n        continue;\n      }\n\n      var levelDetails = levelInfo.details;\n      var avgDuration = (partCurrent ? levelDetails === null || levelDetails === void 0 ? void 0 : levelDetails.partTarget : levelDetails === null || levelDetails === void 0 ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;\n      var adjustedbw = void 0; // follow algorithm captured from stagefright :\n      // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp\n      // Pick the highest bandwidth stream below or equal to estimated bandwidth.\n      // consider only 80% of the available bandwidth, but if we are switching up,\n      // be even more conservative (70%) to avoid overestimating and immediately\n      // switching back.\n\n      if (i <= currentLevel) {\n        adjustedbw = bwFactor * currentBw;\n      } else {\n        adjustedbw = bwUpFactor * currentBw;\n      }\n\n      var bitrate = levels[i].maxBitrate;\n      var fetchDuration = bitrate * avgDuration / adjustedbw;\n      _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].trace(\"level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: \" + i + \"/\" + Math.round(adjustedbw) + \"/\" + bitrate + \"/\" + avgDuration + \"/\" + maxFetchDuration + \"/\" + fetchDuration); // if adjusted bw is greater than level bitrate AND\n\n      if (adjustedbw > bitrate && ( // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n      // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n      // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1\n      !fetchDuration || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {\n        // as we are looping from highest to lowest, this will return the best achievable quality level\n        return i;\n      }\n    } // not enough time budget even with quality level 0 ... rebuffering might happen\n\n\n    return -1;\n  };\n\n  _createClass(AbrController, [{\n    key: \"nextAutoLevel\",\n    get: function get() {\n      var forcedAutoLevel = this._nextAutoLevel;\n      var bwEstimator = this.bwEstimator; // in case next auto level has been forced, and bw not available or not reliable, return forced value\n\n      if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {\n        return forcedAutoLevel;\n      } // compute next level using ABR logic\n\n\n      var nextABRAutoLevel = this.getNextABRAutoLevel(); // if forced auto level has been defined, use it to cap ABR computed quality level\n\n      if (forcedAutoLevel !== -1) {\n        nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);\n      }\n\n      return nextABRAutoLevel;\n    },\n    set: function set(nextLevel) {\n      this._nextAutoLevel = nextLevel;\n    }\n  }]);\n\n  return AbrController;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AbrController);\n\n/***/ }),\n\n/***/ \"./src/controller/audio-stream-controller.ts\":\n/*!***************************************************!*\\\n  !*** ./src/controller/audio-stream-controller.ts ***!\n  \\***************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_62308__) {\n\n\"use strict\";\n__nested_webpack_require_62308__.r(__webpack_exports__);\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_62308__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_62308__(/*! ./base-stream-controller */ \"./src/controller/base-stream-controller.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_62308__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_62308__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_62308__(/*! ./fragment-tracker */ \"./src/controller/fragment-tracker.ts\");\n/* harmony import */ var _types_level__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_62308__(/*! ../types/level */ \"./src/types/level.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_62308__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_62308__(/*! ../loader/fragment */ \"./src/loader/fragment.ts\");\n/* harmony import */ var _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_62308__(/*! ../demux/chunk-cache */ \"./src/demux/chunk-cache.ts\");\n/* harmony import */ var _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_62308__(/*! ../demux/transmuxer-interface */ \"./src/demux/transmuxer-interface.ts\");\n/* harmony import */ var _types_transmuxer__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_62308__(/*! ../types/transmuxer */ \"./src/types/transmuxer.ts\");\n/* harmony import */ var _fragment_finders__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_62308__(/*! ./fragment-finders */ \"./src/controller/fragment-finders.ts\");\n/* harmony import */ var _utils_discontinuities__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_62308__(/*! ../utils/discontinuities */ \"./src/utils/discontinuities.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_62308__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_62308__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar TICK_INTERVAL = 100; // how often to tick in ms\n\nvar AudioStreamController = /*#__PURE__*/function (_BaseStreamController) {\n  _inheritsLoose(AudioStreamController, _BaseStreamController);\n\n  function AudioStreamController(hls, fragmentTracker) {\n    var _this;\n\n    _this = _BaseStreamController.call(this, hls, fragmentTracker, '[audio-stream-controller]') || this;\n    _this.videoBuffer = null;\n    _this.videoTrackCC = -1;\n    _this.waitingVideoCC = -1;\n    _this.audioSwitch = false;\n    _this.trackId = -1;\n    _this.waitingData = null;\n    _this.mainDetails = null;\n    _this.bufferFlushed = false;\n    _this.cachedTrackLoadedData = null;\n\n    _this._registerListeners();\n\n    return _this;\n  }\n\n  var _proto = AudioStreamController.prototype;\n\n  _proto.onHandlerDestroying = function onHandlerDestroying() {\n    this._unregisterListeners();\n\n    this.mainDetails = null;\n  };\n\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, this.onError, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_RESET, this.onBufferReset, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_CREATED, this.onBufferCreated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_BUFFERED, this.onFragBuffered, this);\n  };\n\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, this.onError, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_RESET, this.onBufferReset, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_CREATED, this.onBufferCreated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_BUFFERED, this.onFragBuffered, this);\n  } // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value\n  ;\n\n  _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {\n    var frag = _ref.frag,\n        id = _ref.id,\n        initPTS = _ref.initPTS;\n\n    // Always update the new INIT PTS\n    // Can change due level switch\n    if (id === 'main') {\n      var cc = frag.cc;\n      this.initPTS[frag.cc] = initPTS;\n      this.log(\"InitPTS for cc: \" + cc + \" found from main: \" + initPTS);\n      this.videoTrackCC = cc; // If we are waiting, tick immediately to unblock audio fragment transmuxing\n\n      if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_INIT_PTS) {\n        this.tick();\n      }\n    }\n  };\n\n  _proto.startLoad = function startLoad(startPosition) {\n    if (!this.levels) {\n      this.startPosition = startPosition;\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].STOPPED;\n      return;\n    }\n\n    var lastCurrentTime = this.lastCurrentTime;\n    this.stopLoad();\n    this.setInterval(TICK_INTERVAL);\n    this.fragLoadError = 0;\n\n    if (lastCurrentTime > 0 && startPosition === -1) {\n      this.log(\"Override startPosition with lastCurrentTime @\" + lastCurrentTime.toFixed(3));\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n    } else {\n      this.loadedmetadata = false;\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_TRACK;\n    }\n\n    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n    this.tick();\n  };\n\n  _proto.doTick = function doTick() {\n    switch (this.state) {\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE:\n        this.doTickIdle();\n        break;\n\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_TRACK:\n        {\n          var _levels$trackId;\n\n          var levels = this.levels,\n              trackId = this.trackId;\n          var details = levels === null || levels === void 0 ? void 0 : (_levels$trackId = levels[trackId]) === null || _levels$trackId === void 0 ? void 0 : _levels$trackId.details;\n\n          if (details) {\n            if (this.waitForCdnTuneIn(details)) {\n              break;\n            }\n\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_INIT_PTS;\n          }\n\n          break;\n        }\n\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].FRAG_LOADING_WAITING_RETRY:\n        {\n          var _this$media;\n\n          var now = performance.now();\n          var retryDate = this.retryDate; // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n\n          if (!retryDate || now >= retryDate || (_this$media = this.media) !== null && _this$media !== void 0 && _this$media.seeking) {\n            this.log('RetryDate reached, switch back to IDLE state');\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n          }\n\n          break;\n        }\n\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_INIT_PTS:\n        {\n          // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS\n          var waitingData = this.waitingData;\n\n          if (waitingData) {\n            var frag = waitingData.frag,\n                part = waitingData.part,\n                cache = waitingData.cache,\n                complete = waitingData.complete;\n\n            if (this.initPTS[frag.cc] !== undefined) {\n              this.waitingData = null;\n              this.waitingVideoCC = -1;\n              this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].FRAG_LOADING;\n              var payload = cache.flush();\n              var data = {\n                frag: frag,\n                part: part,\n                payload: payload,\n                networkDetails: null\n              };\n\n              this._handleFragmentLoadProgress(data);\n\n              if (complete) {\n                _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, data);\n              }\n            } else if (this.videoTrackCC !== this.waitingVideoCC) {\n              // Drop waiting fragment if videoTrackCC has changed since waitingFragment was set and initPTS was not found\n              _utils_logger__WEBPACK_IMPORTED_MODULE_14__[\"logger\"].log(\"Waiting fragment cc (\" + frag.cc + \") cancelled because video is at cc \" + this.videoTrackCC);\n              this.clearWaitingFragment();\n            } else {\n              // Drop waiting fragment if an earlier fragment is needed\n              var pos = this.getLoadPosition();\n              var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].bufferInfo(this.mediaBuffer, pos, this.config.maxBufferHole);\n              var waitingFragmentAtPosition = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_11__[\"fragmentWithinToleranceTest\"])(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);\n\n              if (waitingFragmentAtPosition < 0) {\n                _utils_logger__WEBPACK_IMPORTED_MODULE_14__[\"logger\"].log(\"Waiting fragment cc (\" + frag.cc + \") @ \" + frag.start + \" cancelled because another fragment at \" + bufferInfo.end + \" is needed\");\n                this.clearWaitingFragment();\n              }\n            }\n          } else {\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n          }\n        }\n    }\n\n    this.onTickEnd();\n  };\n\n  _proto.clearWaitingFragment = function clearWaitingFragment() {\n    var waitingData = this.waitingData;\n\n    if (waitingData) {\n      this.fragmentTracker.removeFragment(waitingData.frag);\n      this.waitingData = null;\n      this.waitingVideoCC = -1;\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n    }\n  };\n\n  _proto.onTickEnd = function onTickEnd() {\n    var media = this.media;\n\n    if (!media || !media.readyState) {\n      // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n      return;\n    }\n\n    var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;\n    var buffered = mediaBuffer.buffered;\n\n    if (!this.loadedmetadata && buffered.length) {\n      this.loadedmetadata = true;\n    }\n\n    this.lastCurrentTime = media.currentTime;\n  };\n\n  _proto.doTickIdle = function doTickIdle() {\n    var _frag$decryptdata, _frag$decryptdata2;\n\n    var hls = this.hls,\n        levels = this.levels,\n        media = this.media,\n        trackId = this.trackId;\n    var config = hls.config;\n\n    if (!levels || !levels[trackId]) {\n      return;\n    } // if video not attached AND\n    // start fragment already requested OR start frag prefetch not enabled\n    // exit loop\n    // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop\n\n\n    if (!media && (this.startFragRequested || !config.startFragPrefetch)) {\n      return;\n    }\n\n    var levelInfo = levels[trackId];\n    var trackDetails = levelInfo.details;\n\n    if (!trackDetails || trackDetails.live && this.levelLastLoaded !== trackId || this.waitForCdnTuneIn(trackDetails)) {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_TRACK;\n      return;\n    }\n\n    if (this.bufferFlushed) {\n      this.bufferFlushed = false;\n      this.afterBufferFlushed(this.mediaBuffer ? this.mediaBuffer : this.media, _loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].AUDIO, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].AUDIO);\n    }\n\n    var bufferInfo = this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].AUDIO);\n\n    if (bufferInfo === null) {\n      return;\n    }\n\n    var mainBufferInfo = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN);\n    var bufferLen = bufferInfo.len;\n    var maxBufLen = this.getMaxBufferLength(mainBufferInfo === null || mainBufferInfo === void 0 ? void 0 : mainBufferInfo.len);\n    var audioSwitch = this.audioSwitch; // if buffer length is less than maxBufLen try to load a new fragment\n\n    if (bufferLen >= maxBufLen && !audioSwitch) {\n      return;\n    }\n\n    if (!audioSwitch && this._streamEnded(bufferInfo, trackDetails)) {\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_EOS, {\n        type: 'audio'\n      });\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].ENDED;\n      return;\n    }\n\n    var fragments = trackDetails.fragments;\n    var start = fragments[0].start;\n    var targetBufferTime = bufferInfo.end;\n\n    if (audioSwitch) {\n      var pos = this.getLoadPosition();\n      targetBufferTime = pos; // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime\n\n      if (trackDetails.PTSKnown && pos < start) {\n        // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start\n        if (bufferInfo.end > start || bufferInfo.nextStart) {\n          this.log('Alt audio track ahead of main track, seek to start of alt audio track');\n          media.currentTime = start + 0.05;\n        }\n      }\n    } // buffer audio up to one target duration ahead of main buffer\n\n\n    if (mainBufferInfo && targetBufferTime > mainBufferInfo.end + trackDetails.targetduration) {\n      return;\n    } // wait for main buffer after buffing some audio\n\n\n    if ((!mainBufferInfo || !mainBufferInfo.len) && bufferInfo.len) {\n      return;\n    }\n\n    var frag = this.getNextFragment(targetBufferTime, trackDetails);\n\n    if (!frag) {\n      this.bufferFlushed = true;\n      return;\n    }\n\n    if (((_frag$decryptdata = frag.decryptdata) === null || _frag$decryptdata === void 0 ? void 0 : _frag$decryptdata.keyFormat) === 'identity' && !((_frag$decryptdata2 = frag.decryptdata) !== null && _frag$decryptdata2 !== void 0 && _frag$decryptdata2.key)) {\n      this.loadKey(frag, trackDetails);\n    } else {\n      this.loadFragment(frag, trackDetails, targetBufferTime);\n    }\n  };\n\n  _proto.getMaxBufferLength = function getMaxBufferLength(mainBufferLength) {\n    var maxConfigBuffer = _BaseStreamController.prototype.getMaxBufferLength.call(this);\n\n    if (!mainBufferLength) {\n      return maxConfigBuffer;\n    }\n\n    return Math.max(maxConfigBuffer, mainBufferLength);\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    this.videoBuffer = null;\n\n    _BaseStreamController.prototype.onMediaDetaching.call(this);\n  };\n\n  _proto.onAudioTracksUpdated = function onAudioTracksUpdated(event, _ref2) {\n    var audioTracks = _ref2.audioTracks;\n    this.resetTransmuxer();\n    this.levels = audioTracks.map(function (mediaPlaylist) {\n      return new _types_level__WEBPACK_IMPORTED_MODULE_5__[\"Level\"](mediaPlaylist);\n    });\n  };\n\n  _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {\n    // if any URL found on new audio track, it is an alternate audio track\n    var altAudio = !!data.url;\n    this.trackId = data.id;\n    var fragCurrent = this.fragCurrent;\n\n    if (fragCurrent !== null && fragCurrent !== void 0 && fragCurrent.loader) {\n      fragCurrent.loader.abort();\n    }\n\n    this.fragCurrent = null;\n    this.clearWaitingFragment(); // destroy useless transmuxer when switching audio to main\n\n    if (!altAudio) {\n      this.resetTransmuxer();\n    } else {\n      // switching to audio track, start timer if not already started\n      this.setInterval(TICK_INTERVAL);\n    } // should we switch tracks ?\n\n\n    if (altAudio) {\n      this.audioSwitch = true; // main audio track are handled by stream-controller, just do something if switching to alt audio track\n\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n    } else {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].STOPPED;\n    }\n\n    this.tick();\n  };\n\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.mainDetails = null;\n    this.fragmentTracker.removeAllFragments();\n    this.startPosition = this.lastCurrentTime = 0;\n    this.bufferFlushed = false;\n  };\n\n  _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n    this.mainDetails = data.details;\n\n    if (this.cachedTrackLoadedData !== null) {\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].AUDIO_TRACK_LOADED, this.cachedTrackLoadedData);\n      this.cachedTrackLoadedData = null;\n    }\n  };\n\n  _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {\n    var _track$details;\n\n    if (this.mainDetails == null) {\n      this.cachedTrackLoadedData = data;\n      return;\n    }\n\n    var levels = this.levels;\n    var newDetails = data.details,\n        trackId = data.id;\n\n    if (!levels) {\n      this.warn(\"Audio tracks were reset while loading level \" + trackId);\n      return;\n    }\n\n    this.log(\"Track \" + trackId + \" loaded [\" + newDetails.startSN + \",\" + newDetails.endSN + \"],duration:\" + newDetails.totalduration);\n    var track = levels[trackId];\n    var sliding = 0;\n\n    if (newDetails.live || (_track$details = track.details) !== null && _track$details !== void 0 && _track$details.live) {\n      var mainDetails = this.mainDetails;\n\n      if (!newDetails.fragments[0]) {\n        newDetails.deltaUpdateFailed = true;\n      }\n\n      if (newDetails.deltaUpdateFailed || !mainDetails) {\n        return;\n      }\n\n      if (!track.details && newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n        // Make sure our audio rendition is aligned with the \"main\" rendition, using\n        // pdt as our reference times.\n        Object(_utils_discontinuities__WEBPACK_IMPORTED_MODULE_12__[\"alignMediaPlaylistByPDT\"])(newDetails, mainDetails);\n        sliding = newDetails.fragments[0].start;\n      } else {\n        sliding = this.alignPlaylists(newDetails, track.details);\n      }\n    }\n\n    track.details = newDetails;\n    this.levelLastLoaded = trackId; // compute start position if we are aligned with the main playlist\n\n    if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {\n      this.setStartPosition(track.details, sliding);\n    } // only switch back to IDLE state if we were waiting for track to start downloading a new fragment\n\n\n    if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n    } // trigger handler right now\n\n\n    this.tick();\n  };\n\n  _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {\n    var _frag$initSegment;\n\n    var frag = data.frag,\n        part = data.part,\n        payload = data.payload;\n    var config = this.config,\n        trackId = this.trackId,\n        levels = this.levels;\n\n    if (!levels) {\n      this.warn(\"Audio tracks were reset while fragment load was in progress. Fragment \" + frag.sn + \" of level \" + frag.level + \" will not be buffered\");\n      return;\n    }\n\n    var track = levels[trackId];\n    console.assert(track, 'Audio track is defined on fragment load progress');\n    var details = track.details;\n    console.assert(details, 'Audio track details are defined on fragment load progress');\n    var audioCodec = config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2';\n    var transmuxer = this.transmuxer;\n\n    if (!transmuxer) {\n      transmuxer = this.transmuxer = new _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_9__[\"default\"](this.hls, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n    } // Check if we have video initPTS\n    // If not we need to wait for it\n\n\n    var initPTS = this.initPTS[frag.cc];\n    var initSegmentData = (_frag$initSegment = frag.initSegment) === null || _frag$initSegment === void 0 ? void 0 : _frag$initSegment.data;\n\n    if (initPTS !== undefined) {\n      // this.log(`Transmuxing ${sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n      // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n      var accurateTimeOffset = false; // details.PTSKnown || !details.live;\n\n      var partIndex = part ? part.index : -1;\n      var partial = partIndex !== -1;\n      var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_10__[\"ChunkMetadata\"](frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n      transmuxer.push(payload, initSegmentData, audioCodec, '', frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_14__[\"logger\"].log(\"Unknown video PTS for cc \" + frag.cc + \", waiting for video PTS before demuxing audio frag \" + frag.sn + \" of [\" + details.startSN + \" ,\" + details.endSN + \"],track \" + trackId);\n\n      var _this$waitingData = this.waitingData = this.waitingData || {\n        frag: frag,\n        part: part,\n        cache: new _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_8__[\"default\"](),\n        complete: false\n      },\n          cache = _this$waitingData.cache;\n\n      cache.push(new Uint8Array(payload));\n      this.waitingVideoCC = this.videoTrackCC;\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_INIT_PTS;\n    }\n  };\n\n  _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {\n    if (this.waitingData) {\n      this.waitingData.complete = true;\n      return;\n    }\n\n    _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, fragLoadedData);\n  };\n\n  _proto.onBufferReset = function\n    /* event: Events.BUFFER_RESET */\n  onBufferReset() {\n    // reset reference to sourcebuffers\n    this.mediaBuffer = this.videoBuffer = null;\n    this.loadedmetadata = false;\n  };\n\n  _proto.onBufferCreated = function onBufferCreated(event, data) {\n    var audioTrack = data.tracks.audio;\n\n    if (audioTrack) {\n      this.mediaBuffer = audioTrack.buffer;\n    }\n\n    if (data.tracks.video) {\n      this.videoBuffer = data.tracks.video.buffer;\n    }\n  };\n\n  _proto.onFragBuffered = function onFragBuffered(event, data) {\n    var frag = data.frag,\n        part = data.part;\n\n    if (frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].AUDIO) {\n      return;\n    }\n\n    if (this.fragContextChanged(frag)) {\n      // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n      // Avoid setting state back to IDLE or concluding the audio switch; otherwise, the switched-to track will not buffer\n      this.warn(\"Fragment \" + frag.sn + (part ? ' p: ' + part.index : '') + \" of level \" + frag.level + \" finished buffering, but was aborted. state: \" + this.state + \", audioSwitch: \" + this.audioSwitch);\n      return;\n    }\n\n    if (frag.sn !== 'initSegment') {\n      this.fragPrevious = frag;\n\n      if (this.audioSwitch) {\n        this.audioSwitch = false;\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].AUDIO_TRACK_SWITCHED, {\n          id: this.trackId\n        });\n      }\n    }\n\n    this.fragBufferedComplete(frag, part);\n  };\n\n  _proto.onError = function onError(event, data) {\n    switch (data.details) {\n      case _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"].FRAG_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"].FRAG_LOAD_TIMEOUT:\n      case _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"].KEY_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"].KEY_LOAD_TIMEOUT:\n        // TODO: Skip fragments that do not belong to this.fragCurrent audio-group id\n        this.onFragmentOrKeyLoadError(_types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].AUDIO, data);\n        break;\n\n      case _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"].AUDIO_TRACK_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"].AUDIO_TRACK_LOAD_TIMEOUT:\n        //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received\n        if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].ERROR && this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].STOPPED) {\n          // if fatal error, stop processing, otherwise move to IDLE to retry loading\n          this.state = data.fatal ? _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].ERROR : _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n          this.warn(data.details + \" while loading frag, switching to \" + this.state + \" state\");\n        }\n\n        break;\n\n      case _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"].BUFFER_FULL_ERROR:\n        // if in appending state\n        if (data.parent === 'audio' && (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSED)) {\n          var flushBuffer = true;\n          var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].AUDIO); // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n          // reduce max buf len if current position is buffered\n\n          if (bufferedInfo && bufferedInfo.len > 0.5) {\n            flushBuffer = !this.reduceMaxBufferLength(bufferedInfo.len);\n          }\n\n          if (flushBuffer) {\n            // current position is not buffered, but browser is still complaining about buffer full error\n            // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n            // in that case flush the whole audio buffer to recover\n            this.warn('Buffer full error also media.currentTime is not buffered, flush audio buffer');\n            this.fragCurrent = null;\n\n            _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, 'audio');\n          }\n\n          this.resetLoadingState();\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  _proto.onBufferFlushed = function onBufferFlushed(event, _ref3) {\n    var type = _ref3.type;\n\n    if (type === _loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].AUDIO) {\n      this.bufferFlushed = true;\n    }\n  };\n\n  _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {\n    var _id3$samples;\n\n    var id = 'audio';\n    var hls = this.hls;\n    var remuxResult = transmuxResult.remuxResult,\n        chunkMeta = transmuxResult.chunkMeta;\n    var context = this.getCurrentContext(chunkMeta);\n\n    if (!context) {\n      this.warn(\"The loading context changed while buffering fragment \" + chunkMeta.sn + \" of level \" + chunkMeta.level + \". This chunk will not be buffered.\");\n      this.resetLiveStartWhenNotLoaded(chunkMeta.level);\n      return;\n    }\n\n    var frag = context.frag,\n        part = context.part,\n        details = context.level.details;\n    var audio = remuxResult.audio,\n        text = remuxResult.text,\n        id3 = remuxResult.id3,\n        initSegment = remuxResult.initSegment; // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n\n    if (this.fragContextChanged(frag) || !details) {\n      return;\n    }\n\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSING;\n\n    if (this.audioSwitch && audio) {\n      this.completeAudioSwitch();\n    }\n\n    if (initSegment !== null && initSegment !== void 0 && initSegment.tracks) {\n      this._bufferInitSegment(initSegment.tracks, frag, chunkMeta);\n\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_PARSING_INIT_SEGMENT, {\n        frag: frag,\n        id: id,\n        tracks: initSegment.tracks\n      }); // Only flush audio from old audio tracks when PTS is known on new audio track\n    }\n\n    if (audio) {\n      var startPTS = audio.startPTS,\n          endPTS = audio.endPTS,\n          startDTS = audio.startDTS,\n          endDTS = audio.endDTS;\n\n      if (part) {\n        part.elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].AUDIO] = {\n          startPTS: startPTS,\n          endPTS: endPTS,\n          startDTS: startDTS,\n          endDTS: endDTS\n        };\n      }\n\n      frag.setElementaryStreamInfo(_loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].AUDIO, startPTS, endPTS, startDTS, endDTS);\n      this.bufferFragmentData(audio, frag, part, chunkMeta);\n    }\n\n    if (id3 !== null && id3 !== void 0 && (_id3$samples = id3.samples) !== null && _id3$samples !== void 0 && _id3$samples.length) {\n      var emittedID3 = _extends({\n        id: id,\n        frag: frag,\n        details: details\n      }, id3);\n\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_PARSING_METADATA, emittedID3);\n    }\n\n    if (text) {\n      var emittedText = _extends({\n        id: id,\n        frag: frag,\n        details: details\n      }, text);\n\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_PARSING_USERDATA, emittedText);\n    }\n  };\n\n  _proto._bufferInitSegment = function _bufferInitSegment(tracks, frag, chunkMeta) {\n    if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSING) {\n      return;\n    } // delete any video track found on audio transmuxer\n\n\n    if (tracks.video) {\n      delete tracks.video;\n    } // include levelCodec in audio and video tracks\n\n\n    var track = tracks.audio;\n\n    if (!track) {\n      return;\n    }\n\n    track.levelCodec = track.codec;\n    track.id = 'audio';\n    this.log(\"Init audio buffer, container:\" + track.container + \", codecs[parsed]=[\" + track.codec + \"]\");\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_CODECS, tracks);\n    var initSegment = track.initSegment;\n\n    if (initSegment !== null && initSegment !== void 0 && initSegment.byteLength) {\n      var segment = {\n        type: 'audio',\n        frag: frag,\n        part: null,\n        chunkMeta: chunkMeta,\n        parent: frag.type,\n        data: initSegment\n      };\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_APPENDING, segment);\n    } // trigger handler right now\n\n\n    this.tick();\n  };\n\n  _proto.loadFragment = function loadFragment(frag, trackDetails, targetBufferTime) {\n    // only load if fragment is not loaded or if in audio switch\n    var fragState = this.fragmentTracker.getState(frag);\n    this.fragCurrent = frag; // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch\n\n    if (this.audioSwitch || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__[\"FragmentState\"].NOT_LOADED || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__[\"FragmentState\"].PARTIAL) {\n      if (frag.sn === 'initSegment') {\n        this._loadInitSegment(frag);\n      } else if (trackDetails.live && !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(this.initPTS[frag.cc])) {\n        this.log(\"Waiting for video PTS in continuity counter \" + frag.cc + \" of live stream before loading audio fragment \" + frag.sn + \" of level \" + this.trackId);\n        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_INIT_PTS;\n      } else {\n        this.startFragRequested = true;\n\n        _BaseStreamController.prototype.loadFragment.call(this, frag, trackDetails, targetBufferTime);\n      }\n    }\n  };\n\n  _proto.completeAudioSwitch = function completeAudioSwitch() {\n    var hls = this.hls,\n        media = this.media,\n        trackId = this.trackId;\n\n    if (media) {\n      this.log('Switching audio track : flushing all audio');\n\n      _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, 'audio');\n    }\n\n    this.audioSwitch = false;\n    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].AUDIO_TRACK_SWITCHED, {\n      id: trackId\n    });\n  };\n\n  return AudioStreamController;\n}(_base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AudioStreamController);\n\n/***/ }),\n\n/***/ \"./src/controller/audio-track-controller.ts\":\n/*!**************************************************!*\\\n  !*** ./src/controller/audio-track-controller.ts ***!\n  \\**************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_98225__) {\n\n\"use strict\";\n__nested_webpack_require_98225__.r(__webpack_exports__);\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_98225__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_98225__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_98225__(/*! ./base-playlist-controller */ \"./src/controller/base-playlist-controller.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_98225__(/*! ../types/loader */ \"./src/types/loader.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\nvar AudioTrackController = /*#__PURE__*/function (_BasePlaylistControll) {\n  _inheritsLoose(AudioTrackController, _BasePlaylistControll);\n\n  function AudioTrackController(hls) {\n    var _this;\n\n    _this = _BasePlaylistControll.call(this, hls, '[audio-track-controller]') || this;\n    _this.tracks = [];\n    _this.groupId = null;\n    _this.tracksInGroup = [];\n    _this.trackId = -1;\n    _this.trackName = '';\n    _this.selectDefaultTrack = true;\n\n    _this.registerListeners();\n\n    return _this;\n  }\n\n  var _proto = AudioTrackController.prototype;\n\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, this.onError, this);\n  };\n\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, this.onError, this);\n  };\n\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.tracks.length = 0;\n    this.tracksInGroup.length = 0;\n\n    _BasePlaylistControll.prototype.destroy.call(this);\n  };\n\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.tracks = [];\n    this.groupId = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.trackName = '';\n    this.selectDefaultTrack = true;\n  };\n\n  _proto.onManifestParsed = function onManifestParsed(event, data) {\n    this.tracks = data.audioTracks || [];\n  };\n\n  _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {\n    var id = data.id,\n        details = data.details;\n    var currentTrack = this.tracksInGroup[id];\n\n    if (!currentTrack) {\n      this.warn(\"Invalid audio track id \" + id);\n      return;\n    }\n\n    var curDetails = currentTrack.details;\n    currentTrack.details = data.details;\n    this.log(\"audioTrack \" + id + \" loaded [\" + details.startSN + \"-\" + details.endSN + \"]\");\n\n    if (id === this.trackId) {\n      this.retryCount = 0;\n      this.playlistLoaded(id, data, curDetails);\n    }\n  };\n\n  _proto.onLevelLoading = function onLevelLoading(event, data) {\n    this.switchLevel(data.level);\n  };\n\n  _proto.onLevelSwitching = function onLevelSwitching(event, data) {\n    this.switchLevel(data.level);\n  };\n\n  _proto.switchLevel = function switchLevel(levelIndex) {\n    var levelInfo = this.hls.levels[levelIndex];\n\n    if (!(levelInfo !== null && levelInfo !== void 0 && levelInfo.audioGroupIds)) {\n      return;\n    }\n\n    var audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];\n\n    if (this.groupId !== audioGroupId) {\n      this.groupId = audioGroupId;\n      var audioTracks = this.tracks.filter(function (track) {\n        return !audioGroupId || track.groupId === audioGroupId;\n      }); // Disable selectDefaultTrack if there are no default tracks\n\n      if (this.selectDefaultTrack && !audioTracks.some(function (track) {\n        return track.default;\n      })) {\n        this.selectDefaultTrack = false;\n      }\n\n      this.tracksInGroup = audioTracks;\n      var audioTracksUpdated = {\n        audioTracks: audioTracks\n      };\n      this.log(\"Updating audio tracks, \" + audioTracks.length + \" track(s) found in \\\"\" + audioGroupId + \"\\\" group-id\");\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].AUDIO_TRACKS_UPDATED, audioTracksUpdated);\n      this.selectInitialTrack();\n    }\n  };\n\n  _proto.onError = function onError(event, data) {\n    _BasePlaylistControll.prototype.onError.call(this, event, data);\n\n    if (data.fatal || !data.context) {\n      return;\n    }\n\n    if (data.context.type === _types_loader__WEBPACK_IMPORTED_MODULE_3__[\"PlaylistContextType\"].AUDIO_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {\n      this.retryLoadingOrFail(data);\n    }\n  };\n\n  _proto.setAudioTrack = function setAudioTrack(newId) {\n    var tracks = this.tracksInGroup; // check if level idx is valid\n\n    if (newId < 0 || newId >= tracks.length) {\n      this.warn('Invalid id passed to audio-track controller');\n      return;\n    } // stopping live reloading timer if any\n\n\n    this.clearTimer();\n    var lastTrack = tracks[this.trackId];\n    this.log(\"Now switching to audio-track index \" + newId);\n    var track = tracks[newId];\n    var id = track.id,\n        _track$groupId = track.groupId,\n        groupId = _track$groupId === void 0 ? '' : _track$groupId,\n        name = track.name,\n        type = track.type,\n        url = track.url;\n    this.trackId = newId;\n    this.trackName = name;\n    this.selectDefaultTrack = false;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].AUDIO_TRACK_SWITCHING, {\n      id: id,\n      groupId: groupId,\n      name: name,\n      type: type,\n      url: url\n    }); // Do not reload track unless live\n\n    if (track.details && !track.details.live) {\n      return;\n    }\n\n    var hlsUrlParameters = this.switchParams(track.url, lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.details);\n    this.loadPlaylist(hlsUrlParameters);\n  };\n\n  _proto.selectInitialTrack = function selectInitialTrack() {\n    var audioTracks = this.tracksInGroup;\n    console.assert(audioTracks.length, 'Initial audio track should be selected when tracks are known');\n    var currentAudioTrackName = this.trackName;\n    var trackId = this.findTrackId(currentAudioTrackName) || this.findTrackId();\n\n    if (trackId !== -1) {\n      this.setAudioTrack(trackId);\n    } else {\n      this.warn(\"No track found for running audio group-ID: \" + this.groupId);\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].AUDIO_TRACK_LOAD_ERROR,\n        fatal: true\n      });\n    }\n  };\n\n  _proto.findTrackId = function findTrackId(name) {\n    var audioTracks = this.tracksInGroup;\n\n    for (var i = 0; i < audioTracks.length; i++) {\n      var track = audioTracks[i];\n\n      if (!this.selectDefaultTrack || track.default) {\n        if (!name || name === track.name) {\n          return track.id;\n        }\n      }\n    }\n\n    return -1;\n  };\n\n  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n    var audioTrack = this.tracksInGroup[this.trackId];\n\n    if (this.shouldLoadTrack(audioTrack)) {\n      var id = audioTrack.id;\n      var groupId = audioTrack.groupId;\n      var url = audioTrack.url;\n\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + error);\n        }\n      } // track not retrieved yet, or live playlist we need to (re)load it\n\n\n      this.log(\"loading audio-track playlist for id: \" + id);\n      this.clearTimer();\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].AUDIO_TRACK_LOADING, {\n        url: url,\n        id: id,\n        groupId: groupId,\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  };\n\n  _createClass(AudioTrackController, [{\n    key: \"audioTracks\",\n    get: function get() {\n      return this.tracksInGroup;\n    }\n  }, {\n    key: \"audioTrack\",\n    get: function get() {\n      return this.trackId;\n    },\n    set: function set(newId) {\n      // If audio track is selected from API then don't choose from the manifest default track\n      this.selectDefaultTrack = false;\n      this.setAudioTrack(newId);\n    }\n  }]);\n\n  return AudioTrackController;\n}(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AudioTrackController);\n\n/***/ }),\n\n/***/ \"./src/controller/base-playlist-controller.ts\":\n/*!****************************************************!*\\\n  !*** ./src/controller/base-playlist-controller.ts ***!\n  \\****************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_108886__) {\n\n\"use strict\";\n__nested_webpack_require_108886__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_108886__.d(__webpack_exports__, \"default\", function() { return BasePlaylistController; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_108886__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _types_level__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_108886__(/*! ../types/level */ \"./src/types/level.ts\");\n/* harmony import */ var _level_helper__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_108886__(/*! ./level-helper */ \"./src/controller/level-helper.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_108886__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_108886__(/*! ../errors */ \"./src/errors.ts\");\n\n\n\n\n\n\n\nvar BasePlaylistController = /*#__PURE__*/function () {\n  function BasePlaylistController(hls, logPrefix) {\n    this.hls = void 0;\n    this.timer = -1;\n    this.canLoad = false;\n    this.retryCount = 0;\n    this.log = void 0;\n    this.warn = void 0;\n    this.log = _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].log.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"], logPrefix + \":\");\n    this.warn = _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"], logPrefix + \":\");\n    this.hls = hls;\n  }\n\n  var _proto = BasePlaylistController.prototype;\n\n  _proto.destroy = function destroy() {\n    this.clearTimer(); // @ts-ignore\n\n    this.hls = this.log = this.warn = null;\n  };\n\n  _proto.onError = function onError(event, data) {\n    if (data.fatal && data.type === _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorTypes\"].NETWORK_ERROR) {\n      this.clearTimer();\n    }\n  };\n\n  _proto.clearTimer = function clearTimer() {\n    clearTimeout(this.timer);\n    this.timer = -1;\n  };\n\n  _proto.startLoad = function startLoad() {\n    this.canLoad = true;\n    this.retryCount = 0;\n    this.loadPlaylist();\n  };\n\n  _proto.stopLoad = function stopLoad() {\n    this.canLoad = false;\n    this.clearTimer();\n  };\n\n  _proto.switchParams = function switchParams(playlistUri, previous) {\n    var renditionReports = previous === null || previous === void 0 ? void 0 : previous.renditionReports;\n\n    if (renditionReports) {\n      for (var i = 0; i < renditionReports.length; i++) {\n        var attr = renditionReports[i];\n        var uri = '' + attr.URI;\n\n        if (uri === playlistUri.slice(-uri.length)) {\n          var msn = parseInt(attr['LAST-MSN']);\n          var part = parseInt(attr['LAST-PART']);\n\n          if (previous && this.hls.config.lowLatencyMode) {\n            var currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);\n\n            if (part !== undefined && currentGoal > previous.partTarget) {\n              part += 1;\n            }\n          }\n\n          if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(msn)) {\n            return new _types_level__WEBPACK_IMPORTED_MODULE_1__[\"HlsUrlParameters\"](msn, Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(part) ? part : undefined, _types_level__WEBPACK_IMPORTED_MODULE_1__[\"HlsSkip\"].No);\n          }\n        }\n      }\n    }\n  };\n\n  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {};\n\n  _proto.shouldLoadTrack = function shouldLoadTrack(track) {\n    return this.canLoad && track && !!track.url && (!track.details || track.details.live);\n  };\n\n  _proto.playlistLoaded = function playlistLoaded(index, data, previousDetails) {\n    var _this = this;\n\n    var details = data.details,\n        stats = data.stats; // Set last updated date-time\n\n    var elapsed = stats.loading.end ? Math.max(0, self.performance.now() - stats.loading.end) : 0;\n    details.advancedDateTime = Date.now() - elapsed; // if current playlist is a live playlist, arm a timer to reload it\n\n    if (details.live || previousDetails !== null && previousDetails !== void 0 && previousDetails.live) {\n      details.reloaded(previousDetails);\n\n      if (previousDetails) {\n        this.log(\"live playlist \" + index + \" \" + (details.advanced ? 'REFRESHED ' + details.lastPartSn + '-' + details.lastPartIndex : 'MISSED'));\n      } // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments\n\n\n      if (previousDetails && details.fragments.length > 0) {\n        Object(_level_helper__WEBPACK_IMPORTED_MODULE_2__[\"mergeDetails\"])(previousDetails, details);\n      }\n\n      if (!this.canLoad || !details.live) {\n        return;\n      }\n\n      var deliveryDirectives;\n      var msn = undefined;\n      var part = undefined;\n\n      if (details.canBlockReload && details.endSN && details.advanced) {\n        // Load level with LL-HLS delivery directives\n        var lowLatencyMode = this.hls.config.lowLatencyMode;\n        var lastPartSn = details.lastPartSn;\n        var endSn = details.endSN;\n        var lastPartIndex = details.lastPartIndex;\n        var hasParts = lastPartIndex !== -1;\n        var lastPart = lastPartSn === endSn; // When low latency mode is disabled, we'll skip part requests once the last part index is found\n\n        var nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;\n\n        if (hasParts) {\n          msn = lastPart ? endSn + 1 : lastPartSn;\n          part = lastPart ? nextSnStartIndex : lastPartIndex + 1;\n        } else {\n          msn = endSn + 1;\n        } // Low-Latency CDN Tune-in: \"age\" header and time since load indicates we're behind by more than one part\n        // Update directives to obtain the Playlist that has the estimated additional duration of media\n\n\n        var lastAdvanced = details.age;\n        var cdnAge = lastAdvanced + details.ageHeader;\n        var currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);\n\n        if (currentGoal > 0) {\n          if (previousDetails && currentGoal > previousDetails.tuneInGoal) {\n            // If we attempted to get the next or latest playlist update, but currentGoal increased,\n            // then we either can't catchup, or the \"age\" header cannot be trusted.\n            this.warn(\"CDN Tune-in goal increased from: \" + previousDetails.tuneInGoal + \" to: \" + currentGoal + \" with playlist age: \" + details.age);\n            currentGoal = 0;\n          } else {\n            var segments = Math.floor(currentGoal / details.targetduration);\n            msn += segments;\n\n            if (part !== undefined) {\n              var parts = Math.round(currentGoal % details.targetduration / details.partTarget);\n              part += parts;\n            }\n\n            this.log(\"CDN Tune-in age: \" + details.ageHeader + \"s last advanced \" + lastAdvanced.toFixed(2) + \"s goal: \" + currentGoal + \" skip sn \" + segments + \" to part \" + part);\n          }\n\n          details.tuneInGoal = currentGoal;\n        }\n\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n\n        if (lowLatencyMode || !lastPart) {\n          this.loadPlaylist(deliveryDirectives);\n          return;\n        }\n      } else {\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n      }\n\n      var reloadInterval = Object(_level_helper__WEBPACK_IMPORTED_MODULE_2__[\"computeReloadInterval\"])(details, stats);\n\n      if (msn !== undefined && details.canBlockReload) {\n        reloadInterval -= details.partTarget || 1;\n      }\n\n      this.log(\"reload live playlist \" + index + \" in \" + Math.round(reloadInterval) + \" ms\");\n      this.timer = self.setTimeout(function () {\n        return _this.loadPlaylist(deliveryDirectives);\n      }, reloadInterval);\n    } else {\n      this.clearTimer();\n    }\n  };\n\n  _proto.getDeliveryDirectives = function getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {\n    var skip = Object(_types_level__WEBPACK_IMPORTED_MODULE_1__[\"getSkipValue\"])(details, msn);\n\n    if (previousDeliveryDirectives !== null && previousDeliveryDirectives !== void 0 && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {\n      msn = previousDeliveryDirectives.msn;\n      part = previousDeliveryDirectives.part;\n      skip = _types_level__WEBPACK_IMPORTED_MODULE_1__[\"HlsSkip\"].No;\n    }\n\n    return new _types_level__WEBPACK_IMPORTED_MODULE_1__[\"HlsUrlParameters\"](msn, part, skip);\n  };\n\n  _proto.retryLoadingOrFail = function retryLoadingOrFail(errorEvent) {\n    var _this2 = this;\n\n    var config = this.hls.config;\n    var retry = this.retryCount < config.levelLoadingMaxRetry;\n\n    if (retry) {\n      var _errorEvent$context;\n\n      this.retryCount++;\n\n      if (errorEvent.details.indexOf('LoadTimeOut') > -1 && (_errorEvent$context = errorEvent.context) !== null && _errorEvent$context !== void 0 && _errorEvent$context.deliveryDirectives) {\n        // The LL-HLS request already timed out so retry immediately\n        this.warn(\"retry playlist loading #\" + this.retryCount + \" after \\\"\" + errorEvent.details + \"\\\"\");\n        this.loadPlaylist();\n      } else {\n        // exponential backoff capped to max retry timeout\n        var delay = Math.min(Math.pow(2, this.retryCount) * config.levelLoadingRetryDelay, config.levelLoadingMaxRetryTimeout); // Schedule level/track reload\n\n        this.timer = self.setTimeout(function () {\n          return _this2.loadPlaylist();\n        }, delay);\n        this.warn(\"retry playlist loading #\" + this.retryCount + \" in \" + delay + \" ms after \\\"\" + errorEvent.details + \"\\\"\");\n      }\n    } else {\n      this.warn(\"cannot recover from error \\\"\" + errorEvent.details + \"\\\"\"); // stopping live reloading timer if any\n\n      this.clearTimer(); // switch error to fatal\n\n      errorEvent.fatal = true;\n    }\n\n    return retry;\n  };\n\n  return BasePlaylistController;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/base-stream-controller.ts\":\n/*!**************************************************!*\\\n  !*** ./src/controller/base-stream-controller.ts ***!\n  \\**************************************************/\n/*! exports provided: State, default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_119186__) {\n\n\"use strict\";\n__nested_webpack_require_119186__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_119186__.d(__webpack_exports__, \"State\", function() { return State; });\n/* harmony export (binding) */ __nested_webpack_require_119186__.d(__webpack_exports__, \"default\", function() { return BaseStreamController; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_119186__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _task_loop__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_119186__(/*! ../task-loop */ \"./src/task-loop.ts\");\n/* harmony import */ var _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_119186__(/*! ./fragment-tracker */ \"./src/controller/fragment-tracker.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_119186__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_119186__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_119186__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_119186__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _types_transmuxer__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_119186__(/*! ../types/transmuxer */ \"./src/types/transmuxer.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_119186__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _utils_discontinuities__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_119186__(/*! ../utils/discontinuities */ \"./src/utils/discontinuities.ts\");\n/* harmony import */ var _fragment_finders__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_119186__(/*! ./fragment-finders */ \"./src/controller/fragment-finders.ts\");\n/* harmony import */ var _level_helper__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_119186__(/*! ./level-helper */ \"./src/controller/level-helper.ts\");\n/* harmony import */ var _loader_fragment_loader__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_119186__(/*! ../loader/fragment-loader */ \"./src/loader/fragment-loader.ts\");\n/* harmony import */ var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_119186__(/*! ../crypt/decrypter */ \"./src/crypt/decrypter.ts\");\n/* harmony import */ var _utils_time_ranges__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_119186__(/*! ../utils/time-ranges */ \"./src/utils/time-ranges.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_119186__(/*! ../types/loader */ \"./src/types/loader.ts\");\n\n\n\n\n\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar State = {\n  STOPPED: 'STOPPED',\n  IDLE: 'IDLE',\n  KEY_LOADING: 'KEY_LOADING',\n  FRAG_LOADING: 'FRAG_LOADING',\n  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',\n  WAITING_TRACK: 'WAITING_TRACK',\n  PARSING: 'PARSING',\n  PARSED: 'PARSED',\n  ENDED: 'ENDED',\n  ERROR: 'ERROR',\n  WAITING_INIT_PTS: 'WAITING_INIT_PTS',\n  WAITING_LEVEL: 'WAITING_LEVEL'\n};\n\nvar BaseStreamController = /*#__PURE__*/function (_TaskLoop) {\n  _inheritsLoose(BaseStreamController, _TaskLoop);\n\n  function BaseStreamController(hls, fragmentTracker, logPrefix) {\n    var _this;\n\n    _this = _TaskLoop.call(this) || this;\n    _this.hls = void 0;\n    _this.fragPrevious = null;\n    _this.fragCurrent = null;\n    _this.fragmentTracker = void 0;\n    _this.transmuxer = null;\n    _this._state = State.STOPPED;\n    _this.media = void 0;\n    _this.mediaBuffer = void 0;\n    _this.config = void 0;\n    _this.bitrateTest = false;\n    _this.lastCurrentTime = 0;\n    _this.nextLoadPosition = 0;\n    _this.startPosition = 0;\n    _this.loadedmetadata = false;\n    _this.fragLoadError = 0;\n    _this.retryDate = 0;\n    _this.levels = null;\n    _this.fragmentLoader = void 0;\n    _this.levelLastLoaded = null;\n    _this.startFragRequested = false;\n    _this.decrypter = void 0;\n    _this.initPTS = [];\n    _this.onvseeking = null;\n    _this.onvended = null;\n    _this.logPrefix = '';\n    _this.log = void 0;\n    _this.warn = void 0;\n    _this.logPrefix = logPrefix;\n    _this.log = _utils_logger__WEBPACK_IMPORTED_MODULE_4__[\"logger\"].log.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_4__[\"logger\"], logPrefix + \":\");\n    _this.warn = _utils_logger__WEBPACK_IMPORTED_MODULE_4__[\"logger\"].warn.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_4__[\"logger\"], logPrefix + \":\");\n    _this.hls = hls;\n    _this.fragmentLoader = new _loader_fragment_loader__WEBPACK_IMPORTED_MODULE_12__[\"default\"](hls.config);\n    _this.fragmentTracker = fragmentTracker;\n    _this.config = hls.config;\n    _this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_13__[\"default\"](hls, hls.config);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].KEY_LOADED, _this.onKeyLoaded, _assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = BaseStreamController.prototype;\n\n  _proto.doTick = function doTick() {\n    this.onTickEnd();\n  };\n\n  _proto.onTickEnd = function onTickEnd() {} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ;\n\n  _proto.startLoad = function startLoad(startPosition) {};\n\n  _proto.stopLoad = function stopLoad() {\n    this.fragmentLoader.abort();\n    var frag = this.fragCurrent;\n\n    if (frag) {\n      this.fragmentTracker.removeFragment(frag);\n    }\n\n    this.resetTransmuxer();\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    this.clearInterval();\n    this.clearNextTick();\n    this.state = State.STOPPED;\n  };\n\n  _proto._streamEnded = function _streamEnded(bufferInfo, levelDetails) {\n    var fragCurrent = this.fragCurrent,\n        fragmentTracker = this.fragmentTracker; // we just got done loading the final fragment and there is no other buffered range after ...\n    // rationale is that in case there are any buffered ranges after, it means that there are unbuffered portion in between\n    // so we should not switch to ENDED in that case, to be able to buffer them\n\n    if (!levelDetails.live && fragCurrent && // NOTE: Because of the way parts are currently parsed/represented in the playlist, we can end up\n    // in situations where the current fragment is actually greater than levelDetails.endSN. While\n    // this feels like the \"wrong place\" to account for that, this is a narrower/safer change than\n    // updating e.g. M3U8Parser::parseLevelPlaylist().\n    fragCurrent.sn >= levelDetails.endSN && !bufferInfo.nextStart) {\n      var partList = levelDetails.partList; // Since the last part isn't guaranteed to correspond to fragCurrent for ll-hls, check instead if the last part is buffered.\n\n      if (partList !== null && partList !== void 0 && partList.length) {\n        var lastPart = partList[partList.length - 1]; // Checking the midpoint of the part for potential margin of error and related issues.\n        // NOTE: Technically I believe parts could yield content that is < the computed duration (including potential a duration of 0)\n        // and still be spec-compliant, so there may still be edge cases here. Likewise, there could be issues in end of stream\n        // part mismatches for independent audio and video playlists/segments.\n\n        var lastPartBuffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].isBuffered(this.media, lastPart.start + lastPart.duration / 2);\n        return lastPartBuffered;\n      }\n\n      var fragState = fragmentTracker.getState(fragCurrent);\n      return fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__[\"FragmentState\"].PARTIAL || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__[\"FragmentState\"].OK;\n    }\n\n    return false;\n  };\n\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    var media = this.media = this.mediaBuffer = data.media;\n    this.onvseeking = this.onMediaSeeking.bind(this);\n    this.onvended = this.onMediaEnded.bind(this);\n    media.addEventListener('seeking', this.onvseeking);\n    media.addEventListener('ended', this.onvended);\n    var config = this.config;\n\n    if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {\n      this.startLoad(config.startPosition);\n    }\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    var media = this.media;\n\n    if (media !== null && media !== void 0 && media.ended) {\n      this.log('MSE detaching and video ended, reset startPosition');\n      this.startPosition = this.lastCurrentTime = 0;\n    } // remove video listeners\n\n\n    if (media) {\n      media.removeEventListener('seeking', this.onvseeking);\n      media.removeEventListener('ended', this.onvended);\n      this.onvseeking = this.onvended = null;\n    }\n\n    this.media = this.mediaBuffer = null;\n    this.loadedmetadata = false;\n    this.fragmentTracker.removeAllFragments();\n    this.stopLoad();\n  };\n\n  _proto.onMediaSeeking = function onMediaSeeking() {\n    var config = this.config,\n        fragCurrent = this.fragCurrent,\n        media = this.media,\n        mediaBuffer = this.mediaBuffer,\n        state = this.state;\n    var currentTime = media ? media.currentTime : 0;\n    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].bufferInfo(mediaBuffer || media, currentTime, config.maxBufferHole);\n    this.log(\"media seeking to \" + (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(currentTime) ? currentTime.toFixed(3) : currentTime) + \", state: \" + state);\n\n    if (state === State.ENDED) {\n      this.resetLoadingState();\n    } else if (fragCurrent && !bufferInfo.len) {\n      // check if we are seeking to a unbuffered area AND if frag loading is in progress\n      var tolerance = config.maxFragLookUpTolerance;\n      var fragStartOffset = fragCurrent.start - tolerance;\n      var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;\n      var pastFragment = currentTime > fragEndOffset; // check if the seek position is past current fragment, and if so abort loading\n\n      if (currentTime < fragStartOffset || pastFragment) {\n        if (pastFragment && fragCurrent.loader) {\n          this.log('seeking outside of buffer while fragment load in progress, cancel fragment load');\n          fragCurrent.loader.abort();\n        }\n\n        this.resetLoadingState();\n      }\n    }\n\n    if (media) {\n      this.lastCurrentTime = currentTime;\n    } // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target\n\n\n    if (!this.loadedmetadata && !bufferInfo.len) {\n      this.nextLoadPosition = this.startPosition = currentTime;\n    } // Async tick to speed up processing\n\n\n    this.tickImmediate();\n  };\n\n  _proto.onMediaEnded = function onMediaEnded() {\n    // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n    this.startPosition = this.lastCurrentTime = 0;\n  };\n\n  _proto.onKeyLoaded = function onKeyLoaded(event, data) {\n    if (this.state !== State.KEY_LOADING || data.frag !== this.fragCurrent || !this.levels) {\n      return;\n    }\n\n    this.state = State.IDLE;\n    var levelDetails = this.levels[data.frag.level].details;\n\n    if (levelDetails) {\n      this.loadFragment(data.frag, levelDetails, data.frag.start);\n    }\n  };\n\n  _proto.onHandlerDestroying = function onHandlerDestroying() {\n    this.stopLoad();\n\n    _TaskLoop.prototype.onHandlerDestroying.call(this);\n  };\n\n  _proto.onHandlerDestroyed = function onHandlerDestroyed() {\n    this.state = State.STOPPED;\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].KEY_LOADED, this.onKeyLoaded, this);\n\n    if (this.fragmentLoader) {\n      this.fragmentLoader.destroy();\n    }\n\n    if (this.decrypter) {\n      this.decrypter.destroy();\n    }\n\n    this.hls = this.log = this.warn = this.decrypter = this.fragmentLoader = this.fragmentTracker = null;\n\n    _TaskLoop.prototype.onHandlerDestroyed.call(this);\n  };\n\n  _proto.loadKey = function loadKey(frag, details) {\n    this.log(\"Loading key for \" + frag.sn + \" of [\" + details.startSN + \"-\" + details.endSN + \"], \" + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \" \" + frag.level);\n    this.state = State.KEY_LOADING;\n    this.fragCurrent = frag;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].KEY_LOADING, {\n      frag: frag\n    });\n  };\n\n  _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {\n    this._loadFragForPlayback(frag, levelDetails, targetBufferTime);\n  };\n\n  _proto._loadFragForPlayback = function _loadFragForPlayback(frag, levelDetails, targetBufferTime) {\n    var _this2 = this;\n\n    var progressCallback = function progressCallback(data) {\n      if (_this2.fragContextChanged(frag)) {\n        _this2.warn(\"Fragment \" + frag.sn + (data.part ? ' p: ' + data.part.index : '') + \" of level \" + frag.level + \" was dropped during download.\");\n\n        _this2.fragmentTracker.removeFragment(frag);\n\n        return;\n      }\n\n      frag.stats.chunkCount++;\n\n      _this2._handleFragmentLoadProgress(data);\n    };\n\n    this._doFragLoad(frag, levelDetails, targetBufferTime, progressCallback).then(function (data) {\n      if (!data) {\n        // if we're here we probably needed to backtrack or are waiting for more parts\n        return;\n      }\n\n      _this2.fragLoadError = 0;\n      var state = _this2.state;\n\n      if (_this2.fragContextChanged(frag)) {\n        if (state === State.FRAG_LOADING || !_this2.fragCurrent && state === State.PARSING) {\n          _this2.fragmentTracker.removeFragment(frag);\n\n          _this2.state = State.IDLE;\n        }\n\n        return;\n      }\n\n      if ('payload' in data) {\n        _this2.log(\"Loaded fragment \" + frag.sn + \" of level \" + frag.level);\n\n        _this2.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].FRAG_LOADED, data);\n      } // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback\n\n\n      _this2._handleFragmentLoadComplete(data);\n    }).catch(function (reason) {\n      if (_this2.state === State.STOPPED) {\n        return;\n      }\n\n      _this2.warn(reason);\n\n      _this2.resetFragmentLoading(frag);\n    });\n  };\n\n  _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset, type) {\n    if (type === void 0) {\n      type = null;\n    }\n\n    if (!(startOffset - endOffset)) {\n      return;\n    } // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,\n    // passing a null type flushes both buffers\n\n\n    var flushScope = {\n      startOffset: startOffset,\n      endOffset: endOffset,\n      type: type\n    }; // Reset load errors on flush\n\n    this.fragLoadError = 0;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].BUFFER_FLUSHING, flushScope);\n  };\n\n  _proto._loadInitSegment = function _loadInitSegment(frag) {\n    var _this3 = this;\n\n    this._doFragLoad(frag).then(function (data) {\n      if (!data || _this3.fragContextChanged(frag) || !_this3.levels) {\n        throw new Error('init load aborted');\n      }\n\n      return data;\n    }).then(function (data) {\n      var hls = _this3.hls;\n      var payload = data.payload;\n      var decryptData = frag.decryptdata; // check to see if the payload needs to be decrypted\n\n      if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {\n        var startTime = self.performance.now(); // decrypt the subtitles\n\n        return _this3.decrypter.webCryptoDecrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).then(function (decryptedData) {\n          var endTime = self.performance.now();\n          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].FRAG_DECRYPTED, {\n            frag: frag,\n            payload: decryptedData,\n            stats: {\n              tstart: startTime,\n              tdecrypt: endTime\n            }\n          });\n          data.payload = decryptedData;\n          return data;\n        });\n      }\n\n      return data;\n    }).then(function (data) {\n      var fragCurrent = _this3.fragCurrent,\n          hls = _this3.hls,\n          levels = _this3.levels;\n\n      if (!levels) {\n        throw new Error('init load aborted, missing levels');\n      }\n\n      var details = levels[frag.level].details;\n      console.assert(details, 'Level details are defined when init segment is loaded');\n      var stats = frag.stats;\n      _this3.state = State.IDLE;\n      _this3.fragLoadError = 0;\n      frag.data = new Uint8Array(data.payload);\n      stats.parsing.start = stats.buffering.start = self.performance.now();\n      stats.parsing.end = stats.buffering.end = self.performance.now(); // Silence FRAG_BUFFERED event if fragCurrent is null\n\n      if (data.frag === fragCurrent) {\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].FRAG_BUFFERED, {\n          stats: stats,\n          frag: fragCurrent,\n          part: null,\n          id: frag.type\n        });\n      }\n\n      _this3.tick();\n    }).catch(function (reason) {\n      _this3.warn(reason);\n\n      _this3.resetFragmentLoading(frag);\n    });\n  };\n\n  _proto.fragContextChanged = function fragContextChanged(frag) {\n    var fragCurrent = this.fragCurrent;\n    return !frag || !fragCurrent || frag.level !== fragCurrent.level || frag.sn !== fragCurrent.sn || frag.urlId !== fragCurrent.urlId;\n  };\n\n  _proto.fragBufferedComplete = function fragBufferedComplete(frag, part) {\n    var media = this.mediaBuffer ? this.mediaBuffer : this.media;\n    this.log(\"Buffered \" + frag.type + \" sn: \" + frag.sn + (part ? ' part: ' + part.index : '') + \" of \" + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \" \" + frag.level + \" \" + _utils_time_ranges__WEBPACK_IMPORTED_MODULE_14__[\"default\"].toString(_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].getBuffered(media)));\n    this.state = State.IDLE;\n    this.tick();\n  };\n\n  _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedEndData) {\n    var transmuxer = this.transmuxer;\n\n    if (!transmuxer) {\n      return;\n    }\n\n    var frag = fragLoadedEndData.frag,\n        part = fragLoadedEndData.part,\n        partsLoaded = fragLoadedEndData.partsLoaded; // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data\n\n    var complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(function (fragLoaded) {\n      return !fragLoaded;\n    });\n    var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_7__[\"ChunkMetadata\"](frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);\n    transmuxer.flush(chunkMeta);\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ;\n\n  _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(frag) {};\n\n  _proto._doFragLoad = function _doFragLoad(frag, details, targetBufferTime, progressCallback) {\n    var _this4 = this;\n\n    if (targetBufferTime === void 0) {\n      targetBufferTime = null;\n    }\n\n    if (!this.levels) {\n      throw new Error('frag load aborted, missing levels');\n    }\n\n    targetBufferTime = Math.max(frag.start, targetBufferTime || 0);\n\n    if (this.config.lowLatencyMode && details) {\n      var partList = details.partList;\n\n      if (partList && progressCallback) {\n        if (targetBufferTime > frag.end && details.fragmentHint) {\n          frag = details.fragmentHint;\n        }\n\n        var partIndex = this.getNextPart(partList, frag, targetBufferTime);\n\n        if (partIndex > -1) {\n          var part = partList[partIndex];\n          this.log(\"Loading part sn: \" + frag.sn + \" p: \" + part.index + \" cc: \" + frag.cc + \" of playlist [\" + details.startSN + \"-\" + details.endSN + \"] parts [0-\" + partIndex + \"-\" + (partList.length - 1) + \"] \" + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \": \" + frag.level + \", target: \" + parseFloat(targetBufferTime.toFixed(3)));\n          this.nextLoadPosition = part.start + part.duration;\n          this.state = State.FRAG_LOADING;\n          this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].FRAG_LOADING, {\n            frag: frag,\n            part: partList[partIndex],\n            targetBufferTime: targetBufferTime\n          });\n          return this.doFragPartsLoad(frag, partList, partIndex, progressCallback).catch(function (error) {\n            return _this4.handleFragLoadError(error);\n          });\n        } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {\n          // Fragment hint has no parts\n          return Promise.resolve(null);\n        }\n      }\n    }\n\n    this.log(\"Loading fragment \" + frag.sn + \" cc: \" + frag.cc + \" \" + (details ? 'of [' + details.startSN + '-' + details.endSN + '] ' : '') + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \": \" + frag.level + \", target: \" + parseFloat(targetBufferTime.toFixed(3))); // Don't update nextLoadPosition for fragments which are not buffered\n\n    if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(frag.sn) && !this.bitrateTest) {\n      this.nextLoadPosition = frag.start + frag.duration;\n    }\n\n    this.state = State.FRAG_LOADING;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].FRAG_LOADING, {\n      frag: frag,\n      targetBufferTime: targetBufferTime\n    });\n    return this.fragmentLoader.load(frag, progressCallback).catch(function (error) {\n      return _this4.handleFragLoadError(error);\n    });\n  };\n\n  _proto.doFragPartsLoad = function doFragPartsLoad(frag, partList, partIndex, progressCallback) {\n    var _this5 = this;\n\n    return new Promise(function (resolve, reject) {\n      var partsLoaded = [];\n\n      var loadPartIndex = function loadPartIndex(index) {\n        var part = partList[index];\n\n        _this5.fragmentLoader.loadPart(frag, part, progressCallback).then(function (partLoadedData) {\n          partsLoaded[part.index] = partLoadedData;\n          var loadedPart = partLoadedData.part;\n\n          _this5.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].FRAG_LOADED, partLoadedData);\n\n          var nextPart = partList[index + 1];\n\n          if (nextPart && nextPart.fragment === frag) {\n            loadPartIndex(index + 1);\n          } else {\n            return resolve({\n              frag: frag,\n              part: loadedPart,\n              partsLoaded: partsLoaded\n            });\n          }\n        }).catch(reject);\n      };\n\n      loadPartIndex(partIndex);\n    });\n  };\n\n  _proto.handleFragLoadError = function handleFragLoadError(_ref) {\n    var data = _ref.data;\n\n    if (data && data.details === _errors__WEBPACK_IMPORTED_MODULE_6__[\"ErrorDetails\"].INTERNAL_ABORTED) {\n      this.handleFragLoadAborted(data.frag, data.part);\n    } else {\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].ERROR, data);\n    }\n\n    return null;\n  };\n\n  _proto._handleTransmuxerFlush = function _handleTransmuxerFlush(chunkMeta) {\n    var context = this.getCurrentContext(chunkMeta);\n\n    if (!context || this.state !== State.PARSING) {\n      if (!this.fragCurrent) {\n        this.state = State.IDLE;\n      }\n\n      return;\n    }\n\n    var frag = context.frag,\n        part = context.part,\n        level = context.level;\n    var now = self.performance.now();\n    frag.stats.parsing.end = now;\n\n    if (part) {\n      part.stats.parsing.end = now;\n    }\n\n    this.updateLevelTiming(frag, part, level, chunkMeta.partial);\n  };\n\n  _proto.getCurrentContext = function getCurrentContext(chunkMeta) {\n    var levels = this.levels;\n    var levelIndex = chunkMeta.level,\n        sn = chunkMeta.sn,\n        partIndex = chunkMeta.part;\n\n    if (!levels || !levels[levelIndex]) {\n      this.warn(\"Levels object was unset while buffering fragment \" + sn + \" of level \" + levelIndex + \". The current chunk will not be buffered.\");\n      return null;\n    }\n\n    var level = levels[levelIndex];\n    var part = partIndex > -1 ? Object(_level_helper__WEBPACK_IMPORTED_MODULE_11__[\"getPartWith\"])(level, sn, partIndex) : null;\n    var frag = part ? part.fragment : Object(_level_helper__WEBPACK_IMPORTED_MODULE_11__[\"getFragmentWithSN\"])(level, sn, this.fragCurrent);\n\n    if (!frag) {\n      return null;\n    }\n\n    return {\n      frag: frag,\n      part: part,\n      level: level\n    };\n  };\n\n  _proto.bufferFragmentData = function bufferFragmentData(data, frag, part, chunkMeta) {\n    if (!data || this.state !== State.PARSING) {\n      return;\n    }\n\n    var data1 = data.data1,\n        data2 = data.data2;\n    var buffer = data1;\n\n    if (data1 && data2) {\n      // Combine the moof + mdat so that we buffer with a single append\n      buffer = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__[\"appendUint8Array\"])(data1, data2);\n    }\n\n    if (!buffer || !buffer.length) {\n      return;\n    }\n\n    var segment = {\n      type: data.type,\n      frag: frag,\n      part: part,\n      chunkMeta: chunkMeta,\n      parent: frag.type,\n      data: buffer\n    };\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].BUFFER_APPENDING, segment);\n\n    if (data.dropped && data.independent && !part) {\n      // Clear buffer so that we reload previous segments sequentially if required\n      this.flushBufferGap(frag);\n    }\n  };\n\n  _proto.flushBufferGap = function flushBufferGap(frag) {\n    var media = this.media;\n\n    if (!media) {\n      return;\n    } // If currentTime is not buffered, clear the back buffer so that we can backtrack as much as needed\n\n\n    if (!_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].isBuffered(media, media.currentTime)) {\n      this.flushMainBuffer(0, frag.start);\n      return;\n    } // Remove back-buffer without interrupting playback to allow back tracking\n\n\n    var currentTime = media.currentTime;\n    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].bufferInfo(media, currentTime, 0);\n    var fragDuration = frag.duration;\n    var segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);\n    var start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);\n\n    if (frag.start - start > segmentFraction) {\n      this.flushMainBuffer(start, frag.start);\n    }\n  };\n\n  _proto.getFwdBufferInfo = function getFwdBufferInfo(bufferable, type) {\n    var config = this.config;\n    var pos = this.getLoadPosition();\n\n    if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(pos)) {\n      return null;\n    }\n\n    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].bufferInfo(bufferable, pos, config.maxBufferHole); // Workaround flaw in getting forward buffer when maxBufferHole is smaller than gap at current pos\n\n    if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {\n      var bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);\n\n      if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {\n        return _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, config.maxBufferHole));\n      }\n    }\n\n    return bufferInfo;\n  };\n\n  _proto.getMaxBufferLength = function getMaxBufferLength(levelBitrate) {\n    var config = this.config;\n    var maxBufLen;\n\n    if (levelBitrate) {\n      maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);\n    } else {\n      maxBufLen = config.maxBufferLength;\n    }\n\n    return Math.min(maxBufLen, config.maxMaxBufferLength);\n  };\n\n  _proto.reduceMaxBufferLength = function reduceMaxBufferLength(threshold) {\n    var config = this.config;\n    var minLength = threshold || config.maxBufferLength;\n\n    if (config.maxMaxBufferLength >= minLength) {\n      // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n      config.maxMaxBufferLength /= 2;\n      this.warn(\"Reduce max buffer length to \" + config.maxMaxBufferLength + \"s\");\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.getNextFragment = function getNextFragment(pos, levelDetails) {\n    var _frag, _frag2;\n\n    var fragments = levelDetails.fragments;\n    var fragLen = fragments.length;\n\n    if (!fragLen) {\n      return null;\n    } // find fragment index, contiguous with end of buffer position\n\n\n    var config = this.config;\n    var start = fragments[0].start;\n    var frag;\n\n    if (levelDetails.live) {\n      var initialLiveManifestSize = config.initialLiveManifestSize;\n\n      if (fragLen < initialLiveManifestSize) {\n        this.warn(\"Not enough fragments to start playback (have: \" + fragLen + \", need: \" + initialLiveManifestSize + \")\");\n        return null;\n      } // The real fragment start times for a live stream are only known after the PTS range for that level is known.\n      // In order to discover the range, we load the best matching fragment for that level and demux it.\n      // Do not load using live logic if the starting frag is requested - we want to use getFragmentAtPosition() so that\n      // we get the fragment matching that start time\n\n\n      if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1) {\n        frag = this.getInitialLiveFragment(levelDetails, fragments);\n        this.startPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;\n      }\n    } else if (pos <= start) {\n      // VoD playlist: if loadPosition before start of playlist, load first fragment\n      frag = fragments[0];\n    } // If we haven't run into any special cases already, just load the fragment most closely matching the requested position\n\n\n    if (!frag) {\n      var end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;\n      frag = this.getFragmentAtPosition(pos, end, levelDetails);\n    } // If an initSegment is present, it must be buffered first\n\n\n    if ((_frag = frag) !== null && _frag !== void 0 && _frag.initSegment && !((_frag2 = frag) !== null && _frag2 !== void 0 && _frag2.initSegment.data) && !this.bitrateTest) {\n      frag = frag.initSegment;\n    }\n\n    return frag;\n  };\n\n  _proto.getNextPart = function getNextPart(partList, frag, targetBufferTime) {\n    var nextPart = -1;\n    var contiguous = false;\n    var independentAttrOmitted = true;\n\n    for (var i = 0, len = partList.length; i < len; i++) {\n      var part = partList[i];\n      independentAttrOmitted = independentAttrOmitted && !part.independent;\n\n      if (nextPart > -1 && targetBufferTime < part.start) {\n        break;\n      }\n\n      var loaded = part.loaded;\n\n      if (!loaded && (contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {\n        nextPart = i;\n      }\n\n      contiguous = loaded;\n    }\n\n    return nextPart;\n  };\n\n  _proto.loadedEndOfParts = function loadedEndOfParts(partList, targetBufferTime) {\n    var lastPart = partList[partList.length - 1];\n    return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;\n  }\n  /*\n   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the\n   \"sliding\" of the playlist, which is its offset from the start of playback. After sliding we can compute the real\n   start and end times for each fragment in the playlist (after which this method will not need to be called).\n  */\n  ;\n\n  _proto.getInitialLiveFragment = function getInitialLiveFragment(levelDetails, fragments) {\n    var fragPrevious = this.fragPrevious;\n    var frag = null;\n\n    if (fragPrevious) {\n      if (levelDetails.hasProgramDateTime) {\n        // Prefer using PDT, because it can be accurate enough to choose the correct fragment without knowing the level sliding\n        this.log(\"Live playlist, switching playlist, load frag with same PDT: \" + fragPrevious.programDateTime);\n        frag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_10__[\"findFragmentByPDT\"])(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);\n      }\n\n      if (!frag) {\n        // SN does not need to be accurate between renditions, but depending on the packaging it may be so.\n        var targetSN = fragPrevious.sn + 1;\n\n        if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {\n          var fragNext = fragments[targetSN - levelDetails.startSN]; // Ensure that we're staying within the continuity range, since PTS resets upon a new range\n\n          if (fragPrevious.cc === fragNext.cc) {\n            frag = fragNext;\n            this.log(\"Live playlist, switching playlist, load frag with next SN: \" + frag.sn);\n          }\n        } // It's important to stay within the continuity range if available; otherwise the fragments in the playlist\n        // will have the wrong start times\n\n\n        if (!frag) {\n          frag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_10__[\"findFragWithCC\"])(fragments, fragPrevious.cc);\n\n          if (frag) {\n            this.log(\"Live playlist, switching playlist, load frag with same CC: \" + frag.sn);\n          }\n        }\n      }\n    } else {\n      // Find a new start fragment when fragPrevious is null\n      var liveStart = this.hls.liveSyncPosition;\n\n      if (liveStart !== null) {\n        frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);\n      }\n    }\n\n    return frag;\n  }\n  /*\n  This method finds the best matching fragment given the provided position.\n   */\n  ;\n\n  _proto.getFragmentAtPosition = function getFragmentAtPosition(bufferEnd, end, levelDetails) {\n    var config = this.config,\n        fragPrevious = this.fragPrevious;\n    var fragments = levelDetails.fragments,\n        endSN = levelDetails.endSN;\n    var fragmentHint = levelDetails.fragmentHint;\n    var tolerance = config.maxFragLookUpTolerance;\n    var loadingParts = !!(config.lowLatencyMode && levelDetails.partList && fragmentHint);\n\n    if (loadingParts && fragmentHint && !this.bitrateTest) {\n      // Include incomplete fragment with parts at end\n      fragments = fragments.concat(fragmentHint);\n      endSN = fragmentHint.sn;\n    }\n\n    var frag;\n\n    if (bufferEnd < end) {\n      var lookupTolerance = bufferEnd > end - tolerance ? 0 : tolerance; // Remove the tolerance if it would put the bufferEnd past the actual end of stream\n      // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)\n\n      frag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_10__[\"findFragmentByPTS\"])(fragPrevious, fragments, bufferEnd, lookupTolerance);\n    } else {\n      // reach end of playlist\n      frag = fragments[fragments.length - 1];\n    }\n\n    if (frag) {\n      var curSNIdx = frag.sn - levelDetails.startSN;\n      var sameLevel = fragPrevious && frag.level === fragPrevious.level;\n      var nextFrag = fragments[curSNIdx + 1];\n\n      if (fragPrevious && frag.sn === fragPrevious.sn && !loadingParts) {\n        // Force the next fragment to load if the previous one was already selected. This can occasionally happen with\n        // non-uniform fragment durations\n        if (sameLevel) {\n          if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__[\"FragmentState\"].OK) {\n            this.log(\"SN \" + frag.sn + \" just loaded, load next one: \" + nextFrag.sn);\n            frag = nextFrag;\n          } else {\n            frag = null;\n          }\n        }\n      }\n    }\n\n    return frag;\n  };\n\n  _proto.synchronizeToLiveEdge = function synchronizeToLiveEdge(levelDetails) {\n    var config = this.config,\n        media = this.media;\n\n    if (!media) {\n      return;\n    }\n\n    var liveSyncPosition = this.hls.liveSyncPosition;\n    var currentTime = media.currentTime;\n    var start = levelDetails.fragments[0].start;\n    var end = levelDetails.edge;\n    var withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end; // Continue if we can seek forward to sync position or if current time is outside of sliding window\n\n    if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {\n      // Continue if buffer is starving or if current time is behind max latency\n      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;\n\n      if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {\n        if (!this.loadedmetadata) {\n          this.nextLoadPosition = liveSyncPosition;\n        } // Only seek if ready and there is not a significant forward buffer available for playback\n\n\n        if (media.readyState) {\n          this.warn(\"Playback: \" + currentTime.toFixed(3) + \" is located too far from the end of live sliding playlist: \" + end + \", reset currentTime to : \" + liveSyncPosition.toFixed(3));\n          media.currentTime = liveSyncPosition;\n        }\n      }\n    }\n  };\n\n  _proto.alignPlaylists = function alignPlaylists(details, previousDetails) {\n    var levels = this.levels,\n        levelLastLoaded = this.levelLastLoaded,\n        fragPrevious = this.fragPrevious;\n    var lastLevel = levelLastLoaded !== null ? levels[levelLastLoaded] : null; // FIXME: If not for `shouldAlignOnDiscontinuities` requiring fragPrevious.cc,\n    //  this could all go in level-helper mergeDetails()\n\n    var length = details.fragments.length;\n\n    if (!length) {\n      this.warn(\"No fragments in live playlist\");\n      return 0;\n    }\n\n    var slidingStart = details.fragments[0].start;\n    var firstLevelLoad = !previousDetails;\n\n    var aligned = details.alignedSliding && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(slidingStart);\n\n    if (firstLevelLoad || !aligned && !slidingStart) {\n      Object(_utils_discontinuities__WEBPACK_IMPORTED_MODULE_9__[\"alignStream\"])(fragPrevious, lastLevel, details);\n      var alignedSlidingStart = details.fragments[0].start;\n      this.log(\"Live playlist sliding: \" + alignedSlidingStart.toFixed(2) + \" start-sn: \" + (previousDetails ? previousDetails.startSN : 'na') + \"->\" + details.startSN + \" prev-sn: \" + (fragPrevious ? fragPrevious.sn : 'na') + \" fragments: \" + length);\n      return alignedSlidingStart;\n    }\n\n    return slidingStart;\n  };\n\n  _proto.waitForCdnTuneIn = function waitForCdnTuneIn(details) {\n    // Wait for Low-Latency CDN Tune-in to get an updated playlist\n    var advancePartLimit = 3;\n    return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);\n  };\n\n  _proto.setStartPosition = function setStartPosition(details, sliding) {\n    // compute start position if set to -1. use it straight away if value is defined\n    var startPosition = this.startPosition;\n\n    if (startPosition < sliding) {\n      startPosition = -1;\n    }\n\n    if (startPosition === -1 || this.lastCurrentTime === -1) {\n      // first, check if start time offset has been set in playlist, if yes, use this value\n      var startTimeOffset = details.startTimeOffset;\n\n      if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(startTimeOffset)) {\n        startPosition = sliding + startTimeOffset;\n\n        if (startTimeOffset < 0) {\n          startPosition += details.totalduration;\n        }\n\n        startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);\n        this.log(\"Start time offset \" + startTimeOffset + \" found in playlist, adjust startPosition to \" + startPosition);\n        this.startPosition = startPosition;\n      } else if (details.live) {\n        // Leave this.startPosition at -1, so that we can use `getInitialLiveFragment` logic when startPosition has\n        // not been specified via the config or an as an argument to startLoad (#3736).\n        startPosition = this.hls.liveSyncPosition || sliding;\n      } else {\n        this.startPosition = startPosition = 0;\n      }\n\n      this.lastCurrentTime = startPosition;\n    }\n\n    this.nextLoadPosition = startPosition;\n  };\n\n  _proto.getLoadPosition = function getLoadPosition() {\n    var media = this.media; // if we have not yet loaded any fragment, start loading from start position\n\n    var pos = 0;\n\n    if (this.loadedmetadata && media) {\n      pos = media.currentTime;\n    } else if (this.nextLoadPosition) {\n      pos = this.nextLoadPosition;\n    }\n\n    return pos;\n  };\n\n  _proto.handleFragLoadAborted = function handleFragLoadAborted(frag, part) {\n    if (this.transmuxer && frag.sn !== 'initSegment' && frag.stats.aborted) {\n      this.warn(\"Fragment \" + frag.sn + (part ? ' part' + part.index : '') + \" of level \" + frag.level + \" was aborted\");\n      this.resetFragmentLoading(frag);\n    }\n  };\n\n  _proto.resetFragmentLoading = function resetFragmentLoading(frag) {\n    if (!this.fragCurrent || !this.fragContextChanged(frag)) {\n      this.state = State.IDLE;\n    }\n  };\n\n  _proto.onFragmentOrKeyLoadError = function onFragmentOrKeyLoadError(filterType, data) {\n    if (data.fatal) {\n      return;\n    }\n\n    var frag = data.frag; // Handle frag error related to caller's filterType\n\n    if (!frag || frag.type !== filterType) {\n      return;\n    }\n\n    var fragCurrent = this.fragCurrent;\n    console.assert(fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level && frag.urlId === fragCurrent.urlId, 'Frag load error must match current frag to retry');\n    var config = this.config; // keep retrying until the limit will be reached\n\n    if (this.fragLoadError + 1 <= config.fragLoadingMaxRetry) {\n      if (this.resetLiveStartWhenNotLoaded(frag.level)) {\n        return;\n      } // exponential backoff capped to config.fragLoadingMaxRetryTimeout\n\n\n      var delay = Math.min(Math.pow(2, this.fragLoadError) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);\n      this.warn(\"Fragment \" + frag.sn + \" of \" + filterType + \" \" + frag.level + \" failed to load, retrying in \" + delay + \"ms\");\n      this.retryDate = self.performance.now() + delay;\n      this.fragLoadError++;\n      this.state = State.FRAG_LOADING_WAITING_RETRY;\n    } else if (data.levelRetry) {\n      if (filterType === _types_loader__WEBPACK_IMPORTED_MODULE_15__[\"PlaylistLevelType\"].AUDIO) {\n        // Reset current fragment since audio track audio is essential and may not have a fail-over track\n        this.fragCurrent = null;\n      } // Fragment errors that result in a level switch or redundant fail-over\n      // should reset the stream controller state to idle\n\n\n      this.fragLoadError = 0;\n      this.state = State.IDLE;\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_4__[\"logger\"].error(data.details + \" reaches max retry, redispatch as fatal ...\"); // switch error to fatal\n\n      data.fatal = true;\n      this.hls.stopLoad();\n      this.state = State.ERROR;\n    }\n  };\n\n  _proto.afterBufferFlushed = function afterBufferFlushed(media, bufferType, playlistType) {\n    if (!media) {\n      return;\n    } // After successful buffer flushing, filter flushed fragments from bufferedFrags use mediaBuffered instead of media\n    // (so that we will check against video.buffered ranges in case of alt audio track)\n\n\n    var bufferedTimeRanges = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].getBuffered(media);\n    this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);\n\n    if (this.state === State.ENDED) {\n      this.resetLoadingState();\n    }\n  };\n\n  _proto.resetLoadingState = function resetLoadingState() {\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    this.state = State.IDLE;\n  };\n\n  _proto.resetLiveStartWhenNotLoaded = function resetLiveStartWhenNotLoaded(level) {\n    // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n    // in that case, reset startFragRequested flag\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n      var details = this.levels ? this.levels[level].details : null;\n\n      if (details !== null && details !== void 0 && details.live) {\n        // We can't afford to retry after a delay in a live scenario. Update the start position and return to IDLE.\n        this.startPosition = -1;\n        this.setStartPosition(details, 0);\n        this.resetLoadingState();\n        return true;\n      }\n\n      this.nextLoadPosition = this.startPosition;\n    }\n\n    return false;\n  };\n\n  _proto.updateLevelTiming = function updateLevelTiming(frag, part, level, partial) {\n    var _this6 = this;\n\n    var details = level.details;\n    console.assert(!!details, 'level.details must be defined');\n    var parsed = Object.keys(frag.elementaryStreams).reduce(function (result, type) {\n      var info = frag.elementaryStreams[type];\n\n      if (info) {\n        var parsedDuration = info.endPTS - info.startPTS;\n\n        if (parsedDuration <= 0) {\n          // Destroy the transmuxer after it's next time offset failed to advance because duration was <= 0.\n          // The new transmuxer will be configured with a time offset matching the next fragment start,\n          // preventing the timeline from shifting.\n          _this6.warn(\"Could not parse fragment \" + frag.sn + \" \" + type + \" duration reliably (\" + parsedDuration + \")\");\n\n          return result || false;\n        }\n\n        var drift = partial ? 0 : Object(_level_helper__WEBPACK_IMPORTED_MODULE_11__[\"updateFragPTSDTS\"])(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);\n\n        _this6.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].LEVEL_PTS_UPDATED, {\n          details: details,\n          level: level,\n          drift: drift,\n          type: type,\n          frag: frag,\n          start: info.startPTS,\n          end: info.endPTS\n        });\n\n        return true;\n      }\n\n      return result;\n    }, false);\n\n    if (!parsed) {\n      this.warn(\"Found no media in fragment \" + frag.sn + \" of level \" + level.id + \" resetting transmuxer to fallback to playlist timing\");\n      this.resetTransmuxer();\n    }\n\n    this.state = State.PARSED;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].FRAG_PARSED, {\n      frag: frag,\n      part: part\n    });\n  };\n\n  _proto.resetTransmuxer = function resetTransmuxer() {\n    if (this.transmuxer) {\n      this.transmuxer.destroy();\n      this.transmuxer = null;\n    }\n  };\n\n  _createClass(BaseStreamController, [{\n    key: \"state\",\n    get: function get() {\n      return this._state;\n    },\n    set: function set(nextState) {\n      var previousState = this._state;\n\n      if (previousState !== nextState) {\n        this._state = nextState;\n        this.log(previousState + \"->\" + nextState);\n      }\n    }\n  }]);\n\n  return BaseStreamController;\n}(_task_loop__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/buffer-controller.ts\":\n/*!*********************************************!*\\\n  !*** ./src/controller/buffer-controller.ts ***!\n  \\*********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_167695__) {\n\n\"use strict\";\n__nested_webpack_require_167695__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_167695__.d(__webpack_exports__, \"default\", function() { return BufferController; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_167695__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_167695__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_167695__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_167695__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_167695__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_167695__(/*! ../utils/mediasource-helper */ \"./src/utils/mediasource-helper.ts\");\n/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_167695__(/*! ../loader/fragment */ \"./src/loader/fragment.ts\");\n/* harmony import */ var _buffer_operation_queue__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_167695__(/*! ./buffer-operation-queue */ \"./src/controller/buffer-operation-queue.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nvar MediaSource = Object(_utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__[\"getMediaSource\"])();\nvar VIDEO_CODEC_PROFILE_REPACE = /([ha]vc.)(?:\\.[^.,]+)+/;\n\nvar BufferController = /*#__PURE__*/function () {\n  // The level details used to determine duration, target-duration and live\n  // cache the self generated object url to detect hijack of video tag\n  // A queue of buffer operations which require the SourceBuffer to not be updating upon execution\n  // References to event listeners for each SourceBuffer, so that they can be referenced for event removal\n  // The number of BUFFER_CODEC events received before any sourceBuffers are created\n  // The total number of BUFFER_CODEC events received\n  // A reference to the attached media element\n  // A reference to the active media source\n  // counters\n  function BufferController(_hls) {\n    var _this = this;\n\n    this.details = null;\n    this._objectUrl = null;\n    this.operationQueue = void 0;\n    this.listeners = void 0;\n    this.hls = void 0;\n    this.bufferCodecEventsExpected = 0;\n    this._bufferCodecEventsTotal = 0;\n    this.media = null;\n    this.mediaSource = null;\n    this.appendError = 0;\n    this.tracks = {};\n    this.pendingTracks = {};\n    this.sourceBuffer = void 0;\n\n    this._onMediaSourceOpen = function () {\n      var hls = _this.hls,\n          media = _this.media,\n          mediaSource = _this.mediaSource;\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('[buffer-controller]: Media source opened');\n\n      if (media) {\n        _this.updateMediaElementDuration();\n\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_ATTACHED, {\n          media: media\n        });\n      }\n\n      if (mediaSource) {\n        // once received, don't listen anymore to sourceopen event\n        mediaSource.removeEventListener('sourceopen', _this._onMediaSourceOpen);\n      }\n\n      _this.checkPendingTracks();\n    };\n\n    this._onMediaSourceClose = function () {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('[buffer-controller]: Media source closed');\n    };\n\n    this._onMediaSourceEnded = function () {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('[buffer-controller]: Media source ended');\n    };\n\n    this.hls = _hls;\n\n    this._initSourceBuffer();\n\n    this.registerListeners();\n  }\n\n  var _proto = BufferController.prototype;\n\n  _proto.hasSourceTypes = function hasSourceTypes() {\n    return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;\n  };\n\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.details = null;\n  };\n\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_RESET, this.onBufferReset, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_EOS, this.onBufferEos, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_PARSED, this.onFragParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_CHANGED, this.onFragChanged, this);\n  };\n\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_RESET, this.onBufferReset, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_EOS, this.onBufferEos, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_PARSED, this.onFragParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_CHANGED, this.onFragChanged, this);\n  };\n\n  _proto._initSourceBuffer = function _initSourceBuffer() {\n    this.sourceBuffer = {};\n    this.operationQueue = new _buffer_operation_queue__WEBPACK_IMPORTED_MODULE_7__[\"default\"](this.sourceBuffer);\n    this.listeners = {\n      audio: [],\n      video: [],\n      audiovideo: []\n    };\n  };\n\n  _proto.onManifestParsed = function onManifestParsed(event, data) {\n    // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller\n    // sourcebuffers will be created all at once when the expected nb of tracks will be reached\n    // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller\n    // it will contain the expected nb of source buffers, no need to compute it\n    var codecEvents = 2;\n\n    if (data.audio && !data.video || !data.altAudio) {\n      codecEvents = 1;\n    }\n\n    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;\n    this.details = null;\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(this.bufferCodecEventsExpected + \" bufferCodec event(s) expected\");\n  };\n\n  _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n    var media = this.media = data.media;\n\n    if (media && MediaSource) {\n      var ms = this.mediaSource = new MediaSource(); // MediaSource listeners are arrow functions with a lexical scope, and do not need to be bound\n\n      ms.addEventListener('sourceopen', this._onMediaSourceOpen);\n      ms.addEventListener('sourceended', this._onMediaSourceEnded);\n      ms.addEventListener('sourceclose', this._onMediaSourceClose); // link video and media Source\n\n      media.src = self.URL.createObjectURL(ms); // cache the locally generated object url\n\n      this._objectUrl = media.src;\n    }\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    var media = this.media,\n        mediaSource = this.mediaSource,\n        _objectUrl = this._objectUrl;\n\n    if (mediaSource) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('[buffer-controller]: media source detaching');\n\n      if (mediaSource.readyState === 'open') {\n        try {\n          // endOfStream could trigger exception if any sourcebuffer is in updating state\n          // we don't really care about checking sourcebuffer state here,\n          // as we are anyway detaching the MediaSource\n          // let's just avoid this exception to propagate\n          mediaSource.endOfStream();\n        } catch (err) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"[buffer-controller]: onMediaDetaching: \" + err.message + \" while calling endOfStream\");\n        }\n      } // Clean up the SourceBuffers by invoking onBufferReset\n\n\n      this.onBufferReset();\n      mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n      mediaSource.removeEventListener('sourceended', this._onMediaSourceEnded);\n      mediaSource.removeEventListener('sourceclose', this._onMediaSourceClose); // Detach properly the MediaSource from the HTMLMediaElement as\n      // suggested in https://github.com/w3c/media-source/issues/53.\n\n      if (media) {\n        if (_objectUrl) {\n          self.URL.revokeObjectURL(_objectUrl);\n        } // clean up video tag src only if it's our own url. some external libraries might\n        // hijack the video tag and change its 'src' without destroying the Hls instance first\n\n\n        if (media.src === _objectUrl) {\n          media.removeAttribute('src');\n          media.load();\n        } else {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn('[buffer-controller]: media.src was changed by a third party - skip cleanup');\n        }\n      }\n\n      this.mediaSource = null;\n      this.media = null;\n      this._objectUrl = null;\n      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;\n      this.pendingTracks = {};\n      this.tracks = {};\n    }\n\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_DETACHED, undefined);\n  };\n\n  _proto.onBufferReset = function onBufferReset() {\n    var _this2 = this;\n\n    this.getSourceBufferTypes().forEach(function (type) {\n      var sb = _this2.sourceBuffer[type];\n\n      try {\n        if (sb) {\n          _this2.removeBufferListeners(type);\n\n          if (_this2.mediaSource) {\n            _this2.mediaSource.removeSourceBuffer(sb);\n          } // Synchronously remove the SB from the map before the next call in order to prevent an async function from\n          // accessing it\n\n\n          _this2.sourceBuffer[type] = undefined;\n        }\n      } catch (err) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"[buffer-controller]: Failed to reset the \" + type + \" buffer\", err);\n      }\n    });\n\n    this._initSourceBuffer();\n  };\n\n  _proto.onBufferCodecs = function onBufferCodecs(event, data) {\n    var _this3 = this;\n\n    var sourceBufferCount = this.getSourceBufferTypes().length;\n    Object.keys(data).forEach(function (trackName) {\n      if (sourceBufferCount) {\n        // check if SourceBuffer codec needs to change\n        var track = _this3.tracks[trackName];\n\n        if (track && typeof track.buffer.changeType === 'function') {\n          var _data$trackName = data[trackName],\n              id = _data$trackName.id,\n              codec = _data$trackName.codec,\n              levelCodec = _data$trackName.levelCodec,\n              container = _data$trackName.container,\n              metadata = _data$trackName.metadata;\n          var currentCodec = (track.levelCodec || track.codec).replace(VIDEO_CODEC_PROFILE_REPACE, '$1');\n          var nextCodec = (levelCodec || codec).replace(VIDEO_CODEC_PROFILE_REPACE, '$1');\n\n          if (currentCodec !== nextCodec) {\n            var mimeType = container + \";codecs=\" + (levelCodec || codec);\n\n            _this3.appendChangeType(trackName, mimeType);\n\n            _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"[buffer-controller]: switching codec \" + currentCodec + \" to \" + nextCodec);\n            _this3.tracks[trackName] = {\n              buffer: track.buffer,\n              codec: codec,\n              container: container,\n              levelCodec: levelCodec,\n              metadata: metadata,\n              id: id\n            };\n          }\n        }\n      } else {\n        // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks\n        _this3.pendingTracks[trackName] = data[trackName];\n      }\n    }); // if sourcebuffers already created, do nothing ...\n\n    if (sourceBufferCount) {\n      return;\n    }\n\n    this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);\n\n    if (this.mediaSource && this.mediaSource.readyState === 'open') {\n      this.checkPendingTracks();\n    }\n  };\n\n  _proto.appendChangeType = function appendChangeType(type, mimeType) {\n    var _this4 = this;\n\n    var operationQueue = this.operationQueue;\n    var operation = {\n      execute: function execute() {\n        var sb = _this4.sourceBuffer[type];\n\n        if (sb) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"[buffer-controller]: changing \" + type + \" sourceBuffer type to \" + mimeType);\n          sb.changeType(mimeType);\n        }\n\n        operationQueue.shiftAndExecuteNext(type);\n      },\n      onStart: function onStart() {},\n      onComplete: function onComplete() {},\n      onError: function onError(e) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"[buffer-controller]: Failed to change \" + type + \" SourceBuffer type\", e);\n      }\n    };\n    operationQueue.append(operation, type);\n  };\n\n  _proto.onBufferAppending = function onBufferAppending(event, eventData) {\n    var _this5 = this;\n\n    var hls = this.hls,\n        operationQueue = this.operationQueue,\n        tracks = this.tracks;\n    var data = eventData.data,\n        type = eventData.type,\n        frag = eventData.frag,\n        part = eventData.part,\n        chunkMeta = eventData.chunkMeta;\n    var chunkStats = chunkMeta.buffering[type];\n    var bufferAppendingStart = self.performance.now();\n    chunkStats.start = bufferAppendingStart;\n    var fragBuffering = frag.stats.buffering;\n    var partBuffering = part ? part.stats.buffering : null;\n\n    if (fragBuffering.start === 0) {\n      fragBuffering.start = bufferAppendingStart;\n    }\n\n    if (partBuffering && partBuffering.start === 0) {\n      partBuffering.start = bufferAppendingStart;\n    } // TODO: Only update timestampOffset when audio/mpeg fragment or part is not contiguous with previously appended\n    // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)\n    // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`\n    // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos).\n    // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486\n\n\n    var audioTrack = tracks.audio;\n    var checkTimestampOffset = type === 'audio' && chunkMeta.id === 1 && (audioTrack === null || audioTrack === void 0 ? void 0 : audioTrack.container) === 'audio/mpeg';\n    var operation = {\n      execute: function execute() {\n        chunkStats.executeStart = self.performance.now();\n\n        if (checkTimestampOffset) {\n          var sb = _this5.sourceBuffer[type];\n\n          if (sb) {\n            var delta = frag.start - sb.timestampOffset;\n\n            if (Math.abs(delta) >= 0.1) {\n              _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"[buffer-controller]: Updating audio SourceBuffer timestampOffset to \" + frag.start + \" (delta: \" + delta + \") sn: \" + frag.sn + \")\");\n              sb.timestampOffset = frag.start;\n            }\n          }\n        }\n\n        _this5.appendExecutor(data, type);\n      },\n      onStart: function onStart() {// logger.debug(`[buffer-controller]: ${type} SourceBuffer updatestart`);\n      },\n      onComplete: function onComplete() {\n        // logger.debug(`[buffer-controller]: ${type} SourceBuffer updateend`);\n        var end = self.performance.now();\n        chunkStats.executeEnd = chunkStats.end = end;\n\n        if (fragBuffering.first === 0) {\n          fragBuffering.first = end;\n        }\n\n        if (partBuffering && partBuffering.first === 0) {\n          partBuffering.first = end;\n        }\n\n        var sourceBuffer = _this5.sourceBuffer;\n        var timeRanges = {};\n\n        for (var _type in sourceBuffer) {\n          timeRanges[_type] = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__[\"BufferHelper\"].getBuffered(sourceBuffer[_type]);\n        }\n\n        _this5.appendError = 0;\n\n        _this5.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_APPENDED, {\n          type: type,\n          frag: frag,\n          part: part,\n          chunkMeta: chunkMeta,\n          parent: frag.type,\n          timeRanges: timeRanges\n        });\n      },\n      onError: function onError(err) {\n        // in case any error occured while appending, put back segment in segments table\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(\"[buffer-controller]: Error encountered while trying to append to the \" + type + \" SourceBuffer\", err);\n        var event = {\n          type: _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorTypes\"].MEDIA_ERROR,\n          parent: frag.type,\n          details: _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorDetails\"].BUFFER_APPEND_ERROR,\n          err: err,\n          fatal: false\n        };\n\n        if (err.code === DOMException.QUOTA_EXCEEDED_ERR) {\n          // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror\n          // let's stop appending any segments, and report BUFFER_FULL_ERROR error\n          event.details = _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorDetails\"].BUFFER_FULL_ERROR;\n        } else {\n          _this5.appendError++;\n          event.details = _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorDetails\"].BUFFER_APPEND_ERROR;\n          /* with UHD content, we could get loop of quota exceeded error until\n            browser is able to evict some data from sourcebuffer. Retrying can help recover.\n          */\n\n          if (_this5.appendError > hls.config.appendErrorMaxRetry) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(\"[buffer-controller]: Failed \" + hls.config.appendErrorMaxRetry + \" times to append segment in sourceBuffer\");\n            event.fatal = true;\n          }\n        }\n\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, event);\n      }\n    };\n    operationQueue.append(operation, type);\n  };\n\n  _proto.onBufferFlushing = function onBufferFlushing(event, data) {\n    var _this6 = this;\n\n    var operationQueue = this.operationQueue;\n\n    var flushOperation = function flushOperation(type) {\n      return {\n        execute: _this6.removeExecutor.bind(_this6, type, data.startOffset, data.endOffset),\n        onStart: function onStart() {// logger.debug(`[buffer-controller]: Started flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n        },\n        onComplete: function onComplete() {\n          // logger.debug(`[buffer-controller]: Finished flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n          _this6.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_FLUSHED, {\n            type: type\n          });\n        },\n        onError: function onError(e) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"[buffer-controller]: Failed to remove from \" + type + \" SourceBuffer\", e);\n        }\n      };\n    };\n\n    if (data.type) {\n      operationQueue.append(flushOperation(data.type), data.type);\n    } else {\n      this.getSourceBufferTypes().forEach(function (type) {\n        operationQueue.append(flushOperation(type), type);\n      });\n    }\n  };\n\n  _proto.onFragParsed = function onFragParsed(event, data) {\n    var _this7 = this;\n\n    var frag = data.frag,\n        part = data.part;\n    var buffersAppendedTo = [];\n    var elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;\n\n    if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__[\"ElementaryStreamTypes\"].AUDIOVIDEO]) {\n      buffersAppendedTo.push('audiovideo');\n    } else {\n      if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__[\"ElementaryStreamTypes\"].AUDIO]) {\n        buffersAppendedTo.push('audio');\n      }\n\n      if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__[\"ElementaryStreamTypes\"].VIDEO]) {\n        buffersAppendedTo.push('video');\n      }\n    }\n\n    var onUnblocked = function onUnblocked() {\n      var now = self.performance.now();\n      frag.stats.buffering.end = now;\n\n      if (part) {\n        part.stats.buffering.end = now;\n      }\n\n      var stats = part ? part.stats : frag.stats;\n\n      _this7.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_BUFFERED, {\n        frag: frag,\n        part: part,\n        stats: stats,\n        id: frag.type\n      });\n    };\n\n    if (buffersAppendedTo.length === 0) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"Fragments must have at least one ElementaryStreamType set. type: \" + frag.type + \" level: \" + frag.level + \" sn: \" + frag.sn);\n    }\n\n    this.blockBuffers(onUnblocked, buffersAppendedTo);\n  };\n\n  _proto.onFragChanged = function onFragChanged(event, data) {\n    this.flushBackBuffer();\n  } // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()\n  // an undefined data.type will mark all buffers as EOS.\n  ;\n\n  _proto.onBufferEos = function onBufferEos(event, data) {\n    var _this8 = this;\n\n    var ended = this.getSourceBufferTypes().reduce(function (acc, type) {\n      var sb = _this8.sourceBuffer[type];\n\n      if (!data.type || data.type === type) {\n        if (sb && !sb.ended) {\n          sb.ended = true;\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"[buffer-controller]: \" + type + \" sourceBuffer now EOS\");\n        }\n      }\n\n      return acc && !!(!sb || sb.ended);\n    }, true);\n\n    if (ended) {\n      this.blockBuffers(function () {\n        var mediaSource = _this8.mediaSource;\n\n        if (!mediaSource || mediaSource.readyState !== 'open') {\n          return;\n        } // Allow this to throw and be caught by the enqueueing function\n\n\n        mediaSource.endOfStream();\n      });\n    }\n  };\n\n  _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {\n    var details = _ref.details;\n\n    if (!details.fragments.length) {\n      return;\n    }\n\n    this.details = details;\n\n    if (this.getSourceBufferTypes().length) {\n      this.blockBuffers(this.updateMediaElementDuration.bind(this));\n    } else {\n      this.updateMediaElementDuration();\n    }\n  };\n\n  _proto.flushBackBuffer = function flushBackBuffer() {\n    var hls = this.hls,\n        details = this.details,\n        media = this.media,\n        sourceBuffer = this.sourceBuffer;\n\n    if (!media || details === null) {\n      return;\n    }\n\n    var sourceBufferTypes = this.getSourceBufferTypes();\n\n    if (!sourceBufferTypes.length) {\n      return;\n    } // Support for deprecated liveBackBufferLength\n\n\n    var backBufferLength = details.live && hls.config.liveBackBufferLength !== null ? hls.config.liveBackBufferLength : hls.config.backBufferLength;\n\n    if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(backBufferLength) || backBufferLength < 0) {\n      return;\n    }\n\n    var currentTime = media.currentTime;\n    var targetDuration = details.levelTargetDuration;\n    var maxBackBufferLength = Math.max(backBufferLength, targetDuration);\n    var targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;\n    sourceBufferTypes.forEach(function (type) {\n      var sb = sourceBuffer[type];\n\n      if (sb) {\n        var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__[\"BufferHelper\"].getBuffered(sb); // when target buffer start exceeds actual buffer start\n\n        if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {\n          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BACK_BUFFER_REACHED, {\n            bufferEnd: targetBackBufferPosition\n          }); // Support for deprecated event:\n\n          if (details.live) {\n            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LIVE_BACK_BUFFER_REACHED, {\n              bufferEnd: targetBackBufferPosition\n            });\n          }\n\n          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_FLUSHING, {\n            startOffset: 0,\n            endOffset: targetBackBufferPosition,\n            type: type\n          });\n        }\n      }\n    });\n  }\n  /**\n   * Update Media Source duration to current level duration or override to Infinity if configuration parameter\n   * 'liveDurationInfinity` is set to `true`\n   * More details: https://github.com/video-dev/hls.js/issues/355\n   */\n  ;\n\n  _proto.updateMediaElementDuration = function updateMediaElementDuration() {\n    if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== 'open') {\n      return;\n    }\n\n    var details = this.details,\n        hls = this.hls,\n        media = this.media,\n        mediaSource = this.mediaSource;\n    var levelDuration = details.fragments[0].start + details.totalduration;\n    var mediaDuration = media.duration;\n    var msDuration = Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(mediaSource.duration) ? mediaSource.duration : 0;\n\n    if (details.live && hls.config.liveDurationInfinity) {\n      // Override duration to Infinity\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('[buffer-controller]: Media Source duration is set to Infinity');\n      mediaSource.duration = Infinity;\n      this.updateSeekableRange(details);\n    } else if (levelDuration > msDuration && levelDuration > mediaDuration || !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(mediaDuration)) {\n      // levelDuration was the last value we set.\n      // not using mediaSource.duration as the browser may tweak this value\n      // only update Media Source duration if its value increase, this is to avoid\n      // flushing already buffered portion when switching between quality level\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"[buffer-controller]: Updating Media Source duration to \" + levelDuration.toFixed(3));\n      mediaSource.duration = levelDuration;\n    }\n  };\n\n  _proto.updateSeekableRange = function updateSeekableRange(levelDetails) {\n    var mediaSource = this.mediaSource;\n    var fragments = levelDetails.fragments;\n    var len = fragments.length;\n\n    if (len && levelDetails.live && mediaSource !== null && mediaSource !== void 0 && mediaSource.setLiveSeekableRange) {\n      var start = Math.max(0, fragments[0].start);\n      var end = Math.max(start, start + levelDetails.totalduration);\n      mediaSource.setLiveSeekableRange(start, end);\n    }\n  };\n\n  _proto.checkPendingTracks = function checkPendingTracks() {\n    var bufferCodecEventsExpected = this.bufferCodecEventsExpected,\n        operationQueue = this.operationQueue,\n        pendingTracks = this.pendingTracks; // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.\n    // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after\n    // data has been appended to existing ones.\n    // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.\n\n    var pendingTracksCount = Object.keys(pendingTracks).length;\n\n    if (pendingTracksCount && !bufferCodecEventsExpected || pendingTracksCount === 2) {\n      // ok, let's create them now !\n      this.createSourceBuffers(pendingTracks);\n      this.pendingTracks = {}; // append any pending segments now !\n\n      var buffers = this.getSourceBufferTypes();\n\n      if (buffers.length === 0) {\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, {\n          type: _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorTypes\"].MEDIA_ERROR,\n          details: _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorDetails\"].BUFFER_INCOMPATIBLE_CODECS_ERROR,\n          fatal: true,\n          reason: 'could not create source buffer for media codec(s)'\n        });\n        return;\n      }\n\n      buffers.forEach(function (type) {\n        operationQueue.executeNext(type);\n      });\n    }\n  };\n\n  _proto.createSourceBuffers = function createSourceBuffers(tracks) {\n    var sourceBuffer = this.sourceBuffer,\n        mediaSource = this.mediaSource;\n\n    if (!mediaSource) {\n      throw Error('createSourceBuffers called when mediaSource was null');\n    }\n\n    var tracksCreated = 0;\n\n    for (var trackName in tracks) {\n      if (!sourceBuffer[trackName]) {\n        var track = tracks[trackName];\n\n        if (!track) {\n          throw Error(\"source buffer exists for track \" + trackName + \", however track does not\");\n        } // use levelCodec as first priority\n\n\n        var codec = track.levelCodec || track.codec;\n        var mimeType = track.container + \";codecs=\" + codec;\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"[buffer-controller]: creating sourceBuffer(\" + mimeType + \")\");\n\n        try {\n          var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);\n          var sbName = trackName;\n          this.addBufferListener(sbName, 'updatestart', this._onSBUpdateStart);\n          this.addBufferListener(sbName, 'updateend', this._onSBUpdateEnd);\n          this.addBufferListener(sbName, 'error', this._onSBUpdateError);\n          this.tracks[trackName] = {\n            buffer: sb,\n            codec: codec,\n            container: track.container,\n            levelCodec: track.levelCodec,\n            metadata: track.metadata,\n            id: track.id\n          };\n          tracksCreated++;\n        } catch (err) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(\"[buffer-controller]: error while trying to add sourceBuffer: \" + err.message);\n          this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, {\n            type: _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorTypes\"].MEDIA_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorDetails\"].BUFFER_ADD_CODEC_ERROR,\n            fatal: false,\n            error: err,\n            mimeType: mimeType\n          });\n        }\n      }\n    }\n\n    if (tracksCreated) {\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_CREATED, {\n        tracks: this.tracks\n      });\n    }\n  } // Keep as arrow functions so that we can directly reference these functions directly as event listeners\n  ;\n\n  _proto._onSBUpdateStart = function _onSBUpdateStart(type) {\n    var operationQueue = this.operationQueue;\n    var operation = operationQueue.current(type);\n    operation.onStart();\n  };\n\n  _proto._onSBUpdateEnd = function _onSBUpdateEnd(type) {\n    var operationQueue = this.operationQueue;\n    var operation = operationQueue.current(type);\n    operation.onComplete();\n    operationQueue.shiftAndExecuteNext(type);\n  };\n\n  _proto._onSBUpdateError = function _onSBUpdateError(type, event) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(\"[buffer-controller]: \" + type + \" SourceBuffer error\", event); // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n    // SourceBuffer errors are not necessarily fatal; if so, the HTMLMediaElement will fire an error event\n\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, {\n      type: _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorTypes\"].MEDIA_ERROR,\n      details: _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorDetails\"].BUFFER_APPENDING_ERROR,\n      fatal: false\n    }); // updateend is always fired after error, so we'll allow that to shift the current operation off of the queue\n\n    var operation = this.operationQueue.current(type);\n\n    if (operation) {\n      operation.onError(event);\n    }\n  } // This method must result in an updateend event; if remove is not called, _onSBUpdateEnd must be called manually\n  ;\n\n  _proto.removeExecutor = function removeExecutor(type, startOffset, endOffset) {\n    var media = this.media,\n        mediaSource = this.mediaSource,\n        operationQueue = this.operationQueue,\n        sourceBuffer = this.sourceBuffer;\n    var sb = sourceBuffer[type];\n\n    if (!media || !mediaSource || !sb) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"[buffer-controller]: Attempting to remove from the \" + type + \" SourceBuffer, but it does not exist\");\n      operationQueue.shiftAndExecuteNext(type);\n      return;\n    }\n\n    var mediaDuration = Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(media.duration) ? media.duration : Infinity;\n    var msDuration = Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(mediaSource.duration) ? mediaSource.duration : Infinity;\n    var removeStart = Math.max(0, startOffset);\n    var removeEnd = Math.min(endOffset, mediaDuration, msDuration);\n\n    if (removeEnd > removeStart) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"[buffer-controller]: Removing [\" + removeStart + \",\" + removeEnd + \"] from the \" + type + \" SourceBuffer\");\n      console.assert(!sb.updating, type + \" sourceBuffer must not be updating\");\n      sb.remove(removeStart, removeEnd);\n    } else {\n      // Cycle the queue\n      operationQueue.shiftAndExecuteNext(type);\n    }\n  } // This method must result in an updateend event; if append is not called, _onSBUpdateEnd must be called manually\n  ;\n\n  _proto.appendExecutor = function appendExecutor(data, type) {\n    var operationQueue = this.operationQueue,\n        sourceBuffer = this.sourceBuffer;\n    var sb = sourceBuffer[type];\n\n    if (!sb) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"[buffer-controller]: Attempting to append to the \" + type + \" SourceBuffer, but it does not exist\");\n      operationQueue.shiftAndExecuteNext(type);\n      return;\n    }\n\n    sb.ended = false;\n    console.assert(!sb.updating, type + \" sourceBuffer must not be updating\");\n    sb.appendBuffer(data);\n  } // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises\n  // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue\n  // upon completion, since we already do it here\n  ;\n\n  _proto.blockBuffers = function blockBuffers(onUnblocked, buffers) {\n    var _this9 = this;\n\n    if (buffers === void 0) {\n      buffers = this.getSourceBufferTypes();\n    }\n\n    if (!buffers.length) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('[buffer-controller]: Blocking operation requested, but no SourceBuffers exist');\n      Promise.resolve().then(onUnblocked);\n      return;\n    }\n\n    var operationQueue = this.operationQueue; // logger.debug(`[buffer-controller]: Blocking ${buffers} SourceBuffer`);\n\n    var blockingOperations = buffers.map(function (type) {\n      return operationQueue.appendBlocker(type);\n    });\n    Promise.all(blockingOperations).then(function () {\n      // logger.debug(`[buffer-controller]: Blocking operation resolved; unblocking ${buffers} SourceBuffer`);\n      onUnblocked();\n      buffers.forEach(function (type) {\n        var sb = _this9.sourceBuffer[type]; // Only cycle the queue if the SB is not updating. There's a bug in Chrome which sets the SB updating flag to\n        // true when changing the MediaSource duration (https://bugs.chromium.org/p/chromium/issues/detail?id=959359&can=2&q=mediasource%20duration)\n        // While this is a workaround, it's probably useful to have around\n\n        if (!sb || !sb.updating) {\n          operationQueue.shiftAndExecuteNext(type);\n        }\n      });\n    });\n  };\n\n  _proto.getSourceBufferTypes = function getSourceBufferTypes() {\n    return Object.keys(this.sourceBuffer);\n  };\n\n  _proto.addBufferListener = function addBufferListener(type, event, fn) {\n    var buffer = this.sourceBuffer[type];\n\n    if (!buffer) {\n      return;\n    }\n\n    var listener = fn.bind(this, type);\n    this.listeners[type].push({\n      event: event,\n      listener: listener\n    });\n    buffer.addEventListener(event, listener);\n  };\n\n  _proto.removeBufferListeners = function removeBufferListeners(type) {\n    var buffer = this.sourceBuffer[type];\n\n    if (!buffer) {\n      return;\n    }\n\n    this.listeners[type].forEach(function (l) {\n      buffer.removeEventListener(l.event, l.listener);\n    });\n  };\n\n  return BufferController;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/buffer-operation-queue.ts\":\n/*!**************************************************!*\\\n  !*** ./src/controller/buffer-operation-queue.ts ***!\n  \\**************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_205463__) {\n\n\"use strict\";\n__nested_webpack_require_205463__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_205463__.d(__webpack_exports__, \"default\", function() { return BufferOperationQueue; });\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_205463__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\nvar BufferOperationQueue = /*#__PURE__*/function () {\n  function BufferOperationQueue(sourceBufferReference) {\n    this.buffers = void 0;\n    this.queues = {\n      video: [],\n      audio: [],\n      audiovideo: []\n    };\n    this.buffers = sourceBufferReference;\n  }\n\n  var _proto = BufferOperationQueue.prototype;\n\n  _proto.append = function append(operation, type) {\n    var queue = this.queues[type];\n    queue.push(operation);\n\n    if (queue.length === 1 && this.buffers[type]) {\n      this.executeNext(type);\n    }\n  };\n\n  _proto.insertAbort = function insertAbort(operation, type) {\n    var queue = this.queues[type];\n    queue.unshift(operation);\n    this.executeNext(type);\n  };\n\n  _proto.appendBlocker = function appendBlocker(type) {\n    var execute;\n    var promise = new Promise(function (resolve) {\n      execute = resolve;\n    });\n    var operation = {\n      execute: execute,\n      onStart: function onStart() {},\n      onComplete: function onComplete() {},\n      onError: function onError() {}\n    };\n    this.append(operation, type);\n    return promise;\n  };\n\n  _proto.executeNext = function executeNext(type) {\n    var buffers = this.buffers,\n        queues = this.queues;\n    var sb = buffers[type];\n    var queue = queues[type];\n\n    if (queue.length) {\n      var operation = queue[0];\n\n      try {\n        // Operations are expected to result in an 'updateend' event being fired. If not, the queue will lock. Operations\n        // which do not end with this event must call _onSBUpdateEnd manually\n        operation.execute();\n      } catch (e) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].warn('[buffer-operation-queue]: Unhandled exception executing the current operation');\n        operation.onError(e); // Only shift the current operation off, otherwise the updateend handler will do this for us\n\n        if (!sb || !sb.updating) {\n          queue.shift();\n          this.executeNext(type);\n        }\n      }\n    }\n  };\n\n  _proto.shiftAndExecuteNext = function shiftAndExecuteNext(type) {\n    this.queues[type].shift();\n    this.executeNext(type);\n  };\n\n  _proto.current = function current(type) {\n    return this.queues[type][0];\n  };\n\n  return BufferOperationQueue;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/cap-level-controller.ts\":\n/*!************************************************!*\\\n  !*** ./src/controller/cap-level-controller.ts ***!\n  \\************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_208335__) {\n\n\"use strict\";\n__nested_webpack_require_208335__.r(__webpack_exports__);\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_208335__(/*! ../events */ \"./src/events.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n/*\n * cap stream level to media size dimension controller\n */\n\n\nvar CapLevelController = /*#__PURE__*/function () {\n  function CapLevelController(hls) {\n    this.autoLevelCapping = void 0;\n    this.firstLevel = void 0;\n    this.media = void 0;\n    this.restrictedLevels = void 0;\n    this.timer = void 0;\n    this.hls = void 0;\n    this.streamController = void 0;\n    this.clientRect = void 0;\n    this.hls = hls;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    this.firstLevel = -1;\n    this.media = null;\n    this.restrictedLevels = [];\n    this.timer = undefined;\n    this.clientRect = null;\n    this.registerListeners();\n  }\n\n  var _proto = CapLevelController.prototype;\n\n  _proto.setStreamController = function setStreamController(streamController) {\n    this.streamController = streamController;\n  };\n\n  _proto.destroy = function destroy() {\n    this.unregisterListener();\n\n    if (this.hls.config.capLevelToPlayerSize) {\n      this.stopCapping();\n    }\n\n    this.media = null;\n    this.clientRect = null; // @ts-ignore\n\n    this.hls = this.streamController = null;\n  };\n\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n  };\n\n  _proto.unregisterListener = function unregisterListener() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n  };\n\n  _proto.onFpsDropLevelCapping = function onFpsDropLevelCapping(event, data) {\n    // Don't add a restricted level more than once\n    if (CapLevelController.isLevelAllowed(data.droppedLevel, this.restrictedLevels)) {\n      this.restrictedLevels.push(data.droppedLevel);\n    }\n  };\n\n  _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n    this.media = data.media instanceof HTMLVideoElement ? data.media : null;\n  };\n\n  _proto.onManifestParsed = function onManifestParsed(event, data) {\n    var hls = this.hls;\n    this.restrictedLevels = [];\n    this.firstLevel = data.firstLevel;\n\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // Start capping immediately if the manifest has signaled video codecs\n      this.startCapping();\n    }\n  } // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted\n  // to the first level\n  ;\n\n  _proto.onBufferCodecs = function onBufferCodecs(event, data) {\n    var hls = this.hls;\n\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // If the manifest did not signal a video codec capping has been deferred until we're certain video is present\n      this.startCapping();\n    }\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    this.stopCapping();\n  };\n\n  _proto.detectPlayerSize = function detectPlayerSize() {\n    if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {\n      var levels = this.hls.levels;\n\n      if (levels.length) {\n        var hls = this.hls;\n        hls.autoLevelCapping = this.getMaxLevel(levels.length - 1);\n\n        if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {\n          // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch\n          // usually happen when the user go to the fullscreen mode.\n          this.streamController.nextLevelSwitch();\n        }\n\n        this.autoLevelCapping = hls.autoLevelCapping;\n      }\n    }\n  }\n  /*\n   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n   */\n  ;\n\n  _proto.getMaxLevel = function getMaxLevel(capLevelIndex) {\n    var _this = this;\n\n    var levels = this.hls.levels;\n\n    if (!levels.length) {\n      return -1;\n    }\n\n    var validLevels = levels.filter(function (level, index) {\n      return CapLevelController.isLevelAllowed(index, _this.restrictedLevels) && index <= capLevelIndex;\n    });\n    this.clientRect = null;\n    return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);\n  };\n\n  _proto.startCapping = function startCapping() {\n    if (this.timer) {\n      // Don't reset capping if started twice; this can happen if the manifest signals a video codec\n      return;\n    }\n\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    this.hls.firstLevel = this.getMaxLevel(this.firstLevel);\n    self.clearInterval(this.timer);\n    this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);\n    this.detectPlayerSize();\n  };\n\n  _proto.stopCapping = function stopCapping() {\n    this.restrictedLevels = [];\n    this.firstLevel = -1;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n\n    if (this.timer) {\n      self.clearInterval(this.timer);\n      this.timer = undefined;\n    }\n  };\n\n  _proto.getDimensions = function getDimensions() {\n    if (this.clientRect) {\n      return this.clientRect;\n    }\n\n    var media = this.media;\n    var boundsRect = {\n      width: 0,\n      height: 0\n    };\n\n    if (media) {\n      var clientRect = media.getBoundingClientRect();\n      boundsRect.width = clientRect.width;\n      boundsRect.height = clientRect.height;\n\n      if (!boundsRect.width && !boundsRect.height) {\n        // When the media element has no width or height (equivalent to not being in the DOM),\n        // then use its width and height attributes (media.width, media.height)\n        boundsRect.width = clientRect.right - clientRect.left || media.width || 0;\n        boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;\n      }\n    }\n\n    this.clientRect = boundsRect;\n    return boundsRect;\n  };\n\n  CapLevelController.isLevelAllowed = function isLevelAllowed(level, restrictedLevels) {\n    if (restrictedLevels === void 0) {\n      restrictedLevels = [];\n    }\n\n    return restrictedLevels.indexOf(level) === -1;\n  };\n\n  CapLevelController.getMaxLevelByMediaSize = function getMaxLevelByMediaSize(levels, width, height) {\n    if (!levels || !levels.length) {\n      return -1;\n    } // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next\n    // to determine whether we've chosen the greatest bandwidth for the media's dimensions\n\n\n    var atGreatestBandwidth = function atGreatestBandwidth(curLevel, nextLevel) {\n      if (!nextLevel) {\n        return true;\n      }\n\n      return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;\n    }; // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to\n    // the max level\n\n\n    var maxLevelIndex = levels.length - 1;\n\n    for (var i = 0; i < levels.length; i += 1) {\n      var level = levels[i];\n\n      if ((level.width >= width || level.height >= height) && atGreatestBandwidth(level, levels[i + 1])) {\n        maxLevelIndex = i;\n        break;\n      }\n    }\n\n    return maxLevelIndex;\n  };\n\n  _createClass(CapLevelController, [{\n    key: \"mediaWidth\",\n    get: function get() {\n      return this.getDimensions().width * this.contentScaleFactor;\n    }\n  }, {\n    key: \"mediaHeight\",\n    get: function get() {\n      return this.getDimensions().height * this.contentScaleFactor;\n    }\n  }, {\n    key: \"contentScaleFactor\",\n    get: function get() {\n      var pixelRatio = 1;\n\n      if (!this.hls.config.ignoreDevicePixelRatio) {\n        try {\n          pixelRatio = self.devicePixelRatio;\n        } catch (e) {\n          /* no-op */\n        }\n      }\n\n      return pixelRatio;\n    }\n  }]);\n\n  return CapLevelController;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (CapLevelController);\n\n/***/ }),\n\n/***/ \"./src/controller/cmcd-controller.ts\":\n/*!*******************************************!*\\\n  !*** ./src/controller/cmcd-controller.ts ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_217960__) {\n\n\"use strict\";\n__nested_webpack_require_217960__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_217960__.d(__webpack_exports__, \"default\", function() { return CMCDController; });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_217960__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _types_cmcd__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_217960__(/*! ../types/cmcd */ \"./src/types/cmcd.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_217960__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_217960__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\n\n\n/**\n * Controller to deal with Common Media Client Data (CMCD)\n * @see https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf\n */\n\nvar CMCDController = /*#__PURE__*/function () {\n  // eslint-disable-line no-restricted-globals\n  // eslint-disable-line no-restricted-globals\n  function CMCDController(hls) {\n    var _this = this;\n\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = void 0;\n    this.sid = void 0;\n    this.cid = void 0;\n    this.useHeaders = false;\n    this.initialized = false;\n    this.starved = false;\n    this.buffering = true;\n    this.audioBuffer = void 0;\n    this.videoBuffer = void 0;\n\n    this.onWaiting = function () {\n      if (_this.initialized) {\n        _this.starved = true;\n      }\n\n      _this.buffering = true;\n    };\n\n    this.onPlaying = function () {\n      if (!_this.initialized) {\n        _this.initialized = true;\n      }\n\n      _this.buffering = false;\n    };\n\n    this.applyPlaylistData = function (context) {\n      try {\n        _this.apply(context, {\n          ot: _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].MANIFEST,\n          su: !_this.initialized\n        });\n      } catch (error) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn('Could not generate manifest CMCD data.', error);\n      }\n    };\n\n    this.applyFragmentData = function (context) {\n      try {\n        var fragment = context.frag;\n        var level = _this.hls.levels[fragment.level];\n\n        var ot = _this.getObjectType(fragment);\n\n        var data = {\n          d: fragment.duration * 1000,\n          ot: ot\n        };\n\n        if (ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].VIDEO || ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].AUDIO || ot == _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].MUXED) {\n          data.br = level.bitrate / 1000;\n          data.tb = _this.getTopBandwidth(ot) / 1000;\n          data.bl = _this.getBufferLength(ot);\n        }\n\n        _this.apply(context, data);\n      } catch (error) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn('Could not generate segment CMCD data.', error);\n      }\n    };\n\n    this.hls = hls;\n    var config = this.config = hls.config;\n    var cmcd = config.cmcd;\n\n    if (cmcd != null) {\n      config.pLoader = this.createPlaylistLoader();\n      config.fLoader = this.createFragmentLoader();\n      this.sid = cmcd.sessionId || CMCDController.uuid();\n      this.cid = cmcd.contentId;\n      this.useHeaders = cmcd.useHeaders === true;\n      this.registerListeners();\n    }\n  }\n\n  var _proto = CMCDController.prototype;\n\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHED, this.onMediaDetached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_CREATED, this.onBufferCreated, this);\n  };\n\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHED, this.onMediaDetached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_CREATED, this.onBufferCreated, this);\n    this.onMediaDetached();\n  };\n\n  _proto.destroy = function destroy() {\n    this.unregisterListeners(); // @ts-ignore\n\n    this.hls = this.config = this.audioBuffer = this.videoBuffer = null;\n  };\n\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    this.media = data.media;\n    this.media.addEventListener('waiting', this.onWaiting);\n    this.media.addEventListener('playing', this.onPlaying);\n  };\n\n  _proto.onMediaDetached = function onMediaDetached() {\n    if (!this.media) {\n      return;\n    }\n\n    this.media.removeEventListener('waiting', this.onWaiting);\n    this.media.removeEventListener('playing', this.onPlaying); // @ts-ignore\n\n    this.media = null;\n  };\n\n  _proto.onBufferCreated = function onBufferCreated(event, data) {\n    var _data$tracks$audio, _data$tracks$video;\n\n    this.audioBuffer = (_data$tracks$audio = data.tracks.audio) === null || _data$tracks$audio === void 0 ? void 0 : _data$tracks$audio.buffer;\n    this.videoBuffer = (_data$tracks$video = data.tracks.video) === null || _data$tracks$video === void 0 ? void 0 : _data$tracks$video.buffer;\n  };\n\n  /**\n   * Create baseline CMCD data\n   */\n  _proto.createData = function createData() {\n    var _this$media;\n\n    return {\n      v: _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDVersion\"],\n      sf: _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDStreamingFormat\"].HLS,\n      sid: this.sid,\n      cid: this.cid,\n      pr: (_this$media = this.media) === null || _this$media === void 0 ? void 0 : _this$media.playbackRate,\n      mtp: this.hls.bandwidthEstimate / 1000\n    };\n  }\n  /**\n   * Apply CMCD data to a request.\n   */\n  ;\n\n  _proto.apply = function apply(context, data) {\n    if (data === void 0) {\n      data = {};\n    }\n\n    // apply baseline data\n    _extends(data, this.createData());\n\n    var isVideo = data.ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].INIT || data.ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].VIDEO || data.ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].MUXED;\n\n    if (this.starved && isVideo) {\n      data.bs = true;\n      data.su = true;\n      this.starved = false;\n    }\n\n    if (data.su == null) {\n      data.su = this.buffering;\n    } // TODO: Implement rtp, nrr, nor, dl\n\n\n    if (this.useHeaders) {\n      var headers = CMCDController.toHeaders(data);\n\n      if (!Object.keys(headers).length) {\n        return;\n      }\n\n      if (!context.headers) {\n        context.headers = {};\n      }\n\n      _extends(context.headers, headers);\n    } else {\n      var query = CMCDController.toQuery(data);\n\n      if (!query) {\n        return;\n      }\n\n      context.url = CMCDController.appendQueryToUri(context.url, query);\n    }\n  }\n  /**\n   * Apply CMCD data to a manifest request.\n   */\n  ;\n\n  /**\n   * The CMCD object type.\n   */\n  _proto.getObjectType = function getObjectType(fragment) {\n    var type = fragment.type;\n\n    if (type === 'subtitle') {\n      return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].TIMED_TEXT;\n    }\n\n    if (fragment.sn === 'initSegment') {\n      return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].INIT;\n    }\n\n    if (type === 'audio') {\n      return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].AUDIO;\n    }\n\n    if (type === 'main') {\n      if (!this.hls.audioTracks.length) {\n        return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].MUXED;\n      }\n\n      return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].VIDEO;\n    }\n\n    return undefined;\n  }\n  /**\n   * Get the highest bitrate.\n   */\n  ;\n\n  _proto.getTopBandwidth = function getTopBandwidth(type) {\n    var bitrate = 0;\n    var levels;\n    var hls = this.hls;\n\n    if (type === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].AUDIO) {\n      levels = hls.audioTracks;\n    } else {\n      var max = hls.maxAutoLevel;\n      var len = max > -1 ? max + 1 : hls.levels.length;\n      levels = hls.levels.slice(0, len);\n    }\n\n    for (var _iterator = _createForOfIteratorHelperLoose(levels), _step; !(_step = _iterator()).done;) {\n      var level = _step.value;\n\n      if (level.bitrate > bitrate) {\n        bitrate = level.bitrate;\n      }\n    }\n\n    return bitrate > 0 ? bitrate : NaN;\n  }\n  /**\n   * Get the buffer length for a media type in milliseconds\n   */\n  ;\n\n  _proto.getBufferLength = function getBufferLength(type) {\n    var media = this.hls.media;\n    var buffer = type === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].AUDIO ? this.audioBuffer : this.videoBuffer;\n\n    if (!buffer || !media) {\n      return NaN;\n    }\n\n    var info = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_2__[\"BufferHelper\"].bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);\n    return info.len * 1000;\n  }\n  /**\n   * Create a playlist loader\n   */\n  ;\n\n  _proto.createPlaylistLoader = function createPlaylistLoader() {\n    var pLoader = this.config.pLoader;\n    var apply = this.applyPlaylistData;\n    var Ctor = pLoader || this.config.loader;\n    return /*#__PURE__*/function () {\n      function CmcdPlaylistLoader(config) {\n        this.loader = void 0;\n        this.loader = new Ctor(config);\n      }\n\n      var _proto2 = CmcdPlaylistLoader.prototype;\n\n      _proto2.destroy = function destroy() {\n        this.loader.destroy();\n      };\n\n      _proto2.abort = function abort() {\n        this.loader.abort();\n      };\n\n      _proto2.load = function load(context, config, callbacks) {\n        apply(context);\n        this.loader.load(context, config, callbacks);\n      };\n\n      _createClass(CmcdPlaylistLoader, [{\n        key: \"stats\",\n        get: function get() {\n          return this.loader.stats;\n        }\n      }, {\n        key: \"context\",\n        get: function get() {\n          return this.loader.context;\n        }\n      }]);\n\n      return CmcdPlaylistLoader;\n    }();\n  }\n  /**\n   * Create a playlist loader\n   */\n  ;\n\n  _proto.createFragmentLoader = function createFragmentLoader() {\n    var fLoader = this.config.fLoader;\n    var apply = this.applyFragmentData;\n    var Ctor = fLoader || this.config.loader;\n    return /*#__PURE__*/function () {\n      function CmcdFragmentLoader(config) {\n        this.loader = void 0;\n        this.loader = new Ctor(config);\n      }\n\n      var _proto3 = CmcdFragmentLoader.prototype;\n\n      _proto3.destroy = function destroy() {\n        this.loader.destroy();\n      };\n\n      _proto3.abort = function abort() {\n        this.loader.abort();\n      };\n\n      _proto3.load = function load(context, config, callbacks) {\n        apply(context);\n        this.loader.load(context, config, callbacks);\n      };\n\n      _createClass(CmcdFragmentLoader, [{\n        key: \"stats\",\n        get: function get() {\n          return this.loader.stats;\n        }\n      }, {\n        key: \"context\",\n        get: function get() {\n          return this.loader.context;\n        }\n      }]);\n\n      return CmcdFragmentLoader;\n    }();\n  }\n  /**\n   * Generate a random v4 UUI\n   *\n   * @returns {string}\n   */\n  ;\n\n  CMCDController.uuid = function uuid() {\n    var url = URL.createObjectURL(new Blob());\n    var uuid = url.toString();\n    URL.revokeObjectURL(url);\n    return uuid.slice(uuid.lastIndexOf('/') + 1);\n  }\n  /**\n   * Serialize a CMCD data object according to the rules defined in the\n   * section 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   */\n  ;\n\n  CMCDController.serialize = function serialize(data) {\n    var results = [];\n\n    var isValid = function isValid(value) {\n      return !Number.isNaN(value) && value != null && value !== '' && value !== false;\n    };\n\n    var toRounded = function toRounded(value) {\n      return Math.round(value);\n    };\n\n    var toHundred = function toHundred(value) {\n      return toRounded(value / 100) * 100;\n    };\n\n    var toUrlSafe = function toUrlSafe(value) {\n      return encodeURIComponent(value);\n    };\n\n    var formatters = {\n      br: toRounded,\n      d: toRounded,\n      bl: toHundred,\n      dl: toHundred,\n      mtp: toHundred,\n      nor: toUrlSafe,\n      rtp: toHundred,\n      tb: toRounded\n    };\n    var keys = Object.keys(data || {}).sort();\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(keys), _step2; !(_step2 = _iterator2()).done;) {\n      var key = _step2.value;\n      var value = data[key]; // ignore invalid values\n\n      if (!isValid(value)) {\n        continue;\n      } // Version should only be reported if not equal to 1.\n\n\n      if (key === 'v' && value === 1) {\n        continue;\n      } // Playback rate should only be sent if not equal to 1.\n\n\n      if (key == 'pr' && value === 1) {\n        continue;\n      } // Certain values require special formatting\n\n\n      var formatter = formatters[key];\n\n      if (formatter) {\n        value = formatter(value);\n      } // Serialize the key/value pair\n\n\n      var type = typeof value;\n      var result = void 0;\n\n      if (key === 'ot' || key === 'sf' || key === 'st') {\n        result = key + \"=\" + value;\n      } else if (type === 'boolean') {\n        result = key;\n      } else if (type === 'number') {\n        result = key + \"=\" + value;\n      } else {\n        result = key + \"=\" + JSON.stringify(value);\n      }\n\n      results.push(result);\n    }\n\n    return results.join(',');\n  }\n  /**\n   * Convert a CMCD data object to request headers according to the rules\n   * defined in the section 2.1 and 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   */\n  ;\n\n  CMCDController.toHeaders = function toHeaders(data) {\n    var keys = Object.keys(data);\n    var headers = {};\n    var headerNames = ['Object', 'Request', 'Session', 'Status'];\n    var headerGroups = [{}, {}, {}, {}];\n    var headerMap = {\n      br: 0,\n      d: 0,\n      ot: 0,\n      tb: 0,\n      bl: 1,\n      dl: 1,\n      mtp: 1,\n      nor: 1,\n      nrr: 1,\n      su: 1,\n      cid: 2,\n      pr: 2,\n      sf: 2,\n      sid: 2,\n      st: 2,\n      v: 2,\n      bs: 3,\n      rtp: 3\n    };\n\n    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n      var key = _keys[_i];\n      // Unmapped fields are mapped to the Request header\n      var index = headerMap[key] != null ? headerMap[key] : 1;\n      headerGroups[index][key] = data[key];\n    }\n\n    for (var i = 0; i < headerGroups.length; i++) {\n      var value = CMCDController.serialize(headerGroups[i]);\n\n      if (value) {\n        headers[\"CMCD-\" + headerNames[i]] = value;\n      }\n    }\n\n    return headers;\n  }\n  /**\n   * Convert a CMCD data object to query args according to the rules\n   * defined in the section 2.2 and 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   */\n  ;\n\n  CMCDController.toQuery = function toQuery(data) {\n    return \"CMCD=\" + encodeURIComponent(CMCDController.serialize(data));\n  }\n  /**\n   * Append query args to a uri.\n   */\n  ;\n\n  CMCDController.appendQueryToUri = function appendQueryToUri(uri, query) {\n    if (!query) {\n      return uri;\n    }\n\n    var separator = uri.includes('?') ? '&' : '?';\n    return \"\" + uri + separator + query;\n  };\n\n  return CMCDController;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/eme-controller.ts\":\n/*!******************************************!*\\\n  !*** ./src/controller/eme-controller.ts ***!\n  \\******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_235739__) {\n\n\"use strict\";\n__nested_webpack_require_235739__.r(__webpack_exports__);\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_235739__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_235739__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_235739__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_235739__(/*! ../utils/mediakeys-helper */ \"./src/utils/mediakeys-helper.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n/**\n * @author Stephan Hesse <disparat@gmail.com> | <tchakabam@gmail.com>\n *\n * DRM support for Hls.js\n */\n\n\n\n\nvar MAX_LICENSE_REQUEST_FAILURES = 3;\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration\n * @param {Array<string>} audioCodecs List of required audio codecs to support\n * @param {Array<string>} videoCodecs List of required video codecs to support\n * @param {object} drmSystemOptions Optional parameters/requirements for the key-system\n * @returns {Array<MediaSystemConfiguration>} An array of supported configurations\n */\n\nvar createWidevineMediaKeySystemConfigurations = function createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs, drmSystemOptions) {\n  /* jshint ignore:line */\n  var baseConfig = {\n    // initDataTypes: ['keyids', 'mp4'],\n    // label: \"\",\n    // persistentState: \"not-allowed\", // or \"required\" ?\n    // distinctiveIdentifier: \"not-allowed\", // or \"required\" ?\n    // sessionTypes: ['temporary'],\n    audioCapabilities: [],\n    // { contentType: 'audio/mp4; codecs=\"mp4a.40.2\"' }\n    videoCapabilities: [] // { contentType: 'video/mp4; codecs=\"avc1.42E01E\"' }\n\n  };\n  audioCodecs.forEach(function (codec) {\n    baseConfig.audioCapabilities.push({\n      contentType: \"audio/mp4; codecs=\\\"\" + codec + \"\\\"\",\n      robustness: drmSystemOptions.audioRobustness || ''\n    });\n  });\n  videoCodecs.forEach(function (codec) {\n    baseConfig.videoCapabilities.push({\n      contentType: \"video/mp4; codecs=\\\"\" + codec + \"\\\"\",\n      robustness: drmSystemOptions.videoRobustness || ''\n    });\n  });\n  return [baseConfig];\n};\n/**\n * The idea here is to handle key-system (and their respective platforms) specific configuration differences\n * in order to work with the local requestMediaKeySystemAccess method.\n *\n * We can also rule-out platform-related key-system support at this point by throwing an error.\n *\n * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum\n * @param {Array<string>} audioCodecs List of required audio codecs to support\n * @param {Array<string>} videoCodecs List of required video codecs to support\n * @throws will throw an error if a unknown key system is passed\n * @returns {Array<MediaSystemConfiguration>} A non-empty Array of MediaKeySystemConfiguration objects\n */\n\n\nvar getSupportedMediaKeySystemConfigurations = function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {\n  switch (keySystem) {\n    case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__[\"KeySystems\"].WIDEVINE:\n      return createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs, drmSystemOptions);\n\n    default:\n      throw new Error(\"Unknown key-system: \" + keySystem);\n  }\n};\n\n/**\n * Controller to deal with encrypted media extensions (EME)\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API\n *\n * @class\n * @constructor\n */\nvar EMEController = /*#__PURE__*/function () {\n  /**\n   * @constructs\n   * @param {Hls} hls Our Hls.js instance\n   */\n  function EMEController(hls) {\n    this.hls = void 0;\n    this._widevineLicenseUrl = void 0;\n    this._licenseXhrSetup = void 0;\n    this._licenseResponseCallback = void 0;\n    this._emeEnabled = void 0;\n    this._requestMediaKeySystemAccess = void 0;\n    this._drmSystemOptions = void 0;\n    this._config = void 0;\n    this._mediaKeysList = [];\n    this._media = null;\n    this._hasSetMediaKeys = false;\n    this._requestLicenseFailureCount = 0;\n    this.mediaKeysPromise = null;\n    this._onMediaEncrypted = this.onMediaEncrypted.bind(this);\n    this.hls = hls;\n    this._config = hls.config;\n    this._widevineLicenseUrl = this._config.widevineLicenseUrl;\n    this._licenseXhrSetup = this._config.licenseXhrSetup;\n    this._licenseResponseCallback = this._config.licenseResponseCallback;\n    this._emeEnabled = this._config.emeEnabled;\n    this._requestMediaKeySystemAccess = this._config.requestMediaKeySystemAccessFunc;\n    this._drmSystemOptions = this._config.drmSystemOptions;\n\n    this._registerListeners();\n  }\n\n  var _proto = EMEController.prototype;\n\n  _proto.destroy = function destroy() {\n    this._unregisterListeners(); // @ts-ignore\n\n\n    this.hls = this._onMediaEncrypted = null;\n    this._requestMediaKeySystemAccess = null;\n  };\n\n  _proto._registerListeners = function _registerListeners() {\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHED, this.onMediaDetached, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n  };\n\n  _proto._unregisterListeners = function _unregisterListeners() {\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHED, this.onMediaDetached, this);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n  }\n  /**\n   * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum\n   * @returns {string} License server URL for key-system (if any configured, otherwise causes error)\n   * @throws if a unsupported keysystem is passed\n   */\n  ;\n\n  _proto.getLicenseServerUrl = function getLicenseServerUrl(keySystem) {\n    switch (keySystem) {\n      case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__[\"KeySystems\"].WIDEVINE:\n        if (!this._widevineLicenseUrl) {\n          break;\n        }\n\n        return this._widevineLicenseUrl;\n    }\n\n    throw new Error(\"no license server URL configured for key-system \\\"\" + keySystem + \"\\\"\");\n  }\n  /**\n   * Requests access object and adds it to our list upon success\n   * @private\n   * @param {string} keySystem System ID (see `KeySystems`)\n   * @param {Array<string>} audioCodecs List of required audio codecs to support\n   * @param {Array<string>} videoCodecs List of required video codecs to support\n   * @throws When a unsupported KeySystem is passed\n   */\n  ;\n\n  _proto._attemptKeySystemAccess = function _attemptKeySystemAccess(keySystem, audioCodecs, videoCodecs) {\n    var _this = this;\n\n    // This can throw, but is caught in event handler callpath\n    var mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this._drmSystemOptions);\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('Requesting encrypted media key-system access'); // expecting interface like window.navigator.requestMediaKeySystemAccess\n\n    var keySystemAccessPromise = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);\n    this.mediaKeysPromise = keySystemAccessPromise.then(function (mediaKeySystemAccess) {\n      return _this._onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess);\n    });\n    keySystemAccessPromise.catch(function (err) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(\"Failed to obtain key-system \\\"\" + keySystem + \"\\\" access:\", err);\n    });\n  };\n\n  /**\n   * Handles obtaining access to a key-system\n   * @private\n   * @param {string} keySystem\n   * @param {MediaKeySystemAccess} mediaKeySystemAccess https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemAccess\n   */\n  _proto._onMediaKeySystemAccessObtained = function _onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess) {\n    var _this2 = this;\n\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"Access for key-system \\\"\" + keySystem + \"\\\" obtained\");\n    var mediaKeysListItem = {\n      mediaKeysSessionInitialized: false,\n      mediaKeySystemAccess: mediaKeySystemAccess,\n      mediaKeySystemDomain: keySystem\n    };\n\n    this._mediaKeysList.push(mediaKeysListItem);\n\n    var mediaKeysPromise = Promise.resolve().then(function () {\n      return mediaKeySystemAccess.createMediaKeys();\n    }).then(function (mediaKeys) {\n      mediaKeysListItem.mediaKeys = mediaKeys;\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"Media-keys created for key-system \\\"\" + keySystem + \"\\\"\");\n\n      _this2._onMediaKeysCreated();\n\n      return mediaKeys;\n    });\n    mediaKeysPromise.catch(function (err) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error('Failed to create media-keys:', err);\n    });\n    return mediaKeysPromise;\n  }\n  /**\n   * Handles key-creation (represents access to CDM). We are going to create key-sessions upon this\n   * for all existing keys where no session exists yet.\n   *\n   * @private\n   */\n  ;\n\n  _proto._onMediaKeysCreated = function _onMediaKeysCreated() {\n    var _this3 = this;\n\n    // check for all key-list items if a session exists, otherwise, create one\n    this._mediaKeysList.forEach(function (mediaKeysListItem) {\n      if (!mediaKeysListItem.mediaKeysSession) {\n        // mediaKeys is definitely initialized here\n        mediaKeysListItem.mediaKeysSession = mediaKeysListItem.mediaKeys.createSession();\n\n        _this3._onNewMediaKeySession(mediaKeysListItem.mediaKeysSession);\n      }\n    });\n  }\n  /**\n   * @private\n   * @param {*} keySession\n   */\n  ;\n\n  _proto._onNewMediaKeySession = function _onNewMediaKeySession(keySession) {\n    var _this4 = this;\n\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"New key-system session \" + keySession.sessionId);\n    keySession.addEventListener('message', function (event) {\n      _this4._onKeySessionMessage(keySession, event.message);\n    }, false);\n  }\n  /**\n   * @private\n   * @param {MediaKeySession} keySession\n   * @param {ArrayBuffer} message\n   */\n  ;\n\n  _proto._onKeySessionMessage = function _onKeySessionMessage(keySession, message) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('Got EME message event, creating license request');\n\n    this._requestLicense(message, function (data) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"Received license data (length: \" + (data ? data.byteLength : data) + \"), updating key-session\");\n      keySession.update(data).catch(function (err) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"Updating key-session failed: \" + err);\n      });\n    });\n  }\n  /**\n   * @private\n   * @param e {MediaEncryptedEvent}\n   */\n  ;\n\n  _proto.onMediaEncrypted = function onMediaEncrypted(e) {\n    var _this5 = this;\n\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"Media is encrypted using \\\"\" + e.initDataType + \"\\\" init data type\");\n\n    if (!this.mediaKeysPromise) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error('Fatal: Media is encrypted but no CDM access or no keys have been requested');\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_NO_KEYS,\n        fatal: true\n      });\n      return;\n    }\n\n    var finallySetKeyAndStartSession = function finallySetKeyAndStartSession(mediaKeys) {\n      if (!_this5._media) {\n        return;\n      }\n\n      _this5._attemptSetMediaKeys(mediaKeys);\n\n      _this5._generateRequestWithPreferredKeySession(e.initDataType, e.initData);\n    }; // Could use `Promise.finally` but some Promise polyfills are missing it\n\n\n    this.mediaKeysPromise.then(finallySetKeyAndStartSession).catch(finallySetKeyAndStartSession);\n  }\n  /**\n   * @private\n   */\n  ;\n\n  _proto._attemptSetMediaKeys = function _attemptSetMediaKeys(mediaKeys) {\n    if (!this._media) {\n      throw new Error('Attempted to set mediaKeys without first attaching a media element');\n    }\n\n    if (!this._hasSetMediaKeys) {\n      // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?\n      var keysListItem = this._mediaKeysList[0];\n\n      if (!keysListItem || !keysListItem.mediaKeys) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error('Fatal: Media is encrypted but no CDM access or no keys have been obtained yet');\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n          type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n          details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_NO_KEYS,\n          fatal: true\n        });\n        return;\n      }\n\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('Setting keys for encrypted media');\n\n      this._media.setMediaKeys(keysListItem.mediaKeys);\n\n      this._hasSetMediaKeys = true;\n    }\n  }\n  /**\n   * @private\n   */\n  ;\n\n  _proto._generateRequestWithPreferredKeySession = function _generateRequestWithPreferredKeySession(initDataType, initData) {\n    var _this6 = this;\n\n    // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?\n    var keysListItem = this._mediaKeysList[0];\n\n    if (!keysListItem) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error('Fatal: Media is encrypted but not any key-system access has been obtained yet');\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_NO_ACCESS,\n        fatal: true\n      });\n      return;\n    }\n\n    if (keysListItem.mediaKeysSessionInitialized) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn('Key-Session already initialized but requested again');\n      return;\n    }\n\n    var keySession = keysListItem.mediaKeysSession;\n\n    if (!keySession) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error('Fatal: Media is encrypted but no key-session existing');\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_NO_SESSION,\n        fatal: true\n      });\n      return;\n    } // initData is null if the media is not CORS-same-origin\n\n\n    if (!initData) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn('Fatal: initData required for generating a key session is null');\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_NO_INIT_DATA,\n        fatal: true\n      });\n      return;\n    }\n\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"Generating key-session request for \\\"\" + initDataType + \"\\\" init data type\");\n    keysListItem.mediaKeysSessionInitialized = true;\n    keySession.generateRequest(initDataType, initData).then(function () {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].debug('Key-session generation succeeded');\n    }).catch(function (err) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error('Error generating key-session request:', err);\n\n      _this6.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_NO_SESSION,\n        fatal: false\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {string} url License server URL\n   * @param {ArrayBuffer} keyMessage Message data issued by key-system\n   * @param {function} callback Called when XHR has succeeded\n   * @returns {XMLHttpRequest} Unsent (but opened state) XHR object\n   * @throws if XMLHttpRequest construction failed\n   */\n  ;\n\n  _proto._createLicenseXhr = function _createLicenseXhr(url, keyMessage, callback) {\n    var xhr = new XMLHttpRequest();\n    xhr.responseType = 'arraybuffer';\n    xhr.onreadystatechange = this._onLicenseRequestReadyStageChange.bind(this, xhr, url, keyMessage, callback);\n    var licenseXhrSetup = this._licenseXhrSetup;\n\n    if (licenseXhrSetup) {\n      try {\n        licenseXhrSetup.call(this.hls, xhr, url);\n        licenseXhrSetup = undefined;\n      } catch (e) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(e);\n      }\n    }\n\n    try {\n      // if licenseXhrSetup did not yet call open, let's do it now\n      if (!xhr.readyState) {\n        xhr.open('POST', url, true);\n      }\n\n      if (licenseXhrSetup) {\n        licenseXhrSetup.call(this.hls, xhr, url);\n      }\n    } catch (e) {\n      // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n      throw new Error(\"issue setting up KeySystem license XHR \" + e);\n    }\n\n    return xhr;\n  }\n  /**\n   * @private\n   * @param {XMLHttpRequest} xhr\n   * @param {string} url License server URL\n   * @param {ArrayBuffer} keyMessage Message data issued by key-system\n   * @param {function} callback Called when XHR has succeeded\n   */\n  ;\n\n  _proto._onLicenseRequestReadyStageChange = function _onLicenseRequestReadyStageChange(xhr, url, keyMessage, callback) {\n    switch (xhr.readyState) {\n      case 4:\n        if (xhr.status === 200) {\n          this._requestLicenseFailureCount = 0;\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('License request succeeded');\n          var _data = xhr.response;\n          var licenseResponseCallback = this._licenseResponseCallback;\n\n          if (licenseResponseCallback) {\n            try {\n              _data = licenseResponseCallback.call(this.hls, xhr, url);\n            } catch (e) {\n              _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(e);\n            }\n          }\n\n          callback(_data);\n        } else {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(\"License Request XHR failed (\" + url + \"). Status: \" + xhr.status + \" (\" + xhr.statusText + \")\");\n          this._requestLicenseFailureCount++;\n\n          if (this._requestLicenseFailureCount > MAX_LICENSE_REQUEST_FAILURES) {\n            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n              type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n              details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n              fatal: true\n            });\n            return;\n          }\n\n          var attemptsLeft = MAX_LICENSE_REQUEST_FAILURES - this._requestLicenseFailureCount + 1;\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"Retrying license request, \" + attemptsLeft + \" attempts left\");\n\n          this._requestLicense(keyMessage, callback);\n        }\n\n        break;\n    }\n  }\n  /**\n   * @private\n   * @param {MediaKeysListItem} keysListItem\n   * @param {ArrayBuffer} keyMessage\n   * @returns {ArrayBuffer} Challenge data posted to license server\n   * @throws if KeySystem is unsupported\n   */\n  ;\n\n  _proto._generateLicenseRequestChallenge = function _generateLicenseRequestChallenge(keysListItem, keyMessage) {\n    switch (keysListItem.mediaKeySystemDomain) {\n      // case KeySystems.PLAYREADY:\n      // from https://github.com/MicrosoftEdge/Demos/blob/master/eme/scripts/demo.js\n\n      /*\n      if (this.licenseType !== this.LICENSE_TYPE_WIDEVINE) {\n        // For PlayReady CDMs, we need to dig the Challenge out of the XML.\n        var keyMessageXml = new DOMParser().parseFromString(String.fromCharCode.apply(null, new Uint16Array(keyMessage)), 'application/xml');\n        if (keyMessageXml.getElementsByTagName('Challenge')[0]) {\n            challenge = atob(keyMessageXml.getElementsByTagName('Challenge')[0].childNodes[0].nodeValue);\n        } else {\n            throw 'Cannot find <Challenge> in key message';\n        }\n        var headerNames = keyMessageXml.getElementsByTagName('name');\n        var headerValues = keyMessageXml.getElementsByTagName('value');\n        if (headerNames.length !== headerValues.length) {\n            throw 'Mismatched header <name>/<value> pair in key message';\n        }\n        for (var i = 0; i < headerNames.length; i++) {\n            xhr.setRequestHeader(headerNames[i].childNodes[0].nodeValue, headerValues[i].childNodes[0].nodeValue);\n        }\n      }\n      break;\n      */\n      case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__[\"KeySystems\"].WIDEVINE:\n        // For Widevine CDMs, the challenge is the keyMessage.\n        return keyMessage;\n    }\n\n    throw new Error(\"unsupported key-system: \" + keysListItem.mediaKeySystemDomain);\n  }\n  /**\n   * @private\n   * @param keyMessage\n   * @param callback\n   */\n  ;\n\n  _proto._requestLicense = function _requestLicense(keyMessage, callback) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('Requesting content license for key-system');\n    var keysListItem = this._mediaKeysList[0];\n\n    if (!keysListItem) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error('Fatal error: Media is encrypted but no key-system access has been obtained yet');\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_NO_ACCESS,\n        fatal: true\n      });\n      return;\n    }\n\n    try {\n      var _url = this.getLicenseServerUrl(keysListItem.mediaKeySystemDomain);\n\n      var _xhr = this._createLicenseXhr(_url, keyMessage, callback);\n\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"Sending license request to URL: \" + _url);\n\n      var challenge = this._generateLicenseRequestChallenge(keysListItem, keyMessage);\n\n      _xhr.send(challenge);\n    } catch (e) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(\"Failure requesting DRM license: \" + e);\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n        fatal: true\n      });\n    }\n  };\n\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    if (!this._emeEnabled) {\n      return;\n    }\n\n    var media = data.media; // keep reference of media\n\n    this._media = media;\n    media.addEventListener('encrypted', this._onMediaEncrypted);\n  };\n\n  _proto.onMediaDetached = function onMediaDetached() {\n    var media = this._media;\n    var mediaKeysList = this._mediaKeysList;\n\n    if (!media) {\n      return;\n    }\n\n    media.removeEventListener('encrypted', this._onMediaEncrypted);\n    this._media = null;\n    this._mediaKeysList = []; // Close all sessions and remove media keys from the video element.\n\n    Promise.all(mediaKeysList.map(function (mediaKeysListItem) {\n      if (mediaKeysListItem.mediaKeysSession) {\n        return mediaKeysListItem.mediaKeysSession.close().catch(function () {// Ignore errors when closing the sessions. Closing a session that\n          // generated no key requests will throw an error.\n        });\n      }\n    })).then(function () {\n      return media.setMediaKeys(null);\n    }).catch(function () {// Ignore any failures while removing media keys from the video element.\n    });\n  };\n\n  _proto.onManifestParsed = function onManifestParsed(event, data) {\n    if (!this._emeEnabled) {\n      return;\n    }\n\n    var audioCodecs = data.levels.map(function (level) {\n      return level.audioCodec;\n    }).filter(function (audioCodec) {\n      return !!audioCodec;\n    });\n    var videoCodecs = data.levels.map(function (level) {\n      return level.videoCodec;\n    }).filter(function (videoCodec) {\n      return !!videoCodec;\n    });\n\n    this._attemptKeySystemAccess(_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__[\"KeySystems\"].WIDEVINE, audioCodecs, videoCodecs);\n  };\n\n  _createClass(EMEController, [{\n    key: \"requestMediaKeySystemAccess\",\n    get: function get() {\n      if (!this._requestMediaKeySystemAccess) {\n        throw new Error('No requestMediaKeySystemAccess function configured');\n      }\n\n      return this._requestMediaKeySystemAccess;\n    }\n  }]);\n\n  return EMEController;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (EMEController);\n\n/***/ }),\n\n/***/ \"./src/controller/fps-controller.ts\":\n/*!******************************************!*\\\n  !*** ./src/controller/fps-controller.ts ***!\n  \\******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_261516__) {\n\n\"use strict\";\n__nested_webpack_require_261516__.r(__webpack_exports__);\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_261516__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_261516__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\nvar FPSController = /*#__PURE__*/function () {\n  // stream controller must be provided as a dependency!\n  function FPSController(hls) {\n    this.hls = void 0;\n    this.isVideoPlaybackQualityAvailable = false;\n    this.timer = void 0;\n    this.media = null;\n    this.lastTime = void 0;\n    this.lastDroppedFrames = 0;\n    this.lastDecodedFrames = 0;\n    this.streamController = void 0;\n    this.hls = hls;\n    this.registerListeners();\n  }\n\n  var _proto = FPSController.prototype;\n\n  _proto.setStreamController = function setStreamController(streamController) {\n    this.streamController = streamController;\n  };\n\n  _proto.registerListeners = function registerListeners() {\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHING, this.onMediaAttaching, this);\n  };\n\n  _proto.unregisterListeners = function unregisterListeners() {\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHING, this.onMediaAttaching);\n  };\n\n  _proto.destroy = function destroy() {\n    if (this.timer) {\n      clearInterval(this.timer);\n    }\n\n    this.unregisterListeners();\n    this.isVideoPlaybackQualityAvailable = false;\n    this.media = null;\n  };\n\n  _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n    var config = this.hls.config;\n\n    if (config.capLevelOnFPSDrop) {\n      var media = data.media instanceof self.HTMLVideoElement ? data.media : null;\n      this.media = media;\n\n      if (media && typeof media.getVideoPlaybackQuality === 'function') {\n        this.isVideoPlaybackQualityAvailable = true;\n      }\n\n      self.clearInterval(this.timer);\n      this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);\n    }\n  };\n\n  _proto.checkFPS = function checkFPS(video, decodedFrames, droppedFrames) {\n    var currentTime = performance.now();\n\n    if (decodedFrames) {\n      if (this.lastTime) {\n        var currentPeriod = currentTime - this.lastTime;\n        var currentDropped = droppedFrames - this.lastDroppedFrames;\n        var currentDecoded = decodedFrames - this.lastDecodedFrames;\n        var droppedFPS = 1000 * currentDropped / currentPeriod;\n        var hls = this.hls;\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FPS_DROP, {\n          currentDropped: currentDropped,\n          currentDecoded: currentDecoded,\n          totalDroppedFrames: droppedFrames\n        });\n\n        if (droppedFPS > 0) {\n          // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));\n          if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {\n            var currentLevel = hls.currentLevel;\n            _utils_logger__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);\n\n            if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {\n              currentLevel = currentLevel - 1;\n              hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FPS_DROP_LEVEL_CAPPING, {\n                level: currentLevel,\n                droppedLevel: hls.currentLevel\n              });\n              hls.autoLevelCapping = currentLevel;\n              this.streamController.nextLevelSwitch();\n            }\n          }\n        }\n      }\n\n      this.lastTime = currentTime;\n      this.lastDroppedFrames = droppedFrames;\n      this.lastDecodedFrames = decodedFrames;\n    }\n  };\n\n  _proto.checkFPSInterval = function checkFPSInterval() {\n    var video = this.media;\n\n    if (video) {\n      if (this.isVideoPlaybackQualityAvailable) {\n        var videoPlaybackQuality = video.getVideoPlaybackQuality();\n        this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n      } else {\n        // HTMLVideoElement doesn't include the webkit types\n        this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n      }\n    }\n  };\n\n  return FPSController;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (FPSController);\n\n/***/ }),\n\n/***/ \"./src/controller/fragment-finders.ts\":\n/*!********************************************!*\\\n  !*** ./src/controller/fragment-finders.ts ***!\n  \\********************************************/\n/*! exports provided: findFragmentByPDT, findFragmentByPTS, fragmentWithinToleranceTest, pdtWithinToleranceTest, findFragWithCC */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_266358__) {\n\n\"use strict\";\n__nested_webpack_require_266358__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_266358__.d(__webpack_exports__, \"findFragmentByPDT\", function() { return findFragmentByPDT; });\n/* harmony export (binding) */ __nested_webpack_require_266358__.d(__webpack_exports__, \"findFragmentByPTS\", function() { return findFragmentByPTS; });\n/* harmony export (binding) */ __nested_webpack_require_266358__.d(__webpack_exports__, \"fragmentWithinToleranceTest\", function() { return fragmentWithinToleranceTest; });\n/* harmony export (binding) */ __nested_webpack_require_266358__.d(__webpack_exports__, \"pdtWithinToleranceTest\", function() { return pdtWithinToleranceTest; });\n/* harmony export (binding) */ __nested_webpack_require_266358__.d(__webpack_exports__, \"findFragWithCC\", function() { return findFragWithCC; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_266358__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_266358__(/*! ../utils/binary-search */ \"./src/utils/binary-search.ts\");\n\n\n\n/**\n * Returns first fragment whose endPdt value exceeds the given PDT.\n * @param {Array<Fragment>} fragments - The array of candidate fragments\n * @param {number|null} [PDTValue = null] - The PDT value which must be exceeded\n * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n * @returns {*|null} fragment - The best matching fragment\n */\nfunction findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {\n  if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(PDTValue)) {\n    return null;\n  } // if less than start\n\n\n  var startPDT = fragments[0].programDateTime;\n\n  if (PDTValue < (startPDT || 0)) {\n    return null;\n  }\n\n  var endPDT = fragments[fragments.length - 1].endProgramDateTime;\n\n  if (PDTValue >= (endPDT || 0)) {\n    return null;\n  }\n\n  maxFragLookUpTolerance = maxFragLookUpTolerance || 0;\n\n  for (var seg = 0; seg < fragments.length; ++seg) {\n    var frag = fragments[seg];\n\n    if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {\n      return frag;\n    }\n  }\n\n  return null;\n}\n/**\n * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.\n * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus\n * breaking any traps which would cause the same fragment to be continuously selected within a small range.\n * @param {*} fragPrevious - The last frag successfully appended\n * @param {Array} fragments - The array of candidate fragments\n * @param {number} [bufferEnd = 0] - The end of the contiguous buffered range the playhead is currently within\n * @param {number} maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n * @returns {*} foundFrag - The best matching fragment\n */\n\nfunction findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance) {\n  if (bufferEnd === void 0) {\n    bufferEnd = 0;\n  }\n\n  if (maxFragLookUpTolerance === void 0) {\n    maxFragLookUpTolerance = 0;\n  }\n\n  var fragNext = null;\n\n  if (fragPrevious) {\n    fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;\n  } else if (bufferEnd === 0 && fragments[0].start === 0) {\n    fragNext = fragments[0];\n  } // Prefer the next fragment if it's within tolerance\n\n\n  if (fragNext && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0) {\n    return fragNext;\n  } // We might be seeking past the tolerance so find the best match\n\n\n  var foundFragment = _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__[\"default\"].search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));\n\n  if (foundFragment) {\n    return foundFragment;\n  } // If no match was found return the next fragment after fragPrevious, or null\n\n\n  return fragNext;\n}\n/**\n * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.\n * @param {*} candidate - The fragment to test\n * @param {number} [bufferEnd = 0] - The end of the current buffered range the playhead is currently within\n * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns {number} - 0 if it matches, 1 if too low, -1 if too high\n */\n\nfunction fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, candidate) {\n  if (bufferEnd === void 0) {\n    bufferEnd = 0;\n  }\n\n  if (maxFragLookUpTolerance === void 0) {\n    maxFragLookUpTolerance = 0;\n  }\n\n  // offset should be within fragment boundary - config.maxFragLookUpTolerance\n  // this is to cope with situations like\n  // bufferEnd = 9.991\n  // frag[] : [0,10]\n  // frag[1] : [10,20]\n  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n  //              frag start               frag start+duration\n  //                  |-----------------------------|\n  //              <--->                         <--->\n  //  ...--------><-----------------------------><---------....\n  // previous frag         matching fragment         next frag\n  //  return -1             return 0                 return 1\n  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));\n\n  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n    return 1;\n  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n    return -1;\n  }\n\n  return 0;\n}\n/**\n * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.\n * This function tests the candidate's program date time values, as represented in Unix time\n * @param {*} candidate - The fragment to test\n * @param {number} [pdtBufferEnd = 0] - The Unix time representing the end of the current buffered range\n * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns {boolean} True if contiguous, false otherwise\n */\n\nfunction pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {\n  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000; // endProgramDateTime can be null, default to zero\n\n  var endProgramDateTime = candidate.endProgramDateTime || 0;\n  return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;\n}\nfunction findFragWithCC(fragments, cc) {\n  return _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__[\"default\"].search(fragments, function (candidate) {\n    if (candidate.cc < cc) {\n      return 1;\n    } else if (candidate.cc > cc) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n}\n\n/***/ }),\n\n/***/ \"./src/controller/fragment-tracker.ts\":\n/*!********************************************!*\\\n  !*** ./src/controller/fragment-tracker.ts ***!\n  \\********************************************/\n/*! exports provided: FragmentState, FragmentTracker */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_274242__) {\n\n\"use strict\";\n__nested_webpack_require_274242__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_274242__.d(__webpack_exports__, \"FragmentState\", function() { return FragmentState; });\n/* harmony export (binding) */ __nested_webpack_require_274242__.d(__webpack_exports__, \"FragmentTracker\", function() { return FragmentTracker; });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_274242__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_274242__(/*! ../types/loader */ \"./src/types/loader.ts\");\n\n\nvar FragmentState;\n\n(function (FragmentState) {\n  FragmentState[\"NOT_LOADED\"] = \"NOT_LOADED\";\n  FragmentState[\"APPENDING\"] = \"APPENDING\";\n  FragmentState[\"PARTIAL\"] = \"PARTIAL\";\n  FragmentState[\"OK\"] = \"OK\";\n})(FragmentState || (FragmentState = {}));\n\nvar FragmentTracker = /*#__PURE__*/function () {\n  function FragmentTracker(hls) {\n    this.activeFragment = null;\n    this.activeParts = null;\n    this.fragments = Object.create(null);\n    this.timeRanges = Object.create(null);\n    this.bufferPadding = 0.2;\n    this.hls = void 0;\n    this.hls = hls;\n\n    this._registerListeners();\n  }\n\n  var _proto = FragmentTracker.prototype;\n\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FRAG_LOADED, this.onFragLoaded, this);\n  };\n\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FRAG_LOADED, this.onFragLoaded, this);\n  };\n\n  _proto.destroy = function destroy() {\n    this._unregisterListeners(); // @ts-ignore\n\n\n    this.fragments = this.timeRanges = null;\n  }\n  /**\n   * Return a Fragment with an appended range that matches the position and levelType.\n   * If not found any Fragment, return null\n   */\n  ;\n\n  _proto.getAppendedFrag = function getAppendedFrag(position, levelType) {\n    if (levelType === _types_loader__WEBPACK_IMPORTED_MODULE_1__[\"PlaylistLevelType\"].MAIN) {\n      var activeFragment = this.activeFragment,\n          activeParts = this.activeParts;\n\n      if (!activeFragment) {\n        return null;\n      }\n\n      if (activeParts) {\n        for (var i = activeParts.length; i--;) {\n          var activePart = activeParts[i];\n          var appendedPTS = activePart ? activePart.end : activeFragment.appendedPTS;\n\n          if (activePart.start <= position && appendedPTS !== undefined && position <= appendedPTS) {\n            // 9 is a magic number. remove parts from lookup after a match but keep some short seeks back.\n            if (i > 9) {\n              this.activeParts = activeParts.slice(i - 9);\n            }\n\n            return activePart;\n          }\n        }\n      } else if (activeFragment.start <= position && activeFragment.appendedPTS !== undefined && position <= activeFragment.appendedPTS) {\n        return activeFragment;\n      }\n    }\n\n    return this.getBufferedFrag(position, levelType);\n  }\n  /**\n   * Return a buffered Fragment that matches the position and levelType.\n   * A buffered Fragment is one whose loading, parsing and appending is done (completed or \"partial\" meaning aborted).\n   * If not found any Fragment, return null\n   */\n  ;\n\n  _proto.getBufferedFrag = function getBufferedFrag(position, levelType) {\n    var fragments = this.fragments;\n    var keys = Object.keys(fragments);\n\n    for (var i = keys.length; i--;) {\n      var fragmentEntity = fragments[keys[i]];\n\n      if ((fragmentEntity === null || fragmentEntity === void 0 ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {\n        var frag = fragmentEntity.body;\n\n        if (frag.start <= position && position <= frag.end) {\n          return frag;\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Partial fragments effected by coded frame eviction will be removed\n   * The browser will unload parts of the buffer to free up memory for new buffer data\n   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)\n   */\n  ;\n\n  _proto.detectEvictedFragments = function detectEvictedFragments(elementaryStream, timeRange, playlistType) {\n    var _this = this;\n\n    // Check if any flagged fragments have been unloaded\n    Object.keys(this.fragments).forEach(function (key) {\n      var fragmentEntity = _this.fragments[key];\n\n      if (!fragmentEntity) {\n        return;\n      }\n\n      if (!fragmentEntity.buffered) {\n        if (fragmentEntity.body.type === playlistType) {\n          _this.removeFragment(fragmentEntity.body);\n        }\n\n        return;\n      }\n\n      var esData = fragmentEntity.range[elementaryStream];\n\n      if (!esData) {\n        return;\n      }\n\n      esData.time.some(function (time) {\n        var isNotBuffered = !_this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);\n\n        if (isNotBuffered) {\n          // Unregister partial fragment as it needs to load again to be reused\n          _this.removeFragment(fragmentEntity.body);\n        }\n\n        return isNotBuffered;\n      });\n    });\n  }\n  /**\n   * Checks if the fragment passed in is loaded in the buffer properly\n   * Partially loaded fragments will be registered as a partial fragment\n   */\n  ;\n\n  _proto.detectPartialFragments = function detectPartialFragments(data) {\n    var _this2 = this;\n\n    var timeRanges = this.timeRanges;\n    var frag = data.frag,\n        part = data.part;\n\n    if (!timeRanges || frag.sn === 'initSegment') {\n      return;\n    }\n\n    var fragKey = getFragmentKey(frag);\n    var fragmentEntity = this.fragments[fragKey];\n\n    if (!fragmentEntity) {\n      return;\n    }\n\n    Object.keys(timeRanges).forEach(function (elementaryStream) {\n      var streamInfo = frag.elementaryStreams[elementaryStream];\n\n      if (!streamInfo) {\n        return;\n      }\n\n      var timeRange = timeRanges[elementaryStream];\n      var partial = part !== null || streamInfo.partial === true;\n      fragmentEntity.range[elementaryStream] = _this2.getBufferedTimes(frag, part, partial, timeRange);\n    });\n    fragmentEntity.loaded = null;\n\n    if (Object.keys(fragmentEntity.range).length) {\n      fragmentEntity.buffered = true;\n    } else {\n      // remove fragment if nothing was appended\n      this.removeFragment(fragmentEntity.body);\n    }\n  };\n\n  _proto.fragBuffered = function fragBuffered(frag) {\n    var fragKey = getFragmentKey(frag);\n    var fragmentEntity = this.fragments[fragKey];\n\n    if (fragmentEntity) {\n      fragmentEntity.loaded = null;\n      fragmentEntity.buffered = true;\n    }\n  };\n\n  _proto.getBufferedTimes = function getBufferedTimes(fragment, part, partial, timeRange) {\n    var buffered = {\n      time: [],\n      partial: partial\n    };\n    var startPTS = part ? part.start : fragment.start;\n    var endPTS = part ? part.end : fragment.end;\n    var minEndPTS = fragment.minEndPTS || endPTS;\n    var maxStartPTS = fragment.maxStartPTS || startPTS;\n\n    for (var i = 0; i < timeRange.length; i++) {\n      var startTime = timeRange.start(i) - this.bufferPadding;\n      var endTime = timeRange.end(i) + this.bufferPadding;\n\n      if (maxStartPTS >= startTime && minEndPTS <= endTime) {\n        // Fragment is entirely contained in buffer\n        // No need to check the other timeRange times since it's completely playable\n        buffered.time.push({\n          startPTS: Math.max(startPTS, timeRange.start(i)),\n          endPTS: Math.min(endPTS, timeRange.end(i))\n        });\n        break;\n      } else if (startPTS < endTime && endPTS > startTime) {\n        buffered.partial = true; // Check for intersection with buffer\n        // Get playable sections of the fragment\n\n        buffered.time.push({\n          startPTS: Math.max(startPTS, timeRange.start(i)),\n          endPTS: Math.min(endPTS, timeRange.end(i))\n        });\n      } else if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        break;\n      }\n    }\n\n    return buffered;\n  }\n  /**\n   * Gets the partial fragment for a certain time\n   */\n  ;\n\n  _proto.getPartialFragment = function getPartialFragment(time) {\n    var bestFragment = null;\n    var timePadding;\n    var startTime;\n    var endTime;\n    var bestOverlap = 0;\n    var bufferPadding = this.bufferPadding,\n        fragments = this.fragments;\n    Object.keys(fragments).forEach(function (key) {\n      var fragmentEntity = fragments[key];\n\n      if (!fragmentEntity) {\n        return;\n      }\n\n      if (isPartial(fragmentEntity)) {\n        startTime = fragmentEntity.body.start - bufferPadding;\n        endTime = fragmentEntity.body.end + bufferPadding;\n\n        if (time >= startTime && time <= endTime) {\n          // Use the fragment that has the most padding from start and end time\n          timePadding = Math.min(time - startTime, endTime - time);\n\n          if (bestOverlap <= timePadding) {\n            bestFragment = fragmentEntity.body;\n            bestOverlap = timePadding;\n          }\n        }\n      }\n    });\n    return bestFragment;\n  };\n\n  _proto.getState = function getState(fragment) {\n    var fragKey = getFragmentKey(fragment);\n    var fragmentEntity = this.fragments[fragKey];\n\n    if (fragmentEntity) {\n      if (!fragmentEntity.buffered) {\n        return FragmentState.APPENDING;\n      } else if (isPartial(fragmentEntity)) {\n        return FragmentState.PARTIAL;\n      } else {\n        return FragmentState.OK;\n      }\n    }\n\n    return FragmentState.NOT_LOADED;\n  };\n\n  _proto.isTimeBuffered = function isTimeBuffered(startPTS, endPTS, timeRange) {\n    var startTime;\n    var endTime;\n\n    for (var i = 0; i < timeRange.length; i++) {\n      startTime = timeRange.start(i) - this.bufferPadding;\n      endTime = timeRange.end(i) + this.bufferPadding;\n\n      if (startPTS >= startTime && endPTS <= endTime) {\n        return true;\n      }\n\n      if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        return false;\n      }\n    }\n\n    return false;\n  };\n\n  _proto.onFragLoaded = function onFragLoaded(event, data) {\n    var frag = data.frag,\n        part = data.part; // don't track initsegment (for which sn is not a number)\n    // don't track frags used for bitrateTest, they're irrelevant.\n    // don't track parts for memory efficiency\n\n    if (frag.sn === 'initSegment' || frag.bitrateTest || part) {\n      return;\n    }\n\n    var fragKey = getFragmentKey(frag);\n    this.fragments[fragKey] = {\n      body: frag,\n      loaded: data,\n      buffered: false,\n      range: Object.create(null)\n    };\n  };\n\n  _proto.onBufferAppended = function onBufferAppended(event, data) {\n    var _this3 = this;\n\n    var frag = data.frag,\n        part = data.part,\n        timeRanges = data.timeRanges;\n\n    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_1__[\"PlaylistLevelType\"].MAIN) {\n      this.activeFragment = frag;\n\n      if (part) {\n        var activeParts = this.activeParts;\n\n        if (!activeParts) {\n          this.activeParts = activeParts = [];\n        }\n\n        activeParts.push(part);\n      } else {\n        this.activeParts = null;\n      }\n    } // Store the latest timeRanges loaded in the buffer\n\n\n    this.timeRanges = timeRanges;\n    Object.keys(timeRanges).forEach(function (elementaryStream) {\n      var timeRange = timeRanges[elementaryStream];\n\n      _this3.detectEvictedFragments(elementaryStream, timeRange);\n\n      if (!part) {\n        for (var i = 0; i < timeRange.length; i++) {\n          frag.appendedPTS = Math.max(timeRange.end(i), frag.appendedPTS || 0);\n        }\n      }\n    });\n  };\n\n  _proto.onFragBuffered = function onFragBuffered(event, data) {\n    this.detectPartialFragments(data);\n  };\n\n  _proto.hasFragment = function hasFragment(fragment) {\n    var fragKey = getFragmentKey(fragment);\n    return !!this.fragments[fragKey];\n  };\n\n  _proto.removeFragmentsInRange = function removeFragmentsInRange(start, end, playlistType) {\n    var _this4 = this;\n\n    Object.keys(this.fragments).forEach(function (key) {\n      var fragmentEntity = _this4.fragments[key];\n\n      if (!fragmentEntity) {\n        return;\n      }\n\n      if (fragmentEntity.buffered) {\n        var frag = fragmentEntity.body;\n\n        if (frag.type === playlistType && frag.start < end && frag.end > start) {\n          _this4.removeFragment(frag);\n        }\n      }\n    });\n  };\n\n  _proto.removeFragment = function removeFragment(fragment) {\n    var fragKey = getFragmentKey(fragment);\n    fragment.stats.loaded = 0;\n    fragment.clearElementaryStreamInfo();\n    delete this.fragments[fragKey];\n  };\n\n  _proto.removeAllFragments = function removeAllFragments() {\n    this.fragments = Object.create(null);\n    this.activeFragment = null;\n    this.activeParts = null;\n  };\n\n  return FragmentTracker;\n}();\n\nfunction isPartial(fragmentEntity) {\n  var _fragmentEntity$range, _fragmentEntity$range2;\n\n  return fragmentEntity.buffered && (((_fragmentEntity$range = fragmentEntity.range.video) === null || _fragmentEntity$range === void 0 ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) === null || _fragmentEntity$range2 === void 0 ? void 0 : _fragmentEntity$range2.partial));\n}\n\nfunction getFragmentKey(fragment) {\n  return fragment.type + \"_\" + fragment.level + \"_\" + fragment.urlId + \"_\" + fragment.sn;\n}\n\n/***/ }),\n\n/***/ \"./src/controller/gap-controller.ts\":\n/*!******************************************!*\\\n  !*** ./src/controller/gap-controller.ts ***!\n  \\******************************************/\n/*! exports provided: STALL_MINIMUM_DURATION_MS, MAX_START_GAP_JUMP, SKIP_BUFFER_HOLE_STEP_SECONDS, SKIP_BUFFER_RANGE_START, default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_288434__) {\n\n\"use strict\";\n__nested_webpack_require_288434__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_288434__.d(__webpack_exports__, \"STALL_MINIMUM_DURATION_MS\", function() { return STALL_MINIMUM_DURATION_MS; });\n/* harmony export (binding) */ __nested_webpack_require_288434__.d(__webpack_exports__, \"MAX_START_GAP_JUMP\", function() { return MAX_START_GAP_JUMP; });\n/* harmony export (binding) */ __nested_webpack_require_288434__.d(__webpack_exports__, \"SKIP_BUFFER_HOLE_STEP_SECONDS\", function() { return SKIP_BUFFER_HOLE_STEP_SECONDS; });\n/* harmony export (binding) */ __nested_webpack_require_288434__.d(__webpack_exports__, \"SKIP_BUFFER_RANGE_START\", function() { return SKIP_BUFFER_RANGE_START; });\n/* harmony export (binding) */ __nested_webpack_require_288434__.d(__webpack_exports__, \"default\", function() { return GapController; });\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_288434__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_288434__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_288434__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_288434__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\n\nvar STALL_MINIMUM_DURATION_MS = 250;\nvar MAX_START_GAP_JUMP = 2.0;\nvar SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;\nvar SKIP_BUFFER_RANGE_START = 0.05;\n\nvar GapController = /*#__PURE__*/function () {\n  function GapController(config, media, fragmentTracker, hls) {\n    this.config = void 0;\n    this.media = null;\n    this.fragmentTracker = void 0;\n    this.hls = void 0;\n    this.nudgeRetry = 0;\n    this.stallReported = false;\n    this.stalled = null;\n    this.moved = false;\n    this.seeking = false;\n    this.config = config;\n    this.media = media;\n    this.fragmentTracker = fragmentTracker;\n    this.hls = hls;\n  }\n\n  var _proto = GapController.prototype;\n\n  _proto.destroy = function destroy() {\n    this.media = null; // @ts-ignore\n\n    this.hls = this.fragmentTracker = null;\n  }\n  /**\n   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.\n   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).\n   *\n   * @param {number} lastCurrentTime Previously read playhead position\n   */\n  ;\n\n  _proto.poll = function poll(lastCurrentTime, activeFrag) {\n    var config = this.config,\n        media = this.media,\n        stalled = this.stalled;\n\n    if (media === null) {\n      return;\n    }\n\n    var currentTime = media.currentTime,\n        seeking = media.seeking;\n    var seeked = this.seeking && !seeking;\n    var beginSeek = !this.seeking && seeking;\n    this.seeking = seeking; // The playhead is moving, no-op\n\n    if (currentTime !== lastCurrentTime) {\n      this.moved = true;\n\n      if (stalled !== null) {\n        // The playhead is now moving, but was previously stalled\n        if (this.stallReported) {\n          var _stalledDuration = self.performance.now() - stalled;\n\n          _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn(\"playback not stuck anymore @\" + currentTime + \", after \" + Math.round(_stalledDuration) + \"ms\");\n          this.stallReported = false;\n        }\n\n        this.stalled = null;\n        this.nudgeRetry = 0;\n      }\n\n      return;\n    } // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek\n\n\n    if (beginSeek || seeked) {\n      this.stalled = null;\n    } // The playhead should not be moving\n\n\n    if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__[\"BufferHelper\"].getBuffered(media).length) {\n      return;\n    }\n\n    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__[\"BufferHelper\"].bufferInfo(media, currentTime, 0);\n    var isBuffered = bufferInfo.len > 0;\n    var nextStart = bufferInfo.nextStart || 0; // There is no playable buffer (seeked, waiting for buffer)\n\n    if (!isBuffered && !nextStart) {\n      return;\n    }\n\n    if (seeking) {\n      // Waiting for seeking in a buffered range to complete\n      var hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP; // Next buffered range is too far ahead to jump to while still seeking\n\n      var noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);\n\n      if (hasEnoughBuffer || noBufferGap) {\n        return;\n      } // Reset moved state when seeking to a point in or before a gap\n\n\n      this.moved = false;\n    } // Skip start gaps if we haven't played, but the last poll detected the start of a stall\n    // The addition poll gives the browser a chance to jump the gap for us\n\n\n    if (!this.moved && this.stalled !== null) {\n      var _level$details;\n\n      // Jump start gaps within jump threshold\n      var startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime; // When joining a live stream with audio tracks, account for live playlist window sliding by allowing\n      // a larger jump over start gaps caused by the audio-stream-controller buffering a start fragment\n      // that begins over 1 target duration after the video start position.\n\n      var level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;\n      var isLive = level === null || level === void 0 ? void 0 : (_level$details = level.details) === null || _level$details === void 0 ? void 0 : _level$details.live;\n      var maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;\n\n      if (startJump > 0 && startJump <= maxStartGapJump) {\n        this._trySkipBufferHole(null);\n\n        return;\n      }\n    } // Start tracking stall time\n\n\n    var tnow = self.performance.now();\n\n    if (stalled === null) {\n      this.stalled = tnow;\n      return;\n    }\n\n    var stalledDuration = tnow - stalled;\n\n    if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {\n      // Report stalling after trying to fix\n      this._reportStall(bufferInfo);\n\n      if (!this.media) {\n        return;\n      }\n    }\n\n    var bufferedWithHoles = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__[\"BufferHelper\"].bufferInfo(media, currentTime, config.maxBufferHole);\n\n    this._tryFixBufferStall(bufferedWithHoles, stalledDuration);\n  }\n  /**\n   * Detects and attempts to fix known buffer stalling issues.\n   * @param bufferInfo - The properties of the current buffer.\n   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.\n   * @private\n   */\n  ;\n\n  _proto._tryFixBufferStall = function _tryFixBufferStall(bufferInfo, stalledDurationMs) {\n    var config = this.config,\n        fragmentTracker = this.fragmentTracker,\n        media = this.media;\n\n    if (media === null) {\n      return;\n    }\n\n    var currentTime = media.currentTime;\n    var partial = fragmentTracker.getPartialFragment(currentTime);\n\n    if (partial) {\n      // Try to skip over the buffer hole caused by a partial fragment\n      // This method isn't limited by the size of the gap between buffered ranges\n      var targetTime = this._trySkipBufferHole(partial); // we return here in this case, meaning\n      // the branch below only executes when we don't handle a partial fragment\n\n\n      if (targetTime || !this.media) {\n        return;\n      }\n    } // if we haven't had to skip over a buffer hole of a partial fragment\n    // we may just have to \"nudge\" the playlist as the browser decoding/rendering engine\n    // needs to cross some sort of threshold covering all source-buffers content\n    // to start playing properly.\n\n\n    if (bufferInfo.len > config.maxBufferHole && stalledDurationMs > config.highBufferWatchdogPeriod * 1000) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn('Trying to nudge playhead over buffer-hole'); // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds\n      // We only try to jump the hole if it's under the configured size\n      // Reset stalled so to rearm watchdog timer\n\n      this.stalled = null;\n\n      this._tryNudgeBuffer();\n    }\n  }\n  /**\n   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.\n   * @param bufferLen - The playhead distance from the end of the current buffer segment.\n   * @private\n   */\n  ;\n\n  _proto._reportStall = function _reportStall(bufferInfo) {\n    var hls = this.hls,\n        media = this.media,\n        stallReported = this.stallReported;\n\n    if (!stallReported && media) {\n      // Report stalled error once\n      this.stallReported = true;\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn(\"Playback stalling at @\" + media.currentTime + \" due to low buffer (\" + JSON.stringify(bufferInfo) + \")\");\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].BUFFER_STALLED_ERROR,\n        fatal: false,\n        buffer: bufferInfo.len\n      });\n    }\n  }\n  /**\n   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments\n   * @param partial - The partial fragment found at the current time (where playback is stalling).\n   * @private\n   */\n  ;\n\n  _proto._trySkipBufferHole = function _trySkipBufferHole(partial) {\n    var config = this.config,\n        hls = this.hls,\n        media = this.media;\n\n    if (media === null) {\n      return 0;\n    }\n\n    var currentTime = media.currentTime;\n    var lastEndTime = 0; // Check if currentTime is between unbuffered regions of partial fragments\n\n    var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__[\"BufferHelper\"].getBuffered(media);\n\n    for (var i = 0; i < buffered.length; i++) {\n      var startTime = buffered.start(i);\n\n      if (currentTime + config.maxBufferHole >= lastEndTime && currentTime < startTime) {\n        var targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, media.currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn(\"skipping hole, adjusting currentTime from \" + currentTime + \" to \" + targetTime);\n        this.moved = true;\n        this.stalled = null;\n        media.currentTime = targetTime;\n\n        if (partial) {\n          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, {\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].MEDIA_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].BUFFER_SEEK_OVER_HOLE,\n            fatal: false,\n            reason: \"fragment loaded with buffer holes, seeking from \" + currentTime + \" to \" + targetTime,\n            frag: partial\n          });\n        }\n\n        return targetTime;\n      }\n\n      lastEndTime = buffered.end(i);\n    }\n\n    return 0;\n  }\n  /**\n   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.\n   * @private\n   */\n  ;\n\n  _proto._tryNudgeBuffer = function _tryNudgeBuffer() {\n    var config = this.config,\n        hls = this.hls,\n        media = this.media,\n        nudgeRetry = this.nudgeRetry;\n\n    if (media === null) {\n      return;\n    }\n\n    var currentTime = media.currentTime;\n    this.nudgeRetry++;\n\n    if (nudgeRetry < config.nudgeMaxRetry) {\n      var targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset; // playback stalled in buffered area ... let's nudge currentTime to try to overcome this\n\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn(\"Nudging 'currentTime' from \" + currentTime + \" to \" + targetTime);\n      media.currentTime = targetTime;\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].BUFFER_NUDGE_ON_STALL,\n        fatal: false\n      });\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].error(\"Playhead still not moving while enough data buffered @\" + currentTime + \" after \" + config.nudgeMaxRetry + \" nudges\");\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].BUFFER_STALLED_ERROR,\n        fatal: true\n      });\n    }\n  };\n\n  return GapController;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/id3-track-controller.ts\":\n/*!************************************************!*\\\n  !*** ./src/controller/id3-track-controller.ts ***!\n  \\************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_301327__) {\n\n\"use strict\";\n__nested_webpack_require_301327__.r(__webpack_exports__);\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_301327__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_301327__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_301327__(/*! ../utils/texttrack-utils */ \"./src/utils/texttrack-utils.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_301327__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\n/* harmony import */ var _loader_date_range__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_301327__(/*! ../loader/date-range */ \"./src/loader/date-range.ts\");\n/* harmony import */ var _types_demuxer__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_301327__(/*! ../types/demuxer */ \"./src/types/demuxer.ts\");\n\n\n\n\n\n\nvar MIN_CUE_DURATION = 0.25;\n\nfunction getCueClass() {\n  // Attempt to recreate Safari functionality by creating\n  // WebKitDataCue objects when available and store the decoded\n  // ID3 data in the value property of the cue\n  return self.WebKitDataCue || self.VTTCue || self.TextTrackCue;\n}\n\nfunction dateRangeDateToTimelineSeconds(date, offset) {\n  return date.getTime() / 1000 - offset;\n}\n\nfunction hexToArrayBuffer(str) {\n  return Uint8Array.from(str.replace(/^0x/, '').replace(/([\\da-fA-F]{2}) ?/g, '0x$1 ').replace(/ +$/, '').split(' ')).buffer;\n}\n\nvar ID3TrackController = /*#__PURE__*/function () {\n  function ID3TrackController(hls) {\n    this.hls = void 0;\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n    this.hls = hls;\n\n    this._registerListeners();\n  }\n\n  var _proto = ID3TrackController.prototype;\n\n  _proto.destroy = function destroy() {\n    this._unregisterListeners();\n\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {}; // @ts-ignore\n\n    this.hls = null;\n  };\n\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_UPDATED, this.onLevelUpdated, this);\n  };\n\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_UPDATED, this.onLevelUpdated, this);\n  } // Add ID3 metatadata text track.\n  ;\n\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    this.media = data.media;\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    if (!this.id3Track) {\n      return;\n    }\n\n    Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__[\"clearCurrentCues\"])(this.id3Track);\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n  };\n\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.dateRangeCuesAppended = {};\n  };\n\n  _proto.createTrack = function createTrack(media) {\n    var track = this.getID3Track(media.textTracks);\n    track.mode = 'hidden';\n    return track;\n  };\n\n  _proto.getID3Track = function getID3Track(textTracks) {\n    if (!this.media) {\n      return;\n    }\n\n    for (var i = 0; i < textTracks.length; i++) {\n      var textTrack = textTracks[i];\n\n      if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {\n        // send 'addtrack' when reusing the textTrack for metadata,\n        // same as what we do for captions\n        Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__[\"sendAddTrackEvent\"])(textTrack, this.media);\n        return textTrack;\n      }\n    }\n\n    return this.media.addTextTrack('metadata', 'id3');\n  };\n\n  _proto.onFragParsingMetadata = function onFragParsingMetadata(event, data) {\n    if (!this.media) {\n      return;\n    }\n\n    var _this$hls$config = this.hls.config,\n        enableEmsgMetadataCues = _this$hls$config.enableEmsgMetadataCues,\n        enableID3MetadataCues = _this$hls$config.enableID3MetadataCues;\n\n    if (!enableEmsgMetadataCues && !enableID3MetadataCues) {\n      return;\n    }\n\n    var fragment = data.frag,\n        samples = data.samples,\n        details = data.details; // create track dynamically\n\n    if (!this.id3Track) {\n      this.id3Track = this.createTrack(this.media);\n    } // VTTCue end time must be finite, so use playlist edge or fragment end until next fragment with same frame type is found\n\n\n    var maxCueTime = details.edge || fragment.end;\n    var Cue = getCueClass();\n    var updateCueRanges = false;\n    var frameTypesAdded = {};\n\n    for (var i = 0; i < samples.length; i++) {\n      var type = samples[i].type;\n\n      if (type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__[\"MetadataSchema\"].emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {\n        continue;\n      }\n\n      var frames = _demux_id3__WEBPACK_IMPORTED_MODULE_3__[\"getID3Frames\"](samples[i].data);\n\n      if (frames) {\n        var startTime = samples[i].pts;\n        var endTime = maxCueTime;\n        var timeDiff = endTime - startTime;\n\n        if (timeDiff <= 0) {\n          endTime = startTime + MIN_CUE_DURATION;\n        }\n\n        for (var j = 0; j < frames.length; j++) {\n          var frame = frames[j]; // Safari doesn't put the timestamp frame in the TextTrack\n\n          if (!_demux_id3__WEBPACK_IMPORTED_MODULE_3__[\"isTimeStampFrame\"](frame)) {\n            var cue = new Cue(startTime, endTime, '');\n            cue.value = frame;\n\n            if (type) {\n              cue.type = type;\n            }\n\n            this.id3Track.addCue(cue);\n            frameTypesAdded[frame.key] = null;\n            updateCueRanges = true;\n          }\n        }\n      }\n    }\n\n    if (updateCueRanges) {\n      this.updateId3CueEnds(frameTypesAdded);\n    }\n  };\n\n  _proto.updateId3CueEnds = function updateId3CueEnds(frameTypesAdded) {\n    var _this$id3Track;\n\n    // Update endTime of previous cue with same IDR frame.type (Ex: TXXX cue spans to next TXXX)\n    var cues = (_this$id3Track = this.id3Track) === null || _this$id3Track === void 0 ? void 0 : _this$id3Track.cues;\n\n    if (cues) {\n      for (var i = cues.length; i--;) {\n        var _cue$value;\n\n        var cue = cues[i];\n        var frameType = (_cue$value = cue.value) === null || _cue$value === void 0 ? void 0 : _cue$value.key;\n\n        if (frameType && frameType in frameTypesAdded) {\n          var startTime = frameTypesAdded[frameType];\n\n          if (startTime && cue.endTime !== startTime) {\n            cue.endTime = startTime;\n          }\n\n          frameTypesAdded[frameType] = cue.startTime;\n        }\n      }\n    }\n  };\n\n  _proto.onBufferFlushing = function onBufferFlushing(event, _ref) {\n    var startOffset = _ref.startOffset,\n        endOffset = _ref.endOffset,\n        type = _ref.type;\n    var id3Track = this.id3Track,\n        hls = this.hls;\n\n    if (!hls) {\n      return;\n    }\n\n    var _hls$config = hls.config,\n        enableEmsgMetadataCues = _hls$config.enableEmsgMetadataCues,\n        enableID3MetadataCues = _hls$config.enableID3MetadataCues;\n\n    if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {\n      var predicate;\n\n      if (type === 'audio') {\n        predicate = function predicate(cue) {\n          return cue.type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__[\"MetadataSchema\"].audioId3 && enableID3MetadataCues;\n        };\n      } else if (type === 'video') {\n        predicate = function predicate(cue) {\n          return cue.type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__[\"MetadataSchema\"].emsg && enableEmsgMetadataCues;\n        };\n      } else {\n        predicate = function predicate(cue) {\n          return cue.type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__[\"MetadataSchema\"].audioId3 && enableID3MetadataCues || cue.type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__[\"MetadataSchema\"].emsg && enableEmsgMetadataCues;\n        };\n      }\n\n      Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__[\"removeCuesInRange\"])(id3Track, startOffset, endOffset, predicate);\n    }\n  };\n\n  _proto.onLevelUpdated = function onLevelUpdated(event, _ref2) {\n    var _this = this;\n\n    var details = _ref2.details;\n\n    if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {\n      return;\n    }\n\n    var dateRangeCuesAppended = this.dateRangeCuesAppended,\n        id3Track = this.id3Track;\n    var dateRanges = details.dateRanges;\n    var ids = Object.keys(dateRanges); // Remove cues from track not found in details.dateRanges\n\n    if (id3Track) {\n      var idsToRemove = Object.keys(dateRangeCuesAppended).filter(function (id) {\n        return !ids.includes(id);\n      });\n\n      var _loop = function _loop(i) {\n        var id = idsToRemove[i];\n        Object.keys(dateRangeCuesAppended[id].cues).forEach(function (key) {\n          id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);\n        });\n        delete dateRangeCuesAppended[id];\n      };\n\n      for (var i = idsToRemove.length; i--;) {\n        _loop(i);\n      }\n    } // Exit if the playlist does not have Date Ranges or does not have Program Date Time\n\n\n    var lastFragment = details.fragments[details.fragments.length - 1];\n\n    if (ids.length === 0 || !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(lastFragment === null || lastFragment === void 0 ? void 0 : lastFragment.programDateTime)) {\n      return;\n    }\n\n    if (!this.id3Track) {\n      this.id3Track = this.createTrack(this.media);\n    }\n\n    var dateTimeOffset = lastFragment.programDateTime / 1000 - lastFragment.start;\n    var maxCueTime = details.edge || lastFragment.end;\n    var Cue = getCueClass();\n\n    var _loop2 = function _loop2(_i) {\n      var id = ids[_i];\n      var dateRange = dateRanges[id];\n      var appendedDateRangeCues = dateRangeCuesAppended[id];\n      var cues = (appendedDateRangeCues === null || appendedDateRangeCues === void 0 ? void 0 : appendedDateRangeCues.cues) || {};\n      var durationKnown = (appendedDateRangeCues === null || appendedDateRangeCues === void 0 ? void 0 : appendedDateRangeCues.durationKnown) || false;\n      var startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);\n      var endTime = maxCueTime;\n      var endDate = dateRange.endDate;\n\n      if (endDate) {\n        endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);\n        durationKnown = true;\n      } else if (dateRange.endOnNext && !durationKnown) {\n        var nextDateRangeWithSameClass = ids.reduce(function (filterMapArray, id) {\n          var candidate = dateRanges[id];\n\n          if (candidate.class === dateRange.class && candidate.id !== id && candidate.startDate > dateRange.startDate) {\n            filterMapArray.push(candidate);\n          }\n\n          return filterMapArray;\n        }, []).sort(function (a, b) {\n          return a.startDate.getTime() - b.startDate.getTime();\n        })[0];\n\n        if (nextDateRangeWithSameClass) {\n          endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);\n          durationKnown = true;\n        }\n      }\n\n      var attributes = Object.keys(dateRange.attr);\n\n      for (var j = 0; j < attributes.length; j++) {\n        var key = attributes[j];\n\n        if (key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__[\"DateRangeAttribute\"].ID || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__[\"DateRangeAttribute\"].CLASS || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__[\"DateRangeAttribute\"].START_DATE || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__[\"DateRangeAttribute\"].DURATION || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__[\"DateRangeAttribute\"].END_DATE || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__[\"DateRangeAttribute\"].END_ON_NEXT) {\n          continue;\n        }\n\n        var cue = cues[key];\n\n        if (cue) {\n          if (durationKnown && !appendedDateRangeCues.durationKnown) {\n            cue.endTime = endTime;\n          }\n        } else {\n          var data = dateRange.attr[key];\n          cue = new Cue(startTime, endTime, '');\n\n          if (key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__[\"DateRangeAttribute\"].SCTE35_OUT || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__[\"DateRangeAttribute\"].SCTE35_IN) {\n            data = hexToArrayBuffer(data);\n          }\n\n          cue.value = {\n            key: key,\n            data: data\n          };\n          cue.type = _types_demuxer__WEBPACK_IMPORTED_MODULE_5__[\"MetadataSchema\"].dateRange;\n\n          _this.id3Track.addCue(cue);\n\n          cues[key] = cue;\n        }\n      }\n\n      dateRangeCuesAppended[id] = {\n        cues: cues,\n        dateRange: dateRange,\n        durationKnown: durationKnown\n      };\n    };\n\n    for (var _i = 0; _i < ids.length; _i++) {\n      _loop2(_i);\n    }\n  };\n\n  return ID3TrackController;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ID3TrackController);\n\n/***/ }),\n\n/***/ \"./src/controller/latency-controller.ts\":\n/*!**********************************************!*\\\n  !*** ./src/controller/latency-controller.ts ***!\n  \\**********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_315693__) {\n\n\"use strict\";\n__nested_webpack_require_315693__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_315693__.d(__webpack_exports__, \"default\", function() { return LatencyController; });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_315693__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_315693__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_315693__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\n\n\nvar LatencyController = /*#__PURE__*/function () {\n  function LatencyController(hls) {\n    var _this = this;\n\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = null;\n    this.levelDetails = null;\n    this.currentTime = 0;\n    this.stallCount = 0;\n    this._latency = null;\n\n    this.timeupdateHandler = function () {\n      return _this.timeupdate();\n    };\n\n    this.hls = hls;\n    this.config = hls.config;\n    this.registerListeners();\n  }\n\n  var _proto = LatencyController.prototype;\n\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.onMediaDetaching();\n    this.levelDetails = null; // @ts-ignore\n\n    this.hls = this.timeupdateHandler = null;\n  };\n\n  _proto.registerListeners = function registerListeners() {\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_UPDATED, this.onLevelUpdated, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, this.onError, this);\n  };\n\n  _proto.unregisterListeners = function unregisterListeners() {\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_UPDATED, this.onLevelUpdated);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, this.onError);\n  };\n\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    this.media = data.media;\n    this.media.addEventListener('timeupdate', this.timeupdateHandler);\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    if (this.media) {\n      this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n      this.media = null;\n    }\n  };\n\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.levelDetails = null;\n    this._latency = null;\n    this.stallCount = 0;\n  };\n\n  _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {\n    var details = _ref.details;\n    this.levelDetails = details;\n\n    if (details.advanced) {\n      this.timeupdate();\n    }\n\n    if (!details.live && this.media) {\n      this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n    }\n  };\n\n  _proto.onError = function onError(event, data) {\n    if (data.details !== _errors__WEBPACK_IMPORTED_MODULE_0__[\"ErrorDetails\"].BUFFER_STALLED_ERROR) {\n      return;\n    }\n\n    this.stallCount++;\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn('[playback-rate-controller]: Stall detected, adjusting target latency');\n  };\n\n  _proto.timeupdate = function timeupdate() {\n    var media = this.media,\n        levelDetails = this.levelDetails;\n\n    if (!media || !levelDetails) {\n      return;\n    }\n\n    this.currentTime = media.currentTime;\n    var latency = this.computeLatency();\n\n    if (latency === null) {\n      return;\n    }\n\n    this._latency = latency; // Adapt playbackRate to meet target latency in low-latency mode\n\n    var _this$config = this.config,\n        lowLatencyMode = _this$config.lowLatencyMode,\n        maxLiveSyncPlaybackRate = _this$config.maxLiveSyncPlaybackRate;\n\n    if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1) {\n      return;\n    }\n\n    var targetLatency = this.targetLatency;\n\n    if (targetLatency === null) {\n      return;\n    }\n\n    var distanceFromTarget = latency - targetLatency; // Only adjust playbackRate when within one target duration of targetLatency\n    // and more than one second from under-buffering.\n    // Playback further than one target duration from target can be considered DVR playback.\n\n    var liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);\n    var inLiveRange = distanceFromTarget < liveMinLatencyDuration;\n\n    if (levelDetails.live && inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {\n      var max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));\n      var rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;\n      media.playbackRate = Math.min(max, Math.max(1, rate));\n    } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {\n      media.playbackRate = 1;\n    }\n  };\n\n  _proto.estimateLiveEdge = function estimateLiveEdge() {\n    var levelDetails = this.levelDetails;\n\n    if (levelDetails === null) {\n      return null;\n    }\n\n    return levelDetails.edge + levelDetails.age;\n  };\n\n  _proto.computeLatency = function computeLatency() {\n    var liveEdge = this.estimateLiveEdge();\n\n    if (liveEdge === null) {\n      return null;\n    }\n\n    return liveEdge - this.currentTime;\n  };\n\n  _createClass(LatencyController, [{\n    key: \"latency\",\n    get: function get() {\n      return this._latency || 0;\n    }\n  }, {\n    key: \"maxLatency\",\n    get: function get() {\n      var config = this.config,\n          levelDetails = this.levelDetails;\n\n      if (config.liveMaxLatencyDuration !== undefined) {\n        return config.liveMaxLatencyDuration;\n      }\n\n      return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;\n    }\n  }, {\n    key: \"targetLatency\",\n    get: function get() {\n      var levelDetails = this.levelDetails;\n\n      if (levelDetails === null) {\n        return null;\n      }\n\n      var holdBack = levelDetails.holdBack,\n          partHoldBack = levelDetails.partHoldBack,\n          targetduration = levelDetails.targetduration;\n      var _this$config2 = this.config,\n          liveSyncDuration = _this$config2.liveSyncDuration,\n          liveSyncDurationCount = _this$config2.liveSyncDurationCount,\n          lowLatencyMode = _this$config2.lowLatencyMode;\n      var userConfig = this.hls.userConfig;\n      var targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;\n\n      if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {\n        targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;\n      }\n\n      var maxLiveSyncOnStallIncrease = targetduration;\n      var liveSyncOnStallIncrease = 1.0;\n      return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);\n    }\n  }, {\n    key: \"liveSyncPosition\",\n    get: function get() {\n      var liveEdge = this.estimateLiveEdge();\n      var targetLatency = this.targetLatency;\n      var levelDetails = this.levelDetails;\n\n      if (liveEdge === null || targetLatency === null || levelDetails === null) {\n        return null;\n      }\n\n      var edge = levelDetails.edge;\n      var syncPosition = liveEdge - targetLatency - this.edgeStalled;\n      var min = edge - levelDetails.totalduration;\n      var max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);\n      return Math.min(Math.max(min, syncPosition), max);\n    }\n  }, {\n    key: \"drift\",\n    get: function get() {\n      var levelDetails = this.levelDetails;\n\n      if (levelDetails === null) {\n        return 1;\n      }\n\n      return levelDetails.drift;\n    }\n  }, {\n    key: \"edgeStalled\",\n    get: function get() {\n      var levelDetails = this.levelDetails;\n\n      if (levelDetails === null) {\n        return 0;\n      }\n\n      var maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;\n      return Math.max(levelDetails.age - maxLevelUpdateAge, 0);\n    }\n  }, {\n    key: \"forwardBufferLength\",\n    get: function get() {\n      var media = this.media,\n          levelDetails = this.levelDetails;\n\n      if (!media || !levelDetails) {\n        return 0;\n      }\n\n      var bufferedRanges = media.buffered.length;\n      return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;\n    }\n  }]);\n\n  return LatencyController;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/level-controller.ts\":\n/*!********************************************!*\\\n  !*** ./src/controller/level-controller.ts ***!\n  \\********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_325472__) {\n\n\"use strict\";\n__nested_webpack_require_325472__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_325472__.d(__webpack_exports__, \"default\", function() { return LevelController; });\n/* harmony import */ var _types_level__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_325472__(/*! ../types/level */ \"./src/types/level.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_325472__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_325472__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_codecs__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_325472__(/*! ../utils/codecs */ \"./src/utils/codecs.ts\");\n/* harmony import */ var _level_helper__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_325472__(/*! ./level-helper */ \"./src/controller/level-helper.ts\");\n/* harmony import */ var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_325472__(/*! ./base-playlist-controller */ \"./src/controller/base-playlist-controller.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_325472__(/*! ../types/loader */ \"./src/types/loader.ts\");\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/*\n * Level Controller\n */\n\n\n\n\n\n\n\nvar chromeOrFirefox = /chrome|firefox/.test(navigator.userAgent.toLowerCase());\n\nvar LevelController = /*#__PURE__*/function (_BasePlaylistControll) {\n  _inheritsLoose(LevelController, _BasePlaylistControll);\n\n  function LevelController(hls) {\n    var _this;\n\n    _this = _BasePlaylistControll.call(this, hls, '[level-controller]') || this;\n    _this._levels = [];\n    _this._firstLevel = -1;\n    _this._startLevel = void 0;\n    _this.currentLevelIndex = -1;\n    _this.manualLevelIndex = -1;\n    _this.onParsedComplete = void 0;\n\n    _this._registerListeners();\n\n    return _this;\n  }\n\n  var _proto = LevelController.prototype;\n\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, this.onError, this);\n  };\n\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, this.onError, this);\n  };\n\n  _proto.destroy = function destroy() {\n    this._unregisterListeners();\n\n    this.manualLevelIndex = -1;\n    this._levels.length = 0;\n\n    _BasePlaylistControll.prototype.destroy.call(this);\n  };\n\n  _proto.startLoad = function startLoad() {\n    var levels = this._levels; // clean up live level details to force reload them, and reset load errors\n\n    levels.forEach(function (level) {\n      level.loadError = 0;\n    });\n\n    _BasePlaylistControll.prototype.startLoad.call(this);\n  };\n\n  _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n    var levels = [];\n    var audioTracks = [];\n    var subtitleTracks = [];\n    var bitrateStart;\n    var levelSet = {};\n    var levelFromSet;\n    var resolutionFound = false;\n    var videoCodecFound = false;\n    var audioCodecFound = false; // regroup redundant levels together\n\n    data.levels.forEach(function (levelParsed) {\n      var attributes = levelParsed.attrs;\n      resolutionFound = resolutionFound || !!(levelParsed.width && levelParsed.height);\n      videoCodecFound = videoCodecFound || !!levelParsed.videoCodec;\n      audioCodecFound = audioCodecFound || !!levelParsed.audioCodec; // erase audio codec info if browser does not support mp4a.40.34.\n      // demuxer will autodetect codec and fallback to mpeg/audio\n\n      if (chromeOrFirefox && levelParsed.audioCodec && levelParsed.audioCodec.indexOf('mp4a.40.34') !== -1) {\n        levelParsed.audioCodec = undefined;\n      }\n\n      var levelKey = levelParsed.bitrate + \"-\" + levelParsed.attrs.RESOLUTION + \"-\" + levelParsed.attrs.CODECS;\n      levelFromSet = levelSet[levelKey];\n\n      if (!levelFromSet) {\n        levelFromSet = new _types_level__WEBPACK_IMPORTED_MODULE_0__[\"Level\"](levelParsed);\n        levelSet[levelKey] = levelFromSet;\n        levels.push(levelFromSet);\n      } else {\n        levelFromSet.url.push(levelParsed.url);\n      }\n\n      if (attributes) {\n        if (attributes.AUDIO) {\n          Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__[\"addGroupId\"])(levelFromSet, 'audio', attributes.AUDIO);\n        }\n\n        if (attributes.SUBTITLES) {\n          Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__[\"addGroupId\"])(levelFromSet, 'text', attributes.SUBTITLES);\n        }\n      }\n    }); // remove audio-only level if we also have levels with video codecs or RESOLUTION signalled\n\n    if ((resolutionFound || videoCodecFound) && audioCodecFound) {\n      levels = levels.filter(function (_ref) {\n        var videoCodec = _ref.videoCodec,\n            width = _ref.width,\n            height = _ref.height;\n        return !!videoCodec || !!(width && height);\n      });\n    } // only keep levels with supported audio/video codecs\n\n\n    levels = levels.filter(function (_ref2) {\n      var audioCodec = _ref2.audioCodec,\n          videoCodec = _ref2.videoCodec;\n      return (!audioCodec || Object(_utils_codecs__WEBPACK_IMPORTED_MODULE_3__[\"isCodecSupportedInMp4\"])(audioCodec, 'audio')) && (!videoCodec || Object(_utils_codecs__WEBPACK_IMPORTED_MODULE_3__[\"isCodecSupportedInMp4\"])(videoCodec, 'video'));\n    });\n\n    if (data.audioTracks) {\n      audioTracks = data.audioTracks.filter(function (track) {\n        return !track.audioCodec || Object(_utils_codecs__WEBPACK_IMPORTED_MODULE_3__[\"isCodecSupportedInMp4\"])(track.audioCodec, 'audio');\n      }); // Assign ids after filtering as array indices by group-id\n\n      Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__[\"assignTrackIdsByGroup\"])(audioTracks);\n    }\n\n    if (data.subtitles) {\n      subtitleTracks = data.subtitles;\n      Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__[\"assignTrackIdsByGroup\"])(subtitleTracks);\n    }\n\n    if (levels.length > 0) {\n      // start bitrate is the first bitrate of the manifest\n      bitrateStart = levels[0].bitrate; // sort level on bitrate\n\n      levels.sort(function (a, b) {\n        return a.bitrate - b.bitrate;\n      });\n      this._levels = levels; // find index of first level in sorted levels\n\n      for (var i = 0; i < levels.length; i++) {\n        if (levels[i].bitrate === bitrateStart) {\n          this._firstLevel = i;\n          this.log(\"manifest loaded, \" + levels.length + \" level(s) found, first bitrate: \" + bitrateStart);\n          break;\n        }\n      } // Audio is only alternate if manifest include a URI along with the audio group tag,\n      // and this is not an audio-only stream where levels contain audio-only\n\n\n      var audioOnly = audioCodecFound && !videoCodecFound;\n      var edata = {\n        levels: levels,\n        audioTracks: audioTracks,\n        subtitleTracks: subtitleTracks,\n        firstLevel: this._firstLevel,\n        stats: data.stats,\n        audio: audioCodecFound,\n        video: videoCodecFound,\n        altAudio: !audioOnly && audioTracks.some(function (t) {\n          return !!t.url;\n        })\n      };\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_PARSED, edata); // Initiate loading after all controllers have received MANIFEST_PARSED\n\n      if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {\n        this.hls.startLoad(this.hls.config.startPosition);\n      }\n    } else {\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorTypes\"].MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n        fatal: true,\n        url: data.url,\n        reason: 'no level with compatible codecs found in manifest'\n      });\n    }\n  };\n\n  _proto.onError = function onError(event, data) {\n    _BasePlaylistControll.prototype.onError.call(this, event, data);\n\n    if (data.fatal) {\n      return;\n    } // Switch to redundant level when track fails to load\n\n\n    var context = data.context;\n    var level = this._levels[this.currentLevelIndex];\n\n    if (context && (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].AUDIO_TRACK && level.audioGroupIds && context.groupId === level.audioGroupIds[level.urlId] || context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].SUBTITLE_TRACK && level.textGroupIds && context.groupId === level.textGroupIds[level.urlId])) {\n      this.redundantFailover(this.currentLevelIndex);\n      return;\n    }\n\n    var levelError = false;\n    var levelSwitch = true;\n    var levelIndex; // try to recover not fatal errors\n\n    switch (data.details) {\n      case _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].FRAG_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].FRAG_LOAD_TIMEOUT:\n      case _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].KEY_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].KEY_LOAD_TIMEOUT:\n        if (data.frag) {\n          var _level = this._levels[data.frag.level]; // Set levelIndex when we're out of fragment retries\n\n          if (_level) {\n            _level.fragmentError++;\n\n            if (_level.fragmentError > this.hls.config.fragLoadingMaxRetry) {\n              levelIndex = data.frag.level;\n            }\n          } else {\n            levelIndex = data.frag.level;\n          }\n        }\n\n        break;\n\n      case _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].LEVEL_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].LEVEL_LOAD_TIMEOUT:\n        // Do not perform level switch if an error occurred using delivery directives\n        // Attempt to reload level without directives first\n        if (context) {\n          if (context.deliveryDirectives) {\n            levelSwitch = false;\n          }\n\n          levelIndex = context.level;\n        }\n\n        levelError = true;\n        break;\n\n      case _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].REMUX_ALLOC_ERROR:\n        levelIndex = data.level;\n        levelError = true;\n        break;\n    }\n\n    if (levelIndex !== undefined) {\n      this.recoverLevel(data, levelIndex, levelError, levelSwitch);\n    }\n  }\n  /**\n   * Switch to a redundant stream if any available.\n   * If redundant stream is not available, emergency switch down if ABR mode is enabled.\n   */\n  ;\n\n  _proto.recoverLevel = function recoverLevel(errorEvent, levelIndex, levelError, levelSwitch) {\n    var errorDetails = errorEvent.details;\n    var level = this._levels[levelIndex];\n    level.loadError++;\n\n    if (levelError) {\n      var retrying = this.retryLoadingOrFail(errorEvent);\n\n      if (retrying) {\n        // boolean used to inform stream controller not to switch back to IDLE on non fatal error\n        errorEvent.levelRetry = true;\n      } else {\n        this.currentLevelIndex = -1;\n        return;\n      }\n    }\n\n    if (levelSwitch) {\n      var redundantLevels = level.url.length; // Try redundant fail-over until level.loadError reaches redundantLevels\n\n      if (redundantLevels > 1 && level.loadError < redundantLevels) {\n        errorEvent.levelRetry = true;\n        this.redundantFailover(levelIndex);\n      } else if (this.manualLevelIndex === -1) {\n        // Search for available level in auto level selection mode, cycling from highest to lowest bitrate\n        var nextLevel = levelIndex === 0 ? this._levels.length - 1 : levelIndex - 1;\n\n        if (this.currentLevelIndex !== nextLevel && this._levels[nextLevel].loadError === 0) {\n          this.warn(errorDetails + \": switch to \" + nextLevel);\n          errorEvent.levelRetry = true;\n          this.hls.nextAutoLevel = nextLevel;\n        }\n      }\n    }\n  };\n\n  _proto.redundantFailover = function redundantFailover(levelIndex) {\n    var level = this._levels[levelIndex];\n    var redundantLevels = level.url.length;\n\n    if (redundantLevels > 1) {\n      // Update the url id of all levels so that we stay on the same set of variants when level switching\n      var newUrlId = (level.urlId + 1) % redundantLevels;\n      this.warn(\"Switching to redundant URL-id \" + newUrlId);\n\n      this._levels.forEach(function (level) {\n        level.urlId = newUrlId;\n      });\n\n      this.level = levelIndex;\n    }\n  } // reset errors on the successful load of a fragment\n  ;\n\n  _proto.onFragLoaded = function onFragLoaded(event, _ref3) {\n    var frag = _ref3.frag;\n\n    if (frag !== undefined && frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN) {\n      var level = this._levels[frag.level];\n\n      if (level !== undefined) {\n        level.fragmentError = 0;\n        level.loadError = 0;\n      }\n    }\n  };\n\n  _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n    var _data$deliveryDirecti2;\n\n    var level = data.level,\n        details = data.details;\n    var curLevel = this._levels[level];\n\n    if (!curLevel) {\n      var _data$deliveryDirecti;\n\n      this.warn(\"Invalid level index \" + level);\n\n      if ((_data$deliveryDirecti = data.deliveryDirectives) !== null && _data$deliveryDirecti !== void 0 && _data$deliveryDirecti.skip) {\n        details.deltaUpdateFailed = true;\n      }\n\n      return;\n    } // only process level loaded events matching with expected level\n\n\n    if (level === this.currentLevelIndex) {\n      // reset level load error counter on successful level loaded only if there is no issues with fragments\n      if (curLevel.fragmentError === 0) {\n        curLevel.loadError = 0;\n        this.retryCount = 0;\n      }\n\n      this.playlistLoaded(level, data, curLevel.details);\n    } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) !== null && _data$deliveryDirecti2 !== void 0 && _data$deliveryDirecti2.skip) {\n      // received a delta playlist update that cannot be merged\n      details.deltaUpdateFailed = true;\n    }\n  };\n\n  _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {\n    var currentLevel = this.hls.levels[this.currentLevelIndex];\n\n    if (!currentLevel) {\n      return;\n    }\n\n    if (currentLevel.audioGroupIds) {\n      var urlId = -1;\n      var audioGroupId = this.hls.audioTracks[data.id].groupId;\n\n      for (var i = 0; i < currentLevel.audioGroupIds.length; i++) {\n        if (currentLevel.audioGroupIds[i] === audioGroupId) {\n          urlId = i;\n          break;\n        }\n      }\n\n      if (urlId !== currentLevel.urlId) {\n        currentLevel.urlId = urlId;\n        this.startLoad();\n      }\n    }\n  };\n\n  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n    var level = this.currentLevelIndex;\n    var currentLevel = this._levels[level];\n\n    if (this.canLoad && currentLevel && currentLevel.url.length > 0) {\n      var id = currentLevel.urlId;\n      var url = currentLevel.url[id];\n\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + error);\n        }\n      }\n\n      this.log(\"Attempt loading level index \" + level + (hlsUrlParameters ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : '') + \" with URL-id \" + id + \" \" + url); // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);\n      // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);\n\n      this.clearTimer();\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_LOADING, {\n        url: url,\n        level: level,\n        id: id,\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  };\n\n  _proto.removeLevel = function removeLevel(levelIndex, urlId) {\n    var filterLevelAndGroupByIdIndex = function filterLevelAndGroupByIdIndex(url, id) {\n      return id !== urlId;\n    };\n\n    var levels = this._levels.filter(function (level, index) {\n      if (index !== levelIndex) {\n        return true;\n      }\n\n      if (level.url.length > 1 && urlId !== undefined) {\n        level.url = level.url.filter(filterLevelAndGroupByIdIndex);\n\n        if (level.audioGroupIds) {\n          level.audioGroupIds = level.audioGroupIds.filter(filterLevelAndGroupByIdIndex);\n        }\n\n        if (level.textGroupIds) {\n          level.textGroupIds = level.textGroupIds.filter(filterLevelAndGroupByIdIndex);\n        }\n\n        level.urlId = 0;\n        return true;\n      }\n\n      return false;\n    }).map(function (level, index) {\n      var details = level.details;\n\n      if (details !== null && details !== void 0 && details.fragments) {\n        details.fragments.forEach(function (fragment) {\n          fragment.level = index;\n        });\n      }\n\n      return level;\n    });\n\n    this._levels = levels;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVELS_UPDATED, {\n      levels: levels\n    });\n  };\n\n  _createClass(LevelController, [{\n    key: \"levels\",\n    get: function get() {\n      if (this._levels.length === 0) {\n        return null;\n      }\n\n      return this._levels;\n    }\n  }, {\n    key: \"level\",\n    get: function get() {\n      return this.currentLevelIndex;\n    },\n    set: function set(newLevel) {\n      var _levels$newLevel;\n\n      var levels = this._levels;\n\n      if (levels.length === 0) {\n        return;\n      }\n\n      if (this.currentLevelIndex === newLevel && (_levels$newLevel = levels[newLevel]) !== null && _levels$newLevel !== void 0 && _levels$newLevel.details) {\n        return;\n      } // check if level idx is valid\n\n\n      if (newLevel < 0 || newLevel >= levels.length) {\n        // invalid level id given, trigger error\n        var fatal = newLevel < 0;\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, {\n          type: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorTypes\"].OTHER_ERROR,\n          details: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].LEVEL_SWITCH_ERROR,\n          level: newLevel,\n          fatal: fatal,\n          reason: 'invalid level idx'\n        });\n\n        if (fatal) {\n          return;\n        }\n\n        newLevel = Math.min(newLevel, levels.length - 1);\n      } // stopping live reloading timer if any\n\n\n      this.clearTimer();\n      var lastLevelIndex = this.currentLevelIndex;\n      var lastLevel = levels[lastLevelIndex];\n      var level = levels[newLevel];\n      this.log(\"switching to level \" + newLevel + \" from \" + lastLevelIndex);\n      this.currentLevelIndex = newLevel;\n\n      var levelSwitchingData = _extends({}, level, {\n        level: newLevel,\n        maxBitrate: level.maxBitrate,\n        uri: level.uri,\n        urlId: level.urlId\n      }); // @ts-ignore\n\n\n      delete levelSwitchingData._urlId;\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_SWITCHING, levelSwitchingData); // check if we need to load playlist for this level\n\n      var levelDetails = level.details;\n\n      if (!levelDetails || levelDetails.live) {\n        // level not retrieved yet, or live playlist we need to (re)load it\n        var hlsUrlParameters = this.switchParams(level.uri, lastLevel === null || lastLevel === void 0 ? void 0 : lastLevel.details);\n        this.loadPlaylist(hlsUrlParameters);\n      }\n    }\n  }, {\n    key: \"manualLevel\",\n    get: function get() {\n      return this.manualLevelIndex;\n    },\n    set: function set(newLevel) {\n      this.manualLevelIndex = newLevel;\n\n      if (this._startLevel === undefined) {\n        this._startLevel = newLevel;\n      }\n\n      if (newLevel !== -1) {\n        this.level = newLevel;\n      }\n    }\n  }, {\n    key: \"firstLevel\",\n    get: function get() {\n      return this._firstLevel;\n    },\n    set: function set(newLevel) {\n      this._firstLevel = newLevel;\n    }\n  }, {\n    key: \"startLevel\",\n    get: function get() {\n      // hls.startLevel takes precedence over config.startLevel\n      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)\n      if (this._startLevel === undefined) {\n        var configStartLevel = this.hls.config.startLevel;\n\n        if (configStartLevel !== undefined) {\n          return configStartLevel;\n        } else {\n          return this._firstLevel;\n        }\n      } else {\n        return this._startLevel;\n      }\n    },\n    set: function set(newLevel) {\n      this._startLevel = newLevel;\n    }\n  }, {\n    key: \"nextLoadLevel\",\n    get: function get() {\n      if (this.manualLevelIndex !== -1) {\n        return this.manualLevelIndex;\n      } else {\n        return this.hls.nextAutoLevel;\n      }\n    },\n    set: function set(nextLevel) {\n      this.level = nextLevel;\n\n      if (this.manualLevelIndex === -1) {\n        this.hls.nextAutoLevel = nextLevel;\n      }\n    }\n  }]);\n\n  return LevelController;\n}(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/level-helper.ts\":\n/*!****************************************!*\\\n  !*** ./src/controller/level-helper.ts ***!\n  \\****************************************/\n/*! exports provided: addGroupId, assignTrackIdsByGroup, updatePTS, updateFragPTSDTS, mergeDetails, mapPartIntersection, mapFragmentIntersection, adjustSliding, addSliding, computeReloadInterval, getFragmentWithSN, getPartWith */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_348880__) {\n\n\"use strict\";\n__nested_webpack_require_348880__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_348880__.d(__webpack_exports__, \"addGroupId\", function() { return addGroupId; });\n/* harmony export (binding) */ __nested_webpack_require_348880__.d(__webpack_exports__, \"assignTrackIdsByGroup\", function() { return assignTrackIdsByGroup; });\n/* harmony export (binding) */ __nested_webpack_require_348880__.d(__webpack_exports__, \"updatePTS\", function() { return updatePTS; });\n/* harmony export (binding) */ __nested_webpack_require_348880__.d(__webpack_exports__, \"updateFragPTSDTS\", function() { return updateFragPTSDTS; });\n/* harmony export (binding) */ __nested_webpack_require_348880__.d(__webpack_exports__, \"mergeDetails\", function() { return mergeDetails; });\n/* harmony export (binding) */ __nested_webpack_require_348880__.d(__webpack_exports__, \"mapPartIntersection\", function() { return mapPartIntersection; });\n/* harmony export (binding) */ __nested_webpack_require_348880__.d(__webpack_exports__, \"mapFragmentIntersection\", function() { return mapFragmentIntersection; });\n/* harmony export (binding) */ __nested_webpack_require_348880__.d(__webpack_exports__, \"adjustSliding\", function() { return adjustSliding; });\n/* harmony export (binding) */ __nested_webpack_require_348880__.d(__webpack_exports__, \"addSliding\", function() { return addSliding; });\n/* harmony export (binding) */ __nested_webpack_require_348880__.d(__webpack_exports__, \"computeReloadInterval\", function() { return computeReloadInterval; });\n/* harmony export (binding) */ __nested_webpack_require_348880__.d(__webpack_exports__, \"getFragmentWithSN\", function() { return getFragmentWithSN; });\n/* harmony export (binding) */ __nested_webpack_require_348880__.d(__webpack_exports__, \"getPartWith\", function() { return getPartWith; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_348880__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_348880__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _loader_date_range__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_348880__(/*! ../loader/date-range */ \"./src/loader/date-range.ts\");\n\n\n\n\n\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n/**\n * @module LevelHelper\n * Providing methods dealing with playlist sliding and drift\n * */\n\n\nfunction addGroupId(level, type, id) {\n  switch (type) {\n    case 'audio':\n      if (!level.audioGroupIds) {\n        level.audioGroupIds = [];\n      }\n\n      level.audioGroupIds.push(id);\n      break;\n\n    case 'text':\n      if (!level.textGroupIds) {\n        level.textGroupIds = [];\n      }\n\n      level.textGroupIds.push(id);\n      break;\n  }\n}\nfunction assignTrackIdsByGroup(tracks) {\n  var groups = {};\n  tracks.forEach(function (track) {\n    var groupId = track.groupId || '';\n    track.id = groups[groupId] = groups[groupId] || 0;\n    groups[groupId]++;\n  });\n}\nfunction updatePTS(fragments, fromIdx, toIdx) {\n  var fragFrom = fragments[fromIdx];\n  var fragTo = fragments[toIdx];\n  updateFromToPTS(fragFrom, fragTo);\n}\n\nfunction updateFromToPTS(fragFrom, fragTo) {\n  var fragToPTS = fragTo.startPTS; // if we know startPTS[toIdx]\n\n  if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(fragToPTS)) {\n    // update fragment duration.\n    // it helps to fix drifts between playlist reported duration and fragment real duration\n    var duration = 0;\n    var frag;\n\n    if (fragTo.sn > fragFrom.sn) {\n      duration = fragToPTS - fragFrom.start;\n      frag = fragFrom;\n    } else {\n      duration = fragFrom.start - fragToPTS;\n      frag = fragTo;\n    } // TODO? Drift can go either way, or the playlist could be completely accurate\n    // console.assert(duration > 0,\n    //   `duration of ${duration} computed for frag ${frag.sn}, level ${frag.level}, there should be some duration drift between playlist and fragment!`);\n\n\n    if (frag.duration !== duration) {\n      frag.duration = duration;\n    } // we dont know startPTS[toIdx]\n\n  } else if (fragTo.sn > fragFrom.sn) {\n    var contiguous = fragFrom.cc === fragTo.cc; // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS\n\n    if (contiguous && fragFrom.minEndPTS) {\n      fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);\n    } else {\n      fragTo.start = fragFrom.start + fragFrom.duration;\n    }\n  } else {\n    fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);\n  }\n}\n\nfunction updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {\n  var parsedMediaDuration = endPTS - startPTS;\n\n  if (parsedMediaDuration <= 0) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].warn('Fragment should have a positive duration', frag);\n    endPTS = startPTS + frag.duration;\n    endDTS = startDTS + frag.duration;\n  }\n\n  var maxStartPTS = startPTS;\n  var minEndPTS = endPTS;\n  var fragStartPts = frag.startPTS;\n  var fragEndPts = frag.endPTS;\n\n  if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(fragStartPts)) {\n    // delta PTS between audio and video\n    var deltaPTS = Math.abs(fragStartPts - startPTS);\n\n    if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(frag.deltaPTS)) {\n      frag.deltaPTS = deltaPTS;\n    } else {\n      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);\n    }\n\n    maxStartPTS = Math.max(startPTS, fragStartPts);\n    startPTS = Math.min(startPTS, fragStartPts);\n    startDTS = Math.min(startDTS, frag.startDTS);\n    minEndPTS = Math.min(endPTS, fragEndPts);\n    endPTS = Math.max(endPTS, fragEndPts);\n    endDTS = Math.max(endDTS, frag.endDTS);\n  }\n\n  frag.duration = endPTS - startPTS;\n  var drift = startPTS - frag.start;\n  frag.appendedPTS = endPTS;\n  frag.start = frag.startPTS = startPTS;\n  frag.maxStartPTS = maxStartPTS;\n  frag.startDTS = startDTS;\n  frag.endPTS = endPTS;\n  frag.minEndPTS = minEndPTS;\n  frag.endDTS = endDTS;\n  var sn = frag.sn; // 'initSegment'\n  // exit if sn out of range\n\n  if (!details || sn < details.startSN || sn > details.endSN) {\n    return 0;\n  }\n\n  var i;\n  var fragIdx = sn - details.startSN;\n  var fragments = details.fragments; // update frag reference in fragments array\n  // rationale is that fragments array might not contain this frag object.\n  // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()\n  // if we don't update frag, we won't be able to propagate PTS info on the playlist\n  // resulting in invalid sliding computation\n\n  fragments[fragIdx] = frag; // adjust fragment PTS/duration from seqnum-1 to frag 0\n\n  for (i = fragIdx; i > 0; i--) {\n    updateFromToPTS(fragments[i], fragments[i - 1]);\n  } // adjust fragment PTS/duration from seqnum to last frag\n\n\n  for (i = fragIdx; i < fragments.length - 1; i++) {\n    updateFromToPTS(fragments[i], fragments[i + 1]);\n  }\n\n  if (details.fragmentHint) {\n    updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);\n  }\n\n  details.PTSKnown = details.alignedSliding = true;\n  return drift;\n}\nfunction mergeDetails(oldDetails, newDetails) {\n  // Track the last initSegment processed. Initialize it to the last one on the timeline.\n  var currentInitSegment = null;\n  var oldFragments = oldDetails.fragments;\n\n  for (var i = oldFragments.length - 1; i >= 0; i--) {\n    var oldInit = oldFragments[i].initSegment;\n\n    if (oldInit) {\n      currentInitSegment = oldInit;\n      break;\n    }\n  }\n\n  if (oldDetails.fragmentHint) {\n    // prevent PTS and duration from being adjusted on the next hint\n    delete oldDetails.fragmentHint.endPTS;\n  } // check if old/new playlists have fragments in common\n  // loop through overlapping SN and update startPTS , cc, and duration if any found\n\n\n  var ccOffset = 0;\n  var PTSFrag;\n  mapFragmentIntersection(oldDetails, newDetails, function (oldFrag, newFrag) {\n    if (oldFrag.relurl) {\n      // Do not compare CC if the old fragment has no url. This is a level.fragmentHint used by LL-HLS parts.\n      // It maybe be off by 1 if it was created before any parts or discontinuity tags were appended to the end\n      // of the playlist.\n      ccOffset = oldFrag.cc - newFrag.cc;\n    }\n\n    if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(oldFrag.startPTS) && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(oldFrag.endPTS)) {\n      newFrag.start = newFrag.startPTS = oldFrag.startPTS;\n      newFrag.startDTS = oldFrag.startDTS;\n      newFrag.appendedPTS = oldFrag.appendedPTS;\n      newFrag.maxStartPTS = oldFrag.maxStartPTS;\n      newFrag.endPTS = oldFrag.endPTS;\n      newFrag.endDTS = oldFrag.endDTS;\n      newFrag.minEndPTS = oldFrag.minEndPTS;\n      newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;\n\n      if (newFrag.duration) {\n        PTSFrag = newFrag;\n      } // PTS is known when any segment has startPTS and endPTS\n\n\n      newDetails.PTSKnown = newDetails.alignedSliding = true;\n    }\n\n    newFrag.elementaryStreams = oldFrag.elementaryStreams;\n    newFrag.loader = oldFrag.loader;\n    newFrag.stats = oldFrag.stats;\n    newFrag.urlId = oldFrag.urlId;\n\n    if (oldFrag.initSegment) {\n      newFrag.initSegment = oldFrag.initSegment;\n      currentInitSegment = oldFrag.initSegment;\n    }\n  });\n\n  if (currentInitSegment) {\n    var fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n    fragmentsToCheck.forEach(function (frag) {\n      var _currentInitSegment;\n\n      if (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) === null || _currentInitSegment === void 0 ? void 0 : _currentInitSegment.relurl)) {\n        frag.initSegment = currentInitSegment;\n      }\n    });\n  }\n\n  if (newDetails.skippedSegments) {\n    newDetails.deltaUpdateFailed = newDetails.fragments.some(function (frag) {\n      return !frag;\n    });\n\n    if (newDetails.deltaUpdateFailed) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].warn('[level-helper] Previous playlist missing segments skipped in delta playlist');\n\n      for (var _i = newDetails.skippedSegments; _i--;) {\n        newDetails.fragments.shift();\n      }\n\n      newDetails.startSN = newDetails.fragments[0].sn;\n      newDetails.startCC = newDetails.fragments[0].cc;\n    } else if (newDetails.canSkipDateRanges) {\n      newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);\n    }\n  }\n\n  var newFragments = newDetails.fragments;\n\n  if (ccOffset) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].warn('discontinuity sliding from playlist, take drift into account');\n\n    for (var _i2 = 0; _i2 < newFragments.length; _i2++) {\n      newFragments[_i2].cc += ccOffset;\n    }\n  }\n\n  if (newDetails.skippedSegments) {\n    newDetails.startCC = newDetails.fragments[0].cc;\n  } // Merge parts\n\n\n  mapPartIntersection(oldDetails.partList, newDetails.partList, function (oldPart, newPart) {\n    newPart.elementaryStreams = oldPart.elementaryStreams;\n    newPart.stats = oldPart.stats;\n  }); // if at least one fragment contains PTS info, recompute PTS information for all fragments\n\n  if (PTSFrag) {\n    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);\n  } else {\n    // ensure that delta is within oldFragments range\n    // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])\n    // in that case we also need to adjust start offset of all fragments\n    adjustSliding(oldDetails, newDetails);\n  }\n\n  if (newFragments.length) {\n    newDetails.totalduration = newDetails.edge - newFragments[0].start;\n  }\n\n  newDetails.driftStartTime = oldDetails.driftStartTime;\n  newDetails.driftStart = oldDetails.driftStart;\n  var advancedDateTime = newDetails.advancedDateTime;\n\n  if (newDetails.advanced && advancedDateTime) {\n    var edge = newDetails.edge;\n\n    if (!newDetails.driftStart) {\n      newDetails.driftStartTime = advancedDateTime;\n      newDetails.driftStart = edge;\n    }\n\n    newDetails.driftEndTime = advancedDateTime;\n    newDetails.driftEnd = edge;\n  } else {\n    newDetails.driftEndTime = oldDetails.driftEndTime;\n    newDetails.driftEnd = oldDetails.driftEnd;\n    newDetails.advancedDateTime = oldDetails.advancedDateTime;\n  }\n}\n\nfunction mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {\n  var dateRanges = _extends({}, oldDateRanges);\n\n  if (recentlyRemovedDateranges) {\n    recentlyRemovedDateranges.forEach(function (id) {\n      delete dateRanges[id];\n    });\n  }\n\n  Object.keys(deltaDateRanges).forEach(function (id) {\n    var dateRange = new _loader_date_range__WEBPACK_IMPORTED_MODULE_2__[\"DateRange\"](deltaDateRanges[id].attr, dateRanges[id]);\n\n    if (dateRange.isValid) {\n      dateRanges[id] = dateRange;\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].warn(\"Ignoring invalid Playlist Delta Update DATERANGE tag: \\\"\" + JSON.stringify(deltaDateRanges[id].attr) + \"\\\"\");\n    }\n  });\n  return dateRanges;\n}\n\nfunction mapPartIntersection(oldParts, newParts, intersectionFn) {\n  if (oldParts && newParts) {\n    var delta = 0;\n\n    for (var i = 0, len = oldParts.length; i <= len; i++) {\n      var _oldPart = oldParts[i];\n      var _newPart = newParts[i + delta];\n\n      if (_oldPart && _newPart && _oldPart.index === _newPart.index && _oldPart.fragment.sn === _newPart.fragment.sn) {\n        intersectionFn(_oldPart, _newPart);\n      } else {\n        delta--;\n      }\n    }\n  }\n}\nfunction mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {\n  var skippedSegments = newDetails.skippedSegments;\n  var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;\n  var end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;\n  var delta = newDetails.startSN - oldDetails.startSN;\n  var newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n  var oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;\n\n  for (var i = start; i <= end; i++) {\n    var _oldFrag = oldFrags[delta + i];\n    var _newFrag = newFrags[i];\n\n    if (skippedSegments && !_newFrag && i < skippedSegments) {\n      // Fill in skipped segments in delta playlist\n      _newFrag = newDetails.fragments[i] = _oldFrag;\n    }\n\n    if (_oldFrag && _newFrag) {\n      intersectionFn(_oldFrag, _newFrag);\n    }\n  }\n}\nfunction adjustSliding(oldDetails, newDetails) {\n  var delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;\n  var oldFragments = oldDetails.fragments;\n\n  if (delta < 0 || delta >= oldFragments.length) {\n    return;\n  }\n\n  addSliding(newDetails, oldFragments[delta].start);\n}\nfunction addSliding(details, start) {\n  if (start) {\n    var fragments = details.fragments;\n\n    for (var i = details.skippedSegments; i < fragments.length; i++) {\n      fragments[i].start += start;\n    }\n\n    if (details.fragmentHint) {\n      details.fragmentHint.start += start;\n    }\n  }\n}\nfunction computeReloadInterval(newDetails, stats) {\n  var reloadInterval = 1000 * newDetails.levelTargetDuration;\n  var reloadIntervalAfterMiss = reloadInterval / 2;\n  var timeSinceLastModified = newDetails.age;\n  var useLastModified = timeSinceLastModified > 0 && timeSinceLastModified < reloadInterval * 3;\n  var roundTrip = stats.loading.end - stats.loading.start;\n  var estimatedTimeUntilUpdate;\n  var availabilityDelay = newDetails.availabilityDelay; // let estimate = 'average';\n\n  if (newDetails.updated === false) {\n    if (useLastModified) {\n      // estimate = 'miss round trip';\n      // We should have had a hit so try again in the time it takes to get a response,\n      // but no less than 1/3 second.\n      var minRetry = 333 * newDetails.misses;\n      estimatedTimeUntilUpdate = Math.max(Math.min(reloadIntervalAfterMiss, roundTrip * 2), minRetry);\n      newDetails.availabilityDelay = (newDetails.availabilityDelay || 0) + estimatedTimeUntilUpdate;\n    } else {\n      // estimate = 'miss half average';\n      // follow HLS Spec, If the client reloads a Playlist file and finds that it has not\n      // changed then it MUST wait for a period of one-half the target\n      // duration before retrying.\n      estimatedTimeUntilUpdate = reloadIntervalAfterMiss;\n    }\n  } else if (useLastModified) {\n    // estimate = 'next modified date';\n    // Get the closest we've been to timeSinceLastModified on update\n    availabilityDelay = Math.min(availabilityDelay || reloadInterval / 2, timeSinceLastModified);\n    newDetails.availabilityDelay = availabilityDelay;\n    estimatedTimeUntilUpdate = availabilityDelay + reloadInterval - timeSinceLastModified;\n  } else {\n    estimatedTimeUntilUpdate = reloadInterval - roundTrip;\n  } // console.log(`[computeReloadInterval] live reload ${newDetails.updated ? 'REFRESHED' : 'MISSED'}`,\n  //   '\\n  method', estimate,\n  //   '\\n  estimated time until update =>', estimatedTimeUntilUpdate,\n  //   '\\n  average target duration', reloadInterval,\n  //   '\\n  time since modified', timeSinceLastModified,\n  //   '\\n  time round trip', roundTrip,\n  //   '\\n  availability delay', availabilityDelay);\n\n\n  return Math.round(estimatedTimeUntilUpdate);\n}\nfunction getFragmentWithSN(level, sn, fragCurrent) {\n  if (!level || !level.details) {\n    return null;\n  }\n\n  var levelDetails = level.details;\n  var fragment = levelDetails.fragments[sn - levelDetails.startSN];\n\n  if (fragment) {\n    return fragment;\n  }\n\n  fragment = levelDetails.fragmentHint;\n\n  if (fragment && fragment.sn === sn) {\n    return fragment;\n  }\n\n  if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {\n    return fragCurrent;\n  }\n\n  return null;\n}\nfunction getPartWith(level, sn, partIndex) {\n  if (!level || !level.details) {\n    return null;\n  }\n\n  var partList = level.details.partList;\n\n  if (partList) {\n    for (var i = partList.length; i--;) {\n      var part = partList[i];\n\n      if (part.index === partIndex && part.fragment.sn === sn) {\n        return part;\n      }\n    }\n  }\n\n  return null;\n}\n\n/***/ }),\n\n/***/ \"./src/controller/stream-controller.ts\":\n/*!*********************************************!*\\\n  !*** ./src/controller/stream-controller.ts ***!\n  \\*********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_367841__) {\n\n\"use strict\";\n__nested_webpack_require_367841__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_367841__.d(__webpack_exports__, \"default\", function() { return StreamController; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_367841__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_367841__(/*! ./base-stream-controller */ \"./src/controller/base-stream-controller.ts\");\n/* harmony import */ var _is_supported__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_367841__(/*! ../is-supported */ \"./src/is-supported.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_367841__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_367841__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_367841__(/*! ./fragment-tracker */ \"./src/controller/fragment-tracker.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_367841__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_367841__(/*! ../loader/fragment */ \"./src/loader/fragment.ts\");\n/* harmony import */ var _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_367841__(/*! ../demux/transmuxer-interface */ \"./src/demux/transmuxer-interface.ts\");\n/* harmony import */ var _types_transmuxer__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_367841__(/*! ../types/transmuxer */ \"./src/types/transmuxer.ts\");\n/* harmony import */ var _gap_controller__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_367841__(/*! ./gap-controller */ \"./src/controller/gap-controller.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_367841__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_367841__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\n\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar TICK_INTERVAL = 100; // how often to tick in ms\n\nvar StreamController = /*#__PURE__*/function (_BaseStreamController) {\n  _inheritsLoose(StreamController, _BaseStreamController);\n\n  function StreamController(hls, fragmentTracker) {\n    var _this;\n\n    _this = _BaseStreamController.call(this, hls, fragmentTracker, '[stream-controller]') || this;\n    _this.audioCodecSwap = false;\n    _this.gapController = null;\n    _this.level = -1;\n    _this._forceStartLoad = false;\n    _this.altAudio = false;\n    _this.audioOnly = false;\n    _this.fragPlaying = null;\n    _this.onvplaying = null;\n    _this.onvseeked = null;\n    _this.fragLastKbps = 0;\n    _this.stalled = false;\n    _this.couldBacktrack = false;\n    _this.backtrackFragment = null;\n    _this.audioCodecSwitch = false;\n    _this.videoBuffer = null;\n\n    _this._registerListeners();\n\n    return _this;\n  }\n\n  var _proto = StreamController.prototype;\n\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].ERROR, this.onError, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_CREATED, this.onBufferCreated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_BUFFERED, this.onFragBuffered, this);\n  };\n\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].ERROR, this.onError, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_CREATED, this.onBufferCreated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_BUFFERED, this.onFragBuffered, this);\n  };\n\n  _proto.onHandlerDestroying = function onHandlerDestroying() {\n    this._unregisterListeners();\n\n    this.onMediaDetaching();\n  };\n\n  _proto.startLoad = function startLoad(startPosition) {\n    if (this.levels) {\n      var lastCurrentTime = this.lastCurrentTime,\n          hls = this.hls;\n      this.stopLoad();\n      this.setInterval(TICK_INTERVAL);\n      this.level = -1;\n      this.fragLoadError = 0;\n\n      if (!this.startFragRequested) {\n        // determine load level\n        var startLevel = hls.startLevel;\n\n        if (startLevel === -1) {\n          if (hls.config.testBandwidth) {\n            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level\n            startLevel = 0;\n            this.bitrateTest = true;\n          } else {\n            startLevel = hls.nextAutoLevel;\n          }\n        } // set new level to playlist loader : this will trigger start level load\n        // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded\n\n\n        this.level = hls.nextLoadLevel = startLevel;\n        this.loadedmetadata = false;\n      } // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime\n\n\n      if (lastCurrentTime > 0 && startPosition === -1) {\n        this.log(\"Override startPosition with lastCurrentTime @\" + lastCurrentTime.toFixed(3));\n        startPosition = lastCurrentTime;\n      }\n\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n      this.tick();\n    } else {\n      this._forceStartLoad = true;\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].STOPPED;\n    }\n  };\n\n  _proto.stopLoad = function stopLoad() {\n    this._forceStartLoad = false;\n\n    _BaseStreamController.prototype.stopLoad.call(this);\n  };\n\n  _proto.doTick = function doTick() {\n    switch (this.state) {\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE:\n        this.doTickIdle();\n        break;\n\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_LEVEL:\n        {\n          var _levels$level;\n\n          var levels = this.levels,\n              level = this.level;\n          var details = levels === null || levels === void 0 ? void 0 : (_levels$level = levels[level]) === null || _levels$level === void 0 ? void 0 : _levels$level.details;\n\n          if (details && (!details.live || this.levelLastLoaded === this.level)) {\n            if (this.waitForCdnTuneIn(details)) {\n              break;\n            }\n\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n            break;\n          }\n\n          break;\n        }\n\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].FRAG_LOADING_WAITING_RETRY:\n        {\n          var _this$media;\n\n          var now = self.performance.now();\n          var retryDate = this.retryDate; // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n\n          if (!retryDate || now >= retryDate || (_this$media = this.media) !== null && _this$media !== void 0 && _this$media.seeking) {\n            this.log('retryDate reached, switch back to IDLE state');\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n          }\n        }\n        break;\n\n      default:\n        break;\n    } // check buffer\n    // check/update current fragment\n\n\n    this.onTickEnd();\n  };\n\n  _proto.onTickEnd = function onTickEnd() {\n    _BaseStreamController.prototype.onTickEnd.call(this);\n\n    this.checkBuffer();\n    this.checkFragmentChanged();\n  };\n\n  _proto.doTickIdle = function doTickIdle() {\n    var _frag$decryptdata, _frag$decryptdata2;\n\n    var hls = this.hls,\n        levelLastLoaded = this.levelLastLoaded,\n        levels = this.levels,\n        media = this.media;\n    var config = hls.config,\n        level = hls.nextLoadLevel; // if start level not parsed yet OR\n    // if video not attached AND start fragment already requested OR start frag prefetch not enabled\n    // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment\n\n    if (levelLastLoaded === null || !media && (this.startFragRequested || !config.startFragPrefetch)) {\n      return;\n    } // If the \"main\" level is audio-only but we are loading an alternate track in the same group, do not load anything\n\n\n    if (this.altAudio && this.audioOnly) {\n      return;\n    }\n\n    if (!levels || !levels[level]) {\n      return;\n    }\n\n    var levelInfo = levels[level]; // if buffer length is less than maxBufLen try to load a new fragment\n    // set next load level : this will trigger a playlist load if needed\n\n    this.level = hls.nextLoadLevel = level;\n    var levelDetails = levelInfo.details; // if level info not retrieved yet, switch state and wait for level retrieval\n    // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load\n    // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)\n\n    if (!levelDetails || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== level) {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_LEVEL;\n      return;\n    }\n\n    var bufferInfo = this.getMainFwdBufferInfo();\n\n    if (bufferInfo === null) {\n      return;\n    }\n\n    var bufferLen = bufferInfo.len; // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s\n\n    var maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate); // Stay idle if we are still with buffer margins\n\n    if (bufferLen >= maxBufLen) {\n      return;\n    }\n\n    if (this._streamEnded(bufferInfo, levelDetails)) {\n      var data = {};\n\n      if (this.altAudio) {\n        data.type = 'video';\n      }\n\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_EOS, data);\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].ENDED;\n      return;\n    }\n\n    if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {\n      this.backtrackFragment = null;\n    }\n\n    var targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;\n    var frag = this.getNextFragment(targetBufferTime, levelDetails); // Avoid backtracking by loading an earlier segment in streams with segments that do not start with a key frame (flagged by `couldBacktrack`)\n\n    if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== 'initSegment' && this.fragmentTracker.getState(frag) !== _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__[\"FragmentState\"].OK) {\n      var _this$backtrackFragme;\n\n      var backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;\n      var fragIdx = backtrackSn - levelDetails.startSN;\n      var backtrackFrag = levelDetails.fragments[fragIdx - 1];\n\n      if (backtrackFrag && frag.cc === backtrackFrag.cc) {\n        frag = backtrackFrag;\n        this.fragmentTracker.removeFragment(backtrackFrag);\n      }\n    } else if (this.backtrackFragment && bufferInfo.len) {\n      this.backtrackFragment = null;\n    } // Avoid loop loading by using nextLoadPosition set for backtracking\n\n\n    if (frag && this.fragmentTracker.getState(frag) === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__[\"FragmentState\"].OK && this.nextLoadPosition > targetBufferTime) {\n      // Cleanup the fragment tracker before trying to find the next unbuffered fragment\n      var type = this.audioOnly && !this.altAudio ? _loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].AUDIO : _loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].VIDEO;\n      this.afterBufferFlushed(media, type, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN);\n      frag = this.getNextFragment(this.nextLoadPosition, levelDetails);\n    }\n\n    if (!frag) {\n      return;\n    }\n\n    if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {\n      frag = frag.initSegment;\n    } // We want to load the key if we're dealing with an identity key, because we will decrypt\n    // this content using the key we fetch. Other keys will be handled by the DRM CDM via EME.\n\n\n    if (((_frag$decryptdata = frag.decryptdata) === null || _frag$decryptdata === void 0 ? void 0 : _frag$decryptdata.keyFormat) === 'identity' && !((_frag$decryptdata2 = frag.decryptdata) !== null && _frag$decryptdata2 !== void 0 && _frag$decryptdata2.key)) {\n      this.loadKey(frag, levelDetails);\n    } else {\n      this.loadFragment(frag, levelDetails, targetBufferTime);\n    }\n  };\n\n  _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {\n    var _this$media2;\n\n    // Check if fragment is not loaded\n    var fragState = this.fragmentTracker.getState(frag);\n    this.fragCurrent = frag;\n\n    if (fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__[\"FragmentState\"].NOT_LOADED || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__[\"FragmentState\"].PARTIAL) {\n      if (frag.sn === 'initSegment') {\n        this._loadInitSegment(frag);\n      } else if (this.bitrateTest) {\n        frag.bitrateTest = true;\n        this.log(\"Fragment \" + frag.sn + \" of level \" + frag.level + \" is being downloaded to test bitrate and will not be buffered\");\n\n        this._loadBitrateTestFrag(frag);\n      } else {\n        this.startFragRequested = true;\n\n        _BaseStreamController.prototype.loadFragment.call(this, frag, levelDetails, targetBufferTime);\n      }\n    } else if (fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__[\"FragmentState\"].APPENDING) {\n      // Lower the buffer size and try again\n      if (this.reduceMaxBufferLength(frag.duration)) {\n        this.fragmentTracker.removeFragment(frag);\n      }\n    } else if (((_this$media2 = this.media) === null || _this$media2 === void 0 ? void 0 : _this$media2.buffered.length) === 0) {\n      // Stop gap for bad tracker / buffer flush behavior\n      this.fragmentTracker.removeAllFragments();\n    }\n  };\n\n  _proto.getAppendedFrag = function getAppendedFrag(position) {\n    var fragOrPart = this.fragmentTracker.getAppendedFrag(position, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN);\n\n    if (fragOrPart && 'fragment' in fragOrPart) {\n      return fragOrPart.fragment;\n    }\n\n    return fragOrPart;\n  };\n\n  _proto.getBufferedFrag = function getBufferedFrag(position) {\n    return this.fragmentTracker.getBufferedFrag(position, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN);\n  };\n\n  _proto.followingBufferedFrag = function followingBufferedFrag(frag) {\n    if (frag) {\n      // try to get range of next fragment (500ms after this range)\n      return this.getBufferedFrag(frag.end + 0.5);\n    }\n\n    return null;\n  }\n  /*\n    on immediate level switch :\n     - pause playback if playing\n     - cancel any pending load request\n     - and trigger a buffer flush\n  */\n  ;\n\n  _proto.immediateLevelSwitch = function immediateLevelSwitch() {\n    this.abortCurrentFrag();\n    this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n  }\n  /**\n   * try to switch ASAP without breaking video playback:\n   * in order to ensure smooth but quick level switching,\n   * we need to find the next flushable buffer range\n   * we should take into account new segment fetch time\n   */\n  ;\n\n  _proto.nextLevelSwitch = function nextLevelSwitch() {\n    var levels = this.levels,\n        media = this.media; // ensure that media is defined and that metadata are available (to retrieve currentTime)\n\n    if (media !== null && media !== void 0 && media.readyState) {\n      var fetchdelay;\n      var fragPlayingCurrent = this.getAppendedFrag(media.currentTime);\n\n      if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {\n        // flush buffer preceding current fragment (flush until current fragment start offset)\n        // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...\n        this.flushMainBuffer(0, fragPlayingCurrent.start - 1);\n      }\n\n      if (!media.paused && levels) {\n        // add a safety delay of 1s\n        var nextLevelId = this.hls.nextLoadLevel;\n        var nextLevel = levels[nextLevelId];\n        var fragLastKbps = this.fragLastKbps;\n\n        if (fragLastKbps && this.fragCurrent) {\n          fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;\n        } else {\n          fetchdelay = 0;\n        }\n      } else {\n        fetchdelay = 0;\n      } // this.log('fetchdelay:'+fetchdelay);\n      // find buffer range that will be reached once new fragment will be fetched\n\n\n      var bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);\n\n      if (bufferedFrag) {\n        // we can flush buffer range following this one without stalling playback\n        var nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);\n\n        if (nextBufferedFrag) {\n          // if we are here, we can also cancel any loading/demuxing in progress, as they are useless\n          this.abortCurrentFrag(); // start flush position is in next buffered frag. Leave some padding for non-independent segments and smoother playback.\n\n          var maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;\n          var fragDuration = nextBufferedFrag.duration;\n          var startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * 0.5), fragDuration * 0.75));\n          this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);\n        }\n      }\n    }\n  };\n\n  _proto.abortCurrentFrag = function abortCurrentFrag() {\n    var fragCurrent = this.fragCurrent;\n    this.fragCurrent = null;\n    this.backtrackFragment = null;\n\n    if (fragCurrent !== null && fragCurrent !== void 0 && fragCurrent.loader) {\n      fragCurrent.loader.abort();\n    }\n\n    switch (this.state) {\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].KEY_LOADING:\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].FRAG_LOADING:\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].FRAG_LOADING_WAITING_RETRY:\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSING:\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSED:\n        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n        break;\n    }\n\n    this.nextLoadPosition = this.getLoadPosition();\n  };\n\n  _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset) {\n    _BaseStreamController.prototype.flushMainBuffer.call(this, startOffset, endOffset, this.altAudio ? 'video' : null);\n  };\n\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    _BaseStreamController.prototype.onMediaAttached.call(this, event, data);\n\n    var media = data.media;\n    this.onvplaying = this.onMediaPlaying.bind(this);\n    this.onvseeked = this.onMediaSeeked.bind(this);\n    media.addEventListener('playing', this.onvplaying);\n    media.addEventListener('seeked', this.onvseeked);\n    this.gapController = new _gap_controller__WEBPACK_IMPORTED_MODULE_10__[\"default\"](this.config, media, this.fragmentTracker, this.hls);\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    var media = this.media;\n\n    if (media) {\n      media.removeEventListener('playing', this.onvplaying);\n      media.removeEventListener('seeked', this.onvseeked);\n      this.onvplaying = this.onvseeked = null;\n      this.videoBuffer = null;\n    }\n\n    this.fragPlaying = null;\n\n    if (this.gapController) {\n      this.gapController.destroy();\n      this.gapController = null;\n    }\n\n    _BaseStreamController.prototype.onMediaDetaching.call(this);\n  };\n\n  _proto.onMediaPlaying = function onMediaPlaying() {\n    // tick to speed up FRAG_CHANGED triggering\n    this.tick();\n  };\n\n  _proto.onMediaSeeked = function onMediaSeeked() {\n    var media = this.media;\n    var currentTime = media ? media.currentTime : null;\n\n    if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(currentTime)) {\n      this.log(\"Media seeked to \" + currentTime.toFixed(3));\n    } // tick to speed up FRAG_CHANGED triggering\n\n\n    this.tick();\n  };\n\n  _proto.onManifestLoading = function onManifestLoading() {\n    // reset buffer on manifest loading\n    this.log('Trigger BUFFER_RESET');\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_RESET, undefined);\n    this.fragmentTracker.removeAllFragments();\n    this.couldBacktrack = this.stalled = false;\n    this.startPosition = this.lastCurrentTime = 0;\n    this.fragPlaying = null;\n    this.backtrackFragment = null;\n  };\n\n  _proto.onManifestParsed = function onManifestParsed(event, data) {\n    var aac = false;\n    var heaac = false;\n    var codec;\n    data.levels.forEach(function (level) {\n      // detect if we have different kind of audio codecs used amongst playlists\n      codec = level.audioCodec;\n\n      if (codec) {\n        if (codec.indexOf('mp4a.40.2') !== -1) {\n          aac = true;\n        }\n\n        if (codec.indexOf('mp4a.40.5') !== -1) {\n          heaac = true;\n        }\n      }\n    });\n    this.audioCodecSwitch = aac && heaac && !Object(_is_supported__WEBPACK_IMPORTED_MODULE_2__[\"changeTypeSupported\"])();\n\n    if (this.audioCodecSwitch) {\n      this.log('Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');\n    }\n\n    this.levels = data.levels;\n    this.startFragRequested = false;\n  };\n\n  _proto.onLevelLoading = function onLevelLoading(event, data) {\n    var levels = this.levels;\n\n    if (!levels || this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE) {\n      return;\n    }\n\n    var level = levels[data.level];\n\n    if (!level.details || level.details.live && this.levelLastLoaded !== data.level || this.waitForCdnTuneIn(level.details)) {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_LEVEL;\n    }\n  };\n\n  _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n    var _curLevel$details;\n\n    var levels = this.levels;\n    var newLevelId = data.level;\n    var newDetails = data.details;\n    var duration = newDetails.totalduration;\n\n    if (!levels) {\n      this.warn(\"Levels were reset while loading level \" + newLevelId);\n      return;\n    }\n\n    this.log(\"Level \" + newLevelId + \" loaded [\" + newDetails.startSN + \",\" + newDetails.endSN + \"], cc [\" + newDetails.startCC + \", \" + newDetails.endCC + \"] duration:\" + duration);\n    var fragCurrent = this.fragCurrent;\n\n    if (fragCurrent && (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].FRAG_LOADING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].FRAG_LOADING_WAITING_RETRY)) {\n      if (fragCurrent.level !== data.level && fragCurrent.loader) {\n        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n        this.backtrackFragment = null;\n        fragCurrent.loader.abort();\n      }\n    }\n\n    var curLevel = levels[newLevelId];\n    var sliding = 0;\n\n    if (newDetails.live || (_curLevel$details = curLevel.details) !== null && _curLevel$details !== void 0 && _curLevel$details.live) {\n      if (!newDetails.fragments[0]) {\n        newDetails.deltaUpdateFailed = true;\n      }\n\n      if (newDetails.deltaUpdateFailed) {\n        return;\n      }\n\n      sliding = this.alignPlaylists(newDetails, curLevel.details);\n    } // override level info\n\n\n    curLevel.details = newDetails;\n    this.levelLastLoaded = newLevelId;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].LEVEL_UPDATED, {\n      details: newDetails,\n      level: newLevelId\n    }); // only switch back to IDLE state if we were waiting for level to start downloading a new fragment\n\n    if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_LEVEL) {\n      if (this.waitForCdnTuneIn(newDetails)) {\n        // Wait for Low-Latency CDN Tune-in\n        return;\n      }\n\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n    }\n\n    if (!this.startFragRequested) {\n      this.setStartPosition(newDetails, sliding);\n    } else if (newDetails.live) {\n      this.synchronizeToLiveEdge(newDetails);\n    } // trigger handler right now\n\n\n    this.tick();\n  };\n\n  _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {\n    var _frag$initSegment;\n\n    var frag = data.frag,\n        part = data.part,\n        payload = data.payload;\n    var levels = this.levels;\n\n    if (!levels) {\n      this.warn(\"Levels were reset while fragment load was in progress. Fragment \" + frag.sn + \" of level \" + frag.level + \" will not be buffered\");\n      return;\n    }\n\n    var currentLevel = levels[frag.level];\n    var details = currentLevel.details;\n\n    if (!details) {\n      this.warn(\"Dropping fragment \" + frag.sn + \" of level \" + frag.level + \" after level details were reset\");\n      return;\n    }\n\n    var videoCodec = currentLevel.videoCodec; // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n\n    var accurateTimeOffset = details.PTSKnown || !details.live;\n    var initSegmentData = (_frag$initSegment = frag.initSegment) === null || _frag$initSegment === void 0 ? void 0 : _frag$initSegment.data;\n\n    var audioCodec = this._getAudioCodec(currentLevel); // transmux the MPEG-TS data to ISO-BMFF segments\n    // this.log(`Transmuxing ${frag.sn} of [${details.startSN} ,${details.endSN}],level ${frag.level}, cc ${frag.cc}`);\n\n\n    var transmuxer = this.transmuxer = this.transmuxer || new _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_8__[\"default\"](this.hls, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n    var partIndex = part ? part.index : -1;\n    var partial = partIndex !== -1;\n    var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_9__[\"ChunkMetadata\"](frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n    var initPTS = this.initPTS[frag.cc];\n    transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n  };\n\n  _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {\n    // if any URL found on new audio track, it is an alternate audio track\n    var fromAltAudio = this.altAudio;\n    var altAudio = !!data.url;\n    var trackId = data.id; // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered\n    // don't do anything if we switch to alt audio: audio stream controller is handling it.\n    // we will just have to change buffer scheduling on audioTrackSwitched\n\n    if (!altAudio) {\n      if (this.mediaBuffer !== this.media) {\n        this.log('Switching on main audio, use media.buffered to schedule main fragment loading');\n        this.mediaBuffer = this.media;\n        var fragCurrent = this.fragCurrent; // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch\n\n        if (fragCurrent !== null && fragCurrent !== void 0 && fragCurrent.loader) {\n          this.log('Switching to main audio track, cancel main fragment load');\n          fragCurrent.loader.abort();\n        } // destroy transmuxer to force init segment generation (following audio switch)\n\n\n        this.resetTransmuxer(); // switch to IDLE state to load new fragment\n\n        this.resetLoadingState();\n      } else if (this.audioOnly) {\n        // Reset audio transmuxer so when switching back to main audio we're not still appending where we left off\n        this.resetTransmuxer();\n      }\n\n      var hls = this.hls; // If switching from alt to main audio, flush all audio and trigger track switched\n\n      if (fromAltAudio) {\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_FLUSHING, {\n          startOffset: 0,\n          endOffset: Number.POSITIVE_INFINITY,\n          type: 'audio'\n        });\n      }\n\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].AUDIO_TRACK_SWITCHED, {\n        id: trackId\n      });\n    }\n  };\n\n  _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {\n    var trackId = data.id;\n    var altAudio = !!this.hls.audioTracks[trackId].url;\n\n    if (altAudio) {\n      var videoBuffer = this.videoBuffer; // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered\n\n      if (videoBuffer && this.mediaBuffer !== videoBuffer) {\n        this.log('Switching on alternate audio, use video.buffered to schedule main fragment loading');\n        this.mediaBuffer = videoBuffer;\n      }\n    }\n\n    this.altAudio = altAudio;\n    this.tick();\n  };\n\n  _proto.onBufferCreated = function onBufferCreated(event, data) {\n    var tracks = data.tracks;\n    var mediaTrack;\n    var name;\n    var alternate = false;\n\n    for (var type in tracks) {\n      var track = tracks[type];\n\n      if (track.id === 'main') {\n        name = type;\n        mediaTrack = track; // keep video source buffer reference\n\n        if (type === 'video') {\n          var videoTrack = tracks[type];\n\n          if (videoTrack) {\n            this.videoBuffer = videoTrack.buffer;\n          }\n        }\n      } else {\n        alternate = true;\n      }\n    }\n\n    if (alternate && mediaTrack) {\n      this.log(\"Alternate track found, use \" + name + \".buffered to schedule main fragment loading\");\n      this.mediaBuffer = mediaTrack.buffer;\n    } else {\n      this.mediaBuffer = this.media;\n    }\n  };\n\n  _proto.onFragBuffered = function onFragBuffered(event, data) {\n    var frag = data.frag,\n        part = data.part;\n\n    if (frag && frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN) {\n      return;\n    }\n\n    if (this.fragContextChanged(frag)) {\n      // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n      // Avoid setting state back to IDLE, since that will interfere with a level switch\n      this.warn(\"Fragment \" + frag.sn + (part ? ' p: ' + part.index : '') + \" of level \" + frag.level + \" finished buffering, but was aborted. state: \" + this.state);\n\n      if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSED) {\n        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n      }\n\n      return;\n    }\n\n    var stats = part ? part.stats : frag.stats;\n    this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));\n\n    if (frag.sn !== 'initSegment') {\n      this.fragPrevious = frag;\n    }\n\n    this.fragBufferedComplete(frag, part);\n  };\n\n  _proto.onError = function onError(event, data) {\n    switch (data.details) {\n      case _errors__WEBPACK_IMPORTED_MODULE_11__[\"ErrorDetails\"].FRAG_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_11__[\"ErrorDetails\"].FRAG_LOAD_TIMEOUT:\n      case _errors__WEBPACK_IMPORTED_MODULE_11__[\"ErrorDetails\"].KEY_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_11__[\"ErrorDetails\"].KEY_LOAD_TIMEOUT:\n        this.onFragmentOrKeyLoadError(_types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN, data);\n        break;\n\n      case _errors__WEBPACK_IMPORTED_MODULE_11__[\"ErrorDetails\"].LEVEL_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_11__[\"ErrorDetails\"].LEVEL_LOAD_TIMEOUT:\n        if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].ERROR) {\n          if (data.fatal) {\n            // if fatal error, stop processing\n            this.warn(\"\" + data.details);\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].ERROR;\n          } else {\n            // in case of non fatal error while loading level, if level controller is not retrying to load level , switch back to IDLE\n            if (!data.levelRetry && this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_LEVEL) {\n              this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n            }\n          }\n        }\n\n        break;\n\n      case _errors__WEBPACK_IMPORTED_MODULE_11__[\"ErrorDetails\"].BUFFER_FULL_ERROR:\n        // if in appending state\n        if (data.parent === 'main' && (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSED)) {\n          var flushBuffer = true;\n          var bufferedInfo = this.getFwdBufferInfo(this.media, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN); // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n          // reduce max buf len if current position is buffered\n\n          if (bufferedInfo && bufferedInfo.len > 0.5) {\n            flushBuffer = !this.reduceMaxBufferLength(bufferedInfo.len);\n          }\n\n          if (flushBuffer) {\n            // current position is not buffered, but browser is still complaining about buffer full error\n            // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n            // in that case flush the whole buffer to recover\n            this.warn('buffer full error also media.currentTime is not buffered, flush main'); // flush main buffer\n\n            this.immediateLevelSwitch();\n          }\n\n          this.resetLoadingState();\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  } // Checks the health of the buffer and attempts to resolve playback stalls.\n  ;\n\n  _proto.checkBuffer = function checkBuffer() {\n    var media = this.media,\n        gapController = this.gapController;\n\n    if (!media || !gapController || !media.readyState) {\n      // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n      return;\n    } // Check combined buffer\n\n\n    var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__[\"BufferHelper\"].getBuffered(media);\n\n    if (!this.loadedmetadata && buffered.length) {\n      this.loadedmetadata = true;\n      this.seekToStartPos();\n    } else {\n      // Resolve gaps using the main buffer, whose ranges are the intersections of the A/V sourcebuffers\n      var activeFrag = this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE ? this.fragCurrent : null;\n      gapController.poll(this.lastCurrentTime, activeFrag);\n    }\n\n    this.lastCurrentTime = media.currentTime;\n  };\n\n  _proto.onFragLoadEmergencyAborted = function onFragLoadEmergencyAborted() {\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE; // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n    // in that case, reset startFragRequested flag\n\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n      this.nextLoadPosition = this.startPosition;\n    }\n\n    this.tickImmediate();\n  };\n\n  _proto.onBufferFlushed = function onBufferFlushed(event, _ref) {\n    var type = _ref.type;\n\n    if (type !== _loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].AUDIO || this.audioOnly && !this.altAudio) {\n      var media = (type === _loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n      this.afterBufferFlushed(media, type, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN);\n    }\n  };\n\n  _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {\n    this.levels = data.levels;\n  };\n\n  _proto.swapAudioCodec = function swapAudioCodec() {\n    this.audioCodecSwap = !this.audioCodecSwap;\n  }\n  /**\n   * Seeks to the set startPosition if not equal to the mediaElement's current time.\n   * @private\n   */\n  ;\n\n  _proto.seekToStartPos = function seekToStartPos() {\n    var media = this.media;\n    var currentTime = media.currentTime;\n    var startPosition = this.startPosition; // only adjust currentTime if different from startPosition or if startPosition not buffered\n    // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered\n\n    if (startPosition >= 0 && currentTime < startPosition) {\n      if (media.seeking) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_12__[\"logger\"].log(\"could not seek to \" + startPosition + \", already seeking at \" + currentTime);\n        return;\n      }\n\n      var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__[\"BufferHelper\"].getBuffered(media);\n      var bufferStart = buffered.length ? buffered.start(0) : 0;\n      var delta = bufferStart - startPosition;\n\n      if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_12__[\"logger\"].log(\"adjusting start position by \" + delta + \" to match buffer start\");\n        startPosition += delta;\n        this.startPosition = startPosition;\n      }\n\n      this.log(\"seek to target start position \" + startPosition + \" from current time \" + currentTime);\n      media.currentTime = startPosition;\n    }\n  };\n\n  _proto._getAudioCodec = function _getAudioCodec(currentLevel) {\n    var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;\n\n    if (this.audioCodecSwap && audioCodec) {\n      this.log('Swapping audio codec');\n\n      if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n        audioCodec = 'mp4a.40.2';\n      } else {\n        audioCodec = 'mp4a.40.5';\n      }\n    }\n\n    return audioCodec;\n  };\n\n  _proto._loadBitrateTestFrag = function _loadBitrateTestFrag(frag) {\n    var _this2 = this;\n\n    this._doFragLoad(frag).then(function (data) {\n      var hls = _this2.hls;\n\n      if (!data || hls.nextLoadLevel || _this2.fragContextChanged(frag)) {\n        return;\n      }\n\n      _this2.fragLoadError = 0;\n      _this2.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n      _this2.startFragRequested = false;\n      _this2.bitrateTest = false;\n      var stats = frag.stats; // Bitrate tests fragments are neither parsed nor buffered\n\n      stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_LOADED, data);\n    });\n  };\n\n  _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {\n    var _id3$samples;\n\n    var id = 'main';\n    var hls = this.hls;\n    var remuxResult = transmuxResult.remuxResult,\n        chunkMeta = transmuxResult.chunkMeta;\n    var context = this.getCurrentContext(chunkMeta);\n\n    if (!context) {\n      this.warn(\"The loading context changed while buffering fragment \" + chunkMeta.sn + \" of level \" + chunkMeta.level + \". This chunk will not be buffered.\");\n      this.resetLiveStartWhenNotLoaded(chunkMeta.level);\n      return;\n    }\n\n    var frag = context.frag,\n        part = context.part,\n        level = context.level;\n    var video = remuxResult.video,\n        text = remuxResult.text,\n        id3 = remuxResult.id3,\n        initSegment = remuxResult.initSegment;\n    var details = level.details; // The audio-stream-controller handles audio buffering if Hls.js is playing an alternate audio track\n\n    var audio = this.altAudio ? undefined : remuxResult.audio; // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n\n    if (this.fragContextChanged(frag)) {\n      return;\n    }\n\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSING;\n\n    if (initSegment) {\n      if (initSegment.tracks) {\n        this._bufferInitSegment(level, initSegment.tracks, frag, chunkMeta);\n\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_PARSING_INIT_SEGMENT, {\n          frag: frag,\n          id: id,\n          tracks: initSegment.tracks\n        });\n      } // This would be nice if Number.isFinite acted as a typeguard, but it doesn't. See: https://github.com/Microsoft/TypeScript/issues/10038\n\n\n      var initPTS = initSegment.initPTS;\n      var timescale = initSegment.timescale;\n\n      if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(initPTS)) {\n        this.initPTS[frag.cc] = initPTS;\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].INIT_PTS_FOUND, {\n          frag: frag,\n          id: id,\n          initPTS: initPTS,\n          timescale: timescale\n        });\n      }\n    } // Avoid buffering if backtracking this fragment\n\n\n    if (video && remuxResult.independent !== false) {\n      if (details) {\n        var startPTS = video.startPTS,\n            endPTS = video.endPTS,\n            startDTS = video.startDTS,\n            endDTS = video.endDTS;\n\n        if (part) {\n          part.elementaryStreams[video.type] = {\n            startPTS: startPTS,\n            endPTS: endPTS,\n            startDTS: startDTS,\n            endDTS: endDTS\n          };\n        } else {\n          if (video.firstKeyFrame && video.independent) {\n            this.couldBacktrack = true;\n          }\n\n          if (video.dropped && video.independent) {\n            // Backtrack if dropped frames create a gap after currentTime\n            var bufferInfo = this.getMainFwdBufferInfo();\n            var targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;\n            var startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;\n\n            if (targetBufferTime < startTime - this.config.maxBufferHole) {\n              this.backtrack(frag);\n              return;\n            } // Set video stream start to fragment start so that truncated samples do not distort the timeline, and mark it partial\n\n\n            frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);\n          }\n        }\n\n        frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);\n\n        if (this.backtrackFragment) {\n          this.backtrackFragment = frag;\n        }\n\n        this.bufferFragmentData(video, frag, part, chunkMeta);\n      }\n    } else if (remuxResult.independent === false) {\n      this.backtrack(frag);\n      return;\n    }\n\n    if (audio) {\n      var _startPTS = audio.startPTS,\n          _endPTS = audio.endPTS,\n          _startDTS = audio.startDTS,\n          _endDTS = audio.endDTS;\n\n      if (part) {\n        part.elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].AUDIO] = {\n          startPTS: _startPTS,\n          endPTS: _endPTS,\n          startDTS: _startDTS,\n          endDTS: _endDTS\n        };\n      }\n\n      frag.setElementaryStreamInfo(_loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].AUDIO, _startPTS, _endPTS, _startDTS, _endDTS);\n      this.bufferFragmentData(audio, frag, part, chunkMeta);\n    }\n\n    if (details && id3 !== null && id3 !== void 0 && (_id3$samples = id3.samples) !== null && _id3$samples !== void 0 && _id3$samples.length) {\n      var emittedID3 = {\n        id: id,\n        frag: frag,\n        details: details,\n        samples: id3.samples\n      };\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_PARSING_METADATA, emittedID3);\n    }\n\n    if (details && text) {\n      var emittedText = {\n        id: id,\n        frag: frag,\n        details: details,\n        samples: text.samples\n      };\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_PARSING_USERDATA, emittedText);\n    }\n  };\n\n  _proto._bufferInitSegment = function _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n    var _this3 = this;\n\n    if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSING) {\n      return;\n    }\n\n    this.audioOnly = !!tracks.audio && !tracks.video; // if audio track is expected to come from audio stream controller, discard any coming from main\n\n    if (this.altAudio && !this.audioOnly) {\n      delete tracks.audio;\n    } // include levelCodec in audio and video tracks\n\n\n    var audio = tracks.audio,\n        video = tracks.video,\n        audiovideo = tracks.audiovideo;\n\n    if (audio) {\n      var audioCodec = currentLevel.audioCodec;\n      var ua = navigator.userAgent.toLowerCase();\n\n      if (this.audioCodecSwitch) {\n        if (audioCodec) {\n          if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n            audioCodec = 'mp4a.40.2';\n          } else {\n            audioCodec = 'mp4a.40.5';\n          }\n        } // In the case that AAC and HE-AAC audio codecs are signalled in manifest,\n        // force HE-AAC, as it seems that most browsers prefers it.\n        // don't force HE-AAC if mono stream, or in Firefox\n\n\n        if (audio.metadata.channelCount !== 1 && ua.indexOf('firefox') === -1) {\n          audioCodec = 'mp4a.40.5';\n        }\n      } // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise\n\n\n      if (ua.indexOf('android') !== -1 && audio.container !== 'audio/mpeg') {\n        // Exclude mpeg audio\n        audioCodec = 'mp4a.40.2';\n        this.log(\"Android: force audio codec to \" + audioCodec);\n      }\n\n      if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {\n        this.log(\"Swapping manifest audio codec \\\"\" + currentLevel.audioCodec + \"\\\" for \\\"\" + audioCodec + \"\\\"\");\n      }\n\n      audio.levelCodec = audioCodec;\n      audio.id = 'main';\n      this.log(\"Init audio buffer, container:\" + audio.container + \", codecs[selected/level/parsed]=[\" + (audioCodec || '') + \"/\" + (currentLevel.audioCodec || '') + \"/\" + audio.codec + \"]\");\n    }\n\n    if (video) {\n      video.levelCodec = currentLevel.videoCodec;\n      video.id = 'main';\n      this.log(\"Init video buffer, container:\" + video.container + \", codecs[level/parsed]=[\" + (currentLevel.videoCodec || '') + \"/\" + video.codec + \"]\");\n    }\n\n    if (audiovideo) {\n      this.log(\"Init audiovideo buffer, container:\" + audiovideo.container + \", codecs[level/parsed]=[\" + (currentLevel.attrs.CODECS || '') + \"/\" + audiovideo.codec + \"]\");\n    }\n\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_CODECS, tracks); // loop through tracks that are going to be provided to bufferController\n\n    Object.keys(tracks).forEach(function (trackName) {\n      var track = tracks[trackName];\n      var initSegment = track.initSegment;\n\n      if (initSegment !== null && initSegment !== void 0 && initSegment.byteLength) {\n        _this3.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_APPENDING, {\n          type: trackName,\n          data: initSegment,\n          frag: frag,\n          part: null,\n          chunkMeta: chunkMeta,\n          parent: frag.type\n        });\n      }\n    }); // trigger handler right now\n\n    this.tick();\n  };\n\n  _proto.getMainFwdBufferInfo = function getMainFwdBufferInfo() {\n    return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN);\n  };\n\n  _proto.backtrack = function backtrack(frag) {\n    this.couldBacktrack = true; // Causes findFragments to backtrack through fragments to find the keyframe\n\n    this.backtrackFragment = frag;\n    this.resetTransmuxer();\n    this.flushBufferGap(frag);\n    this.fragmentTracker.removeFragment(frag);\n    this.fragPrevious = null;\n    this.nextLoadPosition = frag.start;\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n  };\n\n  _proto.checkFragmentChanged = function checkFragmentChanged() {\n    var video = this.media;\n    var fragPlayingCurrent = null;\n\n    if (video && video.readyState > 1 && video.seeking === false) {\n      var currentTime = video.currentTime;\n      /* if video element is in seeked state, currentTime can only increase.\n        (assuming that playback rate is positive ...)\n        As sometimes currentTime jumps back to zero after a\n        media decode error, check this, to avoid seeking back to\n        wrong position after a media decode error\n      */\n\n      if (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__[\"BufferHelper\"].isBuffered(video, currentTime)) {\n        fragPlayingCurrent = this.getAppendedFrag(currentTime);\n      } else if (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__[\"BufferHelper\"].isBuffered(video, currentTime + 0.1)) {\n        /* ensure that FRAG_CHANGED event is triggered at startup,\n          when first video frame is displayed and playback is paused.\n          add a tolerance of 100ms, in case current position is not buffered,\n          check if current pos+100ms is buffered and use that buffer range\n          for FRAG_CHANGED event reporting */\n        fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);\n      }\n\n      if (fragPlayingCurrent) {\n        this.backtrackFragment = null;\n        var fragPlaying = this.fragPlaying;\n        var fragCurrentLevel = fragPlayingCurrent.level;\n\n        if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel || fragPlayingCurrent.urlId !== fragPlaying.urlId) {\n          this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_CHANGED, {\n            frag: fragPlayingCurrent\n          });\n\n          if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {\n            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].LEVEL_SWITCHED, {\n              level: fragCurrentLevel\n            });\n          }\n\n          this.fragPlaying = fragPlayingCurrent;\n        }\n      }\n    }\n  };\n\n  _createClass(StreamController, [{\n    key: \"nextLevel\",\n    get: function get() {\n      var frag = this.nextBufferedFrag;\n\n      if (frag) {\n        return frag.level;\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"currentFrag\",\n    get: function get() {\n      var media = this.media;\n\n      if (media) {\n        return this.fragPlaying || this.getAppendedFrag(media.currentTime);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"currentProgramDateTime\",\n    get: function get() {\n      var media = this.media;\n\n      if (media) {\n        var currentTime = media.currentTime;\n        var frag = this.currentFrag;\n\n        if (frag && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(currentTime) && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(frag.programDateTime)) {\n          var epocMs = frag.programDateTime + (currentTime - frag.start) * 1000;\n          return new Date(epocMs);\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"currentLevel\",\n    get: function get() {\n      var frag = this.currentFrag;\n\n      if (frag) {\n        return frag.level;\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"nextBufferedFrag\",\n    get: function get() {\n      var frag = this.currentFrag;\n\n      if (frag) {\n        return this.followingBufferedFrag(frag);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"forceStartLoad\",\n    get: function get() {\n      return this._forceStartLoad;\n    }\n  }]);\n\n  return StreamController;\n}(_base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/subtitle-stream-controller.ts\":\n/*!******************************************************!*\\\n  !*** ./src/controller/subtitle-stream-controller.ts ***!\n  \\******************************************************/\n/*! exports provided: SubtitleStreamController */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_423218__) {\n\n\"use strict\";\n__nested_webpack_require_423218__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_423218__.d(__webpack_exports__, \"SubtitleStreamController\", function() { return SubtitleStreamController; });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_423218__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_423218__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _fragment_finders__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_423218__(/*! ./fragment-finders */ \"./src/controller/fragment-finders.ts\");\n/* harmony import */ var _utils_discontinuities__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_423218__(/*! ../utils/discontinuities */ \"./src/utils/discontinuities.ts\");\n/* harmony import */ var _level_helper__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_423218__(/*! ./level-helper */ \"./src/controller/level-helper.ts\");\n/* harmony import */ var _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_423218__(/*! ./fragment-tracker */ \"./src/controller/fragment-tracker.ts\");\n/* harmony import */ var _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_423218__(/*! ./base-stream-controller */ \"./src/controller/base-stream-controller.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_423218__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _types_level__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_423218__(/*! ../types/level */ \"./src/types/level.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\n\nvar TICK_INTERVAL = 500; // how often to tick in ms\n\nvar SubtitleStreamController = /*#__PURE__*/function (_BaseStreamController) {\n  _inheritsLoose(SubtitleStreamController, _BaseStreamController);\n\n  function SubtitleStreamController(hls, fragmentTracker) {\n    var _this;\n\n    _this = _BaseStreamController.call(this, hls, fragmentTracker, '[subtitle-stream-controller]') || this;\n    _this.levels = [];\n    _this.currentTrackId = -1;\n    _this.tracksBuffered = [];\n    _this.mainDetails = null;\n\n    _this._registerListeners();\n\n    return _this;\n  }\n\n  var _proto = SubtitleStreamController.prototype;\n\n  _proto.onHandlerDestroying = function onHandlerDestroying() {\n    this._unregisterListeners();\n\n    this.mainDetails = null;\n  };\n\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, this.onError, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_FLUSHING, this.onBufferFlushing, this);\n  };\n\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, this.onError, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_FLUSHING, this.onBufferFlushing, this);\n  };\n\n  _proto.startLoad = function startLoad() {\n    this.stopLoad();\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__[\"State\"].IDLE;\n    this.setInterval(TICK_INTERVAL);\n    this.tick();\n  };\n\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.mainDetails = null;\n    this.fragmentTracker.removeAllFragments();\n  };\n\n  _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n    this.mainDetails = data.details;\n  };\n\n  _proto.onSubtitleFragProcessed = function onSubtitleFragProcessed(event, data) {\n    var frag = data.frag,\n        success = data.success;\n    this.fragPrevious = frag;\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__[\"State\"].IDLE;\n\n    if (!success) {\n      return;\n    }\n\n    var buffered = this.tracksBuffered[this.currentTrackId];\n\n    if (!buffered) {\n      return;\n    } // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo\n    // so we can re-use the logic used to detect how much has been buffered\n\n\n    var timeRange;\n    var fragStart = frag.start;\n\n    for (var i = 0; i < buffered.length; i++) {\n      if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {\n        timeRange = buffered[i];\n        break;\n      }\n    }\n\n    var fragEnd = frag.start + frag.duration;\n\n    if (timeRange) {\n      timeRange.end = fragEnd;\n    } else {\n      timeRange = {\n        start: fragStart,\n        end: fragEnd\n      };\n      buffered.push(timeRange);\n    }\n\n    this.fragmentTracker.fragBuffered(frag);\n  };\n\n  _proto.onBufferFlushing = function onBufferFlushing(event, data) {\n    var startOffset = data.startOffset,\n        endOffset = data.endOffset;\n\n    if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {\n      var currentTrackId = this.currentTrackId,\n          levels = this.levels;\n\n      if (!levels.length || !levels[currentTrackId] || !levels[currentTrackId].details) {\n        return;\n      }\n\n      var trackDetails = levels[currentTrackId].details;\n      var targetDuration = trackDetails.targetduration;\n      var endOffsetSubtitles = endOffset - targetDuration;\n\n      if (endOffsetSubtitles <= 0) {\n        return;\n      }\n\n      data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);\n      this.tracksBuffered.forEach(function (buffered) {\n        for (var i = 0; i < buffered.length;) {\n          if (buffered[i].end <= endOffsetSubtitles) {\n            buffered.shift();\n            continue;\n          } else if (buffered[i].start < endOffsetSubtitles) {\n            buffered[i].start = endOffsetSubtitles;\n          } else {\n            break;\n          }\n\n          i++;\n        }\n      });\n      this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, _types_loader__WEBPACK_IMPORTED_MODULE_7__[\"PlaylistLevelType\"].SUBTITLE);\n    }\n  } // If something goes wrong, proceed to next frag, if we were processing one.\n  ;\n\n  _proto.onError = function onError(event, data) {\n    var _this$fragCurrent;\n\n    var frag = data.frag; // don't handle error not related to subtitle fragment\n\n    if (!frag || frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_7__[\"PlaylistLevelType\"].SUBTITLE) {\n      return;\n    }\n\n    if ((_this$fragCurrent = this.fragCurrent) !== null && _this$fragCurrent !== void 0 && _this$fragCurrent.loader) {\n      this.fragCurrent.loader.abort();\n    }\n\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__[\"State\"].IDLE;\n  } // Got all new subtitle levels.\n  ;\n\n  _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, _ref) {\n    var _this2 = this;\n\n    var subtitleTracks = _ref.subtitleTracks;\n    this.tracksBuffered = [];\n    this.levels = subtitleTracks.map(function (mediaPlaylist) {\n      return new _types_level__WEBPACK_IMPORTED_MODULE_8__[\"Level\"](mediaPlaylist);\n    });\n    this.fragmentTracker.removeAllFragments();\n    this.fragPrevious = null;\n    this.levels.forEach(function (level) {\n      _this2.tracksBuffered[level.id] = [];\n    });\n    this.mediaBuffer = null;\n  };\n\n  _proto.onSubtitleTrackSwitch = function onSubtitleTrackSwitch(event, data) {\n    this.currentTrackId = data.id;\n\n    if (!this.levels.length || this.currentTrackId === -1) {\n      this.clearInterval();\n      return;\n    } // Check if track has the necessary details to load fragments\n\n\n    var currentTrack = this.levels[this.currentTrackId];\n\n    if (currentTrack !== null && currentTrack !== void 0 && currentTrack.details) {\n      this.mediaBuffer = this.mediaBufferTimeRanges;\n    } else {\n      this.mediaBuffer = null;\n    }\n\n    if (currentTrack) {\n      this.setInterval(TICK_INTERVAL);\n    }\n  } // Got a new set of subtitle fragments.\n  ;\n\n  _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {\n    var _track$details;\n\n    var newDetails = data.details,\n        trackId = data.id;\n    var currentTrackId = this.currentTrackId,\n        levels = this.levels;\n\n    if (!levels.length) {\n      return;\n    }\n\n    var track = levels[currentTrackId];\n\n    if (trackId >= levels.length || trackId !== currentTrackId || !track) {\n      return;\n    }\n\n    this.mediaBuffer = this.mediaBufferTimeRanges;\n\n    if (newDetails.live || (_track$details = track.details) !== null && _track$details !== void 0 && _track$details.live) {\n      var mainDetails = this.mainDetails;\n\n      if (newDetails.deltaUpdateFailed || !mainDetails) {\n        return;\n      }\n\n      var mainSlidingStartFragment = mainDetails.fragments[0];\n\n      if (!track.details) {\n        if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n          Object(_utils_discontinuities__WEBPACK_IMPORTED_MODULE_3__[\"alignMediaPlaylistByPDT\"])(newDetails, mainDetails);\n        } else if (mainSlidingStartFragment) {\n          // line up live playlist with main so that fragments in range are loaded\n          Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__[\"addSliding\"])(newDetails, mainSlidingStartFragment.start);\n        }\n      } else {\n        var sliding = this.alignPlaylists(newDetails, track.details);\n\n        if (sliding === 0 && mainSlidingStartFragment) {\n          // realign with main when there is no overlap with last refresh\n          Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__[\"addSliding\"])(newDetails, mainSlidingStartFragment.start);\n        }\n      }\n    }\n\n    track.details = newDetails;\n    this.levelLastLoaded = trackId; // trigger handler right now\n\n    this.tick(); // If playlist is misaligned because of bad PDT or drift, delete details to resync with main on reload\n\n    if (newDetails.live && !this.fragCurrent && this.media && this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__[\"State\"].IDLE) {\n      var foundFrag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_2__[\"findFragmentByPTS\"])(null, newDetails.fragments, this.media.currentTime, 0);\n\n      if (!foundFrag) {\n        this.warn('Subtitle playlist not aligned with playback');\n        track.details = undefined;\n      }\n    }\n  };\n\n  _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {\n    var frag = fragLoadedData.frag,\n        payload = fragLoadedData.payload;\n    var decryptData = frag.decryptdata;\n    var hls = this.hls;\n\n    if (this.fragContextChanged(frag)) {\n      return;\n    } // check to see if the payload needs to be decrypted\n\n\n    if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {\n      var startTime = performance.now(); // decrypt the subtitles\n\n      this.decrypter.webCryptoDecrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).then(function (decryptedData) {\n        var endTime = performance.now();\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FRAG_DECRYPTED, {\n          frag: frag,\n          payload: decryptedData,\n          stats: {\n            tstart: startTime,\n            tdecrypt: endTime\n          }\n        });\n      });\n    }\n  };\n\n  _proto.doTick = function doTick() {\n    if (!this.media) {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__[\"State\"].IDLE;\n      return;\n    }\n\n    if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__[\"State\"].IDLE) {\n      var _foundFrag;\n\n      var currentTrackId = this.currentTrackId,\n          levels = this.levels;\n\n      if (!levels.length || !levels[currentTrackId] || !levels[currentTrackId].details) {\n        return;\n      } // Expand range of subs loaded by one target-duration in either direction to make up for misaligned playlists\n\n\n      var trackDetails = levels[currentTrackId].details;\n      var targetDuration = trackDetails.targetduration;\n      var config = this.config,\n          media = this.media;\n      var bufferedInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_1__[\"BufferHelper\"].bufferedInfo(this.mediaBufferTimeRanges, media.currentTime - targetDuration, config.maxBufferHole);\n      var targetBufferTime = bufferedInfo.end,\n          bufferLen = bufferedInfo.len;\n      var maxBufLen = this.getMaxBufferLength() + targetDuration;\n\n      if (bufferLen > maxBufLen) {\n        return;\n      }\n\n      console.assert(trackDetails, 'Subtitle track details are defined on idle subtitle stream controller tick');\n      var fragments = trackDetails.fragments;\n      var fragLen = fragments.length;\n      var end = trackDetails.edge;\n      var foundFrag;\n      var fragPrevious = this.fragPrevious;\n\n      if (targetBufferTime < end) {\n        var maxFragLookUpTolerance = config.maxFragLookUpTolerance;\n        foundFrag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_2__[\"findFragmentByPTS\"])(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), maxFragLookUpTolerance);\n\n        if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {\n          foundFrag = fragments[0];\n        }\n      } else {\n        foundFrag = fragments[fragLen - 1];\n      }\n\n      if ((_foundFrag = foundFrag) !== null && _foundFrag !== void 0 && _foundFrag.encrypted) {\n        this.loadKey(foundFrag, trackDetails);\n      } else if (foundFrag && this.fragmentTracker.getState(foundFrag) === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__[\"FragmentState\"].NOT_LOADED) {\n        // only load if fragment is not loaded\n        this.loadFragment(foundFrag, trackDetails, targetBufferTime);\n      }\n    }\n  };\n\n  _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {\n    this.fragCurrent = frag;\n\n    _BaseStreamController.prototype.loadFragment.call(this, frag, levelDetails, targetBufferTime);\n  };\n\n  _createClass(SubtitleStreamController, [{\n    key: \"mediaBufferTimeRanges\",\n    get: function get() {\n      return this.tracksBuffered[this.currentTrackId] || [];\n    }\n  }]);\n\n  return SubtitleStreamController;\n}(_base_stream_controller__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n\n/***/ }),\n\n/***/ \"./src/controller/subtitle-track-controller.ts\":\n/*!*****************************************************!*\\\n  !*** ./src/controller/subtitle-track-controller.ts ***!\n  \\*****************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_440164__) {\n\n\"use strict\";\n__nested_webpack_require_440164__.r(__webpack_exports__);\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_440164__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_440164__(/*! ../utils/texttrack-utils */ \"./src/utils/texttrack-utils.ts\");\n/* harmony import */ var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_440164__(/*! ./base-playlist-controller */ \"./src/controller/base-playlist-controller.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_440164__(/*! ../types/loader */ \"./src/types/loader.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\nvar SubtitleTrackController = /*#__PURE__*/function (_BasePlaylistControll) {\n  _inheritsLoose(SubtitleTrackController, _BasePlaylistControll);\n\n  function SubtitleTrackController(hls) {\n    var _this;\n\n    _this = _BasePlaylistControll.call(this, hls, '[subtitle-track-controller]') || this;\n    _this.media = null;\n    _this.tracks = [];\n    _this.groupId = null;\n    _this.tracksInGroup = [];\n    _this.trackId = -1;\n    _this.selectDefaultTrack = true;\n    _this.queuedDefaultTrack = -1;\n\n    _this.trackChangeListener = function () {\n      return _this.onTextTracksChanged();\n    };\n\n    _this.asyncPollTrackChange = function () {\n      return _this.pollTrackChange(0);\n    };\n\n    _this.useTextTrackPolling = false;\n    _this.subtitlePollingInterval = -1;\n    _this._subtitleDisplay = true;\n\n    _this.registerListeners();\n\n    return _this;\n  }\n\n  var _proto = SubtitleTrackController.prototype;\n\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.tracks.length = 0;\n    this.tracksInGroup.length = 0;\n    this.trackChangeListener = this.asyncPollTrackChange = null;\n\n    _BasePlaylistControll.prototype.destroy.call(this);\n  };\n\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, this.onError, this);\n  };\n\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, this.onError, this);\n  } // Listen for subtitle track change, then extract the current track ID.\n  ;\n\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    this.media = data.media;\n\n    if (!this.media) {\n      return;\n    }\n\n    if (this.queuedDefaultTrack > -1) {\n      this.subtitleTrack = this.queuedDefaultTrack;\n      this.queuedDefaultTrack = -1;\n    }\n\n    this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);\n\n    if (this.useTextTrackPolling) {\n      this.pollTrackChange(500);\n    } else {\n      this.media.textTracks.addEventListener('change', this.asyncPollTrackChange);\n    }\n  };\n\n  _proto.pollTrackChange = function pollTrackChange(timeout) {\n    self.clearInterval(this.subtitlePollingInterval);\n    this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, timeout);\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    if (!this.media) {\n      return;\n    }\n\n    self.clearInterval(this.subtitlePollingInterval);\n\n    if (!this.useTextTrackPolling) {\n      this.media.textTracks.removeEventListener('change', this.asyncPollTrackChange);\n    }\n\n    if (this.trackId > -1) {\n      this.queuedDefaultTrack = this.trackId;\n    }\n\n    var textTracks = filterSubtitleTracks(this.media.textTracks); // Clear loaded cues on media detachment from tracks\n\n    textTracks.forEach(function (track) {\n      Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__[\"clearCurrentCues\"])(track);\n    }); // Disable all subtitle tracks before detachment so when reattached only tracks in that content are enabled.\n\n    this.subtitleTrack = -1;\n    this.media = null;\n  };\n\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.tracks = [];\n    this.groupId = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.selectDefaultTrack = true;\n  } // Fired whenever a new manifest is loaded.\n  ;\n\n  _proto.onManifestParsed = function onManifestParsed(event, data) {\n    this.tracks = data.subtitleTracks;\n  };\n\n  _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {\n    var id = data.id,\n        details = data.details;\n    var trackId = this.trackId;\n    var currentTrack = this.tracksInGroup[trackId];\n\n    if (!currentTrack) {\n      this.warn(\"Invalid subtitle track id \" + id);\n      return;\n    }\n\n    var curDetails = currentTrack.details;\n    currentTrack.details = data.details;\n    this.log(\"subtitle track \" + id + \" loaded [\" + details.startSN + \"-\" + details.endSN + \"]\");\n\n    if (id === this.trackId) {\n      this.retryCount = 0;\n      this.playlistLoaded(id, data, curDetails);\n    }\n  };\n\n  _proto.onLevelLoading = function onLevelLoading(event, data) {\n    this.switchLevel(data.level);\n  };\n\n  _proto.onLevelSwitching = function onLevelSwitching(event, data) {\n    this.switchLevel(data.level);\n  };\n\n  _proto.switchLevel = function switchLevel(levelIndex) {\n    var levelInfo = this.hls.levels[levelIndex];\n\n    if (!(levelInfo !== null && levelInfo !== void 0 && levelInfo.textGroupIds)) {\n      return;\n    }\n\n    var textGroupId = levelInfo.textGroupIds[levelInfo.urlId];\n\n    if (this.groupId !== textGroupId) {\n      var lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : undefined;\n      var subtitleTracks = this.tracks.filter(function (track) {\n        return !textGroupId || track.groupId === textGroupId;\n      });\n      this.tracksInGroup = subtitleTracks;\n      var initialTrackId = this.findTrackId(lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.name) || this.findTrackId();\n      this.groupId = textGroupId;\n      var subtitleTracksUpdated = {\n        subtitleTracks: subtitleTracks\n      };\n      this.log(\"Updating subtitle tracks, \" + subtitleTracks.length + \" track(s) found in \\\"\" + textGroupId + \"\\\" group-id\");\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);\n\n      if (initialTrackId !== -1) {\n        this.setSubtitleTrack(initialTrackId, lastTrack);\n      }\n    }\n  };\n\n  _proto.findTrackId = function findTrackId(name) {\n    var textTracks = this.tracksInGroup;\n\n    for (var i = 0; i < textTracks.length; i++) {\n      var track = textTracks[i];\n\n      if (!this.selectDefaultTrack || track.default) {\n        if (!name || name === track.name) {\n          return track.id;\n        }\n      }\n    }\n\n    return -1;\n  };\n\n  _proto.onError = function onError(event, data) {\n    _BasePlaylistControll.prototype.onError.call(this, event, data);\n\n    if (data.fatal || !data.context) {\n      return;\n    }\n\n    if (data.context.type === _types_loader__WEBPACK_IMPORTED_MODULE_3__[\"PlaylistContextType\"].SUBTITLE_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {\n      this.retryLoadingOrFail(data);\n    }\n  }\n  /** get alternate subtitle tracks list from playlist **/\n  ;\n\n  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n    var currentTrack = this.tracksInGroup[this.trackId];\n\n    if (this.shouldLoadTrack(currentTrack)) {\n      var id = currentTrack.id;\n      var groupId = currentTrack.groupId;\n      var url = currentTrack.url;\n\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + error);\n        }\n      }\n\n      this.log(\"Loading subtitle playlist for id \" + id);\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_LOADING, {\n        url: url,\n        id: id,\n        groupId: groupId,\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  }\n  /**\n   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.\n   * This operates on the DOM textTracks.\n   * A value of -1 will disable all subtitle tracks.\n   */\n  ;\n\n  _proto.toggleTrackModes = function toggleTrackModes(newId) {\n    var _this2 = this;\n\n    var media = this.media,\n        trackId = this.trackId;\n\n    if (!media) {\n      return;\n    }\n\n    var textTracks = filterSubtitleTracks(media.textTracks);\n    var groupTracks = textTracks.filter(function (track) {\n      return track.groupId === _this2.groupId;\n    });\n\n    if (newId === -1) {\n      [].slice.call(textTracks).forEach(function (track) {\n        track.mode = 'disabled';\n      });\n    } else {\n      var oldTrack = groupTracks[trackId];\n\n      if (oldTrack) {\n        oldTrack.mode = 'disabled';\n      }\n    }\n\n    var nextTrack = groupTracks[newId];\n\n    if (nextTrack) {\n      nextTrack.mode = this.subtitleDisplay ? 'showing' : 'hidden';\n    }\n  }\n  /**\n   * This method is responsible for validating the subtitle index and periodically reloading if live.\n   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.\n   */\n  ;\n\n  _proto.setSubtitleTrack = function setSubtitleTrack(newId, lastTrack) {\n    var _tracks$newId;\n\n    var tracks = this.tracksInGroup; // setting this.subtitleTrack will trigger internal logic\n    // if media has not been attached yet, it will fail\n    // we keep a reference to the default track id\n    // and we'll set subtitleTrack when onMediaAttached is triggered\n\n    if (!this.media) {\n      this.queuedDefaultTrack = newId;\n      return;\n    }\n\n    if (this.trackId !== newId) {\n      this.toggleTrackModes(newId);\n    } // exit if track id as already set or invalid\n\n\n    if (this.trackId === newId && (newId === -1 || (_tracks$newId = tracks[newId]) !== null && _tracks$newId !== void 0 && _tracks$newId.details) || newId < -1 || newId >= tracks.length) {\n      return;\n    } // stopping live reloading timer if any\n\n\n    this.clearTimer();\n    var track = tracks[newId];\n    this.log(\"Switching to subtitle track \" + newId);\n    this.trackId = newId;\n\n    if (track) {\n      var id = track.id,\n          _track$groupId = track.groupId,\n          groupId = _track$groupId === void 0 ? '' : _track$groupId,\n          name = track.name,\n          type = track.type,\n          url = track.url;\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_SWITCH, {\n        id: id,\n        groupId: groupId,\n        name: name,\n        type: type,\n        url: url\n      });\n      var hlsUrlParameters = this.switchParams(track.url, lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.details);\n      this.loadPlaylist(hlsUrlParameters);\n    } else {\n      // switch to -1\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_SWITCH, {\n        id: newId\n      });\n    }\n  };\n\n  _proto.onTextTracksChanged = function onTextTracksChanged() {\n    if (!this.useTextTrackPolling) {\n      self.clearInterval(this.subtitlePollingInterval);\n    } // Media is undefined when switching streams via loadSource()\n\n\n    if (!this.media || !this.hls.config.renderTextTracksNatively) {\n      return;\n    }\n\n    var trackId = -1;\n    var tracks = filterSubtitleTracks(this.media.textTracks);\n\n    for (var id = 0; id < tracks.length; id++) {\n      if (tracks[id].mode === 'hidden') {\n        // Do not break in case there is a following track with showing.\n        trackId = id;\n      } else if (tracks[id].mode === 'showing') {\n        trackId = id;\n        break;\n      }\n    } // Setting current subtitleTrack will invoke code.\n\n\n    if (this.subtitleTrack !== trackId) {\n      this.subtitleTrack = trackId;\n    }\n  };\n\n  _createClass(SubtitleTrackController, [{\n    key: \"subtitleDisplay\",\n    get: function get() {\n      return this._subtitleDisplay;\n    },\n    set: function set(value) {\n      this._subtitleDisplay = value;\n\n      if (this.trackId > -1) {\n        this.toggleTrackModes(this.trackId);\n      }\n    }\n  }, {\n    key: \"subtitleTracks\",\n    get: function get() {\n      return this.tracksInGroup;\n    }\n    /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/\n\n  }, {\n    key: \"subtitleTrack\",\n    get: function get() {\n      return this.trackId;\n    },\n    set: function set(newId) {\n      this.selectDefaultTrack = false;\n      var lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : undefined;\n      this.setSubtitleTrack(newId, lastTrack);\n    }\n  }]);\n\n  return SubtitleTrackController;\n}(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n\nfunction filterSubtitleTracks(textTrackList) {\n  var tracks = [];\n\n  for (var i = 0; i < textTrackList.length; i++) {\n    var track = textTrackList[i]; // Edge adds a track without a label; we don't want to use it\n\n    if (track.kind === 'subtitles' && track.label) {\n      tracks.push(textTrackList[i]);\n    }\n  }\n\n  return tracks;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SubtitleTrackController);\n\n/***/ }),\n\n/***/ \"./src/controller/timeline-controller.ts\":\n/*!***********************************************!*\\\n  !*** ./src/controller/timeline-controller.ts ***!\n  \\***********************************************/\n/*! exports provided: TimelineController */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_455966__) {\n\n\"use strict\";\n__nested_webpack_require_455966__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_455966__.d(__webpack_exports__, \"TimelineController\", function() { return TimelineController; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_455966__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_455966__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_455966__(/*! ../utils/cea-608-parser */ \"./src/utils/cea-608-parser.ts\");\n/* harmony import */ var _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_455966__(/*! ../utils/output-filter */ \"./src/utils/output-filter.ts\");\n/* harmony import */ var _utils_webvtt_parser__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_455966__(/*! ../utils/webvtt-parser */ \"./src/utils/webvtt-parser.ts\");\n/* harmony import */ var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_455966__(/*! ../utils/texttrack-utils */ \"./src/utils/texttrack-utils.ts\");\n/* harmony import */ var _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_455966__(/*! ../utils/imsc1-ttml-parser */ \"./src/utils/imsc1-ttml-parser.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_455966__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_455966__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\n\n\n\n\n\n\n\nvar TimelineController = /*#__PURE__*/function () {\n  function TimelineController(hls) {\n    this.hls = void 0;\n    this.media = null;\n    this.config = void 0;\n    this.enabled = true;\n    this.Cues = void 0;\n    this.textTracks = [];\n    this.tracks = [];\n    this.initPTS = [];\n    this.timescale = [];\n    this.unparsedVttFrags = [];\n    this.captionsTracks = {};\n    this.nonNativeCaptionsTracks = {};\n    this.cea608Parser1 = void 0;\n    this.cea608Parser2 = void 0;\n    this.lastSn = -1;\n    this.lastPartIndex = -1;\n    this.prevCC = -1;\n    this.vttCCs = newVTTCCs();\n    this.captionsProperties = void 0;\n    this.hls = hls;\n    this.config = hls.config;\n    this.Cues = hls.config.cueHandler;\n    this.captionsProperties = {\n      textTrack1: {\n        label: this.config.captionsTextTrack1Label,\n        languageCode: this.config.captionsTextTrack1LanguageCode\n      },\n      textTrack2: {\n        label: this.config.captionsTextTrack2Label,\n        languageCode: this.config.captionsTextTrack2LanguageCode\n      },\n      textTrack3: {\n        label: this.config.captionsTextTrack3Label,\n        languageCode: this.config.captionsTextTrack3LanguageCode\n      },\n      textTrack4: {\n        label: this.config.captionsTextTrack4Label,\n        languageCode: this.config.captionsTextTrack4LanguageCode\n      }\n    };\n\n    if (this.config.enableCEA708Captions) {\n      var channel1 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this, 'textTrack1');\n      var channel2 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this, 'textTrack2');\n      var channel3 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this, 'textTrack3');\n      var channel4 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this, 'textTrack4');\n      this.cea608Parser1 = new _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__[\"default\"](1, channel1, channel2);\n      this.cea608Parser2 = new _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__[\"default\"](3, channel3, channel4);\n    }\n\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_LOADING, this.onFragLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_DECRYPTED, this.onFragDecrypted, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_FLUSHING, this.onBufferFlushing, this);\n  }\n\n  var _proto = TimelineController.prototype;\n\n  _proto.destroy = function destroy() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_LOADING, this.onFragLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_DECRYPTED, this.onFragDecrypted, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_FLUSHING, this.onBufferFlushing, this); // @ts-ignore\n\n    this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null;\n  };\n\n  _proto.addCues = function addCues(trackName, startTime, endTime, screen, cueRanges) {\n    // skip cues which overlap more than 50% with previously parsed time ranges\n    var merged = false;\n\n    for (var i = cueRanges.length; i--;) {\n      var cueRange = cueRanges[i];\n      var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);\n\n      if (overlap >= 0) {\n        cueRange[0] = Math.min(cueRange[0], startTime);\n        cueRange[1] = Math.max(cueRange[1], endTime);\n        merged = true;\n\n        if (overlap / (endTime - startTime) > 0.5) {\n          return;\n        }\n      }\n    }\n\n    if (!merged) {\n      cueRanges.push([startTime, endTime]);\n    }\n\n    if (this.config.renderTextTracksNatively) {\n      var track = this.captionsTracks[trackName];\n      this.Cues.newCue(track, startTime, endTime, screen);\n    } else {\n      var cues = this.Cues.newCue(null, startTime, endTime, screen);\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].CUES_PARSED, {\n        type: 'captions',\n        cues: cues,\n        track: trackName\n      });\n    }\n  } // Triggered when an initial PTS is found; used for synchronisation of WebVTT.\n  ;\n\n  _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {\n    var _this = this;\n\n    var frag = _ref.frag,\n        id = _ref.id,\n        initPTS = _ref.initPTS,\n        timescale = _ref.timescale;\n    var unparsedVttFrags = this.unparsedVttFrags;\n\n    if (id === 'main') {\n      this.initPTS[frag.cc] = initPTS;\n      this.timescale[frag.cc] = timescale;\n    } // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.\n    // Parse any unparsed fragments upon receiving the initial PTS.\n\n\n    if (unparsedVttFrags.length) {\n      this.unparsedVttFrags = [];\n      unparsedVttFrags.forEach(function (frag) {\n        _this.onFragLoaded(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_LOADED, frag);\n      });\n    }\n  };\n\n  _proto.getExistingTrack = function getExistingTrack(trackName) {\n    var media = this.media;\n\n    if (media) {\n      for (var i = 0; i < media.textTracks.length; i++) {\n        var textTrack = media.textTracks[i];\n\n        if (textTrack[trackName]) {\n          return textTrack;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  _proto.createCaptionsTrack = function createCaptionsTrack(trackName) {\n    if (this.config.renderTextTracksNatively) {\n      this.createNativeTrack(trackName);\n    } else {\n      this.createNonNativeTrack(trackName);\n    }\n  };\n\n  _proto.createNativeTrack = function createNativeTrack(trackName) {\n    if (this.captionsTracks[trackName]) {\n      return;\n    }\n\n    var captionsProperties = this.captionsProperties,\n        captionsTracks = this.captionsTracks,\n        media = this.media;\n    var _captionsProperties$t = captionsProperties[trackName],\n        label = _captionsProperties$t.label,\n        languageCode = _captionsProperties$t.languageCode; // Enable reuse of existing text track.\n\n    var existingTrack = this.getExistingTrack(trackName);\n\n    if (!existingTrack) {\n      var textTrack = this.createTextTrack('captions', label, languageCode);\n\n      if (textTrack) {\n        // Set a special property on the track so we know it's managed by Hls.js\n        textTrack[trackName] = true;\n        captionsTracks[trackName] = textTrack;\n      }\n    } else {\n      captionsTracks[trackName] = existingTrack;\n      Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__[\"clearCurrentCues\"])(captionsTracks[trackName]);\n      Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__[\"sendAddTrackEvent\"])(captionsTracks[trackName], media);\n    }\n  };\n\n  _proto.createNonNativeTrack = function createNonNativeTrack(trackName) {\n    if (this.nonNativeCaptionsTracks[trackName]) {\n      return;\n    } // Create a list of a single track for the provider to consume\n\n\n    var trackProperties = this.captionsProperties[trackName];\n\n    if (!trackProperties) {\n      return;\n    }\n\n    var label = trackProperties.label;\n    var track = {\n      _id: trackName,\n      label: label,\n      kind: 'captions',\n      default: trackProperties.media ? !!trackProperties.media.default : false,\n      closedCaptions: trackProperties.media\n    };\n    this.nonNativeCaptionsTracks[trackName] = track;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].NON_NATIVE_TEXT_TRACKS_FOUND, {\n      tracks: [track]\n    });\n  };\n\n  _proto.createTextTrack = function createTextTrack(kind, label, lang) {\n    var media = this.media;\n\n    if (!media) {\n      return;\n    }\n\n    return media.addTextTrack(kind, label, lang);\n  };\n\n  _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n    this.media = data.media;\n\n    this._cleanTracks();\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    var captionsTracks = this.captionsTracks;\n    Object.keys(captionsTracks).forEach(function (trackName) {\n      Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__[\"clearCurrentCues\"])(captionsTracks[trackName]);\n      delete captionsTracks[trackName];\n    });\n    this.nonNativeCaptionsTracks = {};\n  };\n\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.lastSn = -1; // Detect discontinuity in fragment parsing\n\n    this.lastPartIndex = -1;\n    this.prevCC = -1;\n    this.vttCCs = newVTTCCs(); // Detect discontinuity in subtitle manifests\n\n    this._cleanTracks();\n\n    this.tracks = [];\n    this.captionsTracks = {};\n    this.nonNativeCaptionsTracks = {};\n    this.textTracks = [];\n    this.unparsedVttFrags = this.unparsedVttFrags || [];\n    this.initPTS = [];\n    this.timescale = [];\n\n    if (this.cea608Parser1 && this.cea608Parser2) {\n      this.cea608Parser1.reset();\n      this.cea608Parser2.reset();\n    }\n  };\n\n  _proto._cleanTracks = function _cleanTracks() {\n    // clear outdated subtitles\n    var media = this.media;\n\n    if (!media) {\n      return;\n    }\n\n    var textTracks = media.textTracks;\n\n    if (textTracks) {\n      for (var i = 0; i < textTracks.length; i++) {\n        Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__[\"clearCurrentCues\"])(textTracks[i]);\n      }\n    }\n  };\n\n  _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, data) {\n    var _this2 = this;\n\n    this.textTracks = [];\n    var tracks = data.subtitleTracks || [];\n    var hasIMSC1 = tracks.some(function (track) {\n      return track.textCodec === _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__[\"IMSC1_CODEC\"];\n    });\n\n    if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {\n      var sameTracks = this.tracks && tracks && this.tracks.length === tracks.length;\n      this.tracks = tracks || [];\n\n      if (this.config.renderTextTracksNatively) {\n        var inUseTracks = this.media ? this.media.textTracks : [];\n        this.tracks.forEach(function (track, index) {\n          var textTrack;\n\n          if (index < inUseTracks.length) {\n            var inUseTrack = null;\n\n            for (var i = 0; i < inUseTracks.length; i++) {\n              if (canReuseVttTextTrack(inUseTracks[i], track)) {\n                inUseTrack = inUseTracks[i];\n                break;\n              }\n            } // Reuse tracks with the same label, but do not reuse 608/708 tracks\n\n\n            if (inUseTrack) {\n              textTrack = inUseTrack;\n            }\n          }\n\n          if (textTrack) {\n            Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__[\"clearCurrentCues\"])(textTrack);\n          } else {\n            textTrack = _this2.createTextTrack('subtitles', track.name, track.lang);\n\n            if (textTrack) {\n              textTrack.mode = 'disabled';\n            }\n          }\n\n          if (textTrack) {\n            textTrack.groupId = track.groupId;\n\n            _this2.textTracks.push(textTrack);\n          }\n        });\n      } else if (!sameTracks && this.tracks && this.tracks.length) {\n        // Create a list of tracks for the provider to consume\n        var tracksList = this.tracks.map(function (track) {\n          return {\n            label: track.name,\n            kind: track.type.toLowerCase(),\n            default: track.default,\n            subtitleTrack: track\n          };\n        });\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].NON_NATIVE_TEXT_TRACKS_FOUND, {\n          tracks: tracksList\n        });\n      }\n    }\n  };\n\n  _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n    var _this3 = this;\n\n    if (this.config.enableCEA708Captions && data.captions) {\n      data.captions.forEach(function (captionsTrack) {\n        var instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);\n\n        if (!instreamIdMatch) {\n          return;\n        }\n\n        var trackName = \"textTrack\" + instreamIdMatch[1];\n        var trackProperties = _this3.captionsProperties[trackName];\n\n        if (!trackProperties) {\n          return;\n        }\n\n        trackProperties.label = captionsTrack.name;\n\n        if (captionsTrack.lang) {\n          // optional attribute\n          trackProperties.languageCode = captionsTrack.lang;\n        }\n\n        trackProperties.media = captionsTrack;\n      });\n    }\n  };\n\n  _proto.onFragLoading = function onFragLoading(event, data) {\n    var cea608Parser1 = this.cea608Parser1,\n        cea608Parser2 = this.cea608Parser2,\n        lastSn = this.lastSn,\n        lastPartIndex = this.lastPartIndex;\n\n    if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {\n      return;\n    } // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack\n\n\n    if (data.frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_7__[\"PlaylistLevelType\"].MAIN) {\n      var _data$part$index, _data$part;\n\n      var sn = data.frag.sn;\n      var partIndex = (_data$part$index = data === null || data === void 0 ? void 0 : (_data$part = data.part) === null || _data$part === void 0 ? void 0 : _data$part.index) != null ? _data$part$index : -1;\n\n      if (!(sn === lastSn + 1 || sn === lastSn && partIndex === lastPartIndex + 1)) {\n        cea608Parser1.reset();\n        cea608Parser2.reset();\n      }\n\n      this.lastSn = sn;\n      this.lastPartIndex = partIndex;\n    }\n  };\n\n  _proto.onFragLoaded = function onFragLoaded(event, data) {\n    var frag = data.frag,\n        payload = data.payload;\n    var initPTS = this.initPTS,\n        unparsedVttFrags = this.unparsedVttFrags;\n\n    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_7__[\"PlaylistLevelType\"].SUBTITLE) {\n      // If fragment is subtitle type, parse as WebVTT.\n      if (payload.byteLength) {\n        // We need an initial synchronisation PTS. Store fragments as long as none has arrived.\n        if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(initPTS[frag.cc])) {\n          unparsedVttFrags.push(data);\n\n          if (initPTS.length) {\n            // finish unsuccessfully, otherwise the subtitle-stream-controller could be blocked from loading new frags.\n            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_FRAG_PROCESSED, {\n              success: false,\n              frag: frag,\n              error: new Error('Missing initial subtitle PTS')\n            });\n          }\n\n          return;\n        }\n\n        var decryptData = frag.decryptdata; // fragment after decryption has a stats object\n\n        var decrypted = ('stats' in data); // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.\n\n        if (decryptData == null || decryptData.key == null || decryptData.method !== 'AES-128' || decrypted) {\n          var trackPlaylistMedia = this.tracks[frag.level];\n          var vttCCs = this.vttCCs;\n\n          if (!vttCCs[frag.cc]) {\n            vttCCs[frag.cc] = {\n              start: frag.start,\n              prevCC: this.prevCC,\n              new: true\n            };\n            this.prevCC = frag.cc;\n          }\n\n          if (trackPlaylistMedia && trackPlaylistMedia.textCodec === _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__[\"IMSC1_CODEC\"]) {\n            this._parseIMSC1(frag, payload);\n          } else {\n            this._parseVTTs(frag, payload, vttCCs);\n          }\n        }\n      } else {\n        // In case there is no payload, finish unsuccessfully.\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_FRAG_PROCESSED, {\n          success: false,\n          frag: frag,\n          error: new Error('Empty subtitle payload')\n        });\n      }\n    }\n  };\n\n  _proto._parseIMSC1 = function _parseIMSC1(frag, payload) {\n    var _this4 = this;\n\n    var hls = this.hls;\n    Object(_utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__[\"parseIMSC1\"])(payload, this.initPTS[frag.cc], this.timescale[frag.cc], function (cues) {\n      _this4._appendCues(cues, frag.level);\n\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_FRAG_PROCESSED, {\n        success: true,\n        frag: frag\n      });\n    }, function (error) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_8__[\"logger\"].log(\"Failed to parse IMSC1: \" + error);\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_FRAG_PROCESSED, {\n        success: false,\n        frag: frag,\n        error: error\n      });\n    });\n  };\n\n  _proto._parseVTTs = function _parseVTTs(frag, payload, vttCCs) {\n    var _this5 = this;\n\n    var hls = this.hls; // Parse the WebVTT file contents.\n\n    Object(_utils_webvtt_parser__WEBPACK_IMPORTED_MODULE_4__[\"parseWebVTT\"])(payload, this.initPTS[frag.cc], this.timescale[frag.cc], vttCCs, frag.cc, frag.start, function (cues) {\n      _this5._appendCues(cues, frag.level);\n\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_FRAG_PROCESSED, {\n        success: true,\n        frag: frag\n      });\n    }, function (error) {\n      _this5._fallbackToIMSC1(frag, payload); // Something went wrong while parsing. Trigger event with success false.\n\n\n      _utils_logger__WEBPACK_IMPORTED_MODULE_8__[\"logger\"].log(\"Failed to parse VTT cue: \" + error);\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_FRAG_PROCESSED, {\n        success: false,\n        frag: frag,\n        error: error\n      });\n    });\n  };\n\n  _proto._fallbackToIMSC1 = function _fallbackToIMSC1(frag, payload) {\n    var _this6 = this;\n\n    // If textCodec is unknown, try parsing as IMSC1. Set textCodec based on the result\n    var trackPlaylistMedia = this.tracks[frag.level];\n\n    if (!trackPlaylistMedia.textCodec) {\n      Object(_utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__[\"parseIMSC1\"])(payload, this.initPTS[frag.cc], this.timescale[frag.cc], function () {\n        trackPlaylistMedia.textCodec = _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__[\"IMSC1_CODEC\"];\n\n        _this6._parseIMSC1(frag, payload);\n      }, function () {\n        trackPlaylistMedia.textCodec = 'wvtt';\n      });\n    }\n  };\n\n  _proto._appendCues = function _appendCues(cues, fragLevel) {\n    var hls = this.hls;\n\n    if (this.config.renderTextTracksNatively) {\n      var textTrack = this.textTracks[fragLevel]; // WebVTTParser.parse is an async method and if the currently selected text track mode is set to \"disabled\"\n      // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null\n      // and trying to access getCueById method of cues will throw an exception\n      // Because we check if the mode is disabled, we can force check `cues` below. They can't be null.\n\n      if (!textTrack || textTrack.mode === 'disabled') {\n        return;\n      }\n\n      cues.forEach(function (cue) {\n        return Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__[\"addCueToTrack\"])(textTrack, cue);\n      });\n    } else {\n      var currentTrack = this.tracks[fragLevel];\n\n      if (!currentTrack) {\n        return;\n      }\n\n      var track = currentTrack.default ? 'default' : 'subtitles' + fragLevel;\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].CUES_PARSED, {\n        type: 'subtitles',\n        cues: cues,\n        track: track\n      });\n    }\n  };\n\n  _proto.onFragDecrypted = function onFragDecrypted(event, data) {\n    var frag = data.frag;\n\n    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_7__[\"PlaylistLevelType\"].SUBTITLE) {\n      if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(this.initPTS[frag.cc])) {\n        this.unparsedVttFrags.push(data);\n        return;\n      }\n\n      this.onFragLoaded(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_LOADED, data);\n    }\n  };\n\n  _proto.onSubtitleTracksCleared = function onSubtitleTracksCleared() {\n    this.tracks = [];\n    this.captionsTracks = {};\n  };\n\n  _proto.onFragParsingUserdata = function onFragParsingUserdata(event, data) {\n    var cea608Parser1 = this.cea608Parser1,\n        cea608Parser2 = this.cea608Parser2;\n\n    if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {\n      return;\n    } // If the event contains captions (found in the bytes property), push all bytes into the parser immediately\n    // It will create the proper timestamps based on the PTS value\n\n\n    for (var i = 0; i < data.samples.length; i++) {\n      var ccBytes = data.samples[i].bytes;\n\n      if (ccBytes) {\n        var ccdatas = this.extractCea608Data(ccBytes);\n        cea608Parser1.addData(data.samples[i].pts, ccdatas[0]);\n        cea608Parser2.addData(data.samples[i].pts, ccdatas[1]);\n      }\n    }\n  };\n\n  _proto.onBufferFlushing = function onBufferFlushing(event, _ref2) {\n    var startOffset = _ref2.startOffset,\n        endOffset = _ref2.endOffset,\n        endOffsetSubtitles = _ref2.endOffsetSubtitles,\n        type = _ref2.type;\n    var media = this.media;\n\n    if (!media || media.currentTime < endOffset) {\n      return;\n    } // Clear 608 caption cues from the captions TextTracks when the video back buffer is flushed\n    // Forward cues are never removed because we can loose streamed 608 content from recent fragments\n\n\n    if (!type || type === 'video') {\n      var captionsTracks = this.captionsTracks;\n      Object.keys(captionsTracks).forEach(function (trackName) {\n        return Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__[\"removeCuesInRange\"])(captionsTracks[trackName], startOffset, endOffset);\n      });\n    }\n\n    if (this.config.renderTextTracksNatively) {\n      // Clear VTT/IMSC1 subtitle cues from the subtitle TextTracks when the back buffer is flushed\n      if (startOffset === 0 && endOffsetSubtitles !== undefined) {\n        var textTracks = this.textTracks;\n        Object.keys(textTracks).forEach(function (trackName) {\n          return Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__[\"removeCuesInRange\"])(textTracks[trackName], startOffset, endOffsetSubtitles);\n        });\n      }\n    }\n  };\n\n  _proto.extractCea608Data = function extractCea608Data(byteArray) {\n    var actualCCBytes = [[], []];\n    var count = byteArray[0] & 0x1f;\n    var position = 2;\n\n    for (var j = 0; j < count; j++) {\n      var tmpByte = byteArray[position++];\n      var ccbyte1 = 0x7f & byteArray[position++];\n      var ccbyte2 = 0x7f & byteArray[position++];\n\n      if (ccbyte1 === 0 && ccbyte2 === 0) {\n        continue;\n      }\n\n      var ccValid = (0x04 & tmpByte) !== 0; // Support all four channels\n\n      if (ccValid) {\n        var ccType = 0x03 & tmpByte;\n\n        if (0x00\n        /* CEA608 field1*/\n        === ccType || 0x01\n        /* CEA608 field2*/\n        === ccType) {\n          // Exclude CEA708 CC data.\n          actualCCBytes[ccType].push(ccbyte1);\n          actualCCBytes[ccType].push(ccbyte2);\n        }\n      }\n    }\n\n    return actualCCBytes;\n  };\n\n  return TimelineController;\n}();\n\nfunction canReuseVttTextTrack(inUseTrack, manifestTrack) {\n  return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);\n}\n\nfunction intersection(x1, x2, y1, y2) {\n  return Math.min(x2, y2) - Math.max(x1, y1);\n}\n\nfunction newVTTCCs() {\n  return {\n    ccOffset: 0,\n    presentationOffset: 0,\n    0: {\n      start: 0,\n      prevCC: -1,\n      new: false\n    }\n  };\n}\n\n/***/ }),\n\n/***/ \"./src/crypt/aes-crypto.ts\":\n/*!*********************************!*\\\n  !*** ./src/crypt/aes-crypto.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_482839__) {\n\n\"use strict\";\n__nested_webpack_require_482839__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_482839__.d(__webpack_exports__, \"default\", function() { return AESCrypto; });\nvar AESCrypto = /*#__PURE__*/function () {\n  function AESCrypto(subtle, iv) {\n    this.subtle = void 0;\n    this.aesIV = void 0;\n    this.subtle = subtle;\n    this.aesIV = iv;\n  }\n\n  var _proto = AESCrypto.prototype;\n\n  _proto.decrypt = function decrypt(data, key) {\n    return this.subtle.decrypt({\n      name: 'AES-CBC',\n      iv: this.aesIV\n    }, key, data);\n  };\n\n  return AESCrypto;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/crypt/aes-decryptor.ts\":\n/*!************************************!*\\\n  !*** ./src/crypt/aes-decryptor.ts ***!\n  \\************************************/\n/*! exports provided: removePadding, default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_483705__) {\n\n\"use strict\";\n__nested_webpack_require_483705__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_483705__.d(__webpack_exports__, \"removePadding\", function() { return removePadding; });\n/* harmony export (binding) */ __nested_webpack_require_483705__.d(__webpack_exports__, \"default\", function() { return AESDecryptor; });\n/* harmony import */ var _utils_typed_array__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_483705__(/*! ../utils/typed-array */ \"./src/utils/typed-array.ts\");\n // PKCS7\n\nfunction removePadding(array) {\n  var outputBytes = array.byteLength;\n  var paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\n\n  if (paddingBytes) {\n    return Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_0__[\"sliceUint8\"])(array, 0, outputBytes - paddingBytes);\n  }\n\n  return array;\n}\n\nvar AESDecryptor = /*#__PURE__*/function () {\n  function AESDecryptor() {\n    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.sBox = new Uint32Array(256);\n    this.invSBox = new Uint32Array(256);\n    this.key = new Uint32Array(0);\n    this.ksRows = 0;\n    this.keySize = 0;\n    this.keySchedule = void 0;\n    this.invKeySchedule = void 0;\n    this.initTable();\n  } // Using view.getUint32() also swaps the byte order.\n\n\n  var _proto = AESDecryptor.prototype;\n\n  _proto.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {\n    var view = new DataView(arrayBuffer);\n    var newArray = new Uint32Array(4);\n\n    for (var i = 0; i < 4; i++) {\n      newArray[i] = view.getUint32(i * 4);\n    }\n\n    return newArray;\n  };\n\n  _proto.initTable = function initTable() {\n    var sBox = this.sBox;\n    var invSBox = this.invSBox;\n    var subMix = this.subMix;\n    var subMix0 = subMix[0];\n    var subMix1 = subMix[1];\n    var subMix2 = subMix[2];\n    var subMix3 = subMix[3];\n    var invSubMix = this.invSubMix;\n    var invSubMix0 = invSubMix[0];\n    var invSubMix1 = invSubMix[1];\n    var invSubMix2 = invSubMix[2];\n    var invSubMix3 = invSubMix[3];\n    var d = new Uint32Array(256);\n    var x = 0;\n    var xi = 0;\n    var i = 0;\n\n    for (i = 0; i < 256; i++) {\n      if (i < 128) {\n        d[i] = i << 1;\n      } else {\n        d[i] = i << 1 ^ 0x11b;\n      }\n    }\n\n    for (i = 0; i < 256; i++) {\n      var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n      sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n      sBox[x] = sx;\n      invSBox[sx] = x; // Compute multiplication\n\n      var x2 = d[x];\n      var x4 = d[x2];\n      var x8 = d[x4]; // Compute sub/invSub bytes, mix columns tables\n\n      var t = d[sx] * 0x101 ^ sx * 0x1010100;\n      subMix0[x] = t << 24 | t >>> 8;\n      subMix1[x] = t << 16 | t >>> 16;\n      subMix2[x] = t << 8 | t >>> 24;\n      subMix3[x] = t; // Compute inv sub bytes, inv mix columns tables\n\n      t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n      invSubMix0[sx] = t << 24 | t >>> 8;\n      invSubMix1[sx] = t << 16 | t >>> 16;\n      invSubMix2[sx] = t << 8 | t >>> 24;\n      invSubMix3[sx] = t; // Compute next counter\n\n      if (!x) {\n        x = xi = 1;\n      } else {\n        x = x2 ^ d[d[d[x8 ^ x2]]];\n        xi ^= d[d[xi]];\n      }\n    }\n  };\n\n  _proto.expandKey = function expandKey(keyBuffer) {\n    // convert keyBuffer to Uint32Array\n    var key = this.uint8ArrayToUint32Array_(keyBuffer);\n    var sameKey = true;\n    var offset = 0;\n\n    while (offset < key.length && sameKey) {\n      sameKey = key[offset] === this.key[offset];\n      offset++;\n    }\n\n    if (sameKey) {\n      return;\n    }\n\n    this.key = key;\n    var keySize = this.keySize = key.length;\n\n    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n      throw new Error('Invalid aes key size=' + keySize);\n    }\n\n    var ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n    var ksRow;\n    var invKsRow;\n    var keySchedule = this.keySchedule = new Uint32Array(ksRows);\n    var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);\n    var sbox = this.sBox;\n    var rcon = this.rcon;\n    var invSubMix = this.invSubMix;\n    var invSubMix0 = invSubMix[0];\n    var invSubMix1 = invSubMix[1];\n    var invSubMix2 = invSubMix[2];\n    var invSubMix3 = invSubMix[3];\n    var prev;\n    var t;\n\n    for (ksRow = 0; ksRow < ksRows; ksRow++) {\n      if (ksRow < keySize) {\n        prev = keySchedule[ksRow] = key[ksRow];\n        continue;\n      }\n\n      t = prev;\n\n      if (ksRow % keySize === 0) {\n        // Rot word\n        t = t << 8 | t >>> 24; // Sub word\n\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff]; // Mix Rcon\n\n        t ^= rcon[ksRow / keySize | 0] << 24;\n      } else if (keySize > 6 && ksRow % keySize === 4) {\n        // Sub word\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n      }\n\n      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n    }\n\n    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n      ksRow = ksRows - invKsRow;\n\n      if (invKsRow & 3) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n      }\n\n      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n    }\n  } // Adding this as a method greatly improves performance.\n  ;\n\n  _proto.networkToHostOrderSwap = function networkToHostOrderSwap(word) {\n    return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n  };\n\n  _proto.decrypt = function decrypt(inputArrayBuffer, offset, aesIV) {\n    var nRounds = this.keySize + 6;\n    var invKeySchedule = this.invKeySchedule;\n    var invSBOX = this.invSBox;\n    var invSubMix = this.invSubMix;\n    var invSubMix0 = invSubMix[0];\n    var invSubMix1 = invSubMix[1];\n    var invSubMix2 = invSubMix[2];\n    var invSubMix3 = invSubMix[3];\n    var initVector = this.uint8ArrayToUint32Array_(aesIV);\n    var initVector0 = initVector[0];\n    var initVector1 = initVector[1];\n    var initVector2 = initVector[2];\n    var initVector3 = initVector[3];\n    var inputInt32 = new Int32Array(inputArrayBuffer);\n    var outputInt32 = new Int32Array(inputInt32.length);\n    var t0, t1, t2, t3;\n    var s0, s1, s2, s3;\n    var inputWords0, inputWords1, inputWords2, inputWords3;\n    var ksRow, i;\n    var swapWord = this.networkToHostOrderSwap;\n\n    while (offset < inputInt32.length) {\n      inputWords0 = swapWord(inputInt32[offset]);\n      inputWords1 = swapWord(inputInt32[offset + 1]);\n      inputWords2 = swapWord(inputInt32[offset + 2]);\n      inputWords3 = swapWord(inputInt32[offset + 3]);\n      s0 = inputWords0 ^ invKeySchedule[0];\n      s1 = inputWords3 ^ invKeySchedule[1];\n      s2 = inputWords2 ^ invKeySchedule[2];\n      s3 = inputWords1 ^ invKeySchedule[3];\n      ksRow = 4; // Iterate through the rounds of decryption\n\n      for (i = 1; i < nRounds; i++) {\n        t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n        t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n        t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n        t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3]; // Update state\n\n        s0 = t0;\n        s1 = t1;\n        s2 = t2;\n        s3 = t3;\n        ksRow = ksRow + 4;\n      } // Shift rows, sub bytes, add round key\n\n\n      t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];\n      t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n      t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n      t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3]; // Write\n\n      outputInt32[offset] = swapWord(t0 ^ initVector0);\n      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n      outputInt32[offset + 3] = swapWord(t1 ^ initVector3); // reset initVector to last 4 unsigned int\n\n      initVector0 = inputWords0;\n      initVector1 = inputWords1;\n      initVector2 = inputWords2;\n      initVector3 = inputWords3;\n      offset = offset + 4;\n    }\n\n    return outputInt32.buffer;\n  };\n\n  return AESDecryptor;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/crypt/decrypter.ts\":\n/*!********************************!*\\\n  !*** ./src/crypt/decrypter.ts ***!\n  \\********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_493088__) {\n\n\"use strict\";\n__nested_webpack_require_493088__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_493088__.d(__webpack_exports__, \"default\", function() { return Decrypter; });\n/* harmony import */ var _aes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_493088__(/*! ./aes-crypto */ \"./src/crypt/aes-crypto.ts\");\n/* harmony import */ var _fast_aes_key__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_493088__(/*! ./fast-aes-key */ \"./src/crypt/fast-aes-key.ts\");\n/* harmony import */ var _aes_decryptor__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_493088__(/*! ./aes-decryptor */ \"./src/crypt/aes-decryptor.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_493088__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_493088__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _utils_typed_array__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_493088__(/*! ../utils/typed-array */ \"./src/utils/typed-array.ts\");\n\n\n\n\n\n\nvar CHUNK_SIZE = 16; // 16 bytes, 128 bits\n\nvar Decrypter = /*#__PURE__*/function () {\n  function Decrypter(observer, config, _temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$removePKCS7Paddi = _ref.removePKCS7Padding,\n        removePKCS7Padding = _ref$removePKCS7Paddi === void 0 ? true : _ref$removePKCS7Paddi;\n\n    this.logEnabled = true;\n    this.observer = void 0;\n    this.config = void 0;\n    this.removePKCS7Padding = void 0;\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n    this.observer = observer;\n    this.config = config;\n    this.removePKCS7Padding = removePKCS7Padding; // built in decryptor expects PKCS7 padding\n\n    if (removePKCS7Padding) {\n      try {\n        var browserCrypto = self.crypto;\n\n        if (browserCrypto) {\n          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n        }\n      } catch (e) {\n        /* no-op */\n      }\n    }\n\n    if (this.subtle === null) {\n      this.config.enableSoftwareAES = true;\n    }\n  }\n\n  var _proto = Decrypter.prototype;\n\n  _proto.destroy = function destroy() {\n    // @ts-ignore\n    this.observer = null;\n  };\n\n  _proto.isSync = function isSync() {\n    return this.config.enableSoftwareAES;\n  };\n\n  _proto.flush = function flush() {\n    var currentResult = this.currentResult;\n\n    if (!currentResult) {\n      this.reset();\n      return;\n    }\n\n    var data = new Uint8Array(currentResult);\n    this.reset();\n\n    if (this.removePKCS7Padding) {\n      return Object(_aes_decryptor__WEBPACK_IMPORTED_MODULE_2__[\"removePadding\"])(data);\n    }\n\n    return data;\n  };\n\n  _proto.reset = function reset() {\n    this.currentResult = null;\n    this.currentIV = null;\n    this.remainderData = null;\n\n    if (this.softwareDecrypter) {\n      this.softwareDecrypter = null;\n    }\n  };\n\n  _proto.decrypt = function decrypt(data, key, iv, callback) {\n    if (this.config.enableSoftwareAES) {\n      this.softwareDecrypt(new Uint8Array(data), key, iv);\n      var decryptResult = this.flush();\n\n      if (decryptResult) {\n        callback(decryptResult.buffer);\n      }\n    } else {\n      this.webCryptoDecrypt(new Uint8Array(data), key, iv).then(callback);\n    }\n  };\n\n  _proto.softwareDecrypt = function softwareDecrypt(data, key, iv) {\n    var currentIV = this.currentIV,\n        currentResult = this.currentResult,\n        remainderData = this.remainderData;\n    this.logOnce('JS AES decrypt'); // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\n    // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\n    // the end on flush(), but by that time we have already received all bytes for the segment.\n    // Progressive decryption does not work with WebCrypto\n\n    if (remainderData) {\n      data = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__[\"appendUint8Array\"])(remainderData, data);\n      this.remainderData = null;\n    } // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\n\n\n    var currentChunk = this.getValidChunk(data);\n\n    if (!currentChunk.length) {\n      return null;\n    }\n\n    if (currentIV) {\n      iv = currentIV;\n    }\n\n    var softwareDecrypter = this.softwareDecrypter;\n\n    if (!softwareDecrypter) {\n      softwareDecrypter = this.softwareDecrypter = new _aes_decryptor__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n    }\n\n    softwareDecrypter.expandKey(key);\n    var result = currentResult;\n    this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\n    this.currentIV = Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__[\"sliceUint8\"])(currentChunk, -16).buffer;\n\n    if (!result) {\n      return null;\n    }\n\n    return result;\n  };\n\n  _proto.webCryptoDecrypt = function webCryptoDecrypt(data, key, iv) {\n    var _this = this;\n\n    var subtle = this.subtle;\n\n    if (this.key !== key || !this.fastAesKey) {\n      this.key = key;\n      this.fastAesKey = new _fast_aes_key__WEBPACK_IMPORTED_MODULE_1__[\"default\"](subtle, key);\n    }\n\n    return this.fastAesKey.expandKey().then(function (aesKey) {\n      // decrypt using web crypto\n      if (!subtle) {\n        return Promise.reject(new Error('web crypto not initialized'));\n      }\n\n      var crypto = new _aes_crypto__WEBPACK_IMPORTED_MODULE_0__[\"default\"](subtle, iv);\n      return crypto.decrypt(data.buffer, aesKey);\n    }).catch(function (err) {\n      return _this.onWebCryptoError(err, data, key, iv);\n    });\n  };\n\n  _proto.onWebCryptoError = function onWebCryptoError(err, data, key, iv) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn('[decrypter.ts]: WebCrypto Error, disable WebCrypto API:', err);\n    this.config.enableSoftwareAES = true;\n    this.logEnabled = true;\n    return this.softwareDecrypt(data, key, iv);\n  };\n\n  _proto.getValidChunk = function getValidChunk(data) {\n    var currentChunk = data;\n    var splitPoint = data.length - data.length % CHUNK_SIZE;\n\n    if (splitPoint !== data.length) {\n      currentChunk = Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__[\"sliceUint8\"])(data, 0, splitPoint);\n      this.remainderData = Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__[\"sliceUint8\"])(data, splitPoint);\n    }\n\n    return currentChunk;\n  };\n\n  _proto.logOnce = function logOnce(msg) {\n    if (!this.logEnabled) {\n      return;\n    }\n\n    _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].log(\"[decrypter.ts]: \" + msg);\n    this.logEnabled = false;\n  };\n\n  return Decrypter;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/crypt/fast-aes-key.ts\":\n/*!***********************************!*\\\n  !*** ./src/crypt/fast-aes-key.ts ***!\n  \\***********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_500059__) {\n\n\"use strict\";\n__nested_webpack_require_500059__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_500059__.d(__webpack_exports__, \"default\", function() { return FastAESKey; });\nvar FastAESKey = /*#__PURE__*/function () {\n  function FastAESKey(subtle, key) {\n    this.subtle = void 0;\n    this.key = void 0;\n    this.subtle = subtle;\n    this.key = key;\n  }\n\n  var _proto = FastAESKey.prototype;\n\n  _proto.expandKey = function expandKey() {\n    return this.subtle.importKey('raw', this.key, {\n      name: 'AES-CBC'\n    }, false, ['encrypt', 'decrypt']);\n  };\n\n  return FastAESKey;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/demux/aacdemuxer.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/aacdemuxer.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_500913__) {\n\n\"use strict\";\n__nested_webpack_require_500913__.r(__webpack_exports__);\n/* harmony import */ var _base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_500913__(/*! ./base-audio-demuxer */ \"./src/demux/base-audio-demuxer.ts\");\n/* harmony import */ var _adts__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_500913__(/*! ./adts */ \"./src/demux/adts.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_500913__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_500913__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * AAC demuxer\n */\n\n\n\n\n\nvar AACDemuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {\n  _inheritsLoose(AACDemuxer, _BaseAudioDemuxer);\n\n  function AACDemuxer(observer, config) {\n    var _this;\n\n    _this = _BaseAudioDemuxer.call(this) || this;\n    _this.observer = void 0;\n    _this.config = void 0;\n    _this.observer = observer;\n    _this.config = config;\n    return _this;\n  }\n\n  var _proto = AACDemuxer.prototype;\n\n  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);\n\n    this._audioTrack = {\n      container: 'audio/adts',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'aac',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  } // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n  ;\n\n  AACDemuxer.probe = function probe(data) {\n    if (!data) {\n      return false;\n    } // Check for the ADTS sync word\n    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n    // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n    // More info https://wiki.multimedia.cx/index.php?title=ADTS\n\n\n    var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_3__[\"getID3Data\"](data, 0) || [];\n    var offset = id3Data.length;\n\n    for (var length = data.length; offset < length; offset++) {\n      if (_adts__WEBPACK_IMPORTED_MODULE_1__[\"probe\"](data, offset)) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('ADTS sync word found !');\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  _proto.canParse = function canParse(data, offset) {\n    return _adts__WEBPACK_IMPORTED_MODULE_1__[\"canParse\"](data, offset);\n  };\n\n  _proto.appendFrame = function appendFrame(track, data, offset) {\n    _adts__WEBPACK_IMPORTED_MODULE_1__[\"initTrackConfig\"](track, this.observer, data, offset, track.manifestCodec);\n    var frame = _adts__WEBPACK_IMPORTED_MODULE_1__[\"appendFrame\"](track, data, offset, this.initPTS, this.frameIndex);\n\n    if (frame && frame.missing === 0) {\n      return frame;\n    }\n  };\n\n  return AACDemuxer;\n}(_base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\nAACDemuxer.minProbeByteLength = 9;\n/* harmony default export */ __webpack_exports__[\"default\"] = (AACDemuxer);\n\n/***/ }),\n\n/***/ \"./src/demux/adts.ts\":\n/*!***************************!*\\\n  !*** ./src/demux/adts.ts ***!\n  \\***************************/\n/*! exports provided: getAudioConfig, isHeaderPattern, getHeaderLength, getFullFrameLength, canGetFrameLength, isHeader, canParse, probe, initTrackConfig, getFrameDuration, parseFrameHeader, appendFrame */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_504810__) {\n\n\"use strict\";\n__nested_webpack_require_504810__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_504810__.d(__webpack_exports__, \"getAudioConfig\", function() { return getAudioConfig; });\n/* harmony export (binding) */ __nested_webpack_require_504810__.d(__webpack_exports__, \"isHeaderPattern\", function() { return isHeaderPattern; });\n/* harmony export (binding) */ __nested_webpack_require_504810__.d(__webpack_exports__, \"getHeaderLength\", function() { return getHeaderLength; });\n/* harmony export (binding) */ __nested_webpack_require_504810__.d(__webpack_exports__, \"getFullFrameLength\", function() { return getFullFrameLength; });\n/* harmony export (binding) */ __nested_webpack_require_504810__.d(__webpack_exports__, \"canGetFrameLength\", function() { return canGetFrameLength; });\n/* harmony export (binding) */ __nested_webpack_require_504810__.d(__webpack_exports__, \"isHeader\", function() { return isHeader; });\n/* harmony export (binding) */ __nested_webpack_require_504810__.d(__webpack_exports__, \"canParse\", function() { return canParse; });\n/* harmony export (binding) */ __nested_webpack_require_504810__.d(__webpack_exports__, \"probe\", function() { return probe; });\n/* harmony export (binding) */ __nested_webpack_require_504810__.d(__webpack_exports__, \"initTrackConfig\", function() { return initTrackConfig; });\n/* harmony export (binding) */ __nested_webpack_require_504810__.d(__webpack_exports__, \"getFrameDuration\", function() { return getFrameDuration; });\n/* harmony export (binding) */ __nested_webpack_require_504810__.d(__webpack_exports__, \"parseFrameHeader\", function() { return parseFrameHeader; });\n/* harmony export (binding) */ __nested_webpack_require_504810__.d(__webpack_exports__, \"appendFrame\", function() { return appendFrame; });\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_504810__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_504810__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_504810__(/*! ../events */ \"./src/events.ts\");\n/**\n * ADTS parser helper\n * @link https://wiki.multimedia.cx/index.php?title=ADTS\n */\n\n\n\nfunction getAudioConfig(observer, data, offset, audioCodec) {\n  var adtsObjectType;\n  var adtsExtensionSamplingIndex;\n  var adtsChanelConfig;\n  var config;\n  var userAgent = navigator.userAgent.toLowerCase();\n  var manifestCodec = audioCodec;\n  var adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350]; // byte 2\n\n  adtsObjectType = ((data[offset + 2] & 0xc0) >>> 6) + 1;\n  var adtsSamplingIndex = (data[offset + 2] & 0x3c) >>> 2;\n\n  if (adtsSamplingIndex > adtsSampleingRates.length - 1) {\n    observer.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, {\n      type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].MEDIA_ERROR,\n      details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].FRAG_PARSING_ERROR,\n      fatal: true,\n      reason: \"invalid ADTS sampling index:\" + adtsSamplingIndex\n    });\n    return;\n  }\n\n  adtsChanelConfig = (data[offset + 2] & 0x01) << 2; // byte 3\n\n  adtsChanelConfig |= (data[offset + 3] & 0xc0) >>> 6;\n  _utils_logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].log(\"manifest codec:\" + audioCodec + \", ADTS type:\" + adtsObjectType + \", samplingIndex:\" + adtsSamplingIndex); // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n\n  if (/firefox/i.test(userAgent)) {\n    if (adtsSamplingIndex >= 6) {\n      adtsObjectType = 5;\n      config = new Array(4); // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n      // there is a factor 2 between frame sample rate and output sample rate\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\n\n      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n    } else {\n      adtsObjectType = 2;\n      config = new Array(2);\n      adtsExtensionSamplingIndex = adtsSamplingIndex;\n    } // Android : always use AAC\n\n  } else if (userAgent.indexOf('android') !== -1) {\n    adtsObjectType = 2;\n    config = new Array(2);\n    adtsExtensionSamplingIndex = adtsSamplingIndex;\n  } else {\n    /*  for other browsers (Chrome/Vivaldi/Opera ...)\n        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\n    */\n    adtsObjectType = 5;\n    config = new Array(4); // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n\n    if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSamplingIndex >= 6) {\n      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n      // there is a factor 2 between frame sample rate and output sample rate\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\n      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n    } else {\n      // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)\n      // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.\n      if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSamplingIndex >= 6 && adtsChanelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChanelConfig === 1) {\n        adtsObjectType = 2;\n        config = new Array(2);\n      }\n\n      adtsExtensionSamplingIndex = adtsSamplingIndex;\n    }\n  }\n  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n      ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()\n    Audio Profile / Audio Object Type\n    0: Null\n    1: AAC Main\n    2: AAC LC (Low Complexity)\n    3: AAC SSR (Scalable Sample Rate)\n    4: AAC LTP (Long Term Prediction)\n    5: SBR (Spectral Band Replication)\n    6: AAC Scalable\n   sampling freq\n    0: 96000 Hz\n    1: 88200 Hz\n    2: 64000 Hz\n    3: 48000 Hz\n    4: 44100 Hz\n    5: 32000 Hz\n    6: 24000 Hz\n    7: 22050 Hz\n    8: 16000 Hz\n    9: 12000 Hz\n    10: 11025 Hz\n    11: 8000 Hz\n    12: 7350 Hz\n    13: Reserved\n    14: Reserved\n    15: frequency is written explictly\n    Channel Configurations\n    These are the channel configurations:\n    0: Defined in AOT Specifc Config\n    1: 1 channel: front-center\n    2: 2 channels: front-left, front-right\n  */\n  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n\n\n  config[0] = adtsObjectType << 3; // samplingFrequencyIndex\n\n  config[0] |= (adtsSamplingIndex & 0x0e) >> 1;\n  config[1] |= (adtsSamplingIndex & 0x01) << 7; // channelConfiguration\n\n  config[1] |= adtsChanelConfig << 3;\n\n  if (adtsObjectType === 5) {\n    // adtsExtensionSampleingIndex\n    config[1] |= (adtsExtensionSamplingIndex & 0x0e) >> 1;\n    config[2] = (adtsExtensionSamplingIndex & 0x01) << 7; // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\n    //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n\n    config[2] |= 2 << 2;\n    config[3] = 0;\n  }\n\n  return {\n    config: config,\n    samplerate: adtsSampleingRates[adtsSamplingIndex],\n    channelCount: adtsChanelConfig,\n    codec: 'mp4a.40.' + adtsObjectType,\n    manifestCodec: manifestCodec\n  };\n}\nfunction isHeaderPattern(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n}\nfunction getHeaderLength(data, offset) {\n  return data[offset + 1] & 0x01 ? 7 : 9;\n}\nfunction getFullFrameLength(data, offset) {\n  return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;\n}\nfunction canGetFrameLength(data, offset) {\n  return offset + 5 < data.length;\n}\nfunction isHeader(data, offset) {\n  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n  // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n  // More info https://wiki.multimedia.cx/index.php?title=ADTS\n  return offset + 1 < data.length && isHeaderPattern(data, offset);\n}\nfunction canParse(data, offset) {\n  return canGetFrameLength(data, offset) && isHeaderPattern(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;\n}\nfunction probe(data, offset) {\n  // same as isHeader but we also check that ADTS frame follows last ADTS frame\n  // or end of data is reached\n  if (isHeader(data, offset)) {\n    // ADTS header Length\n    var headerLength = getHeaderLength(data, offset);\n\n    if (offset + headerLength >= data.length) {\n      return false;\n    } // ADTS frame Length\n\n\n    var frameLength = getFullFrameLength(data, offset);\n\n    if (frameLength <= headerLength) {\n      return false;\n    }\n\n    var newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader(data, newOffset);\n  }\n\n  return false;\n}\nfunction initTrackConfig(track, observer, data, offset, audioCodec) {\n  if (!track.samplerate) {\n    var config = getAudioConfig(observer, data, offset, audioCodec);\n\n    if (!config) {\n      return;\n    }\n\n    track.config = config.config;\n    track.samplerate = config.samplerate;\n    track.channelCount = config.channelCount;\n    track.codec = config.codec;\n    track.manifestCodec = config.manifestCodec;\n    _utils_logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].log(\"parsed codec:\" + track.codec + \", rate:\" + config.samplerate + \", channels:\" + config.channelCount);\n  }\n}\nfunction getFrameDuration(samplerate) {\n  return 1024 * 90000 / samplerate;\n}\nfunction parseFrameHeader(data, offset) {\n  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n  var headerLength = getHeaderLength(data, offset);\n\n  if (offset + headerLength <= data.length) {\n    // retrieve frame size\n    var frameLength = getFullFrameLength(data, offset) - headerLength;\n\n    if (frameLength > 0) {\n      // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}`);\n      return {\n        headerLength: headerLength,\n        frameLength: frameLength\n      };\n    }\n  }\n}\nfunction appendFrame(track, data, offset, pts, frameIndex) {\n  var frameDuration = getFrameDuration(track.samplerate);\n  var stamp = pts + frameIndex * frameDuration;\n  var header = parseFrameHeader(data, offset);\n  var unit;\n\n  if (header) {\n    var frameLength = header.frameLength,\n        headerLength = header.headerLength;\n\n    var _length = headerLength + frameLength;\n\n    var missing = Math.max(0, offset + _length - data.length); // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);\n\n    if (missing) {\n      unit = new Uint8Array(_length - headerLength);\n      unit.set(data.subarray(offset + headerLength, data.length), 0);\n    } else {\n      unit = data.subarray(offset + headerLength, offset + _length);\n    }\n\n    var _sample = {\n      unit: unit,\n      pts: stamp\n    };\n\n    if (!missing) {\n      track.samples.push(_sample);\n    }\n\n    return {\n      sample: _sample,\n      length: _length,\n      missing: missing\n    };\n  } // overflow incomplete header\n\n\n  var length = data.length - offset;\n  unit = new Uint8Array(length);\n  unit.set(data.subarray(offset, data.length), 0);\n  var sample = {\n    unit: unit,\n    pts: stamp\n  };\n  return {\n    sample: sample,\n    length: length,\n    missing: -1\n  };\n}\n\n/***/ }),\n\n/***/ \"./src/demux/base-audio-demuxer.ts\":\n/*!*****************************************!*\\\n  !*** ./src/demux/base-audio-demuxer.ts ***!\n  \\*****************************************/\n/*! exports provided: initPTSFn, default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_516536__) {\n\n\"use strict\";\n__nested_webpack_require_516536__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_516536__.d(__webpack_exports__, \"initPTSFn\", function() { return initPTSFn; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_516536__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_516536__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\n/* harmony import */ var _types_demuxer__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_516536__(/*! ../types/demuxer */ \"./src/types/demuxer.ts\");\n/* harmony import */ var _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_516536__(/*! ./dummy-demuxed-track */ \"./src/demux/dummy-demuxed-track.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_516536__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _utils_typed_array__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_516536__(/*! ../utils/typed-array */ \"./src/utils/typed-array.ts\");\n\n\n\n\n\n\n\nvar BaseAudioDemuxer = /*#__PURE__*/function () {\n  function BaseAudioDemuxer() {\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this.frameIndex = 0;\n    this.cachedData = null;\n    this.initPTS = null;\n  }\n\n  var _proto = BaseAudioDemuxer.prototype;\n\n  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    this._id3Track = {\n      type: 'id3',\n      id: 3,\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0\n    };\n  };\n\n  _proto.resetTimeStamp = function resetTimeStamp() {};\n\n  _proto.resetContiguity = function resetContiguity() {};\n\n  _proto.canParse = function canParse(data, offset) {\n    return false;\n  };\n\n  _proto.appendFrame = function appendFrame(track, data, offset) {} // feed incoming data to the front of the parsing pipeline\n  ;\n\n  _proto.demux = function demux(data, timeOffset) {\n    if (this.cachedData) {\n      data = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__[\"appendUint8Array\"])(this.cachedData, data);\n      this.cachedData = null;\n    }\n\n    var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__[\"getID3Data\"](data, 0);\n    var offset = id3Data ? id3Data.length : 0;\n    var lastDataIndex;\n    var pts;\n    var track = this._audioTrack;\n    var id3Track = this._id3Track;\n    var timestamp = id3Data ? _demux_id3__WEBPACK_IMPORTED_MODULE_1__[\"getTimeStamp\"](id3Data) : undefined;\n    var length = data.length;\n\n    if (this.frameIndex === 0 || this.initPTS === null) {\n      this.initPTS = initPTSFn(timestamp, timeOffset);\n    } // more expressive than alternative: id3Data?.length\n\n\n    if (id3Data && id3Data.length > 0) {\n      id3Track.samples.push({\n        pts: this.initPTS,\n        dts: this.initPTS,\n        data: id3Data,\n        type: _types_demuxer__WEBPACK_IMPORTED_MODULE_2__[\"MetadataSchema\"].audioId3\n      });\n    }\n\n    pts = this.initPTS;\n\n    while (offset < length) {\n      if (this.canParse(data, offset)) {\n        var frame = this.appendFrame(track, data, offset);\n\n        if (frame) {\n          this.frameIndex++;\n          pts = frame.sample.pts;\n          offset += frame.length;\n          lastDataIndex = offset;\n        } else {\n          offset = length;\n        }\n      } else if (_demux_id3__WEBPACK_IMPORTED_MODULE_1__[\"canParse\"](data, offset)) {\n        // after a ID3.canParse, a call to ID3.getID3Data *should* always returns some data\n        id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__[\"getID3Data\"](data, offset);\n        id3Track.samples.push({\n          pts: pts,\n          dts: pts,\n          data: id3Data,\n          type: _types_demuxer__WEBPACK_IMPORTED_MODULE_2__[\"MetadataSchema\"].audioId3\n        });\n        offset += id3Data.length;\n        lastDataIndex = offset;\n      } else {\n        offset++;\n      }\n\n      if (offset === length && lastDataIndex !== length) {\n        var partialData = Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__[\"sliceUint8\"])(data, lastDataIndex);\n\n        if (this.cachedData) {\n          this.cachedData = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__[\"appendUint8Array\"])(this.cachedData, partialData);\n        } else {\n          this.cachedData = partialData;\n        }\n      }\n    }\n\n    return {\n      audioTrack: track,\n      videoTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__[\"dummyTrack\"])(),\n      id3Track: id3Track,\n      textTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__[\"dummyTrack\"])()\n    };\n  };\n\n  _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error(\"[\" + this + \"] This demuxer does not support Sample-AES decryption\"));\n  };\n\n  _proto.flush = function flush(timeOffset) {\n    // Parse cache in case of remaining frames.\n    var cachedData = this.cachedData;\n\n    if (cachedData) {\n      this.cachedData = null;\n      this.demux(cachedData, 0);\n    }\n\n    this.frameIndex = 0;\n    return {\n      audioTrack: this._audioTrack,\n      videoTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__[\"dummyTrack\"])(),\n      id3Track: this._id3Track,\n      textTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__[\"dummyTrack\"])()\n    };\n  };\n\n  _proto.destroy = function destroy() {};\n\n  return BaseAudioDemuxer;\n}();\n/**\n * Initialize PTS\n * <p>\n *    use timestamp unless it is undefined, NaN or Infinity\n * </p>\n */\n\n\nvar initPTSFn = function initPTSFn(timestamp, timeOffset) {\n  return Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(timestamp) ? timestamp * 90 : timeOffset * 90000;\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (BaseAudioDemuxer);\n\n/***/ }),\n\n/***/ \"./src/demux/chunk-cache.ts\":\n/*!**********************************!*\\\n  !*** ./src/demux/chunk-cache.ts ***!\n  \\**********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_522648__) {\n\n\"use strict\";\n__nested_webpack_require_522648__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_522648__.d(__webpack_exports__, \"default\", function() { return ChunkCache; });\nvar ChunkCache = /*#__PURE__*/function () {\n  function ChunkCache() {\n    this.chunks = [];\n    this.dataLength = 0;\n  }\n\n  var _proto = ChunkCache.prototype;\n\n  _proto.push = function push(chunk) {\n    this.chunks.push(chunk);\n    this.dataLength += chunk.length;\n  };\n\n  _proto.flush = function flush() {\n    var chunks = this.chunks,\n        dataLength = this.dataLength;\n    var result;\n\n    if (!chunks.length) {\n      return new Uint8Array(0);\n    } else if (chunks.length === 1) {\n      result = chunks[0];\n    } else {\n      result = concatUint8Arrays(chunks, dataLength);\n    }\n\n    this.reset();\n    return result;\n  };\n\n  _proto.reset = function reset() {\n    this.chunks.length = 0;\n    this.dataLength = 0;\n  };\n\n  return ChunkCache;\n}();\n\n\n\nfunction concatUint8Arrays(chunks, dataLength) {\n  var result = new Uint8Array(dataLength);\n  var offset = 0;\n\n  for (var i = 0; i < chunks.length; i++) {\n    var chunk = chunks[i];\n    result.set(chunk, offset);\n    offset += chunk.length;\n  }\n\n  return result;\n}\n\n/***/ }),\n\n/***/ \"./src/demux/dummy-demuxed-track.ts\":\n/*!******************************************!*\\\n  !*** ./src/demux/dummy-demuxed-track.ts ***!\n  \\******************************************/\n/*! exports provided: dummyTrack */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_524151__) {\n\n\"use strict\";\n__nested_webpack_require_524151__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_524151__.d(__webpack_exports__, \"dummyTrack\", function() { return dummyTrack; });\nfunction dummyTrack(type, inputTimeScale) {\n  if (type === void 0) {\n    type = '';\n  }\n\n  if (inputTimeScale === void 0) {\n    inputTimeScale = 90000;\n  }\n\n  return {\n    type: type,\n    id: -1,\n    pid: -1,\n    inputTimeScale: inputTimeScale,\n    sequenceNumber: -1,\n    samples: [],\n    dropped: 0\n  };\n}\n\n/***/ }),\n\n/***/ \"./src/demux/exp-golomb.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/exp-golomb.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_524906__) {\n\n\"use strict\";\n__nested_webpack_require_524906__.r(__webpack_exports__);\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_524906__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n */\n\n\nvar ExpGolomb = /*#__PURE__*/function () {\n  function ExpGolomb(data) {\n    this.data = void 0;\n    this.bytesAvailable = void 0;\n    this.word = void 0;\n    this.bitsAvailable = void 0;\n    this.data = data; // the number of bytes left to examine in this.data\n\n    this.bytesAvailable = data.byteLength; // the current word being examined\n\n    this.word = 0; // :uint\n    // the number of bits left to examine in the current word\n\n    this.bitsAvailable = 0; // :uint\n  } // ():void\n\n\n  var _proto = ExpGolomb.prototype;\n\n  _proto.loadWord = function loadWord() {\n    var data = this.data;\n    var bytesAvailable = this.bytesAvailable;\n    var position = data.byteLength - bytesAvailable;\n    var workingBytes = new Uint8Array(4);\n    var availableBytes = Math.min(4, bytesAvailable);\n\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n\n    workingBytes.set(data.subarray(position, position + availableBytes));\n    this.word = new DataView(workingBytes.buffer).getUint32(0); // track the amount of this.data that has been processed\n\n    this.bitsAvailable = availableBytes * 8;\n    this.bytesAvailable -= availableBytes;\n  } // (count:int):void\n  ;\n\n  _proto.skipBits = function skipBits(count) {\n    var skipBytes; // :int\n\n    if (this.bitsAvailable > count) {\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    } else {\n      count -= this.bitsAvailable;\n      skipBytes = count >> 3;\n      count -= skipBytes >> 3;\n      this.bytesAvailable -= skipBytes;\n      this.loadWord();\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    }\n  } // (size:int):uint\n  ;\n\n  _proto.readBits = function readBits(size) {\n    var bits = Math.min(this.bitsAvailable, size); // :uint\n\n    var valu = this.word >>> 32 - bits; // :uint\n\n    if (size > 32) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].error('Cannot read more than 32 bits at a time');\n    }\n\n    this.bitsAvailable -= bits;\n\n    if (this.bitsAvailable > 0) {\n      this.word <<= bits;\n    } else if (this.bytesAvailable > 0) {\n      this.loadWord();\n    }\n\n    bits = size - bits;\n\n    if (bits > 0 && this.bitsAvailable) {\n      return valu << bits | this.readBits(bits);\n    } else {\n      return valu;\n    }\n  } // ():uint\n  ;\n\n  _proto.skipLZ = function skipLZ() {\n    var leadingZeroCount; // :uint\n\n    for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {\n      if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {\n        // the first bit of working word is 1\n        this.word <<= leadingZeroCount;\n        this.bitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    } // we exhausted word and still have not found a 1\n\n\n    this.loadWord();\n    return leadingZeroCount + this.skipLZ();\n  } // ():void\n  ;\n\n  _proto.skipUEG = function skipUEG() {\n    this.skipBits(1 + this.skipLZ());\n  } // ():void\n  ;\n\n  _proto.skipEG = function skipEG() {\n    this.skipBits(1 + this.skipLZ());\n  } // ():uint\n  ;\n\n  _proto.readUEG = function readUEG() {\n    var clz = this.skipLZ(); // :uint\n\n    return this.readBits(clz + 1) - 1;\n  } // ():int\n  ;\n\n  _proto.readEG = function readEG() {\n    var valu = this.readUEG(); // :int\n\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n    } else {\n      return -1 * (valu >>> 1); // divide by two then make it negative\n    }\n  } // Some convenience functions\n  // :Boolean\n  ;\n\n  _proto.readBoolean = function readBoolean() {\n    return this.readBits(1) === 1;\n  } // ():int\n  ;\n\n  _proto.readUByte = function readUByte() {\n    return this.readBits(8);\n  } // ():int\n  ;\n\n  _proto.readUShort = function readUShort() {\n    return this.readBits(16);\n  } // ():int\n  ;\n\n  _proto.readUInt = function readUInt() {\n    return this.readBits(32);\n  }\n  /**\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\n   * list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count the number of entries in this scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */\n  ;\n\n  _proto.skipScalingList = function skipScalingList(count) {\n    var lastScale = 8;\n    var nextScale = 8;\n    var deltaScale;\n\n    for (var j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = this.readEG();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n\n      lastScale = nextScale === 0 ? lastScale : nextScale;\n    }\n  }\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @param data {Uint8Array} the bytes of a sequence parameter set\n   * @return {object} an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */\n  ;\n\n  _proto.readSPS = function readSPS() {\n    var frameCropLeftOffset = 0;\n    var frameCropRightOffset = 0;\n    var frameCropTopOffset = 0;\n    var frameCropBottomOffset = 0;\n    var numRefFramesInPicOrderCntCycle;\n    var scalingListCount;\n    var i;\n    var readUByte = this.readUByte.bind(this);\n    var readBits = this.readBits.bind(this);\n    var readUEG = this.readUEG.bind(this);\n    var readBoolean = this.readBoolean.bind(this);\n    var skipBits = this.skipBits.bind(this);\n    var skipEG = this.skipEG.bind(this);\n    var skipUEG = this.skipUEG.bind(this);\n    var skipScalingList = this.skipScalingList.bind(this);\n    readUByte();\n    var profileIdc = readUByte(); // profile_idc\n\n    readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\n\n    skipBits(3); // reserved_zero_3bits u(3),\n\n    readUByte(); // level_idc u(8)\n\n    skipUEG(); // seq_parameter_set_id\n    // some profiles have more optional data we don't need\n\n    if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {\n      var chromaFormatIdc = readUEG();\n\n      if (chromaFormatIdc === 3) {\n        skipBits(1);\n      } // separate_colour_plane_flag\n\n\n      skipUEG(); // bit_depth_luma_minus8\n\n      skipUEG(); // bit_depth_chroma_minus8\n\n      skipBits(1); // qpprime_y_zero_transform_bypass_flag\n\n      if (readBoolean()) {\n        // seq_scaling_matrix_present_flag\n        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n\n        for (i = 0; i < scalingListCount; i++) {\n          if (readBoolean()) {\n            // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              skipScalingList(16);\n            } else {\n              skipScalingList(64);\n            }\n          }\n        }\n      }\n    }\n\n    skipUEG(); // log2_max_frame_num_minus4\n\n    var picOrderCntType = readUEG();\n\n    if (picOrderCntType === 0) {\n      readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      skipBits(1); // delta_pic_order_always_zero_flag\n\n      skipEG(); // offset_for_non_ref_pic\n\n      skipEG(); // offset_for_top_to_bottom_field\n\n      numRefFramesInPicOrderCntCycle = readUEG();\n\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        skipEG();\n      } // offset_for_ref_frame[ i ]\n\n    }\n\n    skipUEG(); // max_num_ref_frames\n\n    skipBits(1); // gaps_in_frame_num_value_allowed_flag\n\n    var picWidthInMbsMinus1 = readUEG();\n    var picHeightInMapUnitsMinus1 = readUEG();\n    var frameMbsOnlyFlag = readBits(1);\n\n    if (frameMbsOnlyFlag === 0) {\n      skipBits(1);\n    } // mb_adaptive_frame_field_flag\n\n\n    skipBits(1); // direct_8x8_inference_flag\n\n    if (readBoolean()) {\n      // frame_cropping_flag\n      frameCropLeftOffset = readUEG();\n      frameCropRightOffset = readUEG();\n      frameCropTopOffset = readUEG();\n      frameCropBottomOffset = readUEG();\n    }\n\n    var pixelRatio = [1, 1];\n\n    if (readBoolean()) {\n      // vui_parameters_present_flag\n      if (readBoolean()) {\n        // aspect_ratio_info_present_flag\n        var aspectRatioIdc = readUByte();\n\n        switch (aspectRatioIdc) {\n          case 1:\n            pixelRatio = [1, 1];\n            break;\n\n          case 2:\n            pixelRatio = [12, 11];\n            break;\n\n          case 3:\n            pixelRatio = [10, 11];\n            break;\n\n          case 4:\n            pixelRatio = [16, 11];\n            break;\n\n          case 5:\n            pixelRatio = [40, 33];\n            break;\n\n          case 6:\n            pixelRatio = [24, 11];\n            break;\n\n          case 7:\n            pixelRatio = [20, 11];\n            break;\n\n          case 8:\n            pixelRatio = [32, 11];\n            break;\n\n          case 9:\n            pixelRatio = [80, 33];\n            break;\n\n          case 10:\n            pixelRatio = [18, 11];\n            break;\n\n          case 11:\n            pixelRatio = [15, 11];\n            break;\n\n          case 12:\n            pixelRatio = [64, 33];\n            break;\n\n          case 13:\n            pixelRatio = [160, 99];\n            break;\n\n          case 14:\n            pixelRatio = [4, 3];\n            break;\n\n          case 15:\n            pixelRatio = [3, 2];\n            break;\n\n          case 16:\n            pixelRatio = [2, 1];\n            break;\n\n          case 255:\n            {\n              pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];\n              break;\n            }\n        }\n      }\n    }\n\n    return {\n      width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n      height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n      pixelRatio: pixelRatio\n    };\n  };\n\n  _proto.readSliceType = function readSliceType() {\n    // skip NALu type\n    this.readUByte(); // discard first_mb_in_slice\n\n    this.readUEG(); // return slice_type\n\n    return this.readUEG();\n  };\n\n  return ExpGolomb;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ExpGolomb);\n\n/***/ }),\n\n/***/ \"./src/demux/id3.ts\":\n/*!**************************!*\\\n  !*** ./src/demux/id3.ts ***!\n  \\**************************/\n/*! exports provided: isHeader, isFooter, getID3Data, canParse, getTimeStamp, isTimeStampFrame, getID3Frames, decodeFrame, utf8ArrayToStr, testables */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_535747__) {\n\n\"use strict\";\n__nested_webpack_require_535747__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_535747__.d(__webpack_exports__, \"isHeader\", function() { return isHeader; });\n/* harmony export (binding) */ __nested_webpack_require_535747__.d(__webpack_exports__, \"isFooter\", function() { return isFooter; });\n/* harmony export (binding) */ __nested_webpack_require_535747__.d(__webpack_exports__, \"getID3Data\", function() { return getID3Data; });\n/* harmony export (binding) */ __nested_webpack_require_535747__.d(__webpack_exports__, \"canParse\", function() { return canParse; });\n/* harmony export (binding) */ __nested_webpack_require_535747__.d(__webpack_exports__, \"getTimeStamp\", function() { return getTimeStamp; });\n/* harmony export (binding) */ __nested_webpack_require_535747__.d(__webpack_exports__, \"isTimeStampFrame\", function() { return isTimeStampFrame; });\n/* harmony export (binding) */ __nested_webpack_require_535747__.d(__webpack_exports__, \"getID3Frames\", function() { return getID3Frames; });\n/* harmony export (binding) */ __nested_webpack_require_535747__.d(__webpack_exports__, \"decodeFrame\", function() { return decodeFrame; });\n/* harmony export (binding) */ __nested_webpack_require_535747__.d(__webpack_exports__, \"utf8ArrayToStr\", function() { return utf8ArrayToStr; });\n/* harmony export (binding) */ __nested_webpack_require_535747__.d(__webpack_exports__, \"testables\", function() { return testables; });\n// breaking up those two types in order to clarify what is happening in the decoding path.\n\n/**\n * Returns true if an ID3 header can be found at offset in data\n * @param {Uint8Array} data - The data to search in\n * @param {number} offset - The offset at which to start searching\n * @return {boolean} - True if an ID3 header is found\n */\nvar isHeader = function isHeader(data, offset) {\n  /*\n   * http://id3.org/id3v2.3.0\n   * [0]     = 'I'\n   * [1]     = 'D'\n   * [2]     = '3'\n   * [3,4]   = {Version}\n   * [5]     = {Flags}\n   * [6-9]   = {ID3 Size}\n   *\n   * An ID3v2 tag can be detected with the following pattern:\n   *  $49 44 33 yy yy xx zz zz zz zz\n   * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n   */\n  if (offset + 10 <= data.length) {\n    // look for 'ID3' identifier\n    if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Returns true if an ID3 footer can be found at offset in data\n * @param {Uint8Array} data - The data to search in\n * @param {number} offset - The offset at which to start searching\n * @return {boolean} - True if an ID3 footer is found\n */\n\nvar isFooter = function isFooter(data, offset) {\n  /*\n   * The footer is a copy of the header, but with a different identifier\n   */\n  if (offset + 10 <= data.length) {\n    // look for '3DI' identifier\n    if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n * @param {Uint8Array} data - The data to search in\n * @param {number} offset - The offset at which to start searching\n * @return {Uint8Array | undefined} - The block of data containing any ID3 tags found\n * or *undefined* if no header is found at the starting offset\n */\n\nvar getID3Data = function getID3Data(data, offset) {\n  var front = offset;\n  var length = 0;\n\n  while (isHeader(data, offset)) {\n    // ID3 header is 10 bytes\n    length += 10;\n    var size = readSize(data, offset + 6);\n    length += size;\n\n    if (isFooter(data, offset + 10)) {\n      // ID3 footer is 10 bytes\n      length += 10;\n    }\n\n    offset += length;\n  }\n\n  if (length > 0) {\n    return data.subarray(front, front + length);\n  }\n\n  return undefined;\n};\n\nvar readSize = function readSize(data, offset) {\n  var size = 0;\n  size = (data[offset] & 0x7f) << 21;\n  size |= (data[offset + 1] & 0x7f) << 14;\n  size |= (data[offset + 2] & 0x7f) << 7;\n  size |= data[offset + 3] & 0x7f;\n  return size;\n};\n\nvar canParse = function canParse(data, offset) {\n  return isHeader(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;\n};\n/**\n * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n * @param {Uint8Array} data - Block of data containing one or more ID3 tags\n * @return {number | undefined} - The timestamp\n */\n\nvar getTimeStamp = function getTimeStamp(data) {\n  var frames = getID3Frames(data);\n\n  for (var i = 0; i < frames.length; i++) {\n    var frame = frames[i];\n\n    if (isTimeStampFrame(frame)) {\n      return readTimeStamp(frame);\n    }\n  }\n\n  return undefined;\n};\n/**\n * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n * @param {ID3 frame} frame\n */\n\nvar isTimeStampFrame = function isTimeStampFrame(frame) {\n  return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';\n};\n\nvar getFrameData = function getFrameData(data) {\n  /*\n  Frame ID       $xx xx xx xx (four characters)\n  Size           $xx xx xx xx\n  Flags          $xx xx\n  */\n  var type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n  var size = readSize(data, 4); // skip frame id, size, and flags\n\n  var offset = 10;\n  return {\n    type: type,\n    size: size,\n    data: data.subarray(offset, offset + size)\n  };\n};\n/**\n * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n * @param {Uint8Array} id3Data - The ID3 data containing one or more ID3 tags\n * @return {ID3.Frame[]} - Array of ID3 frame objects\n */\n\n\nvar getID3Frames = function getID3Frames(id3Data) {\n  var offset = 0;\n  var frames = [];\n\n  while (isHeader(id3Data, offset)) {\n    var size = readSize(id3Data, offset + 6); // skip past ID3 header\n\n    offset += 10;\n    var end = offset + size; // loop through frames in the ID3 tag\n\n    while (offset + 8 < end) {\n      var frameData = getFrameData(id3Data.subarray(offset));\n      var frame = decodeFrame(frameData);\n\n      if (frame) {\n        frames.push(frame);\n      } // skip frame header and frame data\n\n\n      offset += frameData.size + 10;\n    }\n\n    if (isFooter(id3Data, offset)) {\n      offset += 10;\n    }\n  }\n\n  return frames;\n};\nvar decodeFrame = function decodeFrame(frame) {\n  if (frame.type === 'PRIV') {\n    return decodePrivFrame(frame);\n  } else if (frame.type[0] === 'W') {\n    return decodeURLFrame(frame);\n  }\n\n  return decodeTextFrame(frame);\n};\n\nvar decodePrivFrame = function decodePrivFrame(frame) {\n  /*\n  Format: <text string>\\0<binary data>\n  */\n  if (frame.size < 2) {\n    return undefined;\n  }\n\n  var owner = utf8ArrayToStr(frame.data, true);\n  var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n  return {\n    key: frame.type,\n    info: owner,\n    data: privateData.buffer\n  };\n};\n\nvar decodeTextFrame = function decodeTextFrame(frame) {\n  if (frame.size < 2) {\n    return undefined;\n  }\n\n  if (frame.type === 'TXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{Value}\n    */\n    var index = 1;\n    var description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    var value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0]   = {Text Encoding}\n  [1-?] = {Value}\n  */\n\n\n  var text = utf8ArrayToStr(frame.data.subarray(1));\n  return {\n    key: frame.type,\n    data: text\n  };\n};\n\nvar decodeURLFrame = function decodeURLFrame(frame) {\n  if (frame.type === 'WXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{URL}\n    */\n    if (frame.size < 2) {\n      return undefined;\n    }\n\n    var index = 1;\n    var description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    var value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0-?] = {URL}\n  */\n\n\n  var url = utf8ArrayToStr(frame.data);\n  return {\n    key: frame.type,\n    data: url\n  };\n};\n\nvar readTimeStamp = function readTimeStamp(timeStampFrame) {\n  if (timeStampFrame.data.byteLength === 8) {\n    var data = new Uint8Array(timeStampFrame.data); // timestamp is 33 bit expressed as a big-endian eight-octet number,\n    // with the upper 31 bits set to zero.\n\n    var pts33Bit = data[3] & 0x1;\n    var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\n    timestamp /= 45;\n\n    if (pts33Bit) {\n      timestamp += 47721858.84;\n    } // 2^32 / 90\n\n\n    return Math.round(timestamp);\n  }\n\n  return undefined;\n}; // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n\n/* utf.js - UTF-8 <=> UTF-16 convertion\n *\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */\n\n\nvar utf8ArrayToStr = function utf8ArrayToStr(array, exitOnNull) {\n  if (exitOnNull === void 0) {\n    exitOnNull = false;\n  }\n\n  var decoder = getTextDecoder();\n\n  if (decoder) {\n    var decoded = decoder.decode(array);\n\n    if (exitOnNull) {\n      // grab up to the first null\n      var idx = decoded.indexOf('\\0');\n      return idx !== -1 ? decoded.substring(0, idx) : decoded;\n    } // remove any null characters\n\n\n    return decoded.replace(/\\0/g, '');\n  }\n\n  var len = array.length;\n  var c;\n  var char2;\n  var char3;\n  var out = '';\n  var i = 0;\n\n  while (i < len) {\n    c = array[i++];\n\n    if (c === 0x00 && exitOnNull) {\n      return out;\n    } else if (c === 0x00 || c === 0x03) {\n      // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it\n      continue;\n    }\n\n    switch (c >> 4) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        // 0xxxxxxx\n        out += String.fromCharCode(c);\n        break;\n\n      case 12:\n      case 13:\n        // 110x xxxx   10xx xxxx\n        char2 = array[i++];\n        out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);\n        break;\n\n      case 14:\n        // 1110 xxxx  10xx xxxx  10xx xxxx\n        char2 = array[i++];\n        char3 = array[i++];\n        out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);\n        break;\n\n      default:\n    }\n  }\n\n  return out;\n};\nvar testables = {\n  decodeTextFrame: decodeTextFrame\n};\nvar decoder;\n\nfunction getTextDecoder() {\n  if (!decoder && typeof self.TextDecoder !== 'undefined') {\n    decoder = new self.TextDecoder('utf-8');\n  }\n\n  return decoder;\n}\n\n/***/ }),\n\n/***/ \"./src/demux/mp3demuxer.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/mp3demuxer.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_547169__) {\n\n\"use strict\";\n__nested_webpack_require_547169__.r(__webpack_exports__);\n/* harmony import */ var _base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_547169__(/*! ./base-audio-demuxer */ \"./src/demux/base-audio-demuxer.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_547169__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_547169__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _mpegaudio__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_547169__(/*! ./mpegaudio */ \"./src/demux/mpegaudio.ts\");\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * MP3 demuxer\n */\n\n\n\n\n\nvar MP3Demuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {\n  _inheritsLoose(MP3Demuxer, _BaseAudioDemuxer);\n\n  function MP3Demuxer() {\n    return _BaseAudioDemuxer.apply(this, arguments) || this;\n  }\n\n  var _proto = MP3Demuxer.prototype;\n\n  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);\n\n    this._audioTrack = {\n      container: 'audio/mpeg',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'mp3',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  };\n\n  MP3Demuxer.probe = function probe(data) {\n    if (!data) {\n      return false;\n    } // check if data contains ID3 timestamp and MPEG sync word\n    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n    // More info http://www.mp3-tech.org/programmer/frame_header.html\n\n\n    var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__[\"getID3Data\"](data, 0) || [];\n    var offset = id3Data.length;\n\n    for (var length = data.length; offset < length; offset++) {\n      if (_mpegaudio__WEBPACK_IMPORTED_MODULE_3__[\"probe\"](data, offset)) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('MPEG Audio sync word found !');\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  _proto.canParse = function canParse(data, offset) {\n    return _mpegaudio__WEBPACK_IMPORTED_MODULE_3__[\"canParse\"](data, offset);\n  };\n\n  _proto.appendFrame = function appendFrame(track, data, offset) {\n    if (this.initPTS === null) {\n      return;\n    }\n\n    return _mpegaudio__WEBPACK_IMPORTED_MODULE_3__[\"appendFrame\"](track, data, offset, this.initPTS, this.frameIndex);\n  };\n\n  return MP3Demuxer;\n}(_base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\nMP3Demuxer.minProbeByteLength = 4;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MP3Demuxer);\n\n/***/ }),\n\n/***/ \"./src/demux/mp4demuxer.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/mp4demuxer.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_550684__) {\n\n\"use strict\";\n__nested_webpack_require_550684__.r(__webpack_exports__);\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_550684__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _types_demuxer__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_550684__(/*! ../types/demuxer */ \"./src/types/demuxer.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_550684__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_550684__(/*! ./dummy-demuxed-track */ \"./src/demux/dummy-demuxed-track.ts\");\n\n\n/**\n * MP4 demuxer\n */\n\n\n\nvar emsgSchemePattern = /\\/emsg[-/]ID3/i;\n\nvar MP4Demuxer = /*#__PURE__*/function () {\n  function MP4Demuxer(observer, config) {\n    this.remainderData = null;\n    this.timeOffset = 0;\n    this.config = void 0;\n    this.videoTrack = void 0;\n    this.audioTrack = void 0;\n    this.id3Track = void 0;\n    this.txtTrack = void 0;\n    this.config = config;\n  }\n\n  var _proto = MP4Demuxer.prototype;\n\n  _proto.resetTimeStamp = function resetTimeStamp() {};\n\n  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    var initData = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__[\"parseInitSegment\"])(initSegment);\n    var videoTrack = this.videoTrack = Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__[\"dummyTrack\"])('video', 1);\n    var audioTrack = this.audioTrack = Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__[\"dummyTrack\"])('audio', 1);\n    var captionTrack = this.txtTrack = Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__[\"dummyTrack\"])('text', 1);\n    this.id3Track = Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__[\"dummyTrack\"])('id3', 1);\n    this.timeOffset = 0;\n\n    if (initData.video) {\n      var _initData$video = initData.video,\n          id = _initData$video.id,\n          timescale = _initData$video.timescale,\n          codec = _initData$video.codec;\n      videoTrack.id = id;\n      videoTrack.timescale = captionTrack.timescale = timescale;\n      videoTrack.codec = codec;\n    }\n\n    if (initData.audio) {\n      var _initData$audio = initData.audio,\n          _id = _initData$audio.id,\n          _timescale = _initData$audio.timescale,\n          _codec = _initData$audio.codec;\n      audioTrack.id = _id;\n      audioTrack.timescale = _timescale;\n      audioTrack.codec = _codec;\n    }\n\n    captionTrack.id = _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__[\"RemuxerTrackIdConfig\"].text;\n    videoTrack.sampleDuration = 0;\n    videoTrack.duration = audioTrack.duration = trackDuration;\n  };\n\n  _proto.resetContiguity = function resetContiguity() {};\n\n  MP4Demuxer.probe = function probe(data) {\n    // ensure we find a moof box in the first 16 kB\n    data = data.length > 16384 ? data.subarray(0, 16384) : data;\n    return Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__[\"findBox\"])(data, ['moof']).length > 0;\n  };\n\n  _proto.demux = function demux(data, timeOffset) {\n    this.timeOffset = timeOffset; // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter\n\n    var videoSamples = data;\n    var videoTrack = this.videoTrack;\n    var textTrack = this.txtTrack;\n\n    if (this.config.progressive) {\n      // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.\n      // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee\n      // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.\n      if (this.remainderData) {\n        videoSamples = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__[\"appendUint8Array\"])(this.remainderData, data);\n      }\n\n      var segmentedData = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__[\"segmentValidRange\"])(videoSamples);\n      this.remainderData = segmentedData.remainder;\n      videoTrack.samples = segmentedData.valid || new Uint8Array();\n    } else {\n      videoTrack.samples = videoSamples;\n    }\n\n    var id3Track = this.extractID3Track(videoTrack, timeOffset);\n    textTrack.samples = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__[\"parseSamples\"])(timeOffset, videoTrack);\n    return {\n      videoTrack: videoTrack,\n      audioTrack: this.audioTrack,\n      id3Track: id3Track,\n      textTrack: this.txtTrack\n    };\n  };\n\n  _proto.flush = function flush() {\n    var timeOffset = this.timeOffset;\n    var videoTrack = this.videoTrack;\n    var textTrack = this.txtTrack;\n    videoTrack.samples = this.remainderData || new Uint8Array();\n    this.remainderData = null;\n    var id3Track = this.extractID3Track(videoTrack, this.timeOffset);\n    textTrack.samples = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__[\"parseSamples\"])(timeOffset, videoTrack);\n    return {\n      videoTrack: videoTrack,\n      audioTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__[\"dummyTrack\"])(),\n      id3Track: id3Track,\n      textTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__[\"dummyTrack\"])()\n    };\n  };\n\n  _proto.extractID3Track = function extractID3Track(videoTrack, timeOffset) {\n    var id3Track = this.id3Track;\n\n    if (videoTrack.samples.length) {\n      var emsgs = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__[\"findBox\"])(videoTrack.samples, ['emsg']);\n\n      if (emsgs) {\n        emsgs.forEach(function (data) {\n          var emsgInfo = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__[\"parseEmsg\"])(data);\n\n          if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {\n            var pts = Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;\n            var payload = emsgInfo.payload;\n            id3Track.samples.push({\n              data: payload,\n              len: payload.byteLength,\n              dts: pts,\n              pts: pts,\n              type: _types_demuxer__WEBPACK_IMPORTED_MODULE_1__[\"MetadataSchema\"].emsg\n            });\n          }\n        });\n      }\n    }\n\n    return id3Track;\n  };\n\n  _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error('The MP4 demuxer does not support SAMPLE-AES decryption'));\n  };\n\n  _proto.destroy = function destroy() {};\n\n  return MP4Demuxer;\n}();\n\nMP4Demuxer.minProbeByteLength = 1024;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MP4Demuxer);\n\n/***/ }),\n\n/***/ \"./src/demux/mpegaudio.ts\":\n/*!********************************!*\\\n  !*** ./src/demux/mpegaudio.ts ***!\n  \\********************************/\n/*! exports provided: appendFrame, parseHeader, isHeaderPattern, isHeader, canParse, probe */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_557788__) {\n\n\"use strict\";\n__nested_webpack_require_557788__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_557788__.d(__webpack_exports__, \"appendFrame\", function() { return appendFrame; });\n/* harmony export (binding) */ __nested_webpack_require_557788__.d(__webpack_exports__, \"parseHeader\", function() { return parseHeader; });\n/* harmony export (binding) */ __nested_webpack_require_557788__.d(__webpack_exports__, \"isHeaderPattern\", function() { return isHeaderPattern; });\n/* harmony export (binding) */ __nested_webpack_require_557788__.d(__webpack_exports__, \"isHeader\", function() { return isHeader; });\n/* harmony export (binding) */ __nested_webpack_require_557788__.d(__webpack_exports__, \"canParse\", function() { return canParse; });\n/* harmony export (binding) */ __nested_webpack_require_557788__.d(__webpack_exports__, \"probe\", function() { return probe; });\n/**\n *  MPEG parser helper\n */\nvar chromeVersion = null;\nvar BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];\nvar SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];\nvar SamplesCoefficients = [// MPEG 2.5\n[0, // Reserved\n72, // Layer3\n144, // Layer2\n12 // Layer1\n], // Reserved\n[0, // Reserved\n0, // Layer3\n0, // Layer2\n0 // Layer1\n], // MPEG 2\n[0, // Reserved\n72, // Layer3\n144, // Layer2\n12 // Layer1\n], // MPEG 1\n[0, // Reserved\n144, // Layer3\n144, // Layer2\n12 // Layer1\n]];\nvar BytesInSlot = [0, // Reserved\n1, // Layer3\n1, // Layer2\n4 // Layer1\n];\nfunction appendFrame(track, data, offset, pts, frameIndex) {\n  // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n  if (offset + 24 > data.length) {\n    return;\n  }\n\n  var header = parseHeader(data, offset);\n\n  if (header && offset + header.frameLength <= data.length) {\n    var frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;\n    var stamp = pts + frameIndex * frameDuration;\n    var sample = {\n      unit: data.subarray(offset, offset + header.frameLength),\n      pts: stamp,\n      dts: stamp\n    };\n    track.config = [];\n    track.channelCount = header.channelCount;\n    track.samplerate = header.sampleRate;\n    track.samples.push(sample);\n    return {\n      sample: sample,\n      length: header.frameLength,\n      missing: 0\n    };\n  }\n}\nfunction parseHeader(data, offset) {\n  var mpegVersion = data[offset + 1] >> 3 & 3;\n  var mpegLayer = data[offset + 1] >> 1 & 3;\n  var bitRateIndex = data[offset + 2] >> 4 & 15;\n  var sampleRateIndex = data[offset + 2] >> 2 & 3;\n\n  if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {\n    var paddingBit = data[offset + 2] >> 1 & 1;\n    var channelMode = data[offset + 3] >> 6;\n    var columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\n    var bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\n    var columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\n    var sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\n    var channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n\n    var sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\n    var bytesInSlot = BytesInSlot[mpegLayer];\n    var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n    var frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;\n\n    if (chromeVersion === null) {\n      var userAgent = navigator.userAgent || '';\n      var result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion = result ? parseInt(result[1]) : 0;\n    }\n\n    var needChromeFix = !!chromeVersion && chromeVersion <= 87;\n\n    if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {\n      // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\n      data[offset + 3] = data[offset + 3] | 0x80;\n    }\n\n    return {\n      sampleRate: sampleRate,\n      channelCount: channelCount,\n      frameLength: frameLength,\n      samplesPerFrame: samplesPerFrame\n    };\n  }\n}\nfunction isHeaderPattern(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;\n}\nfunction isHeader(data, offset) {\n  // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n  // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n  // More info http://www.mp3-tech.org/programmer/frame_header.html\n  return offset + 1 < data.length && isHeaderPattern(data, offset);\n}\nfunction canParse(data, offset) {\n  var headerSize = 4;\n  return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\n}\nfunction probe(data, offset) {\n  // same as isHeader but we also check that MPEG frame follows last MPEG frame\n  // or end of data is reached\n  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n    // MPEG header Length\n    var headerLength = 4; // MPEG frame Length\n\n    var header = parseHeader(data, offset);\n    var frameLength = headerLength;\n\n    if (header !== null && header !== void 0 && header.frameLength) {\n      frameLength = header.frameLength;\n    }\n\n    var newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader(data, newOffset);\n  }\n\n  return false;\n}\n\n/***/ }),\n\n/***/ \"./src/demux/sample-aes.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/sample-aes.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_563627__) {\n\n\"use strict\";\n__nested_webpack_require_563627__.r(__webpack_exports__);\n/* harmony import */ var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_563627__(/*! ../crypt/decrypter */ \"./src/crypt/decrypter.ts\");\n/* harmony import */ var _tsdemuxer__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_563627__(/*! ./tsdemuxer */ \"./src/demux/tsdemuxer.ts\");\n/**\n * SAMPLE-AES decrypter\n */\n\n\n\nvar SampleAesDecrypter = /*#__PURE__*/function () {\n  function SampleAesDecrypter(observer, config, keyData) {\n    this.keyData = void 0;\n    this.decrypter = void 0;\n    this.keyData = keyData;\n    this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_0__[\"default\"](observer, config, {\n      removePKCS7Padding: false\n    });\n  }\n\n  var _proto = SampleAesDecrypter.prototype;\n\n  _proto.decryptBuffer = function decryptBuffer(encryptedData, callback) {\n    this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer, callback);\n  } // AAC - encrypt all full 16 bytes blocks starting from offset 16\n  ;\n\n  _proto.decryptAacSample = function decryptAacSample(samples, sampleIndex, callback, sync) {\n    var curUnit = samples[sampleIndex].unit;\n\n    if (curUnit.length <= 16) {\n      // No encrypted portion in this sample (first 16 bytes is not\n      // encrypted, see https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html),\n      return;\n    }\n\n    var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n    var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);\n    var localthis = this;\n    this.decryptBuffer(encryptedBuffer, function (decryptedBuffer) {\n      var decryptedData = new Uint8Array(decryptedBuffer);\n      curUnit.set(decryptedData, 16);\n\n      if (!sync) {\n        localthis.decryptAacSamples(samples, sampleIndex + 1, callback);\n      }\n    });\n  };\n\n  _proto.decryptAacSamples = function decryptAacSamples(samples, sampleIndex, callback) {\n    for (;; sampleIndex++) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n\n      if (samples[sampleIndex].unit.length < 32) {\n        continue;\n      }\n\n      var sync = this.decrypter.isSync();\n      this.decryptAacSample(samples, sampleIndex, callback, sync);\n\n      if (!sync) {\n        return;\n      }\n    }\n  } // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n  ;\n\n  _proto.getAvcEncryptedData = function getAvcEncryptedData(decodedData) {\n    var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n    var encryptedData = new Int8Array(encryptedDataLen);\n    var outputPos = 0;\n\n    for (var inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {\n      encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n\n    return encryptedData;\n  };\n\n  _proto.getAvcDecryptedUnit = function getAvcDecryptedUnit(decodedData, decryptedData) {\n    var uint8DecryptedData = new Uint8Array(decryptedData);\n    var inputPos = 0;\n\n    for (var outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {\n      decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n\n    return decodedData;\n  };\n\n  _proto.decryptAvcSample = function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync) {\n    var decodedData = Object(_tsdemuxer__WEBPACK_IMPORTED_MODULE_1__[\"discardEPB\"])(curUnit.data);\n    var encryptedData = this.getAvcEncryptedData(decodedData);\n    var localthis = this;\n    this.decryptBuffer(encryptedData.buffer, function (decryptedBuffer) {\n      curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedBuffer);\n\n      if (!sync) {\n        localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n      }\n    });\n  };\n\n  _proto.decryptAvcSamples = function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {\n    if (samples instanceof Uint8Array) {\n      throw new Error('Cannot decrypt samples of type Uint8Array');\n    }\n\n    for (;; sampleIndex++, unitIndex = 0) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n\n      var curUnits = samples[sampleIndex].units;\n\n      for (;; unitIndex++) {\n        if (unitIndex >= curUnits.length) {\n          break;\n        }\n\n        var curUnit = curUnits[unitIndex];\n\n        if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {\n          continue;\n        }\n\n        var sync = this.decrypter.isSync();\n        this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);\n\n        if (!sync) {\n          return;\n        }\n      }\n    }\n  };\n\n  return SampleAesDecrypter;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SampleAesDecrypter);\n\n/***/ }),\n\n/***/ \"./src/demux/transmuxer-interface.ts\":\n/*!*******************************************!*\\\n  !*** ./src/demux/transmuxer-interface.ts ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_568835__) {\n\n\"use strict\";\n__nested_webpack_require_568835__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_568835__.d(__webpack_exports__, \"default\", function() { return TransmuxerInterface; });\n/* harmony import */ var webworkify_webpack__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_568835__(/*! webworkify-webpack */ \"./node_modules/webworkify-webpack/index.js\");\n/* harmony import */ var webworkify_webpack__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_568835__.n(webworkify_webpack__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_568835__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_568835__(/*! ../demux/transmuxer */ \"./src/demux/transmuxer.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_568835__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_568835__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_568835__(/*! ../utils/mediasource-helper */ \"./src/utils/mediasource-helper.ts\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_568835__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__nested_webpack_require_568835__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\nvar MediaSource = Object(_utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__[\"getMediaSource\"])() || {\n  isTypeSupported: function isTypeSupported() {\n    return false;\n  }\n};\n\nvar TransmuxerInterface = /*#__PURE__*/function () {\n  function TransmuxerInterface(hls, id, onTransmuxComplete, onFlush) {\n    var _this = this;\n\n    this.hls = void 0;\n    this.id = void 0;\n    this.observer = void 0;\n    this.frag = null;\n    this.part = null;\n    this.worker = void 0;\n    this.onwmsg = void 0;\n    this.transmuxer = null;\n    this.onTransmuxComplete = void 0;\n    this.onFlush = void 0;\n    this.hls = hls;\n    this.id = id;\n    this.onTransmuxComplete = onTransmuxComplete;\n    this.onFlush = onFlush;\n    var config = hls.config;\n\n    var forwardMessage = function forwardMessage(ev, data) {\n      data = data || {};\n      data.frag = _this.frag;\n      data.id = _this.id;\n      hls.trigger(ev, data);\n    }; // forward events to main thread\n\n\n    this.observer = new eventemitter3__WEBPACK_IMPORTED_MODULE_6__[\"EventEmitter\"]();\n    this.observer.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_DECRYPTED, forwardMessage);\n    this.observer.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, forwardMessage);\n    var typeSupported = {\n      mp4: MediaSource.isTypeSupported('video/mp4'),\n      mpeg: MediaSource.isTypeSupported('audio/mpeg'),\n      mp3: MediaSource.isTypeSupported('audio/mp4; codecs=\"mp3\"')\n    }; // navigator.vendor is not always available in Web Worker\n    // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator\n\n    var vendor = navigator.vendor;\n\n    if (config.enableWorker && typeof Worker !== 'undefined') {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].log('demuxing in webworker');\n      var worker;\n\n      try {\n        worker = this.worker = webworkify_webpack__WEBPACK_IMPORTED_MODULE_0__(/*require.resolve*/(/*! ../demux/transmuxer-worker.ts */ \"./src/demux/transmuxer-worker.ts\"));\n        this.onwmsg = this.onWorkerMessage.bind(this);\n        worker.addEventListener('message', this.onwmsg);\n\n        worker.onerror = function (event) {\n          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, {\n            type: _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorTypes\"].OTHER_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorDetails\"].INTERNAL_EXCEPTION,\n            fatal: true,\n            event: 'demuxerWorker',\n            error: new Error(event.message + \"  (\" + event.filename + \":\" + event.lineno + \")\")\n          });\n        };\n\n        worker.postMessage({\n          cmd: 'init',\n          typeSupported: typeSupported,\n          vendor: vendor,\n          id: id,\n          config: JSON.stringify(config)\n        });\n      } catch (err) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn('Error in worker:', err);\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].error('Error while initializing DemuxerWorker, fallback to inline');\n\n        if (worker) {\n          // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n          self.URL.revokeObjectURL(worker.objectURL);\n        }\n\n        this.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.observer, typeSupported, config, vendor, id);\n        this.worker = null;\n      }\n    } else {\n      this.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.observer, typeSupported, config, vendor, id);\n    }\n  }\n\n  var _proto = TransmuxerInterface.prototype;\n\n  _proto.destroy = function destroy() {\n    var w = this.worker;\n\n    if (w) {\n      w.removeEventListener('message', this.onwmsg);\n      w.terminate();\n      this.worker = null;\n      this.onwmsg = undefined;\n    } else {\n      var transmuxer = this.transmuxer;\n\n      if (transmuxer) {\n        transmuxer.destroy();\n        this.transmuxer = null;\n      }\n    }\n\n    var observer = this.observer;\n\n    if (observer) {\n      observer.removeAllListeners();\n    }\n\n    this.frag = null; // @ts-ignore\n\n    this.observer = null; // @ts-ignore\n\n    this.hls = null;\n  };\n\n  _proto.push = function push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {\n    var _frag$initSegment,\n        _lastFrag$initSegment,\n        _this2 = this;\n\n    chunkMeta.transmuxing.start = self.performance.now();\n    var transmuxer = this.transmuxer,\n        worker = this.worker;\n    var timeOffset = part ? part.start : frag.start;\n    var decryptdata = frag.decryptdata;\n    var lastFrag = this.frag;\n    var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);\n    var trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);\n    var snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;\n    var partDiff = this.part ? chunkMeta.part - this.part.index : -1;\n    var contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && partDiff === 1);\n    var now = self.performance.now();\n\n    if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {\n      frag.stats.parsing.start = now;\n    }\n\n    if (part && (partDiff || !contiguous)) {\n      part.stats.parsing.start = now;\n    }\n\n    var initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) === null || _frag$initSegment === void 0 ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) === null || _lastFrag$initSegment === void 0 ? void 0 : _lastFrag$initSegment.url));\n    var state = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__[\"TransmuxState\"](discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);\n\n    if (!contiguous || discontinuity || initSegmentChange) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].log(\"[transmuxer-interface, \" + frag.type + \"]: Starting new transmux session for sn: \" + chunkMeta.sn + \" p: \" + chunkMeta.part + \" level: \" + chunkMeta.level + \" id: \" + chunkMeta.id + \"\\n        discontinuity: \" + discontinuity + \"\\n        trackSwitch: \" + trackSwitch + \"\\n        contiguous: \" + contiguous + \"\\n        accurateTimeOffset: \" + accurateTimeOffset + \"\\n        timeOffset: \" + timeOffset + \"\\n        initSegmentChange: \" + initSegmentChange);\n      var config = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__[\"TransmuxConfig\"](audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);\n      this.configureTransmuxer(config);\n    }\n\n    this.frag = frag;\n    this.part = part; // Frags with sn of 'initSegment' are not transmuxed\n\n    if (worker) {\n      // post fragment payload as transferable objects for ArrayBuffer (no copy)\n      worker.postMessage({\n        cmd: 'demux',\n        data: data,\n        decryptdata: decryptdata,\n        chunkMeta: chunkMeta,\n        state: state\n      }, data instanceof ArrayBuffer ? [data] : []);\n    } else if (transmuxer) {\n      var _transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);\n\n      if (Object(_demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__[\"isPromise\"])(_transmuxResult)) {\n        _transmuxResult.then(function (data) {\n          _this2.handleTransmuxComplete(data);\n        });\n      } else {\n        this.handleTransmuxComplete(_transmuxResult);\n      }\n    }\n  };\n\n  _proto.flush = function flush(chunkMeta) {\n    var _this3 = this;\n\n    chunkMeta.transmuxing.start = self.performance.now();\n    var transmuxer = this.transmuxer,\n        worker = this.worker;\n\n    if (worker) {\n      worker.postMessage({\n        cmd: 'flush',\n        chunkMeta: chunkMeta\n      });\n    } else if (transmuxer) {\n      var _transmuxResult2 = transmuxer.flush(chunkMeta);\n\n      if (Object(_demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__[\"isPromise\"])(_transmuxResult2)) {\n        _transmuxResult2.then(function (data) {\n          _this3.handleFlushResult(data, chunkMeta);\n        });\n      } else {\n        this.handleFlushResult(_transmuxResult2, chunkMeta);\n      }\n    }\n  };\n\n  _proto.handleFlushResult = function handleFlushResult(results, chunkMeta) {\n    var _this4 = this;\n\n    results.forEach(function (result) {\n      _this4.handleTransmuxComplete(result);\n    });\n    this.onFlush(chunkMeta);\n  };\n\n  _proto.onWorkerMessage = function onWorkerMessage(ev) {\n    var data = ev.data;\n    var hls = this.hls;\n\n    switch (data.event) {\n      case 'init':\n        {\n          // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n          self.URL.revokeObjectURL(this.worker.objectURL);\n          break;\n        }\n\n      case 'transmuxComplete':\n        {\n          this.handleTransmuxComplete(data.data);\n          break;\n        }\n\n      case 'flush':\n        {\n          this.onFlush(data.data);\n          break;\n        }\n\n      /* falls through */\n\n      default:\n        {\n          data.data = data.data || {};\n          data.data.frag = this.frag;\n          data.data.id = this.id;\n          hls.trigger(data.event, data.data);\n          break;\n        }\n    }\n  };\n\n  _proto.configureTransmuxer = function configureTransmuxer(config) {\n    var worker = this.worker,\n        transmuxer = this.transmuxer;\n\n    if (worker) {\n      worker.postMessage({\n        cmd: 'configure',\n        config: config\n      });\n    } else if (transmuxer) {\n      transmuxer.configure(config);\n    }\n  };\n\n  _proto.handleTransmuxComplete = function handleTransmuxComplete(result) {\n    result.chunkMeta.transmuxing.end = self.performance.now();\n    this.onTransmuxComplete(result);\n  };\n\n  return TransmuxerInterface;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/demux/transmuxer-worker.ts\":\n/*!****************************************!*\\\n  !*** ./src/demux/transmuxer-worker.ts ***!\n  \\****************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_580241__) {\n\n\"use strict\";\n__nested_webpack_require_580241__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_580241__.d(__webpack_exports__, \"default\", function() { return TransmuxerWorker; });\n/* harmony import */ var _demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_580241__(/*! ../demux/transmuxer */ \"./src/demux/transmuxer.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_580241__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_580241__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_580241__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_580241__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nfunction TransmuxerWorker(self) {\n  var observer = new eventemitter3__WEBPACK_IMPORTED_MODULE_3__[\"EventEmitter\"]();\n\n  var forwardMessage = function forwardMessage(ev, data) {\n    self.postMessage({\n      event: ev,\n      data: data\n    });\n  }; // forward events to main thread\n\n\n  observer.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_DECRYPTED, forwardMessage);\n  observer.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, forwardMessage);\n  self.addEventListener('message', function (ev) {\n    var data = ev.data;\n\n    switch (data.cmd) {\n      case 'init':\n        {\n          var config = JSON.parse(data.config);\n          self.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__[\"default\"](observer, data.typeSupported, config, data.vendor, data.id);\n          Object(_utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"enableLogs\"])(config.debug);\n          forwardMessage('init', null);\n          break;\n        }\n\n      case 'configure':\n        {\n          self.transmuxer.configure(data.config);\n          break;\n        }\n\n      case 'demux':\n        {\n          var transmuxResult = self.transmuxer.push(data.data, data.decryptdata, data.chunkMeta, data.state);\n\n          if (Object(_demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__[\"isPromise\"])(transmuxResult)) {\n            transmuxResult.then(function (data) {\n              emitTransmuxComplete(self, data);\n            });\n          } else {\n            emitTransmuxComplete(self, transmuxResult);\n          }\n\n          break;\n        }\n\n      case 'flush':\n        {\n          var id = data.chunkMeta;\n\n          var _transmuxResult = self.transmuxer.flush(id);\n\n          if (Object(_demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__[\"isPromise\"])(_transmuxResult)) {\n            _transmuxResult.then(function (results) {\n              handleFlushResult(self, results, id);\n            });\n          } else {\n            handleFlushResult(self, _transmuxResult, id);\n          }\n\n          break;\n        }\n\n      default:\n        break;\n    }\n  });\n}\n\nfunction emitTransmuxComplete(self, transmuxResult) {\n  if (isEmptyResult(transmuxResult.remuxResult)) {\n    return false;\n  }\n\n  var transferable = [];\n  var _transmuxResult$remux = transmuxResult.remuxResult,\n      audio = _transmuxResult$remux.audio,\n      video = _transmuxResult$remux.video;\n\n  if (audio) {\n    addToTransferable(transferable, audio);\n  }\n\n  if (video) {\n    addToTransferable(transferable, video);\n  }\n\n  self.postMessage({\n    event: 'transmuxComplete',\n    data: transmuxResult\n  }, transferable);\n  return true;\n} // Converts data to a transferable object https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast)\n// in order to minimize message passing overhead\n\n\nfunction addToTransferable(transferable, track) {\n  if (track.data1) {\n    transferable.push(track.data1.buffer);\n  }\n\n  if (track.data2) {\n    transferable.push(track.data2.buffer);\n  }\n}\n\nfunction handleFlushResult(self, results, chunkMeta) {\n  var parsed = results.reduce(function (parsed, result) {\n    return emitTransmuxComplete(self, result) || parsed;\n  }, false);\n\n  if (!parsed) {\n    // Emit at least one \"transmuxComplete\" message even if media is not found to update stream-controller state to PARSING\n    self.postMessage({\n      event: 'transmuxComplete',\n      data: results[0]\n    });\n  }\n\n  self.postMessage({\n    event: 'flush',\n    data: chunkMeta\n  });\n}\n\nfunction isEmptyResult(remuxResult) {\n  return !remuxResult.audio && !remuxResult.video && !remuxResult.text && !remuxResult.id3 && !remuxResult.initSegment;\n}\n\n/***/ }),\n\n/***/ \"./src/demux/transmuxer.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/transmuxer.ts ***!\n  \\*********************************/\n/*! exports provided: default, isPromise, TransmuxConfig, TransmuxState */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_585060__) {\n\n\"use strict\";\n__nested_webpack_require_585060__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_585060__.d(__webpack_exports__, \"default\", function() { return Transmuxer; });\n/* harmony export (binding) */ __nested_webpack_require_585060__.d(__webpack_exports__, \"isPromise\", function() { return isPromise; });\n/* harmony export (binding) */ __nested_webpack_require_585060__.d(__webpack_exports__, \"TransmuxConfig\", function() { return TransmuxConfig; });\n/* harmony export (binding) */ __nested_webpack_require_585060__.d(__webpack_exports__, \"TransmuxState\", function() { return TransmuxState; });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_585060__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_585060__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_585060__(/*! ../crypt/decrypter */ \"./src/crypt/decrypter.ts\");\n/* harmony import */ var _demux_aacdemuxer__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_585060__(/*! ../demux/aacdemuxer */ \"./src/demux/aacdemuxer.ts\");\n/* harmony import */ var _demux_mp4demuxer__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_585060__(/*! ../demux/mp4demuxer */ \"./src/demux/mp4demuxer.ts\");\n/* harmony import */ var _demux_tsdemuxer__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_585060__(/*! ../demux/tsdemuxer */ \"./src/demux/tsdemuxer.ts\");\n/* harmony import */ var _demux_mp3demuxer__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_585060__(/*! ../demux/mp3demuxer */ \"./src/demux/mp3demuxer.ts\");\n/* harmony import */ var _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_585060__(/*! ../remux/mp4-remuxer */ \"./src/remux/mp4-remuxer.ts\");\n/* harmony import */ var _remux_passthrough_remuxer__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_585060__(/*! ../remux/passthrough-remuxer */ \"./src/remux/passthrough-remuxer.ts\");\n/* harmony import */ var _chunk_cache__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_585060__(/*! ./chunk-cache */ \"./src/demux/chunk-cache.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_585060__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_585060__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nvar now; // performance.now() not available on WebWorker, at least on Safari Desktop\n\ntry {\n  now = self.performance.now.bind(self.performance);\n} catch (err) {\n  _utils_logger__WEBPACK_IMPORTED_MODULE_11__[\"logger\"].debug('Unable to use Performance API on this environment');\n  now = self.Date.now;\n}\n\nvar muxConfig = [{\n  demux: _demux_tsdemuxer__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n  remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__[\"default\"]\n}, {\n  demux: _demux_mp4demuxer__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n  remux: _remux_passthrough_remuxer__WEBPACK_IMPORTED_MODULE_8__[\"default\"]\n}, {\n  demux: _demux_aacdemuxer__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n  remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__[\"default\"]\n}, {\n  demux: _demux_mp3demuxer__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n  remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__[\"default\"]\n}];\nvar minProbeByteLength = 1024;\nmuxConfig.forEach(function (_ref) {\n  var demux = _ref.demux;\n  minProbeByteLength = Math.max(minProbeByteLength, demux.minProbeByteLength);\n});\n\nvar Transmuxer = /*#__PURE__*/function () {\n  function Transmuxer(observer, typeSupported, config, vendor, id) {\n    this.observer = void 0;\n    this.typeSupported = void 0;\n    this.config = void 0;\n    this.vendor = void 0;\n    this.id = void 0;\n    this.demuxer = void 0;\n    this.remuxer = void 0;\n    this.decrypter = void 0;\n    this.probe = void 0;\n    this.decryptionPromise = null;\n    this.transmuxConfig = void 0;\n    this.currentTransmuxState = void 0;\n    this.cache = new _chunk_cache__WEBPACK_IMPORTED_MODULE_9__[\"default\"]();\n    this.observer = observer;\n    this.typeSupported = typeSupported;\n    this.config = config;\n    this.vendor = vendor;\n    this.id = id;\n  }\n\n  var _proto = Transmuxer.prototype;\n\n  _proto.configure = function configure(transmuxConfig) {\n    this.transmuxConfig = transmuxConfig;\n\n    if (this.decrypter) {\n      this.decrypter.reset();\n    }\n  };\n\n  _proto.push = function push(data, decryptdata, chunkMeta, state) {\n    var _this = this;\n\n    var stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    var uintData = new Uint8Array(data);\n    var cache = this.cache,\n        config = this.config,\n        currentTransmuxState = this.currentTransmuxState,\n        transmuxConfig = this.transmuxConfig;\n\n    if (state) {\n      this.currentTransmuxState = state;\n    }\n\n    var keyData = getEncryptionType(uintData, decryptdata);\n\n    if (keyData && keyData.method === 'AES-128') {\n      var decrypter = this.getDecrypter(); // Software decryption is synchronous; webCrypto is not\n\n      if (config.enableSoftwareAES) {\n        // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n        // data is handled in the flush() call\n        var decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);\n\n        if (!decryptedData) {\n          stats.executeEnd = now();\n          return emptyResult(chunkMeta);\n        }\n\n        uintData = new Uint8Array(decryptedData);\n      } else {\n        this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then(function (decryptedData) {\n          // Calling push here is important; if flush() is called while this is still resolving, this ensures that\n          // the decrypted data has been transmuxed\n          var result = _this.push(decryptedData, null, chunkMeta);\n\n          _this.decryptionPromise = null;\n          return result;\n        });\n        return this.decryptionPromise;\n      }\n    }\n\n    var _ref2 = state || currentTransmuxState,\n        contiguous = _ref2.contiguous,\n        discontinuity = _ref2.discontinuity,\n        trackSwitch = _ref2.trackSwitch,\n        accurateTimeOffset = _ref2.accurateTimeOffset,\n        timeOffset = _ref2.timeOffset,\n        initSegmentChange = _ref2.initSegmentChange;\n\n    var audioCodec = transmuxConfig.audioCodec,\n        videoCodec = transmuxConfig.videoCodec,\n        defaultInitPts = transmuxConfig.defaultInitPts,\n        duration = transmuxConfig.duration,\n        initSegmentData = transmuxConfig.initSegmentData; // Reset muxers before probing to ensure that their state is clean, even if flushing occurs before a successful probe\n\n    if (discontinuity || trackSwitch || initSegmentChange) {\n      this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration);\n    }\n\n    if (discontinuity || initSegmentChange) {\n      this.resetInitialTimestamp(defaultInitPts);\n    }\n\n    if (!contiguous) {\n      this.resetContiguity();\n    }\n\n    if (this.needsProbing(uintData, discontinuity, trackSwitch)) {\n      if (cache.dataLength) {\n        var cachedData = cache.flush();\n        uintData = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_10__[\"appendUint8Array\"])(cachedData, uintData);\n      }\n\n      this.configureTransmuxer(uintData, transmuxConfig);\n    }\n\n    var result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    var currentState = this.currentTransmuxState;\n    currentState.contiguous = true;\n    currentState.discontinuity = false;\n    currentState.trackSwitch = false;\n    stats.executeEnd = now();\n    return result;\n  } // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n  ;\n\n  _proto.flush = function flush(chunkMeta) {\n    var _this2 = this;\n\n    var stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    var decrypter = this.decrypter,\n        cache = this.cache,\n        currentTransmuxState = this.currentTransmuxState,\n        decryptionPromise = this.decryptionPromise;\n\n    if (decryptionPromise) {\n      // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\n      // only flushing is required for async decryption\n      return decryptionPromise.then(function () {\n        return _this2.flush(chunkMeta);\n      });\n    }\n\n    var transmuxResults = [];\n    var timeOffset = currentTransmuxState.timeOffset;\n\n    if (decrypter) {\n      // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\n      // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\n      // or for progressive downloads with small segments)\n      var decryptedData = decrypter.flush();\n\n      if (decryptedData) {\n        // Push always returns a TransmuxerResult if decryptdata is null\n        transmuxResults.push(this.push(decryptedData, null, chunkMeta));\n      }\n    }\n\n    var bytesSeen = cache.dataLength;\n    cache.reset();\n    var demuxer = this.demuxer,\n        remuxer = this.remuxer;\n\n    if (!demuxer || !remuxer) {\n      // If probing failed, and each demuxer saw enough bytes to be able to probe, then Hls.js has been given content its not able to handle\n      if (bytesSeen >= minProbeByteLength) {\n        this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, _events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n          type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].MEDIA_ERROR,\n          details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].FRAG_PARSING_ERROR,\n          fatal: true,\n          reason: 'no demux matching with content found'\n        });\n      }\n\n      stats.executeEnd = now();\n      return [emptyResult(chunkMeta)];\n    }\n\n    var demuxResultOrPromise = demuxer.flush(timeOffset);\n\n    if (isPromise(demuxResultOrPromise)) {\n      // Decrypt final SAMPLE-AES samples\n      return demuxResultOrPromise.then(function (demuxResult) {\n        _this2.flushRemux(transmuxResults, demuxResult, chunkMeta);\n\n        return transmuxResults;\n      });\n    }\n\n    this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\n    return transmuxResults;\n  };\n\n  _proto.flushRemux = function flushRemux(transmuxResults, demuxResult, chunkMeta) {\n    var audioTrack = demuxResult.audioTrack,\n        videoTrack = demuxResult.videoTrack,\n        id3Track = demuxResult.id3Track,\n        textTrack = demuxResult.textTrack;\n    var _this$currentTransmux = this.currentTransmuxState,\n        accurateTimeOffset = _this$currentTransmux.accurateTimeOffset,\n        timeOffset = _this$currentTransmux.timeOffset;\n    _utils_logger__WEBPACK_IMPORTED_MODULE_11__[\"logger\"].log(\"[transmuxer.ts]: Flushed fragment \" + chunkMeta.sn + (chunkMeta.part > -1 ? ' p: ' + chunkMeta.part : '') + \" of level \" + chunkMeta.level);\n    var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);\n    transmuxResults.push({\n      remuxResult: remuxResult,\n      chunkMeta: chunkMeta\n    });\n    chunkMeta.transmuxing.executeEnd = now();\n  };\n\n  _proto.resetInitialTimestamp = function resetInitialTimestamp(defaultInitPts) {\n    var demuxer = this.demuxer,\n        remuxer = this.remuxer;\n\n    if (!demuxer || !remuxer) {\n      return;\n    }\n\n    demuxer.resetTimeStamp(defaultInitPts);\n    remuxer.resetTimeStamp(defaultInitPts);\n  };\n\n  _proto.resetContiguity = function resetContiguity() {\n    var demuxer = this.demuxer,\n        remuxer = this.remuxer;\n\n    if (!demuxer || !remuxer) {\n      return;\n    }\n\n    demuxer.resetContiguity();\n    remuxer.resetNextTimestamp();\n  };\n\n  _proto.resetInitSegment = function resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration) {\n    var demuxer = this.demuxer,\n        remuxer = this.remuxer;\n\n    if (!demuxer || !remuxer) {\n      return;\n    }\n\n    demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);\n    remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec);\n  };\n\n  _proto.destroy = function destroy() {\n    if (this.demuxer) {\n      this.demuxer.destroy();\n      this.demuxer = undefined;\n    }\n\n    if (this.remuxer) {\n      this.remuxer.destroy();\n      this.remuxer = undefined;\n    }\n  };\n\n  _proto.transmux = function transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {\n    var result;\n\n    if (keyData && keyData.method === 'SAMPLE-AES') {\n      result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    } else {\n      result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);\n    }\n\n    return result;\n  };\n\n  _proto.transmuxUnencrypted = function transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {\n    var _demux = this.demuxer.demux(data, timeOffset, false, !this.config.progressive),\n        audioTrack = _demux.audioTrack,\n        videoTrack = _demux.videoTrack,\n        id3Track = _demux.id3Track,\n        textTrack = _demux.textTrack;\n\n    var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);\n    return {\n      remuxResult: remuxResult,\n      chunkMeta: chunkMeta\n    };\n  };\n\n  _proto.transmuxSampleAes = function transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {\n    var _this3 = this;\n\n    return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(function (demuxResult) {\n      var remuxResult = _this3.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, _this3.id);\n\n      return {\n        remuxResult: remuxResult,\n        chunkMeta: chunkMeta\n      };\n    });\n  };\n\n  _proto.configureTransmuxer = function configureTransmuxer(data, transmuxConfig) {\n    var config = this.config,\n        observer = this.observer,\n        typeSupported = this.typeSupported,\n        vendor = this.vendor;\n    var audioCodec = transmuxConfig.audioCodec,\n        defaultInitPts = transmuxConfig.defaultInitPts,\n        duration = transmuxConfig.duration,\n        initSegmentData = transmuxConfig.initSegmentData,\n        videoCodec = transmuxConfig.videoCodec; // probe for content type\n\n    var mux;\n\n    for (var i = 0, len = muxConfig.length; i < len; i++) {\n      if (muxConfig[i].demux.probe(data)) {\n        mux = muxConfig[i];\n        break;\n      }\n    }\n\n    if (!mux) {\n      // If probing previous configs fail, use mp4 passthrough\n      _utils_logger__WEBPACK_IMPORTED_MODULE_11__[\"logger\"].warn('Failed to find demuxer by probing frag, treating as mp4 passthrough');\n      mux = {\n        demux: _demux_mp4demuxer__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n        remux: _remux_passthrough_remuxer__WEBPACK_IMPORTED_MODULE_8__[\"default\"]\n      };\n    } // so let's check that current remuxer and demuxer are still valid\n\n\n    var demuxer = this.demuxer;\n    var remuxer = this.remuxer;\n    var Remuxer = mux.remux;\n    var Demuxer = mux.demux;\n\n    if (!remuxer || !(remuxer instanceof Remuxer)) {\n      this.remuxer = new Remuxer(observer, config, typeSupported, vendor);\n    }\n\n    if (!demuxer || !(demuxer instanceof Demuxer)) {\n      this.demuxer = new Demuxer(observer, config, typeSupported);\n      this.probe = Demuxer.probe;\n    } // Ensure that muxers are always initialized with an initSegment\n\n\n    this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration);\n    this.resetInitialTimestamp(defaultInitPts);\n  };\n\n  _proto.needsProbing = function needsProbing(data, discontinuity, trackSwitch) {\n    // in case of continuity change, or track switch\n    // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n    return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\n  };\n\n  _proto.getDecrypter = function getDecrypter() {\n    var decrypter = this.decrypter;\n\n    if (!decrypter) {\n      decrypter = this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.observer, this.config);\n    }\n\n    return decrypter;\n  };\n\n  return Transmuxer;\n}();\n\n\n\nfunction getEncryptionType(data, decryptData) {\n  var encryptionType = null;\n\n  if (data.byteLength > 0 && decryptData != null && decryptData.key != null && decryptData.iv !== null && decryptData.method != null) {\n    encryptionType = decryptData;\n  }\n\n  return encryptionType;\n}\n\nvar emptyResult = function emptyResult(chunkMeta) {\n  return {\n    remuxResult: {},\n    chunkMeta: chunkMeta\n  };\n};\n\nfunction isPromise(p) {\n  return 'then' in p && p.then instanceof Function;\n}\nvar TransmuxConfig = function TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {\n  this.audioCodec = void 0;\n  this.videoCodec = void 0;\n  this.initSegmentData = void 0;\n  this.duration = void 0;\n  this.defaultInitPts = void 0;\n  this.audioCodec = audioCodec;\n  this.videoCodec = videoCodec;\n  this.initSegmentData = initSegmentData;\n  this.duration = duration;\n  this.defaultInitPts = defaultInitPts;\n};\nvar TransmuxState = function TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {\n  this.discontinuity = void 0;\n  this.contiguous = void 0;\n  this.accurateTimeOffset = void 0;\n  this.trackSwitch = void 0;\n  this.timeOffset = void 0;\n  this.initSegmentChange = void 0;\n  this.discontinuity = discontinuity;\n  this.contiguous = contiguous;\n  this.accurateTimeOffset = accurateTimeOffset;\n  this.trackSwitch = trackSwitch;\n  this.timeOffset = timeOffset;\n  this.initSegmentChange = initSegmentChange;\n};\n\n/***/ }),\n\n/***/ \"./src/demux/tsdemuxer.ts\":\n/*!********************************!*\\\n  !*** ./src/demux/tsdemuxer.ts ***!\n  \\********************************/\n/*! exports provided: discardEPB, default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_602991__) {\n\n\"use strict\";\n__nested_webpack_require_602991__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_602991__.d(__webpack_exports__, \"discardEPB\", function() { return discardEPB; });\n/* harmony import */ var _adts__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_602991__(/*! ./adts */ \"./src/demux/adts.ts\");\n/* harmony import */ var _mpegaudio__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_602991__(/*! ./mpegaudio */ \"./src/demux/mpegaudio.ts\");\n/* harmony import */ var _exp_golomb__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_602991__(/*! ./exp-golomb */ \"./src/demux/exp-golomb.ts\");\n/* harmony import */ var _sample_aes__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_602991__(/*! ./sample-aes */ \"./src/demux/sample-aes.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_602991__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_602991__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_602991__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_602991__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _types_demuxer__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_602991__(/*! ../types/demuxer */ \"./src/types/demuxer.ts\");\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n/**\n * highly optimized TS demuxer:\n * parse PAT, PMT\n * extract PES packet from audio and video PIDs\n * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet\n * trigger the remuxer upon parsing completion\n * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.\n * it also controls the remuxing process :\n * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.\n */\n\n\n\n\n\n\n\n\n\n\nvar TSDemuxer = /*#__PURE__*/function () {\n  function TSDemuxer(observer, config, typeSupported) {\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.sampleAes = null;\n    this.pmtParsed = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this._duration = 0;\n    this._pmtId = -1;\n    this._avcTrack = void 0;\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this._txtTrack = void 0;\n    this.aacOverFlow = null;\n    this.avcSample = null;\n    this.remainderData = null;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n  }\n\n  TSDemuxer.probe = function probe(data) {\n    var syncOffset = TSDemuxer.syncOffset(data);\n\n    if (syncOffset < 0) {\n      return false;\n    } else {\n      if (syncOffset) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].warn(\"MPEG2-TS detected but first sync word found @ offset \" + syncOffset + \", junk ahead ?\");\n      }\n\n      return true;\n    }\n  };\n\n  TSDemuxer.syncOffset = function syncOffset(data) {\n    // scan 1000 first bytes\n    var scanwindow = Math.min(1000, data.length - 3 * 188);\n    var i = 0;\n\n    while (i < scanwindow) {\n      // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47\n      if (data[i] === 0x47 && data[i + 188] === 0x47 && data[i + 2 * 188] === 0x47) {\n        return i;\n      } else {\n        i++;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Creates a track model internal to demuxer used to drive remuxing input\n   *\n   * @param type 'audio' | 'video' | 'id3' | 'text'\n   * @param duration\n   * @return TSDemuxer's internal track model\n   */\n  ;\n\n  TSDemuxer.createTrack = function createTrack(type, duration) {\n    return {\n      container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,\n      type: type,\n      id: _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_5__[\"RemuxerTrackIdConfig\"][type],\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0,\n      duration: type === 'audio' ? duration : undefined\n    };\n  }\n  /**\n   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n   * Resets all internal track instances of the demuxer.\n   */\n  ;\n\n  var _proto = TSDemuxer.prototype;\n\n  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    this.pmtParsed = false;\n    this._pmtId = -1;\n    this._avcTrack = TSDemuxer.createTrack('video');\n    this._audioTrack = TSDemuxer.createTrack('audio', trackDuration);\n    this._id3Track = TSDemuxer.createTrack('id3');\n    this._txtTrack = TSDemuxer.createTrack('text');\n    this._audioTrack.segmentCodec = 'aac'; // flush any partial content\n\n    this.aacOverFlow = null;\n    this.avcSample = null;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this._duration = trackDuration;\n  };\n\n  _proto.resetTimeStamp = function resetTimeStamp() {};\n\n  _proto.resetContiguity = function resetContiguity() {\n    var _audioTrack = this._audioTrack,\n        _avcTrack = this._avcTrack,\n        _id3Track = this._id3Track;\n\n    if (_audioTrack) {\n      _audioTrack.pesData = null;\n    }\n\n    if (_avcTrack) {\n      _avcTrack.pesData = null;\n    }\n\n    if (_id3Track) {\n      _id3Track.pesData = null;\n    }\n\n    this.aacOverFlow = null;\n  };\n\n  _proto.demux = function demux(data, timeOffset, isSampleAes, flush) {\n    if (isSampleAes === void 0) {\n      isSampleAes = false;\n    }\n\n    if (flush === void 0) {\n      flush = false;\n    }\n\n    if (!isSampleAes) {\n      this.sampleAes = null;\n    }\n\n    var pes;\n    var videoTrack = this._avcTrack;\n    var audioTrack = this._audioTrack;\n    var id3Track = this._id3Track;\n    var textTrack = this._txtTrack;\n    var avcId = videoTrack.pid;\n    var avcData = videoTrack.pesData;\n    var audioId = audioTrack.pid;\n    var id3Id = id3Track.pid;\n    var audioData = audioTrack.pesData;\n    var id3Data = id3Track.pesData;\n    var unknownPIDs = false;\n    var pmtParsed = this.pmtParsed;\n    var pmtId = this._pmtId;\n    var len = data.length;\n\n    if (this.remainderData) {\n      data = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_5__[\"appendUint8Array\"])(this.remainderData, data);\n      len = data.length;\n      this.remainderData = null;\n    }\n\n    if (len < 188 && !flush) {\n      this.remainderData = data;\n      return {\n        audioTrack: audioTrack,\n        videoTrack: videoTrack,\n        id3Track: id3Track,\n        textTrack: textTrack\n      };\n    }\n\n    var syncOffset = Math.max(0, TSDemuxer.syncOffset(data));\n    len -= (len + syncOffset) % 188;\n\n    if (len < data.byteLength && !flush) {\n      this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);\n    } // loop through TS packets\n\n\n    var tsPacketErrors = 0;\n\n    for (var start = syncOffset; start < len; start += 188) {\n      if (data[start] === 0x47) {\n        var stt = !!(data[start + 1] & 0x40); // pid is a 13-bit field starting at the last bit of TS[1]\n\n        var pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];\n        var atf = (data[start + 3] & 0x30) >> 4; // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n\n        var offset = void 0;\n\n        if (atf > 1) {\n          offset = start + 5 + data[start + 4]; // continue if there is only adaptation field\n\n          if (offset === start + 188) {\n            continue;\n          }\n        } else {\n          offset = start + 4;\n        }\n\n        switch (pid) {\n          case avcId:\n            if (stt) {\n              if (avcData && (pes = parsePES(avcData))) {\n                this.parseAVCPES(videoTrack, textTrack, pes, false);\n              }\n\n              avcData = {\n                data: [],\n                size: 0\n              };\n            }\n\n            if (avcData) {\n              avcData.data.push(data.subarray(offset, start + 188));\n              avcData.size += start + 188 - offset;\n            }\n\n            break;\n\n          case audioId:\n            if (stt) {\n              if (audioData && (pes = parsePES(audioData))) {\n                switch (audioTrack.segmentCodec) {\n                  case 'aac':\n                    this.parseAACPES(audioTrack, pes);\n                    break;\n\n                  case 'mp3':\n                    this.parseMPEGPES(audioTrack, pes);\n                    break;\n                }\n              }\n\n              audioData = {\n                data: [],\n                size: 0\n              };\n            }\n\n            if (audioData) {\n              audioData.data.push(data.subarray(offset, start + 188));\n              audioData.size += start + 188 - offset;\n            }\n\n            break;\n\n          case id3Id:\n            if (stt) {\n              if (id3Data && (pes = parsePES(id3Data))) {\n                this.parseID3PES(id3Track, pes);\n              }\n\n              id3Data = {\n                data: [],\n                size: 0\n              };\n            }\n\n            if (id3Data) {\n              id3Data.data.push(data.subarray(offset, start + 188));\n              id3Data.size += start + 188 - offset;\n            }\n\n            break;\n\n          case 0:\n            if (stt) {\n              offset += data[offset] + 1;\n            }\n\n            pmtId = this._pmtId = parsePAT(data, offset);\n            break;\n\n          case pmtId:\n            {\n              if (stt) {\n                offset += data[offset] + 1;\n              }\n\n              var parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes); // only update track id if track PID found while parsing PMT\n              // this is to avoid resetting the PID to -1 in case\n              // track PID transiently disappears from the stream\n              // this could happen in case of transient missing audio samples for example\n              // NOTE this is only the PID of the track as found in TS,\n              // but we are not using this for MP4 track IDs.\n\n              avcId = parsedPIDs.avc;\n\n              if (avcId > 0) {\n                videoTrack.pid = avcId;\n              }\n\n              audioId = parsedPIDs.audio;\n\n              if (audioId > 0) {\n                audioTrack.pid = audioId;\n                audioTrack.segmentCodec = parsedPIDs.segmentCodec;\n              }\n\n              id3Id = parsedPIDs.id3;\n\n              if (id3Id > 0) {\n                id3Track.pid = id3Id;\n              }\n\n              if (unknownPIDs && !pmtParsed) {\n                _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].log('reparse from beginning');\n                unknownPIDs = false; // we set it to -188, the += 188 in the for loop will reset start to 0\n\n                start = syncOffset - 188;\n              }\n\n              pmtParsed = this.pmtParsed = true;\n              break;\n            }\n\n          case 17:\n          case 0x1fff:\n            break;\n\n          default:\n            unknownPIDs = true;\n            break;\n        }\n      } else {\n        tsPacketErrors++;\n      }\n    }\n\n    if (tsPacketErrors > 0) {\n      this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_4__[\"Events\"].ERROR, _events__WEBPACK_IMPORTED_MODULE_4__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_7__[\"ErrorTypes\"].MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_7__[\"ErrorDetails\"].FRAG_PARSING_ERROR,\n        fatal: false,\n        reason: \"Found \" + tsPacketErrors + \" TS packet/s that do not start with 0x47\"\n      });\n    }\n\n    videoTrack.pesData = avcData;\n    audioTrack.pesData = audioData;\n    id3Track.pesData = id3Data;\n    var demuxResult = {\n      audioTrack: audioTrack,\n      videoTrack: videoTrack,\n      id3Track: id3Track,\n      textTrack: textTrack\n    };\n\n    if (flush) {\n      this.extractRemainingSamples(demuxResult);\n    }\n\n    return demuxResult;\n  };\n\n  _proto.flush = function flush() {\n    var remainderData = this.remainderData;\n    this.remainderData = null;\n    var result;\n\n    if (remainderData) {\n      result = this.demux(remainderData, -1, false, true);\n    } else {\n      result = {\n        videoTrack: this._avcTrack,\n        audioTrack: this._audioTrack,\n        id3Track: this._id3Track,\n        textTrack: this._txtTrack\n      };\n    }\n\n    this.extractRemainingSamples(result);\n\n    if (this.sampleAes) {\n      return this.decrypt(result, this.sampleAes);\n    }\n\n    return result;\n  };\n\n  _proto.extractRemainingSamples = function extractRemainingSamples(demuxResult) {\n    var audioTrack = demuxResult.audioTrack,\n        videoTrack = demuxResult.videoTrack,\n        id3Track = demuxResult.id3Track,\n        textTrack = demuxResult.textTrack;\n    var avcData = videoTrack.pesData;\n    var audioData = audioTrack.pesData;\n    var id3Data = id3Track.pesData; // try to parse last PES packets\n\n    var pes;\n\n    if (avcData && (pes = parsePES(avcData))) {\n      this.parseAVCPES(videoTrack, textTrack, pes, true);\n      videoTrack.pesData = null;\n    } else {\n      // either avcData null or PES truncated, keep it for next frag parsing\n      videoTrack.pesData = avcData;\n    }\n\n    if (audioData && (pes = parsePES(audioData))) {\n      switch (audioTrack.segmentCodec) {\n        case 'aac':\n          this.parseAACPES(audioTrack, pes);\n          break;\n\n        case 'mp3':\n          this.parseMPEGPES(audioTrack, pes);\n          break;\n      }\n\n      audioTrack.pesData = null;\n    } else {\n      if (audioData !== null && audioData !== void 0 && audioData.size) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].log('last AAC PES packet truncated,might overlap between fragments');\n      } // either audioData null or PES truncated, keep it for next frag parsing\n\n\n      audioTrack.pesData = audioData;\n    }\n\n    if (id3Data && (pes = parsePES(id3Data))) {\n      this.parseID3PES(id3Track, pes);\n      id3Track.pesData = null;\n    } else {\n      // either id3Data null or PES truncated, keep it for next frag parsing\n      id3Track.pesData = id3Data;\n    }\n  };\n\n  _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n    var demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);\n    var sampleAes = this.sampleAes = new _sample_aes__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.observer, this.config, keyData);\n    return this.decrypt(demuxResult, sampleAes);\n  };\n\n  _proto.decrypt = function decrypt(demuxResult, sampleAes) {\n    return new Promise(function (resolve) {\n      var audioTrack = demuxResult.audioTrack,\n          videoTrack = demuxResult.videoTrack;\n\n      if (audioTrack.samples && audioTrack.segmentCodec === 'aac') {\n        sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {\n          if (videoTrack.samples) {\n            sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {\n              resolve(demuxResult);\n            });\n          } else {\n            resolve(demuxResult);\n          }\n        });\n      } else if (videoTrack.samples) {\n        sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {\n          resolve(demuxResult);\n        });\n      }\n    });\n  };\n\n  _proto.destroy = function destroy() {\n    this._duration = 0;\n  };\n\n  _proto.parseAVCPES = function parseAVCPES(track, textTrack, pes, last) {\n    var _this = this;\n\n    var units = this.parseAVCNALu(track, pes.data);\n    var debug = false;\n    var avcSample = this.avcSample;\n    var push;\n    var spsfound = false; // free pes.data to save up some memory\n\n    pes.data = null; // if new NAL units found and last sample still there, let's push ...\n    // this helps parsing streams with missing AUD (only do this if AUD never found)\n\n    if (avcSample && units.length && !track.audFound) {\n      pushAccessUnit(avcSample, track);\n      avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');\n    }\n\n    units.forEach(function (unit) {\n      switch (unit.type) {\n        // NDR\n        case 1:\n          {\n            push = true;\n\n            if (!avcSample) {\n              avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n            }\n\n            if (debug) {\n              avcSample.debug += 'NDR ';\n            }\n\n            avcSample.frame = true;\n            var data = unit.data; // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n\n            if (spsfound && data.length > 4) {\n              // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n              var sliceType = new _exp_golomb__WEBPACK_IMPORTED_MODULE_2__[\"default\"](data).readSliceType(); // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n              // if (sliceType === 2 || sliceType === 7) {\n\n              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                avcSample.key = true;\n              }\n            }\n\n            break; // IDR\n          }\n\n        case 5:\n          push = true; // handle PES not starting with AUD\n\n          if (!avcSample) {\n            avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n          }\n\n          if (debug) {\n            avcSample.debug += 'IDR ';\n          }\n\n          avcSample.key = true;\n          avcSample.frame = true;\n          break;\n        // SEI\n\n        case 6:\n          {\n            push = true;\n\n            if (debug && avcSample) {\n              avcSample.debug += 'SEI ';\n            }\n\n            Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_5__[\"parseSEIMessageFromNALu\"])(discardEPB(unit.data), pes.pts, textTrack.samples);\n            break; // SPS\n          }\n\n        case 7:\n          push = true;\n          spsfound = true;\n\n          if (debug && avcSample) {\n            avcSample.debug += 'SPS ';\n          }\n\n          if (!track.sps) {\n            var expGolombDecoder = new _exp_golomb__WEBPACK_IMPORTED_MODULE_2__[\"default\"](unit.data);\n            var config = expGolombDecoder.readSPS();\n            track.width = config.width;\n            track.height = config.height;\n            track.pixelRatio = config.pixelRatio; // TODO: `track.sps` is defined as a `number[]`, but we're setting it to a `Uint8Array[]`.\n\n            track.sps = [unit.data];\n            track.duration = _this._duration;\n            var codecarray = unit.data.subarray(1, 4);\n            var codecstring = 'avc1.';\n\n            for (var i = 0; i < 3; i++) {\n              var h = codecarray[i].toString(16);\n\n              if (h.length < 2) {\n                h = '0' + h;\n              }\n\n              codecstring += h;\n            }\n\n            track.codec = codecstring;\n          }\n\n          break;\n        // PPS\n\n        case 8:\n          push = true;\n\n          if (debug && avcSample) {\n            avcSample.debug += 'PPS ';\n          }\n\n          if (!track.pps) {\n            // TODO: `track.pss` is defined as a `number[]`, but we're setting it to a `Uint8Array[]`.\n            track.pps = [unit.data];\n          }\n\n          break;\n        // AUD\n\n        case 9:\n          push = false;\n          track.audFound = true;\n\n          if (avcSample) {\n            pushAccessUnit(avcSample, track);\n          }\n\n          avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');\n          break;\n        // Filler Data\n\n        case 12:\n          push = true;\n          break;\n\n        default:\n          push = false;\n\n          if (avcSample) {\n            avcSample.debug += 'unknown NAL ' + unit.type + ' ';\n          }\n\n          break;\n      }\n\n      if (avcSample && push) {\n        var _units = avcSample.units;\n\n        _units.push(unit);\n      }\n    }); // if last PES packet, push samples\n\n    if (last && avcSample) {\n      pushAccessUnit(avcSample, track);\n      this.avcSample = null;\n    }\n  };\n\n  _proto.getLastNalUnit = function getLastNalUnit(samples) {\n    var _avcSample;\n\n    var avcSample = this.avcSample;\n    var lastUnit; // try to fallback to previous sample if current one is empty\n\n    if (!avcSample || avcSample.units.length === 0) {\n      avcSample = samples[samples.length - 1];\n    }\n\n    if ((_avcSample = avcSample) !== null && _avcSample !== void 0 && _avcSample.units) {\n      var units = avcSample.units;\n      lastUnit = units[units.length - 1];\n    }\n\n    return lastUnit;\n  };\n\n  _proto.parseAVCNALu = function parseAVCNALu(track, array) {\n    var len = array.byteLength;\n    var state = track.naluState || 0;\n    var lastState = state;\n    var units = [];\n    var i = 0;\n    var value;\n    var overflow;\n    var unitType;\n    var lastUnitStart = -1;\n    var lastUnitType = 0; // logger.log('PES:' + Hex.hexDump(array));\n\n    if (state === -1) {\n      // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n      lastUnitStart = 0; // NALu type is value read from offset 0\n\n      lastUnitType = array[0] & 0x1f;\n      state = 0;\n      i = 1;\n    }\n\n    while (i < len) {\n      value = array[i++]; // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n\n      if (!state) {\n        state = value ? 0 : 1;\n        continue;\n      }\n\n      if (state === 1) {\n        state = value ? 0 : 2;\n        continue;\n      } // here we have state either equal to 2 or 3\n\n\n      if (!value) {\n        state = 3;\n      } else if (value === 1) {\n        if (lastUnitStart >= 0) {\n          var unit = {\n            data: array.subarray(lastUnitStart, i - state - 1),\n            type: lastUnitType\n          }; // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n\n          units.push(unit);\n        } else {\n          // lastUnitStart is undefined => this is the first start code found in this PES packet\n          // first check if start code delimiter is overlapping between 2 PES packets,\n          // ie it started in last packet (lastState not zero)\n          // and ended at the beginning of this PES packet (i <= 4 - lastState)\n          var lastUnit = this.getLastNalUnit(track.samples);\n\n          if (lastUnit) {\n            if (lastState && i <= 4 - lastState) {\n              // start delimiter overlapping between PES packets\n              // strip start delimiter bytes from the end of last NAL unit\n              // check if lastUnit had a state different from zero\n              if (lastUnit.state) {\n                // strip last bytes\n                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n              }\n            } // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n\n\n            overflow = i - state - 1;\n\n            if (overflow > 0) {\n              // logger.log('first NALU found with overflow:' + overflow);\n              var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);\n              tmp.set(lastUnit.data, 0);\n              tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);\n              lastUnit.data = tmp;\n              lastUnit.state = 0;\n            }\n          }\n        } // check if we can read unit type\n\n\n        if (i < len) {\n          unitType = array[i] & 0x1f; // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n\n          lastUnitStart = i;\n          lastUnitType = unitType;\n          state = 0;\n        } else {\n          // not enough byte to read unit type. let's read it on next PES parsing\n          state = -1;\n        }\n      } else {\n        state = 0;\n      }\n    }\n\n    if (lastUnitStart >= 0 && state >= 0) {\n      var _unit = {\n        data: array.subarray(lastUnitStart, len),\n        type: lastUnitType,\n        state: state\n      };\n      units.push(_unit); // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n    } // no NALu found\n\n\n    if (units.length === 0) {\n      // append pes.data to previous NAL unit\n      var _lastUnit = this.getLastNalUnit(track.samples);\n\n      if (_lastUnit) {\n        var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);\n\n        _tmp.set(_lastUnit.data, 0);\n\n        _tmp.set(array, _lastUnit.data.byteLength);\n\n        _lastUnit.data = _tmp;\n      }\n    }\n\n    track.naluState = state;\n    return units;\n  };\n\n  _proto.parseAACPES = function parseAACPES(track, pes) {\n    var startOffset = 0;\n    var aacOverFlow = this.aacOverFlow;\n    var data = pes.data;\n\n    if (aacOverFlow) {\n      this.aacOverFlow = null;\n      var frameMissingBytes = aacOverFlow.missing;\n      var sampleLength = aacOverFlow.sample.unit.byteLength; // logger.log(`AAC: append overflowing ${sampleLength} bytes to beginning of new PES`);\n\n      if (frameMissingBytes === -1) {\n        var tmp = new Uint8Array(sampleLength + data.byteLength);\n        tmp.set(aacOverFlow.sample.unit, 0);\n        tmp.set(data, sampleLength);\n        data = tmp;\n      } else {\n        var frameOverflowBytes = sampleLength - frameMissingBytes;\n        aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);\n        track.samples.push(aacOverFlow.sample);\n        startOffset = aacOverFlow.missing;\n      }\n    } // look for ADTS header (0xFFFx)\n\n\n    var offset;\n    var len;\n\n    for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n      if (_adts__WEBPACK_IMPORTED_MODULE_0__[\"isHeader\"](data, offset)) {\n        break;\n      }\n    } // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n\n\n    if (offset !== startOffset) {\n      var reason;\n      var fatal;\n\n      if (offset < len - 1) {\n        reason = \"AAC PES did not start with ADTS header,offset:\" + offset;\n        fatal = false;\n      } else {\n        reason = 'no ADTS header found in AAC PES';\n        fatal = true;\n      }\n\n      _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].warn(\"parsing error:\" + reason);\n      this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_4__[\"Events\"].ERROR, _events__WEBPACK_IMPORTED_MODULE_4__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_7__[\"ErrorTypes\"].MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_7__[\"ErrorDetails\"].FRAG_PARSING_ERROR,\n        fatal: fatal,\n        reason: reason\n      });\n\n      if (fatal) {\n        return;\n      }\n    }\n\n    _adts__WEBPACK_IMPORTED_MODULE_0__[\"initTrackConfig\"](track, this.observer, data, offset, this.audioCodec);\n    var pts;\n\n    if (pes.pts !== undefined) {\n      pts = pes.pts;\n    } else if (aacOverFlow) {\n      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n      // first sample PTS should be equal to last sample PTS + frameDuration\n      var frameDuration = _adts__WEBPACK_IMPORTED_MODULE_0__[\"getFrameDuration\"](track.samplerate);\n      pts = aacOverFlow.sample.pts + frameDuration;\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].warn('[tsdemuxer]: AAC PES unknown PTS');\n      return;\n    } // scan for aac samples\n\n\n    var frameIndex = 0;\n    var frame;\n\n    while (offset < len) {\n      frame = _adts__WEBPACK_IMPORTED_MODULE_0__[\"appendFrame\"](track, data, offset, pts, frameIndex);\n      offset += frame.length;\n\n      if (!frame.missing) {\n        frameIndex++;\n\n        for (; offset < len - 1; offset++) {\n          if (_adts__WEBPACK_IMPORTED_MODULE_0__[\"isHeader\"](data, offset)) {\n            break;\n          }\n        }\n      } else {\n        this.aacOverFlow = frame;\n        break;\n      }\n    }\n  };\n\n  _proto.parseMPEGPES = function parseMPEGPES(track, pes) {\n    var data = pes.data;\n    var length = data.length;\n    var frameIndex = 0;\n    var offset = 0;\n    var pts = pes.pts;\n\n    if (pts === undefined) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].warn('[tsdemuxer]: MPEG PES unknown PTS');\n      return;\n    }\n\n    while (offset < length) {\n      if (_mpegaudio__WEBPACK_IMPORTED_MODULE_1__[\"isHeader\"](data, offset)) {\n        var frame = _mpegaudio__WEBPACK_IMPORTED_MODULE_1__[\"appendFrame\"](track, data, offset, pts, frameIndex);\n\n        if (frame) {\n          offset += frame.length;\n          frameIndex++;\n        } else {\n          // logger.log('Unable to parse Mpeg audio frame');\n          break;\n        }\n      } else {\n        // nothing found, keep looking\n        offset++;\n      }\n    }\n  };\n\n  _proto.parseID3PES = function parseID3PES(id3Track, pes) {\n    if (pes.pts === undefined) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].warn('[tsdemuxer]: ID3 PES unknown PTS');\n      return;\n    }\n\n    var id3Sample = _extends({}, pes, {\n      type: this._avcTrack ? _types_demuxer__WEBPACK_IMPORTED_MODULE_8__[\"MetadataSchema\"].emsg : _types_demuxer__WEBPACK_IMPORTED_MODULE_8__[\"MetadataSchema\"].audioId3\n    });\n\n    id3Track.samples.push(id3Sample);\n  };\n\n  return TSDemuxer;\n}();\n\nTSDemuxer.minProbeByteLength = 188;\n\nfunction createAVCSample(key, pts, dts, debug) {\n  return {\n    key: key,\n    frame: false,\n    pts: pts,\n    dts: dts,\n    units: [],\n    debug: debug,\n    length: 0\n  };\n}\n\nfunction parsePAT(data, offset) {\n  // skip the PSI header and parse the first PMT entry\n  return (data[offset + 10] & 0x1f) << 8 | data[offset + 11]; // logger.log('PMT PID:'  + this._pmtId);\n}\n\nfunction parsePMT(data, offset, typeSupported, isSampleAes) {\n  var result = {\n    audio: -1,\n    avc: -1,\n    id3: -1,\n    segmentCodec: 'aac'\n  };\n  var sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n  var tableEnd = offset + 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\n  // long the program info descriptors are\n\n  var programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11]; // advance the offset to the first entry in the mapping table\n\n  offset += 12 + programInfoLength;\n\n  while (offset < tableEnd) {\n    var pid = (data[offset + 1] & 0x1f) << 8 | data[offset + 2];\n\n    switch (data[offset]) {\n      case 0xcf:\n        // SAMPLE-AES AAC\n        if (!isSampleAes) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].log('ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream');\n          break;\n        }\n\n      /* falls through */\n\n      case 0x0f:\n        // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n        // logger.log('AAC PID:'  + pid);\n        if (result.audio === -1) {\n          result.audio = pid;\n        }\n\n        break;\n      // Packetized metadata (ID3)\n\n      case 0x15:\n        // logger.log('ID3 PID:'  + pid);\n        if (result.id3 === -1) {\n          result.id3 = pid;\n        }\n\n        break;\n\n      case 0xdb:\n        // SAMPLE-AES AVC\n        if (!isSampleAes) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].log('H.264 with AES-128-CBC slice encryption found in unencrypted stream');\n          break;\n        }\n\n      /* falls through */\n\n      case 0x1b:\n        // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n        // logger.log('AVC PID:'  + pid);\n        if (result.avc === -1) {\n          result.avc = pid;\n        }\n\n        break;\n      // ISO/IEC 11172-3 (MPEG-1 audio)\n      // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n\n      case 0x03:\n      case 0x04:\n        // logger.log('MPEG PID:'  + pid);\n        if (typeSupported.mpeg !== true && typeSupported.mp3 !== true) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].log('MPEG audio found, not supported in this browser');\n        } else if (result.audio === -1) {\n          result.audio = pid;\n          result.segmentCodec = 'mp3';\n        }\n\n        break;\n\n      case 0x24:\n        _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].warn('Unsupported HEVC stream type found');\n        break;\n\n      default:\n        // logger.log('unknown stream type:' + data[offset]);\n        break;\n    } // move to the next table entry\n    // skip past the elementary stream descriptors, if present\n\n\n    offset += ((data[offset + 3] & 0x0f) << 8 | data[offset + 4]) + 5;\n  }\n\n  return result;\n}\n\nfunction parsePES(stream) {\n  var i = 0;\n  var frag;\n  var pesLen;\n  var pesHdrLen;\n  var pesPts;\n  var pesDts;\n  var data = stream.data; // safety check\n\n  if (!stream || stream.size === 0) {\n    return null;\n  } // we might need up to 19 bytes to read PES header\n  // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n  // usually only one merge is needed (and this is rare ...)\n\n\n  while (data[0].length < 19 && data.length > 1) {\n    var newData = new Uint8Array(data[0].length + data[1].length);\n    newData.set(data[0]);\n    newData.set(data[1], data[0].length);\n    data[0] = newData;\n    data.splice(1, 1);\n  } // retrieve PTS/DTS from first fragment\n\n\n  frag = data[0];\n  var pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n\n  if (pesPrefix === 1) {\n    pesLen = (frag[4] << 8) + frag[5]; // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n    // minus 6 : PES header size\n\n    if (pesLen && pesLen > stream.size - 6) {\n      return null;\n    }\n\n    var pesFlags = frag[7];\n\n    if (pesFlags & 0xc0) {\n      /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n          as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n          as Bitwise operators treat their operands as a sequence of 32 bits */\n      pesPts = (frag[9] & 0x0e) * 536870912 + // 1 << 29\n      (frag[10] & 0xff) * 4194304 + // 1 << 22\n      (frag[11] & 0xfe) * 16384 + // 1 << 14\n      (frag[12] & 0xff) * 128 + // 1 << 7\n      (frag[13] & 0xfe) / 2;\n\n      if (pesFlags & 0x40) {\n        pesDts = (frag[14] & 0x0e) * 536870912 + // 1 << 29\n        (frag[15] & 0xff) * 4194304 + // 1 << 22\n        (frag[16] & 0xfe) * 16384 + // 1 << 14\n        (frag[17] & 0xff) * 128 + // 1 << 7\n        (frag[18] & 0xfe) / 2;\n\n        if (pesPts - pesDts > 60 * 90000) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].warn(Math.round((pesPts - pesDts) / 90000) + \"s delta between PTS and DTS, align them\");\n          pesPts = pesDts;\n        }\n      } else {\n        pesDts = pesPts;\n      }\n    }\n\n    pesHdrLen = frag[8]; // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n\n    var payloadStartOffset = pesHdrLen + 9;\n\n    if (stream.size <= payloadStartOffset) {\n      return null;\n    }\n\n    stream.size -= payloadStartOffset; // reassemble PES packet\n\n    var pesData = new Uint8Array(stream.size);\n\n    for (var j = 0, dataLen = data.length; j < dataLen; j++) {\n      frag = data[j];\n      var len = frag.byteLength;\n\n      if (payloadStartOffset) {\n        if (payloadStartOffset > len) {\n          // trim full frag if PES header bigger than frag\n          payloadStartOffset -= len;\n          continue;\n        } else {\n          // trim partial frag if PES header smaller than frag\n          frag = frag.subarray(payloadStartOffset);\n          len -= payloadStartOffset;\n          payloadStartOffset = 0;\n        }\n      }\n\n      pesData.set(frag, i);\n      i += len;\n    }\n\n    if (pesLen) {\n      // payload size : remove PES header + PES extension\n      pesLen -= pesHdrLen + 3;\n    }\n\n    return {\n      data: pesData,\n      pts: pesPts,\n      dts: pesDts,\n      len: pesLen\n    };\n  }\n\n  return null;\n}\n\nfunction pushAccessUnit(avcSample, avcTrack) {\n  if (avcSample.units.length && avcSample.frame) {\n    // if sample does not have PTS/DTS, patch with last sample PTS/DTS\n    if (avcSample.pts === undefined) {\n      var samples = avcTrack.samples;\n      var nbSamples = samples.length;\n\n      if (nbSamples) {\n        var lastSample = samples[nbSamples - 1];\n        avcSample.pts = lastSample.pts;\n        avcSample.dts = lastSample.dts;\n      } else {\n        // dropping samples, no timestamp found\n        avcTrack.dropped++;\n        return;\n      }\n    }\n\n    avcTrack.samples.push(avcSample);\n  }\n\n  if (avcSample.debug.length) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);\n  }\n}\n/**\n * remove Emulation Prevention bytes from a RBSP\n */\n\n\nfunction discardEPB(data) {\n  var length = data.byteLength;\n  var EPBPositions = [];\n  var i = 1; // Find all `Emulation Prevention Bytes`\n\n  while (i < length - 2) {\n    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n      EPBPositions.push(i + 2);\n      i += 2;\n    } else {\n      i++;\n    }\n  } // If no Emulation Prevention Bytes were found just return the original\n  // array\n\n\n  if (EPBPositions.length === 0) {\n    return data;\n  } // Create a new array to hold the NAL unit data\n\n\n  var newLength = length - EPBPositions.length;\n  var newData = new Uint8Array(newLength);\n  var sourceIndex = 0;\n\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === EPBPositions[0]) {\n      // Skip this byte\n      sourceIndex++; // Remove this position index\n\n      EPBPositions.shift();\n    }\n\n    newData[i] = data[sourceIndex];\n  }\n\n  return newData;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (TSDemuxer);\n\n/***/ }),\n\n/***/ \"./src/errors.ts\":\n/*!***********************!*\\\n  !*** ./src/errors.ts ***!\n  \\***********************/\n/*! exports provided: ErrorTypes, ErrorDetails */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_641112__) {\n\n\"use strict\";\n__nested_webpack_require_641112__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_641112__.d(__webpack_exports__, \"ErrorTypes\", function() { return ErrorTypes; });\n/* harmony export (binding) */ __nested_webpack_require_641112__.d(__webpack_exports__, \"ErrorDetails\", function() { return ErrorDetails; });\nvar ErrorTypes;\n/**\n * @enum {ErrorDetails}\n * @typedef {string} ErrorDetail\n */\n\n(function (ErrorTypes) {\n  ErrorTypes[\"NETWORK_ERROR\"] = \"networkError\";\n  ErrorTypes[\"MEDIA_ERROR\"] = \"mediaError\";\n  ErrorTypes[\"KEY_SYSTEM_ERROR\"] = \"keySystemError\";\n  ErrorTypes[\"MUX_ERROR\"] = \"muxError\";\n  ErrorTypes[\"OTHER_ERROR\"] = \"otherError\";\n})(ErrorTypes || (ErrorTypes = {}));\n\nvar ErrorDetails;\n\n(function (ErrorDetails) {\n  ErrorDetails[\"KEY_SYSTEM_NO_KEYS\"] = \"keySystemNoKeys\";\n  ErrorDetails[\"KEY_SYSTEM_NO_ACCESS\"] = \"keySystemNoAccess\";\n  ErrorDetails[\"KEY_SYSTEM_NO_SESSION\"] = \"keySystemNoSession\";\n  ErrorDetails[\"KEY_SYSTEM_LICENSE_REQUEST_FAILED\"] = \"keySystemLicenseRequestFailed\";\n  ErrorDetails[\"KEY_SYSTEM_NO_INIT_DATA\"] = \"keySystemNoInitData\";\n  ErrorDetails[\"MANIFEST_LOAD_ERROR\"] = \"manifestLoadError\";\n  ErrorDetails[\"MANIFEST_LOAD_TIMEOUT\"] = \"manifestLoadTimeOut\";\n  ErrorDetails[\"MANIFEST_PARSING_ERROR\"] = \"manifestParsingError\";\n  ErrorDetails[\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\"] = \"manifestIncompatibleCodecsError\";\n  ErrorDetails[\"LEVEL_EMPTY_ERROR\"] = \"levelEmptyError\";\n  ErrorDetails[\"LEVEL_LOAD_ERROR\"] = \"levelLoadError\";\n  ErrorDetails[\"LEVEL_LOAD_TIMEOUT\"] = \"levelLoadTimeOut\";\n  ErrorDetails[\"LEVEL_SWITCH_ERROR\"] = \"levelSwitchError\";\n  ErrorDetails[\"AUDIO_TRACK_LOAD_ERROR\"] = \"audioTrackLoadError\";\n  ErrorDetails[\"AUDIO_TRACK_LOAD_TIMEOUT\"] = \"audioTrackLoadTimeOut\";\n  ErrorDetails[\"SUBTITLE_LOAD_ERROR\"] = \"subtitleTrackLoadError\";\n  ErrorDetails[\"SUBTITLE_TRACK_LOAD_TIMEOUT\"] = \"subtitleTrackLoadTimeOut\";\n  ErrorDetails[\"FRAG_LOAD_ERROR\"] = \"fragLoadError\";\n  ErrorDetails[\"FRAG_LOAD_TIMEOUT\"] = \"fragLoadTimeOut\";\n  ErrorDetails[\"FRAG_DECRYPT_ERROR\"] = \"fragDecryptError\";\n  ErrorDetails[\"FRAG_PARSING_ERROR\"] = \"fragParsingError\";\n  ErrorDetails[\"REMUX_ALLOC_ERROR\"] = \"remuxAllocError\";\n  ErrorDetails[\"KEY_LOAD_ERROR\"] = \"keyLoadError\";\n  ErrorDetails[\"KEY_LOAD_TIMEOUT\"] = \"keyLoadTimeOut\";\n  ErrorDetails[\"BUFFER_ADD_CODEC_ERROR\"] = \"bufferAddCodecError\";\n  ErrorDetails[\"BUFFER_INCOMPATIBLE_CODECS_ERROR\"] = \"bufferIncompatibleCodecsError\";\n  ErrorDetails[\"BUFFER_APPEND_ERROR\"] = \"bufferAppendError\";\n  ErrorDetails[\"BUFFER_APPENDING_ERROR\"] = \"bufferAppendingError\";\n  ErrorDetails[\"BUFFER_STALLED_ERROR\"] = \"bufferStalledError\";\n  ErrorDetails[\"BUFFER_FULL_ERROR\"] = \"bufferFullError\";\n  ErrorDetails[\"BUFFER_SEEK_OVER_HOLE\"] = \"bufferSeekOverHole\";\n  ErrorDetails[\"BUFFER_NUDGE_ON_STALL\"] = \"bufferNudgeOnStall\";\n  ErrorDetails[\"INTERNAL_EXCEPTION\"] = \"internalException\";\n  ErrorDetails[\"INTERNAL_ABORTED\"] = \"aborted\";\n  ErrorDetails[\"UNKNOWN\"] = \"unknown\";\n})(ErrorDetails || (ErrorDetails = {}));\n\n/***/ }),\n\n/***/ \"./src/events.ts\":\n/*!***********************!*\\\n  !*** ./src/events.ts ***!\n  \\***********************/\n/*! exports provided: Events */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_644302__) {\n\n\"use strict\";\n__nested_webpack_require_644302__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_644302__.d(__webpack_exports__, \"Events\", function() { return Events; });\n/**\n * @readonly\n * @enum {string}\n */\nvar Events;\n\n(function (Events) {\n  Events[\"MEDIA_ATTACHING\"] = \"hlsMediaAttaching\";\n  Events[\"MEDIA_ATTACHED\"] = \"hlsMediaAttached\";\n  Events[\"MEDIA_DETACHING\"] = \"hlsMediaDetaching\";\n  Events[\"MEDIA_DETACHED\"] = \"hlsMediaDetached\";\n  Events[\"BUFFER_RESET\"] = \"hlsBufferReset\";\n  Events[\"BUFFER_CODECS\"] = \"hlsBufferCodecs\";\n  Events[\"BUFFER_CREATED\"] = \"hlsBufferCreated\";\n  Events[\"BUFFER_APPENDING\"] = \"hlsBufferAppending\";\n  Events[\"BUFFER_APPENDED\"] = \"hlsBufferAppended\";\n  Events[\"BUFFER_EOS\"] = \"hlsBufferEos\";\n  Events[\"BUFFER_FLUSHING\"] = \"hlsBufferFlushing\";\n  Events[\"BUFFER_FLUSHED\"] = \"hlsBufferFlushed\";\n  Events[\"MANIFEST_LOADING\"] = \"hlsManifestLoading\";\n  Events[\"MANIFEST_LOADED\"] = \"hlsManifestLoaded\";\n  Events[\"MANIFEST_PARSED\"] = \"hlsManifestParsed\";\n  Events[\"LEVEL_SWITCHING\"] = \"hlsLevelSwitching\";\n  Events[\"LEVEL_SWITCHED\"] = \"hlsLevelSwitched\";\n  Events[\"LEVEL_LOADING\"] = \"hlsLevelLoading\";\n  Events[\"LEVEL_LOADED\"] = \"hlsLevelLoaded\";\n  Events[\"LEVEL_UPDATED\"] = \"hlsLevelUpdated\";\n  Events[\"LEVEL_PTS_UPDATED\"] = \"hlsLevelPtsUpdated\";\n  Events[\"LEVELS_UPDATED\"] = \"hlsLevelsUpdated\";\n  Events[\"AUDIO_TRACKS_UPDATED\"] = \"hlsAudioTracksUpdated\";\n  Events[\"AUDIO_TRACK_SWITCHING\"] = \"hlsAudioTrackSwitching\";\n  Events[\"AUDIO_TRACK_SWITCHED\"] = \"hlsAudioTrackSwitched\";\n  Events[\"AUDIO_TRACK_LOADING\"] = \"hlsAudioTrackLoading\";\n  Events[\"AUDIO_TRACK_LOADED\"] = \"hlsAudioTrackLoaded\";\n  Events[\"SUBTITLE_TRACKS_UPDATED\"] = \"hlsSubtitleTracksUpdated\";\n  Events[\"SUBTITLE_TRACKS_CLEARED\"] = \"hlsSubtitleTracksCleared\";\n  Events[\"SUBTITLE_TRACK_SWITCH\"] = \"hlsSubtitleTrackSwitch\";\n  Events[\"SUBTITLE_TRACK_LOADING\"] = \"hlsSubtitleTrackLoading\";\n  Events[\"SUBTITLE_TRACK_LOADED\"] = \"hlsSubtitleTrackLoaded\";\n  Events[\"SUBTITLE_FRAG_PROCESSED\"] = \"hlsSubtitleFragProcessed\";\n  Events[\"CUES_PARSED\"] = \"hlsCuesParsed\";\n  Events[\"NON_NATIVE_TEXT_TRACKS_FOUND\"] = \"hlsNonNativeTextTracksFound\";\n  Events[\"INIT_PTS_FOUND\"] = \"hlsInitPtsFound\";\n  Events[\"FRAG_LOADING\"] = \"hlsFragLoading\";\n  Events[\"FRAG_LOAD_EMERGENCY_ABORTED\"] = \"hlsFragLoadEmergencyAborted\";\n  Events[\"FRAG_LOADED\"] = \"hlsFragLoaded\";\n  Events[\"FRAG_DECRYPTED\"] = \"hlsFragDecrypted\";\n  Events[\"FRAG_PARSING_INIT_SEGMENT\"] = \"hlsFragParsingInitSegment\";\n  Events[\"FRAG_PARSING_USERDATA\"] = \"hlsFragParsingUserdata\";\n  Events[\"FRAG_PARSING_METADATA\"] = \"hlsFragParsingMetadata\";\n  Events[\"FRAG_PARSED\"] = \"hlsFragParsed\";\n  Events[\"FRAG_BUFFERED\"] = \"hlsFragBuffered\";\n  Events[\"FRAG_CHANGED\"] = \"hlsFragChanged\";\n  Events[\"FPS_DROP\"] = \"hlsFpsDrop\";\n  Events[\"FPS_DROP_LEVEL_CAPPING\"] = \"hlsFpsDropLevelCapping\";\n  Events[\"ERROR\"] = \"hlsError\";\n  Events[\"DESTROYING\"] = \"hlsDestroying\";\n  Events[\"KEY_LOADING\"] = \"hlsKeyLoading\";\n  Events[\"KEY_LOADED\"] = \"hlsKeyLoaded\";\n  Events[\"LIVE_BACK_BUFFER_REACHED\"] = \"hlsLiveBackBufferReached\";\n  Events[\"BACK_BUFFER_REACHED\"] = \"hlsBackBufferReached\";\n})(Events || (Events = {}));\n\n/***/ }),\n\n/***/ \"./src/hls.ts\":\n/*!********************!*\\\n  !*** ./src/hls.ts ***!\n  \\********************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_647642__) {\n\n\"use strict\";\n__nested_webpack_require_647642__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_647642__.d(__webpack_exports__, \"default\", function() { return Hls; });\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_647642__(/*! url-toolkit */ \"./node_modules/url-toolkit/src/url-toolkit.js\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_647642__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _loader_playlist_loader__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_647642__(/*! ./loader/playlist-loader */ \"./src/loader/playlist-loader.ts\");\n/* harmony import */ var _loader_key_loader__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_647642__(/*! ./loader/key-loader */ \"./src/loader/key-loader.ts\");\n/* harmony import */ var _controller_id3_track_controller__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_647642__(/*! ./controller/id3-track-controller */ \"./src/controller/id3-track-controller.ts\");\n/* harmony import */ var _controller_latency_controller__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_647642__(/*! ./controller/latency-controller */ \"./src/controller/latency-controller.ts\");\n/* harmony import */ var _controller_level_controller__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_647642__(/*! ./controller/level-controller */ \"./src/controller/level-controller.ts\");\n/* harmony import */ var _controller_fragment_tracker__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_647642__(/*! ./controller/fragment-tracker */ \"./src/controller/fragment-tracker.ts\");\n/* harmony import */ var _controller_stream_controller__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_647642__(/*! ./controller/stream-controller */ \"./src/controller/stream-controller.ts\");\n/* harmony import */ var _is_supported__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_647642__(/*! ./is-supported */ \"./src/is-supported.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_647642__(/*! ./utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_647642__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_647642__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__nested_webpack_require_647642__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_647642__(/*! ./events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_647642__(/*! ./errors */ \"./src/errors.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @module Hls\n * @class\n * @constructor\n */\nvar Hls = /*#__PURE__*/function () {\n  Hls.isSupported = function isSupported() {\n    return Object(_is_supported__WEBPACK_IMPORTED_MODULE_8__[\"isSupported\"])();\n  };\n\n  /**\n   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.\n   *\n   * @constructs Hls\n   * @param {HlsConfig} config\n   */\n  function Hls(userConfig) {\n    if (userConfig === void 0) {\n      userConfig = {};\n    }\n\n    this.config = void 0;\n    this.userConfig = void 0;\n    this.coreComponents = void 0;\n    this.networkControllers = void 0;\n    this._emitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_11__[\"EventEmitter\"]();\n    this._autoLevelCapping = void 0;\n    this.abrController = void 0;\n    this.bufferController = void 0;\n    this.capLevelController = void 0;\n    this.latencyController = void 0;\n    this.levelController = void 0;\n    this.streamController = void 0;\n    this.audioTrackController = void 0;\n    this.subtitleTrackController = void 0;\n    this.emeController = void 0;\n    this.cmcdController = void 0;\n    this._media = null;\n    this.url = null;\n    var config = this.config = Object(_config__WEBPACK_IMPORTED_MODULE_10__[\"mergeConfig\"])(Hls.DefaultConfig, userConfig);\n    this.userConfig = userConfig;\n    Object(_utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"enableLogs\"])(config.debug);\n    this._autoLevelCapping = -1;\n\n    if (config.progressive) {\n      Object(_config__WEBPACK_IMPORTED_MODULE_10__[\"enableStreamingMode\"])(config);\n    } // core controllers and network loaders\n\n\n    var ConfigAbrController = config.abrController,\n        ConfigBufferController = config.bufferController,\n        ConfigCapLevelController = config.capLevelController,\n        ConfigFpsController = config.fpsController;\n    var abrController = this.abrController = new ConfigAbrController(this);\n    var bufferController = this.bufferController = new ConfigBufferController(this);\n    var capLevelController = this.capLevelController = new ConfigCapLevelController(this);\n    var fpsController = new ConfigFpsController(this);\n    var playListLoader = new _loader_playlist_loader__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this);\n    var keyLoader = new _loader_key_loader__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this);\n    var id3TrackController = new _controller_id3_track_controller__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this); // network controllers\n\n    var levelController = this.levelController = new _controller_level_controller__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this); // FragmentTracker must be defined before StreamController because the order of event handling is important\n\n    var fragmentTracker = new _controller_fragment_tracker__WEBPACK_IMPORTED_MODULE_6__[\"FragmentTracker\"](this);\n    var streamController = this.streamController = new _controller_stream_controller__WEBPACK_IMPORTED_MODULE_7__[\"default\"](this, fragmentTracker); // Cap level controller uses streamController to flush the buffer\n\n    capLevelController.setStreamController(streamController); // fpsController uses streamController to switch when frames are being dropped\n\n    fpsController.setStreamController(streamController);\n    var networkControllers = [levelController, streamController];\n    this.networkControllers = networkControllers;\n    var coreComponents = [playListLoader, keyLoader, abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];\n    this.audioTrackController = this.createController(config.audioTrackController, null, networkControllers);\n    this.createController(config.audioStreamController, fragmentTracker, networkControllers); // subtitleTrackController must be defined before  because the order of event handling is important\n\n    this.subtitleTrackController = this.createController(config.subtitleTrackController, null, networkControllers);\n    this.createController(config.subtitleStreamController, fragmentTracker, networkControllers);\n    this.createController(config.timelineController, null, coreComponents);\n    this.emeController = this.createController(config.emeController, null, coreComponents);\n    this.cmcdController = this.createController(config.cmcdController, null, coreComponents);\n    this.latencyController = this.createController(_controller_latency_controller__WEBPACK_IMPORTED_MODULE_4__[\"default\"], null, coreComponents);\n    this.coreComponents = coreComponents;\n  }\n\n  var _proto = Hls.prototype;\n\n  _proto.createController = function createController(ControllerClass, fragmentTracker, components) {\n    if (ControllerClass) {\n      var controllerInstance = fragmentTracker ? new ControllerClass(this, fragmentTracker) : new ControllerClass(this);\n\n      if (components) {\n        components.push(controllerInstance);\n      }\n\n      return controllerInstance;\n    }\n\n    return null;\n  } // Delegate the EventEmitter through the public API of Hls.js\n  ;\n\n  _proto.on = function on(event, listener, context) {\n    if (context === void 0) {\n      context = this;\n    }\n\n    this._emitter.on(event, listener, context);\n  };\n\n  _proto.once = function once(event, listener, context) {\n    if (context === void 0) {\n      context = this;\n    }\n\n    this._emitter.once(event, listener, context);\n  };\n\n  _proto.removeAllListeners = function removeAllListeners(event) {\n    this._emitter.removeAllListeners(event);\n  };\n\n  _proto.off = function off(event, listener, context, once) {\n    if (context === void 0) {\n      context = this;\n    }\n\n    this._emitter.off(event, listener, context, once);\n  };\n\n  _proto.listeners = function listeners(event) {\n    return this._emitter.listeners(event);\n  };\n\n  _proto.emit = function emit(event, name, eventObject) {\n    return this._emitter.emit(event, name, eventObject);\n  };\n\n  _proto.trigger = function trigger(event, eventObject) {\n    if (this.config.debug) {\n      return this.emit(event, event, eventObject);\n    } else {\n      try {\n        return this.emit(event, event, eventObject);\n      } catch (e) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].error('An internal error happened while handling event ' + event + '. Error message: \"' + e.message + '\". Here is a stacktrace:', e);\n        this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__[\"Events\"].ERROR, {\n          type: _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorTypes\"].OTHER_ERROR,\n          details: _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"].INTERNAL_EXCEPTION,\n          fatal: false,\n          event: event,\n          error: e\n        });\n      }\n    }\n\n    return false;\n  };\n\n  _proto.listenerCount = function listenerCount(event) {\n    return this._emitter.listenerCount(event);\n  }\n  /**\n   * Dispose of the instance\n   */\n  ;\n\n  _proto.destroy = function destroy() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log('destroy');\n    this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__[\"Events\"].DESTROYING, undefined);\n    this.detachMedia();\n    this.removeAllListeners();\n    this._autoLevelCapping = -1;\n    this.url = null;\n    this.networkControllers.forEach(function (component) {\n      return component.destroy();\n    });\n    this.networkControllers.length = 0;\n    this.coreComponents.forEach(function (component) {\n      return component.destroy();\n    });\n    this.coreComponents.length = 0;\n  }\n  /**\n   * Attaches Hls.js to a media element\n   * @param {HTMLMediaElement} media\n   */\n  ;\n\n  _proto.attachMedia = function attachMedia(media) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log('attachMedia');\n    this._media = media;\n    this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__[\"Events\"].MEDIA_ATTACHING, {\n      media: media\n    });\n  }\n  /**\n   * Detach Hls.js from the media\n   */\n  ;\n\n  _proto.detachMedia = function detachMedia() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log('detachMedia');\n    this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__[\"Events\"].MEDIA_DETACHING, undefined);\n    this._media = null;\n  }\n  /**\n   * Set the source URL. Can be relative or absolute.\n   * @param {string} url\n   */\n  ;\n\n  _proto.loadSource = function loadSource(url) {\n    this.stopLoad();\n    var media = this.media;\n    var loadedSource = this.url;\n    var loadingSource = this.url = url_toolkit__WEBPACK_IMPORTED_MODULE_0__[\"buildAbsoluteURL\"](self.location.href, url, {\n      alwaysNormalize: true\n    });\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log(\"loadSource:\" + loadingSource);\n\n    if (media && loadedSource && loadedSource !== loadingSource && this.bufferController.hasSourceTypes()) {\n      this.detachMedia();\n      this.attachMedia(media);\n    } // when attaching to a source URL, trigger a playlist load\n\n\n    this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__[\"Events\"].MANIFEST_LOADING, {\n      url: url\n    });\n  }\n  /**\n   * Start loading data from the stream source.\n   * Depending on default config, client starts loading automatically when a source is set.\n   *\n   * @param {number} startPosition Set the start position to stream from\n   * @default -1 None (from earliest point)\n   */\n  ;\n\n  _proto.startLoad = function startLoad(startPosition) {\n    if (startPosition === void 0) {\n      startPosition = -1;\n    }\n\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log(\"startLoad(\" + startPosition + \")\");\n    this.networkControllers.forEach(function (controller) {\n      controller.startLoad(startPosition);\n    });\n  }\n  /**\n   * Stop loading of any stream data.\n   */\n  ;\n\n  _proto.stopLoad = function stopLoad() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log('stopLoad');\n    this.networkControllers.forEach(function (controller) {\n      controller.stopLoad();\n    });\n  }\n  /**\n   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)\n   */\n  ;\n\n  _proto.swapAudioCodec = function swapAudioCodec() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log('swapAudioCodec');\n    this.streamController.swapAudioCodec();\n  }\n  /**\n   * When the media-element fails, this allows to detach and then re-attach it\n   * as one call (convenience method).\n   *\n   * Automatic recovery of media-errors by this process is configurable.\n   */\n  ;\n\n  _proto.recoverMediaError = function recoverMediaError() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log('recoverMediaError');\n    var media = this._media;\n    this.detachMedia();\n\n    if (media) {\n      this.attachMedia(media);\n    }\n  };\n\n  _proto.removeLevel = function removeLevel(levelIndex, urlId) {\n    if (urlId === void 0) {\n      urlId = 0;\n    }\n\n    this.levelController.removeLevel(levelIndex, urlId);\n  }\n  /**\n   * @type {Level[]}\n   */\n  ;\n\n  _createClass(Hls, [{\n    key: \"levels\",\n    get: function get() {\n      var levels = this.levelController.levels;\n      return levels ? levels : [];\n    }\n    /**\n     * Index of quality level currently played\n     * @type {number}\n     */\n\n  }, {\n    key: \"currentLevel\",\n    get: function get() {\n      return this.streamController.currentLevel;\n    }\n    /**\n     * Set quality level index immediately .\n     * This will flush the current buffer to replace the quality asap.\n     * That means playback will interrupt at least shortly to re-buffer and re-sync eventually.\n     * @type {number} -1 for automatic level selection\n     */\n    ,\n    set: function set(newLevel) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log(\"set currentLevel:\" + newLevel);\n      this.loadLevel = newLevel;\n      this.abrController.clearTimer();\n      this.streamController.immediateLevelSwitch();\n    }\n    /**\n     * Index of next quality level loaded as scheduled by stream controller.\n     * @type {number}\n     */\n\n  }, {\n    key: \"nextLevel\",\n    get: function get() {\n      return this.streamController.nextLevel;\n    }\n    /**\n     * Set quality level index for next loaded data.\n     * This will switch the video quality asap, without interrupting playback.\n     * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).\n     * @type {number} -1 for automatic level selection\n     */\n    ,\n    set: function set(newLevel) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log(\"set nextLevel:\" + newLevel);\n      this.levelController.manualLevel = newLevel;\n      this.streamController.nextLevelSwitch();\n    }\n    /**\n     * Return the quality level of the currently or last (of none is loaded currently) segment\n     * @type {number}\n     */\n\n  }, {\n    key: \"loadLevel\",\n    get: function get() {\n      return this.levelController.level;\n    }\n    /**\n     * Set quality level index for next loaded data in a conservative way.\n     * This will switch the quality without flushing, but interrupt current loading.\n     * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.\n     * @type {number} newLevel -1 for automatic level selection\n     */\n    ,\n    set: function set(newLevel) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log(\"set loadLevel:\" + newLevel);\n      this.levelController.manualLevel = newLevel;\n    }\n    /**\n     * get next quality level loaded\n     * @type {number}\n     */\n\n  }, {\n    key: \"nextLoadLevel\",\n    get: function get() {\n      return this.levelController.nextLoadLevel;\n    }\n    /**\n     * Set quality level of next loaded segment in a fully \"non-destructive\" way.\n     * Same as `loadLevel` but will wait for next switch (until current loading is done).\n     * @type {number} level\n     */\n    ,\n    set: function set(level) {\n      this.levelController.nextLoadLevel = level;\n    }\n    /**\n     * Return \"first level\": like a default level, if not set,\n     * falls back to index of first level referenced in manifest\n     * @type {number}\n     */\n\n  }, {\n    key: \"firstLevel\",\n    get: function get() {\n      return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n    }\n    /**\n     * Sets \"first-level\", see getter.\n     * @type {number}\n     */\n    ,\n    set: function set(newLevel) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log(\"set firstLevel:\" + newLevel);\n      this.levelController.firstLevel = newLevel;\n    }\n    /**\n     * Return start level (level of first fragment that will be played back)\n     * if not overrided by user, first level appearing in manifest will be used as start level\n     * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n     * (determined from download of first segment)\n     * @type {number}\n     */\n\n  }, {\n    key: \"startLevel\",\n    get: function get() {\n      return this.levelController.startLevel;\n    }\n    /**\n     * set  start level (level of first fragment that will be played back)\n     * if not overrided by user, first level appearing in manifest will be used as start level\n     * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n     * (determined from download of first segment)\n     * @type {number} newLevel\n     */\n    ,\n    set: function set(newLevel) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log(\"set startLevel:\" + newLevel); // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel\n\n      if (newLevel !== -1) {\n        newLevel = Math.max(newLevel, this.minAutoLevel);\n      }\n\n      this.levelController.startLevel = newLevel;\n    }\n    /**\n     * Get the current setting for capLevelToPlayerSize\n     *\n     * @type {boolean}\n     */\n\n  }, {\n    key: \"capLevelToPlayerSize\",\n    get: function get() {\n      return this.config.capLevelToPlayerSize;\n    }\n    /**\n     * set  dynamically set capLevelToPlayerSize against (`CapLevelController`)\n     *\n     * @type {boolean}\n     */\n    ,\n    set: function set(shouldStartCapping) {\n      var newCapLevelToPlayerSize = !!shouldStartCapping;\n\n      if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {\n        if (newCapLevelToPlayerSize) {\n          this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.\n        } else {\n          this.capLevelController.stopCapping();\n          this.autoLevelCapping = -1;\n          this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.\n        }\n\n        this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;\n      }\n    }\n    /**\n     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n     * @type {number}\n     */\n\n  }, {\n    key: \"autoLevelCapping\",\n    get: function get() {\n      return this._autoLevelCapping;\n    }\n    /**\n     * get bandwidth estimate\n     * @type {number}\n     */\n    ,\n    set:\n    /**\n     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n     * @type {number}\n     */\n    function set(newLevel) {\n      if (this._autoLevelCapping !== newLevel) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log(\"set autoLevelCapping:\" + newLevel);\n        this._autoLevelCapping = newLevel;\n      }\n    }\n    /**\n     * True when automatic level selection enabled\n     * @type {boolean}\n     */\n\n  }, {\n    key: \"bandwidthEstimate\",\n    get: function get() {\n      var bwEstimator = this.abrController.bwEstimator;\n\n      if (!bwEstimator) {\n        return NaN;\n      }\n\n      return bwEstimator.getEstimate();\n    }\n  }, {\n    key: \"autoLevelEnabled\",\n    get: function get() {\n      return this.levelController.manualLevel === -1;\n    }\n    /**\n     * Level set manually (if any)\n     * @type {number}\n     */\n\n  }, {\n    key: \"manualLevel\",\n    get: function get() {\n      return this.levelController.manualLevel;\n    }\n    /**\n     * min level selectable in auto mode according to config.minAutoBitrate\n     * @type {number}\n     */\n\n  }, {\n    key: \"minAutoLevel\",\n    get: function get() {\n      var levels = this.levels,\n          minAutoBitrate = this.config.minAutoBitrate;\n      if (!levels) return 0;\n      var len = levels.length;\n\n      for (var i = 0; i < len; i++) {\n        if (levels[i].maxBitrate >= minAutoBitrate) {\n          return i;\n        }\n      }\n\n      return 0;\n    }\n    /**\n     * max level selectable in auto mode according to autoLevelCapping\n     * @type {number}\n     */\n\n  }, {\n    key: \"maxAutoLevel\",\n    get: function get() {\n      var levels = this.levels,\n          autoLevelCapping = this.autoLevelCapping;\n      var maxAutoLevel;\n\n      if (autoLevelCapping === -1 && levels && levels.length) {\n        maxAutoLevel = levels.length - 1;\n      } else {\n        maxAutoLevel = autoLevelCapping;\n      }\n\n      return maxAutoLevel;\n    }\n    /**\n     * next automatically selected quality level\n     * @type {number}\n     */\n\n  }, {\n    key: \"nextAutoLevel\",\n    get: function get() {\n      // ensure next auto level is between  min and max auto level\n      return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);\n    }\n    /**\n     * this setter is used to force next auto level.\n     * this is useful to force a switch down in auto mode:\n     * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n     * forced value is valid for one fragment. upon successful frag loading at forced level,\n     * this value will be resetted to -1 by ABR controller.\n     * @type {number}\n     */\n    ,\n    set: function set(nextLevel) {\n      this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, nextLevel);\n    }\n    /**\n     * get the datetime value relative to media.currentTime for the active level Program Date Time if present\n     * @type {Date}\n     */\n\n  }, {\n    key: \"playingDate\",\n    get: function get() {\n      return this.streamController.currentProgramDateTime;\n    }\n    /**\n     * @type {AudioTrack[]}\n     */\n\n  }, {\n    key: \"audioTracks\",\n    get: function get() {\n      var audioTrackController = this.audioTrackController;\n      return audioTrackController ? audioTrackController.audioTracks : [];\n    }\n    /**\n     * index of the selected audio track (index in audio track lists)\n     * @type {number}\n     */\n\n  }, {\n    key: \"audioTrack\",\n    get: function get() {\n      var audioTrackController = this.audioTrackController;\n      return audioTrackController ? audioTrackController.audioTrack : -1;\n    }\n    /**\n     * selects an audio track, based on its index in audio track lists\n     * @type {number}\n     */\n    ,\n    set: function set(audioTrackId) {\n      var audioTrackController = this.audioTrackController;\n\n      if (audioTrackController) {\n        audioTrackController.audioTrack = audioTrackId;\n      }\n    }\n    /**\n     * get alternate subtitle tracks list from playlist\n     * @type {MediaPlaylist[]}\n     */\n\n  }, {\n    key: \"subtitleTracks\",\n    get: function get() {\n      var subtitleTrackController = this.subtitleTrackController;\n      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];\n    }\n    /**\n     * index of the selected subtitle track (index in subtitle track lists)\n     * @type {number}\n     */\n\n  }, {\n    key: \"subtitleTrack\",\n    get: function get() {\n      var subtitleTrackController = this.subtitleTrackController;\n      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;\n    },\n    set:\n    /**\n     * select an subtitle track, based on its index in subtitle track lists\n     * @type {number}\n     */\n    function set(subtitleTrackId) {\n      var subtitleTrackController = this.subtitleTrackController;\n\n      if (subtitleTrackController) {\n        subtitleTrackController.subtitleTrack = subtitleTrackId;\n      }\n    }\n    /**\n     * @type {boolean}\n     */\n\n  }, {\n    key: \"media\",\n    get: function get() {\n      return this._media;\n    }\n  }, {\n    key: \"subtitleDisplay\",\n    get: function get() {\n      var subtitleTrackController = this.subtitleTrackController;\n      return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;\n    }\n    /**\n     * Enable/disable subtitle display rendering\n     * @type {boolean}\n     */\n    ,\n    set: function set(value) {\n      var subtitleTrackController = this.subtitleTrackController;\n\n      if (subtitleTrackController) {\n        subtitleTrackController.subtitleDisplay = value;\n      }\n    }\n    /**\n     * get mode for Low-Latency HLS loading\n     * @type {boolean}\n     */\n\n  }, {\n    key: \"lowLatencyMode\",\n    get: function get() {\n      return this.config.lowLatencyMode;\n    }\n    /**\n     * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.\n     * @type {boolean}\n     */\n    ,\n    set: function set(mode) {\n      this.config.lowLatencyMode = mode;\n    }\n    /**\n     * position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)\n     * @type {number}\n     */\n\n  }, {\n    key: \"liveSyncPosition\",\n    get: function get() {\n      return this.latencyController.liveSyncPosition;\n    }\n    /**\n     * estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)\n     * returns 0 before first playlist is loaded\n     * @type {number}\n     */\n\n  }, {\n    key: \"latency\",\n    get: function get() {\n      return this.latencyController.latency;\n    }\n    /**\n     * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```\n     * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```\n     * returns 0 before first playlist is loaded\n     * @type {number}\n     */\n\n  }, {\n    key: \"maxLatency\",\n    get: function get() {\n      return this.latencyController.maxLatency;\n    }\n    /**\n     * target distance from the edge as calculated by the latency controller\n     * @type {number}\n     */\n\n  }, {\n    key: \"targetLatency\",\n    get: function get() {\n      return this.latencyController.targetLatency;\n    }\n    /**\n     * the rate at which the edge of the current live playlist is advancing or 1 if there is none\n     * @type {number}\n     */\n\n  }, {\n    key: \"drift\",\n    get: function get() {\n      return this.latencyController.drift;\n    }\n    /**\n     * set to true when startLoad is called before MANIFEST_PARSED event\n     * @type {boolean}\n     */\n\n  }, {\n    key: \"forceStartLoad\",\n    get: function get() {\n      return this.streamController.forceStartLoad;\n    }\n  }], [{\n    key: \"version\",\n    get: function get() {\n      return \"1.2.0\";\n    }\n  }, {\n    key: \"Events\",\n    get: function get() {\n      return _events__WEBPACK_IMPORTED_MODULE_12__[\"Events\"];\n    }\n  }, {\n    key: \"ErrorTypes\",\n    get: function get() {\n      return _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorTypes\"];\n    }\n  }, {\n    key: \"ErrorDetails\",\n    get: function get() {\n      return _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"];\n    }\n  }, {\n    key: \"DefaultConfig\",\n    get: function get() {\n      if (!Hls.defaultConfig) {\n        return _config__WEBPACK_IMPORTED_MODULE_10__[\"hlsDefaultConfig\"];\n      }\n\n      return Hls.defaultConfig;\n    }\n    /**\n     * @type {HlsConfig}\n     */\n    ,\n    set: function set(defaultConfig) {\n      Hls.defaultConfig = defaultConfig;\n    }\n  }]);\n\n  return Hls;\n}();\n\nHls.defaultConfig = void 0;\n\n\n/***/ }),\n\n/***/ \"./src/is-supported.ts\":\n/*!*****************************!*\\\n  !*** ./src/is-supported.ts ***!\n  \\*****************************/\n/*! exports provided: isSupported, changeTypeSupported */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_676623__) {\n\n\"use strict\";\n__nested_webpack_require_676623__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_676623__.d(__webpack_exports__, \"isSupported\", function() { return isSupported; });\n/* harmony export (binding) */ __nested_webpack_require_676623__.d(__webpack_exports__, \"changeTypeSupported\", function() { return changeTypeSupported; });\n/* harmony import */ var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_676623__(/*! ./utils/mediasource-helper */ \"./src/utils/mediasource-helper.ts\");\n\n\nfunction getSourceBuffer() {\n  return self.SourceBuffer || self.WebKitSourceBuffer;\n}\n\nfunction isSupported() {\n  var mediaSource = Object(_utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_0__[\"getMediaSource\"])();\n\n  if (!mediaSource) {\n    return false;\n  }\n\n  var sourceBuffer = getSourceBuffer();\n  var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === 'function' && mediaSource.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"'); // if SourceBuffer is exposed ensure its API is valid\n  // safari and old version of Chrome doe not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible\n\n  var sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';\n  return !!isTypeSupported && !!sourceBufferValidAPI;\n}\nfunction changeTypeSupported() {\n  var _sourceBuffer$prototy;\n\n  var sourceBuffer = getSourceBuffer();\n  return typeof (sourceBuffer === null || sourceBuffer === void 0 ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) === null || _sourceBuffer$prototy === void 0 ? void 0 : _sourceBuffer$prototy.changeType) === 'function';\n}\n\n/***/ }),\n\n/***/ \"./src/loader/date-range.ts\":\n/*!**********************************!*\\\n  !*** ./src/loader/date-range.ts ***!\n  \\**********************************/\n/*! exports provided: DateRangeAttribute, DateRange */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_678642__) {\n\n\"use strict\";\n__nested_webpack_require_678642__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_678642__.d(__webpack_exports__, \"DateRangeAttribute\", function() { return DateRangeAttribute; });\n/* harmony export (binding) */ __nested_webpack_require_678642__.d(__webpack_exports__, \"DateRange\", function() { return DateRange; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_678642__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _utils_attr_list__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_678642__(/*! ../utils/attr-list */ \"./src/utils/attr-list.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_678642__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\nvar DateRangeAttribute;\n\n(function (DateRangeAttribute) {\n  DateRangeAttribute[\"ID\"] = \"ID\";\n  DateRangeAttribute[\"CLASS\"] = \"CLASS\";\n  DateRangeAttribute[\"START_DATE\"] = \"START-DATE\";\n  DateRangeAttribute[\"DURATION\"] = \"DURATION\";\n  DateRangeAttribute[\"END_DATE\"] = \"END-DATE\";\n  DateRangeAttribute[\"END_ON_NEXT\"] = \"END-ON-NEXT\";\n  DateRangeAttribute[\"PLANNED_DURATION\"] = \"PLANNED-DURATION\";\n  DateRangeAttribute[\"SCTE35_OUT\"] = \"SCTE35-OUT\";\n  DateRangeAttribute[\"SCTE35_IN\"] = \"SCTE35-IN\";\n})(DateRangeAttribute || (DateRangeAttribute = {}));\n\nvar DateRange = /*#__PURE__*/function () {\n  function DateRange(dateRangeAttr, dateRangeWithSameId) {\n    this.attr = void 0;\n    this._startDate = void 0;\n    this._endDate = void 0;\n    this._badValueForSameId = void 0;\n\n    if (dateRangeWithSameId) {\n      var previousAttr = dateRangeWithSameId.attr;\n\n      for (var key in previousAttr) {\n        if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"DATERANGE tag attribute: \\\"\" + key + \"\\\" does not match for tags with ID: \\\"\" + dateRangeAttr.ID + \"\\\"\");\n          this._badValueForSameId = key;\n          break;\n        }\n      } // Merge DateRange tags with the same ID\n\n\n      dateRangeAttr = _extends(new _utils_attr_list__WEBPACK_IMPORTED_MODULE_1__[\"AttrList\"]({}), previousAttr, dateRangeAttr);\n    }\n\n    this.attr = dateRangeAttr;\n    this._startDate = new Date(dateRangeAttr[DateRangeAttribute.START_DATE]);\n\n    if (DateRangeAttribute.END_DATE in this.attr) {\n      var endDate = new Date(this.attr[DateRangeAttribute.END_DATE]);\n\n      if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(endDate.getTime())) {\n        this._endDate = endDate;\n      }\n    }\n  }\n\n  _createClass(DateRange, [{\n    key: \"id\",\n    get: function get() {\n      return this.attr.ID;\n    }\n  }, {\n    key: \"class\",\n    get: function get() {\n      return this.attr.CLASS;\n    }\n  }, {\n    key: \"startDate\",\n    get: function get() {\n      return this._startDate;\n    }\n  }, {\n    key: \"endDate\",\n    get: function get() {\n      if (this._endDate) {\n        return this._endDate;\n      }\n\n      var duration = this.duration;\n\n      if (duration !== null) {\n        return new Date(this._startDate.getTime() + duration * 1000);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"duration\",\n    get: function get() {\n      if (DateRangeAttribute.DURATION in this.attr) {\n        var duration = this.attr.decimalFloatingPoint(DateRangeAttribute.DURATION);\n\n        if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(duration)) {\n          return duration;\n        }\n      } else if (this._endDate) {\n        return (this._endDate.getTime() - this._startDate.getTime()) / 1000;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"plannedDuration\",\n    get: function get() {\n      if (DateRangeAttribute.PLANNED_DURATION in this.attr) {\n        return this.attr.decimalFloatingPoint(DateRangeAttribute.PLANNED_DURATION);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"endOnNext\",\n    get: function get() {\n      return this.attr.bool(DateRangeAttribute.END_ON_NEXT);\n    }\n  }, {\n    key: \"isValid\",\n    get: function get() {\n      return !!this.id && !this._badValueForSameId && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);\n    }\n  }]);\n\n  return DateRange;\n}();\n\n/***/ }),\n\n/***/ \"./src/loader/fragment-loader.ts\":\n/*!***************************************!*\\\n  !*** ./src/loader/fragment-loader.ts ***!\n  \\***************************************/\n/*! exports provided: default, LoadError */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_684365__) {\n\n\"use strict\";\n__nested_webpack_require_684365__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_684365__.d(__webpack_exports__, \"default\", function() { return FragmentLoader; });\n/* harmony export (binding) */ __nested_webpack_require_684365__.d(__webpack_exports__, \"LoadError\", function() { return LoadError; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_684365__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_684365__(/*! ../errors */ \"./src/errors.ts\");\n\n\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\nvar MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb\n\nvar FragmentLoader = /*#__PURE__*/function () {\n  function FragmentLoader(config) {\n    this.config = void 0;\n    this.loader = null;\n    this.partLoadTimeout = -1;\n    this.config = config;\n  }\n\n  var _proto = FragmentLoader.prototype;\n\n  _proto.destroy = function destroy() {\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n  };\n\n  _proto.abort = function abort() {\n    if (this.loader) {\n      // Abort the loader for current fragment. Only one may load at any given time\n      this.loader.abort();\n    }\n  };\n\n  _proto.load = function load(frag, _onProgress) {\n    var _this = this;\n\n    var url = frag.url;\n\n    if (!url) {\n      return Promise.reject(new LoadError({\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].FRAG_LOAD_ERROR,\n        fatal: false,\n        frag: frag,\n        networkDetails: null\n      }, \"Fragment does not have a \" + (url ? 'part list' : 'url')));\n    }\n\n    this.abort();\n    var config = this.config;\n    var FragmentILoader = config.fLoader;\n    var DefaultILoader = config.loader;\n    return new Promise(function (resolve, reject) {\n      if (_this.loader) {\n        _this.loader.destroy();\n      }\n\n      var loader = _this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      var loaderContext = createLoaderContext(frag);\n      var loaderConfig = {\n        timeout: config.fragLoadingTimeOut,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: config.fragLoadingMaxRetryTimeout,\n        highWaterMark: frag.sn === 'initSegment' ? Infinity : MIN_CHUNK_SIZE\n      }; // Assign frag stats to the loader's stats reference\n\n      frag.stats = loader.stats;\n      loader.load(loaderContext, loaderConfig, {\n        onSuccess: function onSuccess(response, stats, context, networkDetails) {\n          _this.resetLoader(frag, loader);\n\n          resolve({\n            frag: frag,\n            part: null,\n            payload: response.data,\n            networkDetails: networkDetails\n          });\n        },\n        onError: function onError(response, context, networkDetails) {\n          _this.resetLoader(frag, loader);\n\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].FRAG_LOAD_ERROR,\n            fatal: false,\n            frag: frag,\n            response: response,\n            networkDetails: networkDetails\n          }));\n        },\n        onAbort: function onAbort(stats, context, networkDetails) {\n          _this.resetLoader(frag, loader);\n\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].INTERNAL_ABORTED,\n            fatal: false,\n            frag: frag,\n            networkDetails: networkDetails\n          }));\n        },\n        onTimeout: function onTimeout(response, context, networkDetails) {\n          _this.resetLoader(frag, loader);\n\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag: frag,\n            networkDetails: networkDetails\n          }));\n        },\n        onProgress: function onProgress(stats, context, data, networkDetails) {\n          if (_onProgress) {\n            _onProgress({\n              frag: frag,\n              part: null,\n              payload: data,\n              networkDetails: networkDetails\n            });\n          }\n        }\n      });\n    });\n  };\n\n  _proto.loadPart = function loadPart(frag, part, onProgress) {\n    var _this2 = this;\n\n    this.abort();\n    var config = this.config;\n    var FragmentILoader = config.fLoader;\n    var DefaultILoader = config.loader;\n    return new Promise(function (resolve, reject) {\n      if (_this2.loader) {\n        _this2.loader.destroy();\n      }\n\n      var loader = _this2.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      var loaderContext = createLoaderContext(frag, part);\n      var loaderConfig = {\n        timeout: config.fragLoadingTimeOut,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: config.fragLoadingMaxRetryTimeout,\n        highWaterMark: MIN_CHUNK_SIZE\n      }; // Assign part stats to the loader's stats reference\n\n      part.stats = loader.stats;\n      loader.load(loaderContext, loaderConfig, {\n        onSuccess: function onSuccess(response, stats, context, networkDetails) {\n          _this2.resetLoader(frag, loader);\n\n          _this2.updateStatsFromPart(frag, part);\n\n          var partLoadedData = {\n            frag: frag,\n            part: part,\n            payload: response.data,\n            networkDetails: networkDetails\n          };\n          onProgress(partLoadedData);\n          resolve(partLoadedData);\n        },\n        onError: function onError(response, context, networkDetails) {\n          _this2.resetLoader(frag, loader);\n\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].FRAG_LOAD_ERROR,\n            fatal: false,\n            frag: frag,\n            part: part,\n            response: response,\n            networkDetails: networkDetails\n          }));\n        },\n        onAbort: function onAbort(stats, context, networkDetails) {\n          frag.stats.aborted = part.stats.aborted;\n\n          _this2.resetLoader(frag, loader);\n\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].INTERNAL_ABORTED,\n            fatal: false,\n            frag: frag,\n            part: part,\n            networkDetails: networkDetails\n          }));\n        },\n        onTimeout: function onTimeout(response, context, networkDetails) {\n          _this2.resetLoader(frag, loader);\n\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag: frag,\n            part: part,\n            networkDetails: networkDetails\n          }));\n        }\n      });\n    });\n  };\n\n  _proto.updateStatsFromPart = function updateStatsFromPart(frag, part) {\n    var fragStats = frag.stats;\n    var partStats = part.stats;\n    var partTotal = partStats.total;\n    fragStats.loaded += partStats.loaded;\n\n    if (partTotal) {\n      var estTotalParts = Math.round(frag.duration / part.duration);\n      var estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);\n      var estRemainingParts = estTotalParts - estLoadedParts;\n      var estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);\n      fragStats.total = fragStats.loaded + estRemainingBytes;\n    } else {\n      fragStats.total = Math.max(fragStats.loaded, fragStats.total);\n    }\n\n    var fragLoading = fragStats.loading;\n    var partLoading = partStats.loading;\n\n    if (fragLoading.start) {\n      // add to fragment loader latency\n      fragLoading.first += partLoading.first - partLoading.start;\n    } else {\n      fragLoading.start = partLoading.start;\n      fragLoading.first = partLoading.first;\n    }\n\n    fragLoading.end = partLoading.end;\n  };\n\n  _proto.resetLoader = function resetLoader(frag, loader) {\n    frag.loader = null;\n\n    if (this.loader === loader) {\n      self.clearTimeout(this.partLoadTimeout);\n      this.loader = null;\n    }\n\n    loader.destroy();\n  };\n\n  return FragmentLoader;\n}();\n\n\n\nfunction createLoaderContext(frag, part) {\n  if (part === void 0) {\n    part = null;\n  }\n\n  var segment = part || frag;\n  var loaderContext = {\n    frag: frag,\n    part: part,\n    responseType: 'arraybuffer',\n    url: segment.url,\n    headers: {},\n    rangeStart: 0,\n    rangeEnd: 0\n  };\n  var start = segment.byteRangeStartOffset;\n  var end = segment.byteRangeEndOffset;\n\n  if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(start) && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(end)) {\n    loaderContext.rangeStart = start;\n    loaderContext.rangeEnd = end;\n  }\n\n  return loaderContext;\n}\n\nvar LoadError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(LoadError, _Error);\n\n  function LoadError(data) {\n    var _this3;\n\n    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      params[_key - 1] = arguments[_key];\n    }\n\n    _this3 = _Error.call.apply(_Error, [this].concat(params)) || this;\n    _this3.data = void 0;\n    _this3.data = data;\n    return _this3;\n  }\n\n  return LoadError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\n/***/ }),\n\n/***/ \"./src/loader/fragment.ts\":\n/*!********************************!*\\\n  !*** ./src/loader/fragment.ts ***!\n  \\********************************/\n/*! exports provided: ElementaryStreamTypes, BaseSegment, Fragment, Part */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_696786__) {\n\n\"use strict\";\n__nested_webpack_require_696786__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_696786__.d(__webpack_exports__, \"ElementaryStreamTypes\", function() { return ElementaryStreamTypes; });\n/* harmony export (binding) */ __nested_webpack_require_696786__.d(__webpack_exports__, \"BaseSegment\", function() { return BaseSegment; });\n/* harmony export (binding) */ __nested_webpack_require_696786__.d(__webpack_exports__, \"Fragment\", function() { return Fragment; });\n/* harmony export (binding) */ __nested_webpack_require_696786__.d(__webpack_exports__, \"Part\", function() { return Part; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_696786__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_696786__(/*! url-toolkit */ \"./node_modules/url-toolkit/src/url-toolkit.js\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_696786__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_696786__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _level_key__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_696786__(/*! ./level-key */ \"./src/loader/level-key.ts\");\n/* harmony import */ var _load_stats__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_696786__(/*! ./load-stats */ \"./src/loader/load-stats.ts\");\n\n\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\n\n\nvar ElementaryStreamTypes;\n\n(function (ElementaryStreamTypes) {\n  ElementaryStreamTypes[\"AUDIO\"] = \"audio\";\n  ElementaryStreamTypes[\"VIDEO\"] = \"video\";\n  ElementaryStreamTypes[\"AUDIOVIDEO\"] = \"audiovideo\";\n})(ElementaryStreamTypes || (ElementaryStreamTypes = {}));\n\nvar BaseSegment = /*#__PURE__*/function () {\n  // baseurl is the URL to the playlist\n  // relurl is the portion of the URL that comes from inside the playlist.\n  // Holds the types of data this fragment supports\n  function BaseSegment(baseurl) {\n    var _this$elementaryStrea;\n\n    this._byteRange = null;\n    this._url = null;\n    this.baseurl = void 0;\n    this.relurl = void 0;\n    this.elementaryStreams = (_this$elementaryStrea = {}, _this$elementaryStrea[ElementaryStreamTypes.AUDIO] = null, _this$elementaryStrea[ElementaryStreamTypes.VIDEO] = null, _this$elementaryStrea[ElementaryStreamTypes.AUDIOVIDEO] = null, _this$elementaryStrea);\n    this.baseurl = baseurl;\n  } // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\n\n\n  var _proto = BaseSegment.prototype;\n\n  _proto.setByteRange = function setByteRange(value, previous) {\n    var params = value.split('@', 2);\n    var byteRange = [];\n\n    if (params.length === 1) {\n      byteRange[0] = previous ? previous.byteRangeEndOffset : 0;\n    } else {\n      byteRange[0] = parseInt(params[1]);\n    }\n\n    byteRange[1] = parseInt(params[0]) + byteRange[0];\n    this._byteRange = byteRange;\n  };\n\n  _createClass(BaseSegment, [{\n    key: \"byteRange\",\n    get: function get() {\n      if (!this._byteRange) {\n        return [];\n      }\n\n      return this._byteRange;\n    }\n  }, {\n    key: \"byteRangeStartOffset\",\n    get: function get() {\n      return this.byteRange[0];\n    }\n  }, {\n    key: \"byteRangeEndOffset\",\n    get: function get() {\n      return this.byteRange[1];\n    }\n  }, {\n    key: \"url\",\n    get: function get() {\n      if (!this._url && this.baseurl && this.relurl) {\n        this._url = Object(url_toolkit__WEBPACK_IMPORTED_MODULE_1__[\"buildAbsoluteURL\"])(this.baseurl, this.relurl, {\n          alwaysNormalize: true\n        });\n      }\n\n      return this._url || '';\n    },\n    set: function set(value) {\n      this._url = value;\n    }\n  }]);\n\n  return BaseSegment;\n}();\nvar Fragment = /*#__PURE__*/function (_BaseSegment) {\n  _inheritsLoose(Fragment, _BaseSegment);\n\n  // EXTINF has to be present for a m3u8 to be considered valid\n  // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'\n  // levelkey is the EXT-X-KEY that applies to this segment for decryption\n  // core difference from the private field _decryptdata is the lack of the initialized IV\n  // _decryptdata will set the IV for this segment based on the segment number in the fragment\n  // A string representing the fragment type\n  // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading\n  // The level/track index to which the fragment belongs\n  // The continuity counter of the fragment\n  // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n  // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n  // The latest Presentation Time Stamp (PTS) appended to the buffer.\n  // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n  // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n  // The start time of the fragment, as listed in the manifest. Updated after transmux complete.\n  // Set by `updateFragPTSDTS` in level-helper\n  // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n  // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n  // Load/parse timing information\n  // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered\n  // #EXTINF  segment title\n  // The Media Initialization Section for this segment\n  function Fragment(type, baseurl) {\n    var _this;\n\n    _this = _BaseSegment.call(this, baseurl) || this;\n    _this._decryptdata = null;\n    _this.rawProgramDateTime = null;\n    _this.programDateTime = null;\n    _this.tagList = [];\n    _this.duration = 0;\n    _this.sn = 0;\n    _this.levelkey = void 0;\n    _this.type = void 0;\n    _this.loader = null;\n    _this.level = -1;\n    _this.cc = 0;\n    _this.startPTS = void 0;\n    _this.endPTS = void 0;\n    _this.appendedPTS = void 0;\n    _this.startDTS = void 0;\n    _this.endDTS = void 0;\n    _this.start = 0;\n    _this.deltaPTS = void 0;\n    _this.maxStartPTS = void 0;\n    _this.minEndPTS = void 0;\n    _this.stats = new _load_stats__WEBPACK_IMPORTED_MODULE_4__[\"LoadStats\"]();\n    _this.urlId = 0;\n    _this.data = void 0;\n    _this.bitrateTest = false;\n    _this.title = null;\n    _this.initSegment = null;\n    _this.type = type;\n    return _this;\n  }\n\n  var _proto2 = Fragment.prototype;\n\n  /**\n   * Utility method for parseLevelPlaylist to create an initialization vector for a given segment\n   * @param {number} segmentNumber - segment number to generate IV with\n   * @returns {Uint8Array}\n   */\n  _proto2.createInitializationVector = function createInitializationVector(segmentNumber) {\n    var uint8View = new Uint8Array(16);\n\n    for (var i = 12; i < 16; i++) {\n      uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n    }\n\n    return uint8View;\n  }\n  /**\n   * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data\n   * @param levelkey - a playlist's encryption info\n   * @param segmentNumber - the fragment's segment number\n   * @returns {LevelKey} - an object to be applied as a fragment's decryptdata\n   */\n  ;\n\n  _proto2.setDecryptDataFromLevelKey = function setDecryptDataFromLevelKey(levelkey, segmentNumber) {\n    var decryptdata = levelkey;\n\n    if ((levelkey === null || levelkey === void 0 ? void 0 : levelkey.method) === 'AES-128' && levelkey.uri && !levelkey.iv) {\n      decryptdata = _level_key__WEBPACK_IMPORTED_MODULE_3__[\"LevelKey\"].fromURI(levelkey.uri);\n      decryptdata.method = levelkey.method;\n      decryptdata.iv = this.createInitializationVector(segmentNumber);\n      decryptdata.keyFormat = 'identity';\n    }\n\n    return decryptdata;\n  };\n\n  _proto2.setElementaryStreamInfo = function setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial) {\n    if (partial === void 0) {\n      partial = false;\n    }\n\n    var elementaryStreams = this.elementaryStreams;\n    var info = elementaryStreams[type];\n\n    if (!info) {\n      elementaryStreams[type] = {\n        startPTS: startPTS,\n        endPTS: endPTS,\n        startDTS: startDTS,\n        endDTS: endDTS,\n        partial: partial\n      };\n      return;\n    }\n\n    info.startPTS = Math.min(info.startPTS, startPTS);\n    info.endPTS = Math.max(info.endPTS, endPTS);\n    info.startDTS = Math.min(info.startDTS, startDTS);\n    info.endDTS = Math.max(info.endDTS, endDTS);\n  };\n\n  _proto2.clearElementaryStreamInfo = function clearElementaryStreamInfo() {\n    var elementaryStreams = this.elementaryStreams;\n    elementaryStreams[ElementaryStreamTypes.AUDIO] = null;\n    elementaryStreams[ElementaryStreamTypes.VIDEO] = null;\n    elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;\n  };\n\n  _createClass(Fragment, [{\n    key: \"decryptdata\",\n    get: function get() {\n      if (!this.levelkey && !this._decryptdata) {\n        return null;\n      }\n\n      if (!this._decryptdata && this.levelkey) {\n        var sn = this.sn;\n\n        if (typeof sn !== 'number') {\n          // We are fetching decryption data for a initialization segment\n          // If the segment was encrypted with AES-128\n          // It must have an IV defined. We cannot substitute the Segment Number in.\n          if (this.levelkey && this.levelkey.method === 'AES-128' && !this.levelkey.iv) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"missing IV for initialization segment with method=\\\"\" + this.levelkey.method + \"\\\" - compliance issue\");\n          }\n          /*\n          Be converted to a Number.\n          'initSegment' will become NaN.\n          NaN, which when converted through ToInt32() -> +0.\n          ---\n          Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.\n          */\n\n\n          sn = 0;\n        }\n\n        this._decryptdata = this.setDecryptDataFromLevelKey(this.levelkey, sn);\n      }\n\n      return this._decryptdata;\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.start + this.duration;\n    }\n  }, {\n    key: \"endProgramDateTime\",\n    get: function get() {\n      if (this.programDateTime === null) {\n        return null;\n      }\n\n      if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(this.programDateTime)) {\n        return null;\n      }\n\n      var duration = !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(this.duration) ? 0 : this.duration;\n      return this.programDateTime + duration * 1000;\n    }\n  }, {\n    key: \"encrypted\",\n    get: function get() {\n      var _this$decryptdata;\n\n      // At the m3u8-parser level we need to add support for manifest signalled keyformats\n      // when we want the fragment to start reporting that it is encrypted.\n      // Currently, keyFormat will only be set for identity keys\n      if ((_this$decryptdata = this.decryptdata) !== null && _this$decryptdata !== void 0 && _this$decryptdata.keyFormat && this.decryptdata.uri) {\n        return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return Fragment;\n}(BaseSegment);\nvar Part = /*#__PURE__*/function (_BaseSegment2) {\n  _inheritsLoose(Part, _BaseSegment2);\n\n  function Part(partAttrs, frag, baseurl, index, previous) {\n    var _this2;\n\n    _this2 = _BaseSegment2.call(this, baseurl) || this;\n    _this2.fragOffset = 0;\n    _this2.duration = 0;\n    _this2.gap = false;\n    _this2.independent = false;\n    _this2.relurl = void 0;\n    _this2.fragment = void 0;\n    _this2.index = void 0;\n    _this2.stats = new _load_stats__WEBPACK_IMPORTED_MODULE_4__[\"LoadStats\"]();\n    _this2.duration = partAttrs.decimalFloatingPoint('DURATION');\n    _this2.gap = partAttrs.bool('GAP');\n    _this2.independent = partAttrs.bool('INDEPENDENT');\n    _this2.relurl = partAttrs.enumeratedString('URI');\n    _this2.fragment = frag;\n    _this2.index = index;\n    var byteRange = partAttrs.enumeratedString('BYTERANGE');\n\n    if (byteRange) {\n      _this2.setByteRange(byteRange, previous);\n    }\n\n    if (previous) {\n      _this2.fragOffset = previous.fragOffset + previous.duration;\n    }\n\n    return _this2;\n  }\n\n  _createClass(Part, [{\n    key: \"start\",\n    get: function get() {\n      return this.fragment.start + this.fragOffset;\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.start + this.duration;\n    }\n  }, {\n    key: \"loaded\",\n    get: function get() {\n      var elementaryStreams = this.elementaryStreams;\n      return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);\n    }\n  }]);\n\n  return Part;\n}(BaseSegment);\n\n/***/ }),\n\n/***/ \"./src/loader/key-loader.ts\":\n/*!**********************************!*\\\n  !*** ./src/loader/key-loader.ts ***!\n  \\**********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_710794__) {\n\n\"use strict\";\n__nested_webpack_require_710794__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_710794__.d(__webpack_exports__, \"default\", function() { return KeyLoader; });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_710794__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_710794__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_710794__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/*\n * Decrypt key Loader\n */\n\n\n\n\nvar KeyLoader = /*#__PURE__*/function () {\n  function KeyLoader(hls) {\n    this.hls = void 0;\n    this.loaders = {};\n    this.decryptkey = null;\n    this.decrypturl = null;\n    this.hls = hls;\n\n    this._registerListeners();\n  }\n\n  var _proto = KeyLoader.prototype;\n\n  _proto._registerListeners = function _registerListeners() {\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].KEY_LOADING, this.onKeyLoading, this);\n  };\n\n  _proto._unregisterListeners = function _unregisterListeners() {\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].KEY_LOADING, this.onKeyLoading);\n  };\n\n  _proto.destroy = function destroy() {\n    this._unregisterListeners();\n\n    for (var loaderName in this.loaders) {\n      var loader = this.loaders[loaderName];\n\n      if (loader) {\n        loader.destroy();\n      }\n    }\n\n    this.loaders = {};\n  };\n\n  _proto.onKeyLoading = function onKeyLoading(event, data) {\n    var frag = data.frag;\n    var type = frag.type;\n    var loader = this.loaders[type];\n\n    if (!frag.decryptdata) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn('Missing decryption data on fragment in onKeyLoading');\n      return;\n    } // Load the key if the uri is different from previous one, or if the decrypt key has not yet been retrieved\n\n\n    var uri = frag.decryptdata.uri;\n\n    if (uri !== this.decrypturl || this.decryptkey === null) {\n      var config = this.hls.config;\n\n      if (loader) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"abort previous key loader for type:\" + type);\n        loader.abort();\n      }\n\n      if (!uri) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn('key uri is falsy');\n        return;\n      }\n\n      var Loader = config.loader;\n      var fragLoader = frag.loader = this.loaders[type] = new Loader(config);\n      this.decrypturl = uri;\n      this.decryptkey = null;\n      var loaderContext = {\n        url: uri,\n        frag: frag,\n        responseType: 'arraybuffer'\n      }; // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,\n      // key-loader will trigger an error and rely on stream-controller to handle retry logic.\n      // this will also align retry logic with fragment-loader\n\n      var loaderConfig = {\n        timeout: config.fragLoadingTimeOut,\n        maxRetry: 0,\n        retryDelay: config.fragLoadingRetryDelay,\n        maxRetryDelay: config.fragLoadingMaxRetryTimeout,\n        highWaterMark: 0\n      };\n      var loaderCallbacks = {\n        onSuccess: this.loadsuccess.bind(this),\n        onError: this.loaderror.bind(this),\n        onTimeout: this.loadtimeout.bind(this)\n      };\n      fragLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n    } else if (this.decryptkey) {\n      // Return the key if it's already been loaded\n      frag.decryptdata.key = this.decryptkey;\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].KEY_LOADED, {\n        frag: frag\n      });\n    }\n  };\n\n  _proto.loadsuccess = function loadsuccess(response, stats, context) {\n    var frag = context.frag;\n\n    if (!frag.decryptdata) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error('after key load, decryptdata unset');\n      return;\n    }\n\n    this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data); // detach fragment loader on load success\n\n    frag.loader = null;\n    delete this.loaders[frag.type];\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].KEY_LOADED, {\n      frag: frag\n    });\n  };\n\n  _proto.loaderror = function loaderror(response, context) {\n    var frag = context.frag;\n    var loader = frag.loader;\n\n    if (loader) {\n      loader.abort();\n    }\n\n    delete this.loaders[frag.type];\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n      type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n      details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_LOAD_ERROR,\n      fatal: false,\n      frag: frag,\n      response: response\n    });\n  };\n\n  _proto.loadtimeout = function loadtimeout(stats, context) {\n    var frag = context.frag;\n    var loader = frag.loader;\n\n    if (loader) {\n      loader.abort();\n    }\n\n    delete this.loaders[frag.type];\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n      type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n      details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_LOAD_TIMEOUT,\n      fatal: false,\n      frag: frag\n    });\n  };\n\n  return KeyLoader;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/loader/level-details.ts\":\n/*!*************************************!*\\\n  !*** ./src/loader/level-details.ts ***!\n  \\*************************************/\n/*! exports provided: LevelDetails */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_716258__) {\n\n\"use strict\";\n__nested_webpack_require_716258__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_716258__.d(__webpack_exports__, \"LevelDetails\", function() { return LevelDetails; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_716258__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar DEFAULT_TARGET_DURATION = 10;\nvar LevelDetails = /*#__PURE__*/function () {\n  // Manifest reload synchronization\n  function LevelDetails(baseUrl) {\n    this.PTSKnown = false;\n    this.alignedSliding = false;\n    this.averagetargetduration = void 0;\n    this.endCC = 0;\n    this.endSN = 0;\n    this.fragments = void 0;\n    this.fragmentHint = void 0;\n    this.partList = null;\n    this.dateRanges = void 0;\n    this.live = true;\n    this.ageHeader = 0;\n    this.advancedDateTime = void 0;\n    this.updated = true;\n    this.advanced = true;\n    this.availabilityDelay = void 0;\n    this.misses = 0;\n    this.needSidxRanges = false;\n    this.startCC = 0;\n    this.startSN = 0;\n    this.startTimeOffset = null;\n    this.targetduration = 0;\n    this.totalduration = 0;\n    this.type = null;\n    this.url = void 0;\n    this.m3u8 = '';\n    this.version = null;\n    this.canBlockReload = false;\n    this.canSkipUntil = 0;\n    this.canSkipDateRanges = false;\n    this.skippedSegments = 0;\n    this.recentlyRemovedDateranges = void 0;\n    this.partHoldBack = 0;\n    this.holdBack = 0;\n    this.partTarget = 0;\n    this.preloadHint = void 0;\n    this.renditionReports = void 0;\n    this.tuneInGoal = 0;\n    this.deltaUpdateFailed = void 0;\n    this.driftStartTime = 0;\n    this.driftEndTime = 0;\n    this.driftStart = 0;\n    this.driftEnd = 0;\n    this.fragments = [];\n    this.dateRanges = {};\n    this.url = baseUrl;\n  }\n\n  var _proto = LevelDetails.prototype;\n\n  _proto.reloaded = function reloaded(previous) {\n    if (!previous) {\n      this.advanced = true;\n      this.updated = true;\n      return;\n    }\n\n    var partSnDiff = this.lastPartSn - previous.lastPartSn;\n    var partIndexDiff = this.lastPartIndex - previous.lastPartIndex;\n    this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff;\n    this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;\n\n    if (this.updated || this.advanced) {\n      this.misses = Math.floor(previous.misses * 0.6);\n    } else {\n      this.misses = previous.misses + 1;\n    }\n\n    this.availabilityDelay = previous.availabilityDelay;\n  };\n\n  _createClass(LevelDetails, [{\n    key: \"hasProgramDateTime\",\n    get: function get() {\n      if (this.fragments.length) {\n        return Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(this.fragments[this.fragments.length - 1].programDateTime);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"levelTargetDuration\",\n    get: function get() {\n      return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;\n    }\n  }, {\n    key: \"drift\",\n    get: function get() {\n      var runTime = this.driftEndTime - this.driftStartTime;\n\n      if (runTime > 0) {\n        var runDuration = this.driftEnd - this.driftStart;\n        return runDuration * 1000 / runTime;\n      }\n\n      return 1;\n    }\n  }, {\n    key: \"edge\",\n    get: function get() {\n      return this.partEnd || this.fragmentEnd;\n    }\n  }, {\n    key: \"partEnd\",\n    get: function get() {\n      var _this$partList;\n\n      if ((_this$partList = this.partList) !== null && _this$partList !== void 0 && _this$partList.length) {\n        return this.partList[this.partList.length - 1].end;\n      }\n\n      return this.fragmentEnd;\n    }\n  }, {\n    key: \"fragmentEnd\",\n    get: function get() {\n      var _this$fragments;\n\n      if ((_this$fragments = this.fragments) !== null && _this$fragments !== void 0 && _this$fragments.length) {\n        return this.fragments[this.fragments.length - 1].end;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"age\",\n    get: function get() {\n      if (this.advancedDateTime) {\n        return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"lastPartIndex\",\n    get: function get() {\n      var _this$partList2;\n\n      if ((_this$partList2 = this.partList) !== null && _this$partList2 !== void 0 && _this$partList2.length) {\n        return this.partList[this.partList.length - 1].index;\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"lastPartSn\",\n    get: function get() {\n      var _this$partList3;\n\n      if ((_this$partList3 = this.partList) !== null && _this$partList3 !== void 0 && _this$partList3.length) {\n        return this.partList[this.partList.length - 1].fragment.sn;\n      }\n\n      return this.endSN;\n    }\n  }]);\n\n  return LevelDetails;\n}();\n\n/***/ }),\n\n/***/ \"./src/loader/level-key.ts\":\n/*!*********************************!*\\\n  !*** ./src/loader/level-key.ts ***!\n  \\*********************************/\n/*! exports provided: LevelKey */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_721939__) {\n\n\"use strict\";\n__nested_webpack_require_721939__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_721939__.d(__webpack_exports__, \"LevelKey\", function() { return LevelKey; });\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_721939__(/*! url-toolkit */ \"./node_modules/url-toolkit/src/url-toolkit.js\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_721939__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_0__);\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\nvar LevelKey = /*#__PURE__*/function () {\n  LevelKey.fromURL = function fromURL(baseUrl, relativeUrl) {\n    return new LevelKey(baseUrl, relativeUrl);\n  };\n\n  LevelKey.fromURI = function fromURI(uri) {\n    return new LevelKey(uri);\n  };\n\n  function LevelKey(absoluteOrBaseURI, relativeURL) {\n    this._uri = null;\n    this.method = null;\n    this.keyFormat = null;\n    this.keyFormatVersions = null;\n    this.keyID = null;\n    this.key = null;\n    this.iv = null;\n\n    if (relativeURL) {\n      this._uri = Object(url_toolkit__WEBPACK_IMPORTED_MODULE_0__[\"buildAbsoluteURL\"])(absoluteOrBaseURI, relativeURL, {\n        alwaysNormalize: true\n      });\n    } else {\n      this._uri = absoluteOrBaseURI;\n    }\n  }\n\n  _createClass(LevelKey, [{\n    key: \"uri\",\n    get: function get() {\n      return this._uri;\n    }\n  }]);\n\n  return LevelKey;\n}();\n\n/***/ }),\n\n/***/ \"./src/loader/load-stats.ts\":\n/*!**********************************!*\\\n  !*** ./src/loader/load-stats.ts ***!\n  \\**********************************/\n/*! exports provided: LoadStats */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_724148__) {\n\n\"use strict\";\n__nested_webpack_require_724148__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_724148__.d(__webpack_exports__, \"LoadStats\", function() { return LoadStats; });\nvar LoadStats = function LoadStats() {\n  this.aborted = false;\n  this.loaded = 0;\n  this.retry = 0;\n  this.total = 0;\n  this.chunkCount = 0;\n  this.bwEstimate = 0;\n  this.loading = {\n    start: 0,\n    first: 0,\n    end: 0\n  };\n  this.parsing = {\n    start: 0,\n    end: 0\n  };\n  this.buffering = {\n    start: 0,\n    first: 0,\n    end: 0\n  };\n};\n\n/***/ }),\n\n/***/ \"./src/loader/m3u8-parser.ts\":\n/*!***********************************!*\\\n  !*** ./src/loader/m3u8-parser.ts ***!\n  \\***********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_724945__) {\n\n\"use strict\";\n__nested_webpack_require_724945__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_724945__.d(__webpack_exports__, \"default\", function() { return M3U8Parser; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_724945__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_724945__(/*! url-toolkit */ \"./node_modules/url-toolkit/src/url-toolkit.js\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_724945__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _date_range__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_724945__(/*! ./date-range */ \"./src/loader/date-range.ts\");\n/* harmony import */ var _fragment__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_724945__(/*! ./fragment */ \"./src/loader/fragment.ts\");\n/* harmony import */ var _level_details__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_724945__(/*! ./level-details */ \"./src/loader/level-details.ts\");\n/* harmony import */ var _level_key__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_724945__(/*! ./level-key */ \"./src/loader/level-key.ts\");\n/* harmony import */ var _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_724945__(/*! ../utils/attr-list */ \"./src/utils/attr-list.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_724945__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _utils_codecs__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_724945__(/*! ../utils/codecs */ \"./src/utils/codecs.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n// https://regex101.com is your friend\nvar MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-SESSION-DATA:([^\\r\\n]*)[\\r\\n]+/g;\nvar MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\nvar LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source, // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title\n/(?!#) *(\\S[\\S ]*)/.source, // segment URI, group 3 => the URI (note newline is not eaten)\n/#EXT-X-BYTERANGE:*(.+)/.source, // next segment's byterange, group 4 => range spec (x@y)\n/#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, // next segment's program date/time group 5 => the datetime spec\n/#.*/.source // All other non-segment oriented tags will match with all groups empty\n].join('|'), 'g');\nvar LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\\r?\\n?/.source].join('|'));\nvar MP4_REGEX_SUFFIX = /\\.(mp4|m4s|m4v|m4a)$/i;\n\nfunction isMP4Url(url) {\n  var _URLToolkit$parseURL$, _URLToolkit$parseURL;\n\n  return MP4_REGEX_SUFFIX.test((_URLToolkit$parseURL$ = (_URLToolkit$parseURL = url_toolkit__WEBPACK_IMPORTED_MODULE_1__[\"parseURL\"](url)) === null || _URLToolkit$parseURL === void 0 ? void 0 : _URLToolkit$parseURL.path) != null ? _URLToolkit$parseURL$ : '');\n}\n\nvar M3U8Parser = /*#__PURE__*/function () {\n  function M3U8Parser() {}\n\n  M3U8Parser.findGroup = function findGroup(groups, mediaGroupId) {\n    for (var i = 0; i < groups.length; i++) {\n      var group = groups[i];\n\n      if (group.id === mediaGroupId) {\n        return group;\n      }\n    }\n  };\n\n  M3U8Parser.convertAVC1ToAVCOTI = function convertAVC1ToAVCOTI(codec) {\n    // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported\n    var avcdata = codec.split('.');\n\n    if (avcdata.length > 2) {\n      var result = avcdata.shift() + '.';\n      result += parseInt(avcdata.shift()).toString(16);\n      result += ('000' + parseInt(avcdata.shift()).toString(16)).slice(-4);\n      return result;\n    }\n\n    return codec;\n  };\n\n  M3U8Parser.resolve = function resolve(url, baseUrl) {\n    return url_toolkit__WEBPACK_IMPORTED_MODULE_1__[\"buildAbsoluteURL\"](baseUrl, url, {\n      alwaysNormalize: true\n    });\n  };\n\n  M3U8Parser.parseMasterPlaylist = function parseMasterPlaylist(string, baseurl) {\n    var levels = [];\n    var sessionData = {};\n    var hasSessionData = false;\n    MASTER_PLAYLIST_REGEX.lastIndex = 0;\n    var result;\n\n    while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {\n      if (result[1]) {\n        // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1\n        var attrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__[\"AttrList\"](result[1]);\n        var level = {\n          attrs: attrs,\n          bitrate: attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH'),\n          name: attrs.NAME,\n          url: M3U8Parser.resolve(result[2], baseurl)\n        };\n        var resolution = attrs.decimalResolution('RESOLUTION');\n\n        if (resolution) {\n          level.width = resolution.width;\n          level.height = resolution.height;\n        }\n\n        setCodecs((attrs.CODECS || '').split(/[ ,]+/).filter(function (c) {\n          return c;\n        }), level);\n\n        if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) {\n          level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);\n        }\n\n        levels.push(level);\n      } else if (result[3]) {\n        // '#EXT-X-SESSION-DATA' is found, parse session data in group 3\n        var sessionAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__[\"AttrList\"](result[3]);\n\n        if (sessionAttrs['DATA-ID']) {\n          hasSessionData = true;\n          sessionData[sessionAttrs['DATA-ID']] = sessionAttrs;\n        }\n      }\n    }\n\n    return {\n      levels: levels,\n      sessionData: hasSessionData ? sessionData : null\n    };\n  };\n\n  M3U8Parser.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(string, baseurl, type, groups) {\n    if (groups === void 0) {\n      groups = [];\n    }\n\n    var result;\n    var medias = [];\n    var id = 0;\n    MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n\n    while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {\n      var attrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__[\"AttrList\"](result[1]);\n\n      if (attrs.TYPE === type) {\n        var media = {\n          attrs: attrs,\n          bitrate: 0,\n          id: id++,\n          groupId: attrs['GROUP-ID'],\n          instreamId: attrs['INSTREAM-ID'],\n          name: attrs.NAME || attrs.LANGUAGE || '',\n          type: type,\n          default: attrs.bool('DEFAULT'),\n          autoselect: attrs.bool('AUTOSELECT'),\n          forced: attrs.bool('FORCED'),\n          lang: attrs.LANGUAGE,\n          url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ''\n        };\n\n        if (groups.length) {\n          // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track\n          // If we don't find the track signalled, lets use the first audio groups codec we have\n          // Acting as a best guess\n          var groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];\n          assignCodec(media, groupCodec, 'audioCodec');\n          assignCodec(media, groupCodec, 'textCodec');\n        }\n\n        medias.push(media);\n      }\n    }\n\n    return medias;\n  };\n\n  M3U8Parser.parseLevelPlaylist = function parseLevelPlaylist(string, baseurl, id, type, levelUrlId) {\n    var level = new _level_details__WEBPACK_IMPORTED_MODULE_4__[\"LevelDetails\"](baseurl);\n    var fragments = level.fragments; // The most recent init segment seen (applies to all subsequent segments)\n\n    var currentInitSegment = null;\n    var currentSN = 0;\n    var currentPart = 0;\n    var totalduration = 0;\n    var discontinuityCounter = 0;\n    var prevFrag = null;\n    var frag = new _fragment__WEBPACK_IMPORTED_MODULE_3__[\"Fragment\"](type, baseurl);\n    var result;\n    var i;\n    var levelkey;\n    var firstPdtIndex = -1;\n    var createNextFrag = false;\n    LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n    level.m3u8 = string;\n\n    while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {\n      if (createNextFrag) {\n        createNextFrag = false;\n        frag = new _fragment__WEBPACK_IMPORTED_MODULE_3__[\"Fragment\"](type, baseurl); // setup the next fragment for part loading\n\n        frag.start = totalduration;\n        frag.sn = currentSN;\n        frag.cc = discontinuityCounter;\n        frag.level = id;\n\n        if (currentInitSegment) {\n          frag.initSegment = currentInitSegment;\n          frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n          currentInitSegment.rawProgramDateTime = null;\n        }\n      }\n\n      var duration = result[1];\n\n      if (duration) {\n        // INF\n        frag.duration = parseFloat(duration); // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n\n        var title = (' ' + result[2]).slice(1);\n        frag.title = title || null;\n        frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);\n      } else if (result[3]) {\n        // url\n        if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(frag.duration)) {\n          frag.start = totalduration;\n\n          if (levelkey) {\n            frag.levelkey = levelkey;\n          }\n\n          frag.sn = currentSN;\n          frag.level = id;\n          frag.cc = discontinuityCounter;\n          frag.urlId = levelUrlId;\n          fragments.push(frag); // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n\n          frag.relurl = (' ' + result[3]).slice(1);\n          assignProgramDateTime(frag, prevFrag);\n          prevFrag = frag;\n          totalduration += frag.duration;\n          currentSN++;\n          currentPart = 0;\n          createNextFrag = true;\n        }\n      } else if (result[4]) {\n        // X-BYTERANGE\n        var data = (' ' + result[4]).slice(1);\n\n        if (prevFrag) {\n          frag.setByteRange(data, prevFrag);\n        } else {\n          frag.setByteRange(data);\n        }\n      } else if (result[5]) {\n        // PROGRAM-DATE-TIME\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        frag.rawProgramDateTime = (' ' + result[5]).slice(1);\n        frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);\n\n        if (firstPdtIndex === -1) {\n          firstPdtIndex = fragments.length;\n        }\n      } else {\n        result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n\n        if (!result) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].warn('No matches on slow regex match for level playlist!');\n          continue;\n        }\n\n        for (i = 1; i < result.length; i++) {\n          if (typeof result[i] !== 'undefined') {\n            break;\n          }\n        } // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n\n\n        var tag = (' ' + result[i]).slice(1);\n        var value1 = (' ' + result[i + 1]).slice(1);\n        var value2 = result[i + 2] ? (' ' + result[i + 2]).slice(1) : '';\n\n        switch (tag) {\n          case 'PLAYLIST-TYPE':\n            level.type = value1.toUpperCase();\n            break;\n\n          case 'MEDIA-SEQUENCE':\n            currentSN = level.startSN = parseInt(value1);\n            break;\n\n          case 'SKIP':\n            {\n              var skipAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__[\"AttrList\"](value1);\n              var skippedSegments = skipAttrs.decimalInteger('SKIPPED-SEGMENTS');\n\n              if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(skippedSegments)) {\n                level.skippedSegments = skippedSegments; // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`\n\n                for (var _i = skippedSegments; _i--;) {\n                  fragments.unshift(null);\n                }\n\n                currentSN += skippedSegments;\n              }\n\n              var recentlyRemovedDateranges = skipAttrs.enumeratedString('RECENTLY-REMOVED-DATERANGES');\n\n              if (recentlyRemovedDateranges) {\n                level.recentlyRemovedDateranges = recentlyRemovedDateranges.split('\\t');\n              }\n\n              break;\n            }\n\n          case 'TARGETDURATION':\n            level.targetduration = parseFloat(value1);\n            break;\n\n          case 'VERSION':\n            level.version = parseInt(value1);\n            break;\n\n          case 'EXTM3U':\n            break;\n\n          case 'ENDLIST':\n            level.live = false;\n            break;\n\n          case '#':\n            if (value1 || value2) {\n              frag.tagList.push(value2 ? [value1, value2] : [value1]);\n            }\n\n            break;\n\n          case 'DISCONTINUITY':\n            discontinuityCounter++;\n            frag.tagList.push(['DIS']);\n            break;\n\n          case 'GAP':\n            frag.tagList.push([tag]);\n            break;\n\n          case 'BITRATE':\n            frag.tagList.push([tag, value1]);\n            break;\n\n          case 'DATERANGE':\n            {\n              var dateRangeAttr = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__[\"AttrList\"](value1);\n              var dateRange = new _date_range__WEBPACK_IMPORTED_MODULE_2__[\"DateRange\"](dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);\n\n              if (dateRange.isValid || level.skippedSegments) {\n                level.dateRanges[dateRange.id] = dateRange;\n              } else {\n                _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].warn(\"Ignoring invalid DATERANGE tag: \\\"\" + value1 + \"\\\"\");\n              } // Add to fragment tag list for backwards compatibility (< v1.2.0)\n\n\n              frag.tagList.push(['EXT-X-DATERANGE', value1]);\n              break;\n            }\n\n          case 'DISCONTINUITY-SEQUENCE':\n            discontinuityCounter = parseInt(value1);\n            break;\n\n          case 'KEY':\n            {\n              var _keyAttrs$enumeratedS;\n\n              // https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n              var keyAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__[\"AttrList\"](value1);\n              var decryptmethod = keyAttrs.enumeratedString('METHOD');\n              var decrypturi = keyAttrs.URI;\n              var decryptiv = keyAttrs.hexadecimalInteger('IV');\n              var decryptkeyformatversions = keyAttrs.enumeratedString('KEYFORMATVERSIONS');\n              var decryptkeyid = keyAttrs.enumeratedString('KEYID'); // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of \"identity\".\n\n              var decryptkeyformat = (_keyAttrs$enumeratedS = keyAttrs.enumeratedString('KEYFORMAT')) != null ? _keyAttrs$enumeratedS : 'identity';\n              var unsupportedKnownKeyformatsInManifest = ['com.apple.streamingkeydelivery', 'com.microsoft.playready', 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed', // widevine (v2)\n              'com.widevine' // earlier widevine (v1)\n              ];\n\n              if (unsupportedKnownKeyformatsInManifest.indexOf(decryptkeyformat) > -1) {\n                _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].warn(\"Keyformat \" + decryptkeyformat + \" is not supported from the manifest\");\n                continue;\n              } else if (decryptkeyformat !== 'identity') {\n                // We are supposed to skip keys we don't understand.\n                // As we currently only officially support identity keys\n                // from the manifest we shouldn't save any other key.\n                continue;\n              } // TODO: multiple keys can be defined on a fragment, and we need to support this\n              // for clients that support both playready and widevine\n\n\n              if (decryptmethod) {\n                // TODO: need to determine if the level key is actually a relative URL\n                // if it isn't, then we should instead construct the LevelKey using fromURI.\n                levelkey = _level_key__WEBPACK_IMPORTED_MODULE_5__[\"LevelKey\"].fromURL(baseurl, decrypturi);\n\n                if (decrypturi && ['AES-128', 'SAMPLE-AES', 'SAMPLE-AES-CENC'].indexOf(decryptmethod) >= 0) {\n                  levelkey.method = decryptmethod;\n                  levelkey.keyFormat = decryptkeyformat;\n\n                  if (decryptkeyid) {\n                    levelkey.keyID = decryptkeyid;\n                  }\n\n                  if (decryptkeyformatversions) {\n                    levelkey.keyFormatVersions = decryptkeyformatversions;\n                  } // Initialization Vector (IV)\n\n\n                  levelkey.iv = decryptiv;\n                }\n              }\n\n              break;\n            }\n\n          case 'START':\n            {\n              var startAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__[\"AttrList\"](value1);\n              var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET'); // TIME-OFFSET can be 0\n\n              if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(startTimeOffset)) {\n                level.startTimeOffset = startTimeOffset;\n              }\n\n              break;\n            }\n\n          case 'MAP':\n            {\n              var mapAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__[\"AttrList\"](value1);\n\n              if (frag.duration) {\n                // Initial segment tag is after segment duration tag.\n                //   #EXTINF: 6.0\n                //   #EXT-X-MAP:URI=\"init.mp4\n                var init = new _fragment__WEBPACK_IMPORTED_MODULE_3__[\"Fragment\"](type, baseurl);\n                setInitSegment(init, mapAttrs, id, levelkey);\n                currentInitSegment = init;\n                frag.initSegment = currentInitSegment;\n\n                if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {\n                  frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n                }\n              } else {\n                // Initial segment tag is before segment duration tag\n                setInitSegment(frag, mapAttrs, id, levelkey);\n                currentInitSegment = frag;\n                createNextFrag = true;\n              }\n\n              break;\n            }\n\n          case 'SERVER-CONTROL':\n            {\n              var serverControlAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__[\"AttrList\"](value1);\n              level.canBlockReload = serverControlAttrs.bool('CAN-BLOCK-RELOAD');\n              level.canSkipUntil = serverControlAttrs.optionalFloat('CAN-SKIP-UNTIL', 0);\n              level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool('CAN-SKIP-DATERANGES');\n              level.partHoldBack = serverControlAttrs.optionalFloat('PART-HOLD-BACK', 0);\n              level.holdBack = serverControlAttrs.optionalFloat('HOLD-BACK', 0);\n              break;\n            }\n\n          case 'PART-INF':\n            {\n              var partInfAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__[\"AttrList\"](value1);\n              level.partTarget = partInfAttrs.decimalFloatingPoint('PART-TARGET');\n              break;\n            }\n\n          case 'PART':\n            {\n              var partList = level.partList;\n\n              if (!partList) {\n                partList = level.partList = [];\n              }\n\n              var previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;\n              var index = currentPart++;\n              var part = new _fragment__WEBPACK_IMPORTED_MODULE_3__[\"Part\"](new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__[\"AttrList\"](value1), frag, baseurl, index, previousFragmentPart);\n              partList.push(part);\n              frag.duration += part.duration;\n              break;\n            }\n\n          case 'PRELOAD-HINT':\n            {\n              var preloadHintAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__[\"AttrList\"](value1);\n              level.preloadHint = preloadHintAttrs;\n              break;\n            }\n\n          case 'RENDITION-REPORT':\n            {\n              var renditionReportAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__[\"AttrList\"](value1);\n              level.renditionReports = level.renditionReports || [];\n              level.renditionReports.push(renditionReportAttrs);\n              break;\n            }\n\n          default:\n            _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].warn(\"line parsed but not handled: \" + result);\n            break;\n        }\n      }\n    }\n\n    if (prevFrag && !prevFrag.relurl) {\n      fragments.pop();\n      totalduration -= prevFrag.duration;\n\n      if (level.partList) {\n        level.fragmentHint = prevFrag;\n      }\n    } else if (level.partList) {\n      assignProgramDateTime(frag, prevFrag);\n      frag.cc = discontinuityCounter;\n      level.fragmentHint = frag;\n    }\n\n    var fragmentLength = fragments.length;\n    var firstFragment = fragments[0];\n    var lastFragment = fragments[fragmentLength - 1];\n    totalduration += level.skippedSegments * level.targetduration;\n\n    if (totalduration > 0 && fragmentLength && lastFragment) {\n      level.averagetargetduration = totalduration / fragmentLength;\n      var lastSn = lastFragment.sn;\n      level.endSN = lastSn !== 'initSegment' ? lastSn : 0;\n\n      if (firstFragment) {\n        level.startCC = firstFragment.cc;\n\n        if (!firstFragment.initSegment) {\n          // this is a bit lurky but HLS really has no other way to tell us\n          // if the fragments are TS or MP4, except if we download them :/\n          // but this is to be able to handle SIDX.\n          if (level.fragments.every(function (frag) {\n            return frag.relurl && isMP4Url(frag.relurl);\n          })) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].warn('MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX');\n            frag = new _fragment__WEBPACK_IMPORTED_MODULE_3__[\"Fragment\"](type, baseurl);\n            frag.relurl = lastFragment.relurl;\n            frag.level = id;\n            frag.sn = 'initSegment';\n            firstFragment.initSegment = frag;\n            level.needSidxRanges = true;\n          }\n        }\n      }\n    } else {\n      level.endSN = 0;\n      level.startCC = 0;\n    }\n\n    if (level.fragmentHint) {\n      totalduration += level.fragmentHint.duration;\n    }\n\n    level.totalduration = totalduration;\n    level.endCC = discontinuityCounter;\n    /**\n     * Backfill any missing PDT values\n     * \"If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after\n     * one or more Media Segment URIs, the client SHOULD extrapolate\n     * backward from that tag (using EXTINF durations and/or media\n     * timestamps) to associate dates with those segments.\"\n     * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs\n     * computed.\n     */\n\n    if (firstPdtIndex > 0) {\n      backfillProgramDateTimes(fragments, firstPdtIndex);\n    }\n\n    return level;\n  };\n\n  return M3U8Parser;\n}();\n\n\n\nfunction setCodecs(codecs, level) {\n  ['video', 'audio', 'text'].forEach(function (type) {\n    var filtered = codecs.filter(function (codec) {\n      return Object(_utils_codecs__WEBPACK_IMPORTED_MODULE_8__[\"isCodecType\"])(codec, type);\n    });\n\n    if (filtered.length) {\n      var preferred = filtered.filter(function (codec) {\n        return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;\n      });\n      level[type + \"Codec\"] = preferred.length > 0 ? preferred[0] : filtered[0]; // remove from list\n\n      codecs = codecs.filter(function (codec) {\n        return filtered.indexOf(codec) === -1;\n      });\n    }\n  });\n  level.unknownCodecs = codecs;\n}\n\nfunction assignCodec(media, groupItem, codecProperty) {\n  var codecValue = groupItem[codecProperty];\n\n  if (codecValue) {\n    media[codecProperty] = codecValue;\n  }\n}\n\nfunction backfillProgramDateTimes(fragments, firstPdtIndex) {\n  var fragPrev = fragments[firstPdtIndex];\n\n  for (var i = firstPdtIndex; i--;) {\n    var frag = fragments[i]; // Exit on delta-playlist skipped segments\n\n    if (!frag) {\n      return;\n    }\n\n    frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;\n    fragPrev = frag;\n  }\n}\n\nfunction assignProgramDateTime(frag, prevFrag) {\n  if (frag.rawProgramDateTime) {\n    frag.programDateTime = Date.parse(frag.rawProgramDateTime);\n  } else if (prevFrag !== null && prevFrag !== void 0 && prevFrag.programDateTime) {\n    frag.programDateTime = prevFrag.endProgramDateTime;\n  }\n\n  if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(frag.programDateTime)) {\n    frag.programDateTime = null;\n    frag.rawProgramDateTime = null;\n  }\n}\n\nfunction setInitSegment(frag, mapAttrs, id, levelkey) {\n  frag.relurl = mapAttrs.URI;\n\n  if (mapAttrs.BYTERANGE) {\n    frag.setByteRange(mapAttrs.BYTERANGE);\n  }\n\n  frag.level = id;\n  frag.sn = 'initSegment';\n\n  if (levelkey) {\n    frag.levelkey = levelkey;\n  }\n\n  frag.initSegment = null;\n}\n\n/***/ }),\n\n/***/ \"./src/loader/playlist-loader.ts\":\n/*!***************************************!*\\\n  !*** ./src/loader/playlist-loader.ts ***!\n  \\***************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_750460__) {\n\n\"use strict\";\n__nested_webpack_require_750460__.r(__webpack_exports__);\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_750460__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_750460__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_750460__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_750460__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_750460__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_750460__(/*! ./m3u8-parser */ \"./src/loader/m3u8-parser.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_750460__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _utils_attr_list__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_750460__(/*! ../utils/attr-list */ \"./src/utils/attr-list.ts\");\n\n\n\n/**\n * PlaylistLoader - delegate for media manifest/playlist loading tasks. Takes care of parsing media to internal data-models.\n *\n * Once loaded, dispatches events with parsed data-models of manifest/levels/audio/subtitle tracks.\n *\n * Uses loader(s) set in config to do actual internal loading of resource tasks.\n *\n * @module\n *\n */\n\n\n\n\n\n\n\n\nfunction mapContextToLevelType(context) {\n  var type = context.type;\n\n  switch (type) {\n    case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].AUDIO_TRACK:\n      return _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].AUDIO;\n\n    case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].SUBTITLE_TRACK:\n      return _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].SUBTITLE;\n\n    default:\n      return _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN;\n  }\n}\n\nfunction getResponseUrl(response, context) {\n  var url = response.url; // responseURL not supported on some browsers (it is used to detect URL redirection)\n  // data-uri mode also not supported (but no need to detect redirection)\n\n  if (url === undefined || url.indexOf('data:') === 0) {\n    // fallback to initial URL\n    url = context.url;\n  }\n\n  return url;\n}\n\nvar PlaylistLoader = /*#__PURE__*/function () {\n  function PlaylistLoader(hls) {\n    this.hls = void 0;\n    this.loaders = Object.create(null);\n    this.hls = hls;\n    this.registerListeners();\n  }\n\n  var _proto = PlaylistLoader.prototype;\n\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n  };\n\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n  }\n  /**\n   * Returns defaults or configured loader-type overloads (pLoader and loader config params)\n   */\n  ;\n\n  _proto.createInternalLoader = function createInternalLoader(context) {\n    var config = this.hls.config;\n    var PLoader = config.pLoader;\n    var Loader = config.loader;\n    var InternalLoader = PLoader || Loader;\n    var loader = new InternalLoader(config);\n    context.loader = loader;\n    this.loaders[context.type] = loader;\n    return loader;\n  };\n\n  _proto.getInternalLoader = function getInternalLoader(context) {\n    return this.loaders[context.type];\n  };\n\n  _proto.resetInternalLoader = function resetInternalLoader(contextType) {\n    if (this.loaders[contextType]) {\n      delete this.loaders[contextType];\n    }\n  }\n  /**\n   * Call `destroy` on all internal loader instances mapped (one per context type)\n   */\n  ;\n\n  _proto.destroyInternalLoaders = function destroyInternalLoaders() {\n    for (var contextType in this.loaders) {\n      var loader = this.loaders[contextType];\n\n      if (loader) {\n        loader.destroy();\n      }\n\n      this.resetInternalLoader(contextType);\n    }\n  };\n\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.destroyInternalLoaders();\n  };\n\n  _proto.onManifestLoading = function onManifestLoading(event, data) {\n    var url = data.url;\n    this.load({\n      id: null,\n      groupId: null,\n      level: 0,\n      responseType: 'text',\n      type: _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].MANIFEST,\n      url: url,\n      deliveryDirectives: null\n    });\n  };\n\n  _proto.onLevelLoading = function onLevelLoading(event, data) {\n    var id = data.id,\n        level = data.level,\n        url = data.url,\n        deliveryDirectives = data.deliveryDirectives;\n    this.load({\n      id: id,\n      groupId: null,\n      level: level,\n      responseType: 'text',\n      type: _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].LEVEL,\n      url: url,\n      deliveryDirectives: deliveryDirectives\n    });\n  };\n\n  _proto.onAudioTrackLoading = function onAudioTrackLoading(event, data) {\n    var id = data.id,\n        groupId = data.groupId,\n        url = data.url,\n        deliveryDirectives = data.deliveryDirectives;\n    this.load({\n      id: id,\n      groupId: groupId,\n      level: null,\n      responseType: 'text',\n      type: _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].AUDIO_TRACK,\n      url: url,\n      deliveryDirectives: deliveryDirectives\n    });\n  };\n\n  _proto.onSubtitleTrackLoading = function onSubtitleTrackLoading(event, data) {\n    var id = data.id,\n        groupId = data.groupId,\n        url = data.url,\n        deliveryDirectives = data.deliveryDirectives;\n    this.load({\n      id: id,\n      groupId: groupId,\n      level: null,\n      responseType: 'text',\n      type: _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].SUBTITLE_TRACK,\n      url: url,\n      deliveryDirectives: deliveryDirectives\n    });\n  };\n\n  _proto.load = function load(context) {\n    var _context$deliveryDire;\n\n    var config = this.hls.config; // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);\n    // Check if a loader for this context already exists\n\n    var loader = this.getInternalLoader(context);\n\n    if (loader) {\n      var loaderContext = loader.context;\n\n      if (loaderContext && loaderContext.url === context.url) {\n        // same URL can't overlap\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].trace('[playlist-loader]: playlist request ongoing');\n        return;\n      }\n\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].log(\"[playlist-loader]: aborting previous loader for type: \" + context.type);\n      loader.abort();\n    }\n\n    var maxRetry;\n    var timeout;\n    var retryDelay;\n    var maxRetryDelay; // apply different configs for retries depending on\n    // context (manifest, level, audio/subs playlist)\n\n    switch (context.type) {\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].MANIFEST:\n        maxRetry = config.manifestLoadingMaxRetry;\n        timeout = config.manifestLoadingTimeOut;\n        retryDelay = config.manifestLoadingRetryDelay;\n        maxRetryDelay = config.manifestLoadingMaxRetryTimeout;\n        break;\n\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].LEVEL:\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].AUDIO_TRACK:\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].SUBTITLE_TRACK:\n        // Manage retries in Level/Track Controller\n        maxRetry = 0;\n        timeout = config.levelLoadingTimeOut;\n        break;\n\n      default:\n        maxRetry = config.levelLoadingMaxRetry;\n        timeout = config.levelLoadingTimeOut;\n        retryDelay = config.levelLoadingRetryDelay;\n        maxRetryDelay = config.levelLoadingMaxRetryTimeout;\n        break;\n    }\n\n    loader = this.createInternalLoader(context); // Override level/track timeout for LL-HLS requests\n    // (the default of 10000ms is counter productive to blocking playlist reload requests)\n\n    if ((_context$deliveryDire = context.deliveryDirectives) !== null && _context$deliveryDire !== void 0 && _context$deliveryDire.part) {\n      var levelDetails;\n\n      if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].LEVEL && context.level !== null) {\n        levelDetails = this.hls.levels[context.level].details;\n      } else if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].AUDIO_TRACK && context.id !== null) {\n        levelDetails = this.hls.audioTracks[context.id].details;\n      } else if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].SUBTITLE_TRACK && context.id !== null) {\n        levelDetails = this.hls.subtitleTracks[context.id].details;\n      }\n\n      if (levelDetails) {\n        var partTarget = levelDetails.partTarget;\n        var targetDuration = levelDetails.targetduration;\n\n        if (partTarget && targetDuration) {\n          timeout = Math.min(Math.max(partTarget * 3, targetDuration * 0.8) * 1000, timeout);\n        }\n      }\n    }\n\n    var loaderConfig = {\n      timeout: timeout,\n      maxRetry: maxRetry,\n      retryDelay: retryDelay,\n      maxRetryDelay: maxRetryDelay,\n      highWaterMark: 0\n    };\n    var loaderCallbacks = {\n      onSuccess: this.loadsuccess.bind(this),\n      onError: this.loaderror.bind(this),\n      onTimeout: this.loadtimeout.bind(this)\n    }; // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);\n\n    loader.load(context, loaderConfig, loaderCallbacks);\n  };\n\n  _proto.loadsuccess = function loadsuccess(response, stats, context, networkDetails) {\n    if (networkDetails === void 0) {\n      networkDetails = null;\n    }\n\n    if (context.isSidxRequest) {\n      this.handleSidxRequest(response, context);\n      this.handlePlaylistLoaded(response, stats, context, networkDetails);\n      return;\n    }\n\n    this.resetInternalLoader(context.type);\n    var string = response.data; // Validate if it is an M3U8 at all\n\n    if (string.indexOf('#EXTM3U') !== 0) {\n      this.handleManifestParsingError(response, context, 'no EXTM3U delimiter', networkDetails);\n      return;\n    }\n\n    stats.parsing.start = performance.now(); // Check if chunk-list or master. handle empty chunk list case (first EXTINF not signaled, but TARGETDURATION present)\n\n    if (string.indexOf('#EXTINF:') > 0 || string.indexOf('#EXT-X-TARGETDURATION:') > 0) {\n      this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails);\n    } else {\n      this.handleMasterPlaylist(response, stats, context, networkDetails);\n    }\n  };\n\n  _proto.loaderror = function loaderror(response, context, networkDetails) {\n    if (networkDetails === void 0) {\n      networkDetails = null;\n    }\n\n    this.handleNetworkError(context, networkDetails, false, response);\n  };\n\n  _proto.loadtimeout = function loadtimeout(stats, context, networkDetails) {\n    if (networkDetails === void 0) {\n      networkDetails = null;\n    }\n\n    this.handleNetworkError(context, networkDetails, true);\n  };\n\n  _proto.handleMasterPlaylist = function handleMasterPlaylist(response, stats, context, networkDetails) {\n    var hls = this.hls;\n    var string = response.data;\n    var url = getResponseUrl(response, context);\n\n    var _M3U8Parser$parseMast = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__[\"default\"].parseMasterPlaylist(string, url),\n        levels = _M3U8Parser$parseMast.levels,\n        sessionData = _M3U8Parser$parseMast.sessionData;\n\n    if (!levels.length) {\n      this.handleManifestParsingError(response, context, 'no level found in manifest', networkDetails);\n      return;\n    } // multi level playlist, parse level info\n\n\n    var audioGroups = levels.map(function (level) {\n      return {\n        id: level.attrs.AUDIO,\n        audioCodec: level.audioCodec\n      };\n    });\n    var subtitleGroups = levels.map(function (level) {\n      return {\n        id: level.attrs.SUBTITLES,\n        textCodec: level.textCodec\n      };\n    });\n    var audioTracks = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__[\"default\"].parseMasterPlaylistMedia(string, url, 'AUDIO', audioGroups);\n    var subtitles = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__[\"default\"].parseMasterPlaylistMedia(string, url, 'SUBTITLES', subtitleGroups);\n    var captions = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__[\"default\"].parseMasterPlaylistMedia(string, url, 'CLOSED-CAPTIONS');\n\n    if (audioTracks.length) {\n      // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n      var embeddedAudioFound = audioTracks.some(function (audioTrack) {\n        return !audioTrack.url;\n      }); // if no embedded audio track defined, but audio codec signaled in quality level,\n      // we need to signal this main audio track this could happen with playlists with\n      // alt audio rendition in which quality levels (main)\n      // contains both audio+video. but with mixed audio track not signaled\n\n      if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].log('[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one');\n        audioTracks.unshift({\n          type: 'main',\n          name: 'main',\n          default: false,\n          autoselect: false,\n          forced: false,\n          id: -1,\n          attrs: new _utils_attr_list__WEBPACK_IMPORTED_MODULE_7__[\"AttrList\"]({}),\n          bitrate: 0,\n          url: ''\n        });\n      }\n    }\n\n    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADED, {\n      levels: levels,\n      audioTracks: audioTracks,\n      subtitles: subtitles,\n      captions: captions,\n      url: url,\n      stats: stats,\n      networkDetails: networkDetails,\n      sessionData: sessionData\n    });\n  };\n\n  _proto.handleTrackOrLevelPlaylist = function handleTrackOrLevelPlaylist(response, stats, context, networkDetails) {\n    var hls = this.hls;\n    var id = context.id,\n        level = context.level,\n        type = context.type;\n    var url = getResponseUrl(response, context);\n    var levelUrlId = Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(id) ? id : 0;\n    var levelId = Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(level) ? level : levelUrlId;\n    var levelType = mapContextToLevelType(context);\n    var levelDetails = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__[\"default\"].parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId);\n\n    if (!levelDetails.fragments.length) {\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorTypes\"].NETWORK_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].LEVEL_EMPTY_ERROR,\n        fatal: false,\n        url: url,\n        reason: 'no fragments found in level',\n        level: typeof context.level === 'number' ? context.level : undefined\n      });\n      return;\n    } // We have done our first request (Manifest-type) and receive\n    // not a master playlist but a chunk-list (track/level)\n    // We fire the manifest-loaded event anyway with the parsed level-details\n    // by creating a single-level structure for it.\n\n\n    if (type === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].MANIFEST) {\n      var singleLevel = {\n        attrs: new _utils_attr_list__WEBPACK_IMPORTED_MODULE_7__[\"AttrList\"]({}),\n        bitrate: 0,\n        details: levelDetails,\n        name: '',\n        url: url\n      };\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADED, {\n        levels: [singleLevel],\n        audioTracks: [],\n        url: url,\n        stats: stats,\n        networkDetails: networkDetails,\n        sessionData: null\n      });\n    } // save parsing time\n\n\n    stats.parsing.end = performance.now(); // in case we need SIDX ranges\n    // return early after calling load for\n    // the SIDX box.\n\n    if (levelDetails.needSidxRanges) {\n      var _levelDetails$fragmen;\n\n      var sidxUrl = (_levelDetails$fragmen = levelDetails.fragments[0].initSegment) === null || _levelDetails$fragmen === void 0 ? void 0 : _levelDetails$fragmen.url;\n      this.load({\n        url: sidxUrl,\n        isSidxRequest: true,\n        type: type,\n        level: level,\n        levelDetails: levelDetails,\n        id: id,\n        groupId: null,\n        rangeStart: 0,\n        rangeEnd: 2048,\n        responseType: 'arraybuffer',\n        deliveryDirectives: null\n      });\n      return;\n    } // extend the context with the new levelDetails property\n\n\n    context.levelDetails = levelDetails;\n    this.handlePlaylistLoaded(response, stats, context, networkDetails);\n  };\n\n  _proto.handleSidxRequest = function handleSidxRequest(response, context) {\n    var sidxInfo = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__[\"parseSegmentIndex\"])(new Uint8Array(response.data)); // if provided fragment does not contain sidx, early return\n\n    if (!sidxInfo) {\n      return;\n    }\n\n    var sidxReferences = sidxInfo.references;\n    var levelDetails = context.levelDetails;\n    sidxReferences.forEach(function (segmentRef, index) {\n      var segRefInfo = segmentRef.info;\n      var frag = levelDetails.fragments[index];\n\n      if (frag.byteRange.length === 0) {\n        frag.setByteRange(String(1 + segRefInfo.end - segRefInfo.start) + '@' + String(segRefInfo.start));\n      }\n\n      if (frag.initSegment) {\n        frag.initSegment.setByteRange(String(sidxInfo.moovEndOffset) + '@0');\n      }\n    });\n  };\n\n  _proto.handleManifestParsingError = function handleManifestParsingError(response, context, reason, networkDetails) {\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, {\n      type: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorTypes\"].NETWORK_ERROR,\n      details: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].MANIFEST_PARSING_ERROR,\n      fatal: context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].MANIFEST,\n      url: response.url,\n      reason: reason,\n      response: response,\n      context: context,\n      networkDetails: networkDetails\n    });\n  };\n\n  _proto.handleNetworkError = function handleNetworkError(context, networkDetails, timeout, response) {\n    if (timeout === void 0) {\n      timeout = false;\n    }\n\n    _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn(\"[playlist-loader]: A network \" + (timeout ? 'timeout' : 'error') + \" occurred while loading \" + context.type + \" level: \" + context.level + \" id: \" + context.id + \" group-id: \\\"\" + context.groupId + \"\\\"\");\n    var details = _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].UNKNOWN;\n    var fatal = false;\n    var loader = this.getInternalLoader(context);\n\n    switch (context.type) {\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].MANIFEST:\n        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].MANIFEST_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].MANIFEST_LOAD_ERROR;\n        fatal = true;\n        break;\n\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].LEVEL:\n        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].LEVEL_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].LEVEL_LOAD_ERROR;\n        fatal = false;\n        break;\n\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].AUDIO_TRACK:\n        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].AUDIO_TRACK_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].AUDIO_TRACK_LOAD_ERROR;\n        fatal = false;\n        break;\n\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].SUBTITLE_TRACK:\n        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].SUBTITLE_TRACK_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].SUBTITLE_LOAD_ERROR;\n        fatal = false;\n        break;\n    }\n\n    if (loader) {\n      this.resetInternalLoader(context.type);\n    }\n\n    var errorData = {\n      type: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorTypes\"].NETWORK_ERROR,\n      details: details,\n      fatal: fatal,\n      url: context.url,\n      loader: loader,\n      context: context,\n      networkDetails: networkDetails\n    };\n\n    if (response) {\n      errorData.response = response;\n    }\n\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, errorData);\n  };\n\n  _proto.handlePlaylistLoaded = function handlePlaylistLoaded(response, stats, context, networkDetails) {\n    var type = context.type,\n        level = context.level,\n        id = context.id,\n        groupId = context.groupId,\n        loader = context.loader,\n        levelDetails = context.levelDetails,\n        deliveryDirectives = context.deliveryDirectives;\n\n    if (!(levelDetails !== null && levelDetails !== void 0 && levelDetails.targetduration)) {\n      this.handleManifestParsingError(response, context, 'invalid target duration', networkDetails);\n      return;\n    }\n\n    if (!loader) {\n      return;\n    }\n\n    if (levelDetails.live) {\n      if (loader.getCacheAge) {\n        levelDetails.ageHeader = loader.getCacheAge() || 0;\n      }\n\n      if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {\n        levelDetails.ageHeader = 0;\n      }\n    }\n\n    switch (type) {\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].MANIFEST:\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].LEVEL:\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_LOADED, {\n          details: levelDetails,\n          level: level || 0,\n          id: id || 0,\n          stats: stats,\n          networkDetails: networkDetails,\n          deliveryDirectives: deliveryDirectives\n        });\n        break;\n\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].AUDIO_TRACK:\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].AUDIO_TRACK_LOADED, {\n          details: levelDetails,\n          id: id || 0,\n          groupId: groupId || '',\n          stats: stats,\n          networkDetails: networkDetails,\n          deliveryDirectives: deliveryDirectives\n        });\n        break;\n\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].SUBTITLE_TRACK:\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_TRACK_LOADED, {\n          details: levelDetails,\n          id: id || 0,\n          groupId: groupId || '',\n          stats: stats,\n          networkDetails: networkDetails,\n          deliveryDirectives: deliveryDirectives\n        });\n        break;\n    }\n  };\n\n  return PlaylistLoader;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (PlaylistLoader);\n\n/***/ }),\n\n/***/ \"./src/polyfills/number.ts\":\n/*!*********************************!*\\\n  !*** ./src/polyfills/number.ts ***!\n  \\*********************************/\n/*! exports provided: isFiniteNumber, MAX_SAFE_INTEGER */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_774641__) {\n\n\"use strict\";\n__nested_webpack_require_774641__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_774641__.d(__webpack_exports__, \"isFiniteNumber\", function() { return isFiniteNumber; });\n/* harmony export (binding) */ __nested_webpack_require_774641__.d(__webpack_exports__, \"MAX_SAFE_INTEGER\", function() { return MAX_SAFE_INTEGER; });\nvar isFiniteNumber = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value);\n};\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n/***/ }),\n\n/***/ \"./src/remux/aac-helper.ts\":\n/*!*********************************!*\\\n  !*** ./src/remux/aac-helper.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_775417__) {\n\n\"use strict\";\n__nested_webpack_require_775417__.r(__webpack_exports__);\n/**\n *  AAC helper\n */\nvar AAC = /*#__PURE__*/function () {\n  function AAC() {}\n\n  AAC.getSilentFrame = function getSilentFrame(codec, channelCount) {\n    switch (codec) {\n      case 'mp4a.40.2':\n        if (channelCount === 1) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n        } else if (channelCount === 2) {\n          return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n        } else if (channelCount === 3) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n        } else if (channelCount === 4) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n        } else if (channelCount === 5) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n        } else if (channelCount === 6) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n        }\n\n        break;\n      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n\n      default:\n        if (channelCount === 1) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 2) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 3) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        }\n\n        break;\n    }\n\n    return undefined;\n  };\n\n  return AAC;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AAC);\n\n/***/ }),\n\n/***/ \"./src/remux/mp4-generator.ts\":\n/*!************************************!*\\\n  !*** ./src/remux/mp4-generator.ts ***!\n  \\************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_778948__) {\n\n\"use strict\";\n__nested_webpack_require_778948__.r(__webpack_exports__);\n/**\n * Generate MP4 Box\n */\nvar UINT32_MAX = Math.pow(2, 32) - 1;\n\nvar MP4 = /*#__PURE__*/function () {\n  function MP4() {}\n\n  MP4.init = function init() {\n    MP4.types = {\n      avc1: [],\n      // codingname\n      avcC: [],\n      btrt: [],\n      dinf: [],\n      dref: [],\n      esds: [],\n      ftyp: [],\n      hdlr: [],\n      mdat: [],\n      mdhd: [],\n      mdia: [],\n      mfhd: [],\n      minf: [],\n      moof: [],\n      moov: [],\n      mp4a: [],\n      '.mp3': [],\n      mvex: [],\n      mvhd: [],\n      pasp: [],\n      sdtp: [],\n      stbl: [],\n      stco: [],\n      stsc: [],\n      stsd: [],\n      stsz: [],\n      stts: [],\n      tfdt: [],\n      tfhd: [],\n      traf: [],\n      trak: [],\n      trun: [],\n      trex: [],\n      tkhd: [],\n      vmhd: [],\n      smhd: []\n    };\n    var i;\n\n    for (i in MP4.types) {\n      if (MP4.types.hasOwnProperty(i)) {\n        MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n      }\n    }\n\n    var videoHdlr = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ]);\n    var audioHdlr = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n    ]);\n    MP4.HDLR_TYPES = {\n      video: videoHdlr,\n      audio: audioHdlr\n    };\n    var dref = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0c, // entry_size\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\n    0x00, // version 0\n    0x00, 0x00, 0x01 // entry_flags\n    ]);\n    var stco = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n    MP4.STTS = MP4.STSC = MP4.STCO = stco;\n    MP4.STSZ = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n    ]);\n    MP4.VMHD = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x01, // flags\n    0x00, 0x00, // graphicsmode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n    ]);\n    MP4.SMHD = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, // balance\n    0x00, 0x00 // reserved\n    ]);\n    MP4.STSD = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01]); // entry_count\n\n    var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n\n    var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n\n    var minorVersion = new Uint8Array([0, 0, 0, 1]);\n    MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n  };\n\n  MP4.box = function box(type) {\n    var size = 8;\n\n    for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      payload[_key - 1] = arguments[_key];\n    }\n\n    var i = payload.length;\n    var len = i; // calculate the total size we need to allocate\n\n    while (i--) {\n      size += payload[i].byteLength;\n    }\n\n    var result = new Uint8Array(size);\n    result[0] = size >> 24 & 0xff;\n    result[1] = size >> 16 & 0xff;\n    result[2] = size >> 8 & 0xff;\n    result[3] = size & 0xff;\n    result.set(type, 4); // copy the payload into the result\n\n    for (i = 0, size = 8; i < len; i++) {\n      // copy payload[i] array @ offset size\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n\n    return result;\n  };\n\n  MP4.hdlr = function hdlr(type) {\n    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n  };\n\n  MP4.mdat = function mdat(data) {\n    return MP4.box(MP4.types.mdat, data);\n  };\n\n  MP4.mdhd = function mdhd(timescale, duration) {\n    duration *= timescale;\n    var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.mdhd, new Uint8Array([0x01, // version 1\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff, // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x55, 0xc4, // 'und' language (undetermined)\n    0x00, 0x00]));\n  };\n\n  MP4.mdia = function mdia(track) {\n    return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));\n  };\n\n  MP4.mfhd = function mfhd(sequenceNumber) {\n    return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags\n    sequenceNumber >> 24, sequenceNumber >> 16 & 0xff, sequenceNumber >> 8 & 0xff, sequenceNumber & 0xff // sequence_number\n    ]));\n  };\n\n  MP4.minf = function minf(track) {\n    if (track.type === 'audio') {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n    } else {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n    }\n  };\n\n  MP4.moof = function moof(sn, baseMediaDecodeTime, track) {\n    return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n  }\n  /**\n   * @param tracks... (optional) {array} the tracks associated with this movie\n   */\n  ;\n\n  MP4.moov = function moov(tracks) {\n    var i = tracks.length;\n    var boxes = [];\n\n    while (i--) {\n      boxes[i] = MP4.trak(tracks[i]);\n    }\n\n    return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));\n  };\n\n  MP4.mvex = function mvex(tracks) {\n    var i = tracks.length;\n    var boxes = [];\n\n    while (i--) {\n      boxes[i] = MP4.trex(tracks[i]);\n    }\n\n    return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));\n  };\n\n  MP4.mvhd = function mvhd(timescale, duration) {\n    duration *= timescale;\n    var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    var bytes = new Uint8Array([0x01, // version 1\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff, // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x01, 0x00, 0x00, // 1.0 rate\n    0x01, 0x00, // 1.0 volume\n    0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n    0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n    return MP4.box(MP4.types.mvhd, bytes);\n  };\n\n  MP4.sdtp = function sdtp(track) {\n    var samples = track.samples || [];\n    var bytes = new Uint8Array(4 + samples.length);\n    var i;\n    var flags; // leave the full box header (4 bytes) all zero\n    // write the sample table\n\n    for (i = 0; i < samples.length; i++) {\n      flags = samples[i].flags;\n      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n    }\n\n    return MP4.box(MP4.types.sdtp, bytes);\n  };\n\n  MP4.stbl = function stbl(track) {\n    return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n  };\n\n  MP4.avc1 = function avc1(track) {\n    var sps = [];\n    var pps = [];\n    var i;\n    var data;\n    var len; // assemble the SPSs\n\n    for (i = 0; i < track.sps.length; i++) {\n      data = track.sps[i];\n      len = data.byteLength;\n      sps.push(len >>> 8 & 0xff);\n      sps.push(len & 0xff); // SPS\n\n      sps = sps.concat(Array.prototype.slice.call(data));\n    } // assemble the PPSs\n\n\n    for (i = 0; i < track.pps.length; i++) {\n      data = track.pps[i];\n      len = data.byteLength;\n      pps.push(len >>> 8 & 0xff);\n      pps.push(len & 0xff);\n      pps = pps.concat(Array.prototype.slice.call(data));\n    }\n\n    var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version\n    sps[3], // profile\n    sps[4], // profile compat\n    sps[5], // level\n    0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes\n    0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n    ].concat(sps).concat([track.pps.length // numOfPictureParameterSets\n    ]).concat(pps))); // \"PPS\"\n\n    var width = track.width;\n    var height = track.height;\n    var hSpacing = track.pixelRatio[0];\n    var vSpacing = track.pixelRatio[1];\n    return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, // data_reference_index\n    0x00, 0x00, // pre_defined\n    0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n    width >> 8 & 0xff, width & 0xff, // width\n    height >> 8 & 0xff, height & 0xff, // height\n    0x00, 0x48, 0x00, 0x00, // horizresolution\n    0x00, 0x48, 0x00, 0x00, // vertresolution\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, // frame_count\n    0x12, 0x64, 0x61, 0x69, 0x6c, // dailymotion/hls.js\n    0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname\n    0x00, 0x18, // depth = 24\n    0x11, 0x11]), // pre_defined = -1\n    avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n    0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n    0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate\n    MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24, // hSpacing\n    hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24, // vSpacing\n    vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));\n  };\n\n  MP4.esds = function esds(track) {\n    var configlen = track.config.length;\n    return new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x03, // descriptor_type\n    0x17 + configlen, // length\n    0x00, 0x01, // es_id\n    0x00, // stream_priority\n    0x04, // descriptor_type\n    0x0f + configlen, // length\n    0x40, // codec : mpeg4_audio\n    0x15, // stream_type\n    0x00, 0x00, 0x00, // buffer_size\n    0x00, 0x00, 0x00, 0x00, // maxBitrate\n    0x00, 0x00, 0x00, 0x00, // avgBitrate\n    0x05 // descriptor_type\n    ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor\n  };\n\n  MP4.mp4a = function mp4a(track) {\n    var samplerate = track.samplerate;\n    return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, // data_reference_index\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, track.channelCount, // channelcount\n    0x00, 0x10, // sampleSize:16bits\n    0x00, 0x00, 0x00, 0x00, // reserved2\n    samplerate >> 8 & 0xff, samplerate & 0xff, //\n    0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));\n  };\n\n  MP4.mp3 = function mp3(track) {\n    var samplerate = track.samplerate;\n    return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, // data_reference_index\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, track.channelCount, // channelcount\n    0x00, 0x10, // sampleSize:16bits\n    0x00, 0x00, 0x00, 0x00, // reserved2\n    samplerate >> 8 & 0xff, samplerate & 0xff, //\n    0x00, 0x00]));\n  };\n\n  MP4.stsd = function stsd(track) {\n    if (track.type === 'audio') {\n      if (track.segmentCodec === 'mp3' && track.codec === 'mp3') {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n      }\n\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n    } else {\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n    }\n  };\n\n  MP4.tkhd = function tkhd(track) {\n    var id = track.id;\n    var duration = track.duration * track.timescale;\n    var width = track.width;\n    var height = track.height;\n    var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.tkhd, new Uint8Array([0x01, // version 1\n    0x00, 0x00, 0x07, // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time\n    id >> 24 & 0xff, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff, // track_ID\n    0x00, 0x00, 0x00, 0x00, // reserved\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, // layer\n    0x00, 0x00, // alternate_group\n    0x00, 0x00, // non-audio track volume\n    0x00, 0x00, // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n    width >> 8 & 0xff, width & 0xff, 0x00, 0x00, // width\n    height >> 8 & 0xff, height & 0xff, 0x00, 0x00 // height\n    ]));\n  };\n\n  MP4.traf = function traf(track, baseMediaDecodeTime) {\n    var sampleDependencyTable = MP4.sdtp(track);\n    var id = track.id;\n    var upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n    var lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff // track_ID\n    ])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01, // version 1\n    0x00, 0x00, 0x00, // flags\n    upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0xff, upperWordBaseMediaDecodeTime >> 8 & 0xff, upperWordBaseMediaDecodeTime & 0xff, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0xff, lowerWordBaseMediaDecodeTime >> 8 & 0xff, lowerWordBaseMediaDecodeTime & 0xff])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd\n    20 + // tfdt\n    8 + // traf header\n    16 + // mfhd\n    8 + // moof header\n    8), // mdat header\n    sampleDependencyTable);\n  }\n  /**\n   * Generate a track box.\n   * @param track {object} a track definition\n   * @return {Uint8Array} the track box\n   */\n  ;\n\n  MP4.trak = function trak(track) {\n    track.duration = track.duration || 0xffffffff;\n    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n  };\n\n  MP4.trex = function trex(track) {\n    var id = track.id;\n    return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff, // track_ID\n    0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]));\n  };\n\n  MP4.trun = function trun(track, offset) {\n    var samples = track.samples || [];\n    var len = samples.length;\n    var arraylen = 12 + 16 * len;\n    var array = new Uint8Array(arraylen);\n    var i;\n    var sample;\n    var duration;\n    var size;\n    var flags;\n    var cts;\n    offset += 8 + arraylen;\n    array.set([0x00, // version 0\n    0x00, 0x0f, 0x01, // flags\n    len >>> 24 & 0xff, len >>> 16 & 0xff, len >>> 8 & 0xff, len & 0xff, // sample_count\n    offset >>> 24 & 0xff, offset >>> 16 & 0xff, offset >>> 8 & 0xff, offset & 0xff // data_offset\n    ], 0);\n\n    for (i = 0; i < len; i++) {\n      sample = samples[i];\n      duration = sample.duration;\n      size = sample.size;\n      flags = sample.flags;\n      cts = sample.cts;\n      array.set([duration >>> 24 & 0xff, duration >>> 16 & 0xff, duration >>> 8 & 0xff, duration & 0xff, // sample_duration\n      size >>> 24 & 0xff, size >>> 16 & 0xff, size >>> 8 & 0xff, size & 0xff, // sample_size\n      flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xf0 << 8, flags.degradPrio & 0x0f, // sample_flags\n      cts >>> 24 & 0xff, cts >>> 16 & 0xff, cts >>> 8 & 0xff, cts & 0xff // sample_composition_time_offset\n      ], 12 + 16 * i);\n    }\n\n    return MP4.box(MP4.types.trun, array);\n  };\n\n  MP4.initSegment = function initSegment(tracks) {\n    if (!MP4.types) {\n      MP4.init();\n    }\n\n    var movie = MP4.moov(tracks);\n    var result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);\n    result.set(MP4.FTYP);\n    result.set(movie, MP4.FTYP.byteLength);\n    return result;\n  };\n\n  return MP4;\n}();\n\nMP4.types = void 0;\nMP4.HDLR_TYPES = void 0;\nMP4.STTS = void 0;\nMP4.STSC = void 0;\nMP4.STCO = void 0;\nMP4.STSZ = void 0;\nMP4.VMHD = void 0;\nMP4.SMHD = void 0;\nMP4.STSD = void 0;\nMP4.FTYP = void 0;\nMP4.DINF = void 0;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MP4);\n\n/***/ }),\n\n/***/ \"./src/remux/mp4-remuxer.ts\":\n/*!**********************************!*\\\n  !*** ./src/remux/mp4-remuxer.ts ***!\n  \\**********************************/\n/*! exports provided: default, normalizePts, flushTextTrackMetadataCueSamples, flushTextTrackUserdataCueSamples */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_797954__) {\n\n\"use strict\";\n__nested_webpack_require_797954__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_797954__.d(__webpack_exports__, \"default\", function() { return MP4Remuxer; });\n/* harmony export (binding) */ __nested_webpack_require_797954__.d(__webpack_exports__, \"normalizePts\", function() { return normalizePts; });\n/* harmony export (binding) */ __nested_webpack_require_797954__.d(__webpack_exports__, \"flushTextTrackMetadataCueSamples\", function() { return flushTextTrackMetadataCueSamples; });\n/* harmony export (binding) */ __nested_webpack_require_797954__.d(__webpack_exports__, \"flushTextTrackUserdataCueSamples\", function() { return flushTextTrackUserdataCueSamples; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_797954__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _aac_helper__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_797954__(/*! ./aac-helper */ \"./src/remux/aac-helper.ts\");\n/* harmony import */ var _mp4_generator__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_797954__(/*! ./mp4-generator */ \"./src/remux/mp4-generator.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_797954__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_797954__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_797954__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_797954__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_797954__(/*! ../utils/timescale-conversion */ \"./src/utils/timescale-conversion.ts\");\n\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\n\n\n\n\n\nvar MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\n\nvar AAC_SAMPLES_PER_FRAME = 1024;\nvar MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\nvar chromeVersion = null;\nvar safariWebkitVersion = null;\nvar requiresPositiveDts = false;\n\nvar MP4Remuxer = /*#__PURE__*/function () {\n  function MP4Remuxer(observer, config, typeSupported, vendor) {\n    if (vendor === void 0) {\n      vendor = '';\n    }\n\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.ISGenerated = false;\n    this._initPTS = void 0;\n    this._initDTS = void 0;\n    this.nextAvcDts = null;\n    this.nextAudioPts = null;\n    this.videoSampleDuration = null;\n    this.isAudioContiguous = false;\n    this.isVideoContiguous = false;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.ISGenerated = false;\n\n    if (chromeVersion === null) {\n      var userAgent = navigator.userAgent || '';\n      var result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion = result ? parseInt(result[1]) : 0;\n    }\n\n    if (safariWebkitVersion === null) {\n      var _result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n\n      safariWebkitVersion = _result ? parseInt(_result[1]) : 0;\n    }\n\n    requiresPositiveDts = !(!!chromeVersion && chromeVersion >= 75 || !!safariWebkitVersion && safariWebkitVersion >= 600);\n  }\n\n  var _proto = MP4Remuxer.prototype;\n\n  _proto.destroy = function destroy() {};\n\n  _proto.resetTimeStamp = function resetTimeStamp(defaultTimeStamp) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].log('[mp4-remuxer]: initPTS & initDTS reset');\n    this._initPTS = this._initDTS = defaultTimeStamp;\n  };\n\n  _proto.resetNextTimestamp = function resetNextTimestamp() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].log('[mp4-remuxer]: reset next timestamp');\n    this.isVideoContiguous = false;\n    this.isAudioContiguous = false;\n  };\n\n  _proto.resetInitSegment = function resetInitSegment() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].log('[mp4-remuxer]: ISGenerated flag reset');\n    this.ISGenerated = false;\n  };\n\n  _proto.getVideoStartPts = function getVideoStartPts(videoSamples) {\n    var rolloverDetected = false;\n    var startPTS = videoSamples.reduce(function (minPTS, sample) {\n      var delta = sample.pts - minPTS;\n\n      if (delta < -4294967296) {\n        // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\n        rolloverDetected = true;\n        return normalizePts(minPTS, sample.pts);\n      } else if (delta > 0) {\n        return minPTS;\n      } else {\n        return sample.pts;\n      }\n    }, videoSamples[0].pts);\n\n    if (rolloverDetected) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].debug('PTS rollover detected');\n    }\n\n    return startPTS;\n  };\n\n  _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {\n    var video;\n    var audio;\n    var initSegment;\n    var text;\n    var id3;\n    var independent;\n    var audioTimeOffset = timeOffset;\n    var videoTimeOffset = timeOffset; // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\n    // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\n    // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\n    // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\n    // then we can remux one track without waiting for the other.\n\n    var hasAudio = audioTrack.pid > -1;\n    var hasVideo = videoTrack.pid > -1;\n    var length = videoTrack.samples.length;\n    var enoughAudioSamples = audioTrack.samples.length > 0;\n    var enoughVideoSamples = flush && length > 0 || length > 1;\n    var canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;\n\n    if (canRemuxAvc) {\n      if (!this.ISGenerated) {\n        initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);\n      }\n\n      var isVideoContiguous = this.isVideoContiguous;\n      var firstKeyFrameIndex = -1;\n      var firstKeyFramePTS;\n\n      if (enoughVideoSamples) {\n        firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\n\n        if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\n          independent = true;\n\n          if (firstKeyFrameIndex > 0) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(\"[mp4-remuxer]: Dropped \" + firstKeyFrameIndex + \" out of \" + length + \" video samples due to a missing keyframe\");\n            var startPTS = this.getVideoStartPts(videoTrack.samples);\n            videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\n            videoTrack.dropped += firstKeyFrameIndex;\n            videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;\n            firstKeyFramePTS = videoTimeOffset;\n          } else if (firstKeyFrameIndex === -1) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(\"[mp4-remuxer]: No keyframe found out of \" + length + \" video samples\");\n            independent = false;\n          }\n        }\n      }\n\n      if (this.ISGenerated) {\n        if (enoughAudioSamples && enoughVideoSamples) {\n          // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n          // if first audio DTS is not aligned with first video DTS then we need to take that into account\n          // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n          // drift between audio and video streams\n          var _startPTS = this.getVideoStartPts(videoTrack.samples);\n\n          var tsDelta = normalizePts(audioTrack.samples[0].pts, _startPTS) - _startPTS;\n\n          var audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\n          audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\n          videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\n        } // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\n\n\n        if (enoughAudioSamples) {\n          // if initSegment was generated without audio samples, regenerate it again\n          if (!audioTrack.samplerate) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn('[mp4-remuxer]: regenerate InitSegment as audio detected');\n            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);\n          }\n\n          audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].AUDIO ? videoTimeOffset : undefined);\n\n          if (enoughVideoSamples) {\n            var audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0; // if initSegment was generated without video samples, regenerate it again\n\n            if (!videoTrack.inputTimeScale) {\n              _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn('[mp4-remuxer]: regenerate InitSegment as video detected');\n              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);\n            }\n\n            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);\n          }\n        } else if (enoughVideoSamples) {\n          video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);\n        }\n\n        if (video) {\n          video.firstKeyFrame = firstKeyFrameIndex;\n          video.independent = firstKeyFrameIndex !== -1;\n          video.firstKeyFramePTS = firstKeyFramePTS;\n        }\n      }\n    } // Allow ID3 and text to remux, even if more audio/video samples are required\n\n\n    if (this.ISGenerated) {\n      if (id3Track.samples.length) {\n        id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);\n      }\n\n      if (textTrack.samples.length) {\n        text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);\n      }\n    }\n\n    return {\n      audio: audio,\n      video: video,\n      initSegment: initSegment,\n      independent: independent,\n      text: text,\n      id3: id3\n    };\n  };\n\n  _proto.generateIS = function generateIS(audioTrack, videoTrack, timeOffset) {\n    var audioSamples = audioTrack.samples;\n    var videoSamples = videoTrack.samples;\n    var typeSupported = this.typeSupported;\n    var tracks = {};\n    var computePTSDTS = !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(this._initPTS);\n    var container = 'audio/mp4';\n    var initPTS;\n    var initDTS;\n    var timescale;\n\n    if (computePTSDTS) {\n      initPTS = initDTS = Infinity;\n    }\n\n    if (audioTrack.config && audioSamples.length) {\n      // let's use audio sampling rate as MP4 time scale.\n      // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n      // using audio sampling rate here helps having an integer MP4 frame duration\n      // this avoids potential rounding issue and AV sync issue\n      audioTrack.timescale = audioTrack.samplerate;\n\n      switch (audioTrack.segmentCodec) {\n        case 'mp3':\n          if (typeSupported.mpeg) {\n            // Chrome and Safari\n            container = 'audio/mpeg';\n            audioTrack.codec = '';\n          } else if (typeSupported.mp3) {\n            // Firefox\n            audioTrack.codec = 'mp3';\n          }\n\n          break;\n      }\n\n      tracks.audio = {\n        id: 'audio',\n        container: container,\n        codec: audioTrack.codec,\n        initSegment: audioTrack.segmentCodec === 'mp3' && typeSupported.mpeg ? new Uint8Array(0) : _mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].initSegment([audioTrack]),\n        metadata: {\n          channelCount: audioTrack.channelCount\n        }\n      };\n\n      if (computePTSDTS) {\n        timescale = audioTrack.inputTimeScale; // remember first PTS of this demuxing context. for audio, PTS = DTS\n\n        initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);\n      }\n    }\n\n    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n      // let's use input time scale as MP4 video timescale\n      // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n      videoTrack.timescale = videoTrack.inputTimeScale;\n      tracks.video = {\n        id: 'main',\n        container: 'video/mp4',\n        codec: videoTrack.codec,\n        initSegment: _mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].initSegment([videoTrack]),\n        metadata: {\n          width: videoTrack.width,\n          height: videoTrack.height\n        }\n      };\n\n      if (computePTSDTS) {\n        timescale = videoTrack.inputTimeScale;\n        var startPTS = this.getVideoStartPts(videoSamples);\n        var startOffset = Math.round(timescale * timeOffset);\n        initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);\n        initPTS = Math.min(initPTS, startPTS - startOffset);\n      }\n    }\n\n    if (Object.keys(tracks).length) {\n      this.ISGenerated = true;\n\n      if (computePTSDTS) {\n        this._initPTS = initPTS;\n        this._initDTS = initDTS;\n      }\n\n      return {\n        tracks: tracks,\n        initPTS: initPTS,\n        timescale: timescale\n      };\n    }\n  };\n\n  _proto.remuxVideo = function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {\n    var timeScale = track.inputTimeScale;\n    var inputSamples = track.samples;\n    var outputSamples = [];\n    var nbSamples = inputSamples.length;\n    var initPTS = this._initPTS;\n    var nextAvcDts = this.nextAvcDts;\n    var offset = 8;\n    var mp4SampleDuration = this.videoSampleDuration;\n    var firstDTS;\n    var lastDTS;\n    var minPTS = Number.POSITIVE_INFINITY;\n    var maxPTS = Number.NEGATIVE_INFINITY;\n    var ptsDtsShift = 0;\n    var sortSamples = false; // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n\n    if (!contiguous || nextAvcDts === null) {\n      var pts = timeOffset * timeScale;\n      var cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts); // if not contiguous, let's use target timeOffset\n\n      nextAvcDts = pts - cts;\n    } // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n    // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n\n\n    for (var i = 0; i < nbSamples; i++) {\n      var sample = inputSamples[i];\n      sample.pts = normalizePts(sample.pts - initPTS, nextAvcDts);\n      sample.dts = normalizePts(sample.dts - initPTS, nextAvcDts);\n\n      if (sample.dts > sample.pts) {\n        var PTS_DTS_SHIFT_TOLERANCE_90KHZ = 90000 * 0.2;\n        ptsDtsShift = Math.max(Math.min(ptsDtsShift, sample.pts - sample.dts), -1 * PTS_DTS_SHIFT_TOLERANCE_90KHZ);\n      }\n\n      if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\n        sortSamples = true;\n      }\n    } // sort video samples by DTS then PTS then demux id order\n\n\n    if (sortSamples) {\n      inputSamples.sort(function (a, b) {\n        var deltadts = a.dts - b.dts;\n        var deltapts = a.pts - b.pts;\n        return deltadts || deltapts;\n      });\n    } // Get first/last DTS\n\n\n    firstDTS = inputSamples[0].dts;\n    lastDTS = inputSamples[inputSamples.length - 1].dts; // on Safari let's signal the same sample duration for all samples\n    // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n    // set this constant duration as being the avg delta between consecutive DTS.\n\n    var inputDuration = lastDTS - firstDTS;\n    var averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30; // handle broken streams with PTS < DTS, tolerance up 0.2 seconds\n\n    if (ptsDtsShift < 0) {\n      if (ptsDtsShift < averageSampleDuration * -2) {\n        // Fix for \"CNN special report, with CC\" in test-streams (including Safari browser)\n        // With large PTS < DTS errors such as this, we want to correct CTS while maintaining increasing DTS values\n        _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(\"PTS < DTS detected in video samples, offsetting DTS from PTS by \" + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__[\"toMsFromMpegTsClock\"])(-averageSampleDuration, true) + \" ms\");\n        var lastDts = ptsDtsShift;\n\n        for (var _i = 0; _i < nbSamples; _i++) {\n          inputSamples[_i].dts = lastDts = Math.max(lastDts, inputSamples[_i].pts - averageSampleDuration);\n          inputSamples[_i].pts = Math.max(lastDts, inputSamples[_i].pts);\n        }\n      } else {\n        // Fix for \"Custom IV with bad PTS DTS\" in test-streams\n        // With smaller PTS < DTS errors we can simply move all DTS back. This increases CTS without causing buffer gaps or decode errors in Safari\n        _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(\"PTS < DTS detected in video samples, shifting DTS by \" + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__[\"toMsFromMpegTsClock\"])(ptsDtsShift, true) + \" ms to overcome this issue\");\n\n        for (var _i2 = 0; _i2 < nbSamples; _i2++) {\n          inputSamples[_i2].dts = inputSamples[_i2].dts + ptsDtsShift;\n        }\n      }\n\n      firstDTS = inputSamples[0].dts;\n    } // if fragment are contiguous, detect hole/overlapping between fragments\n\n\n    if (contiguous) {\n      // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\n      var delta = firstDTS - nextAvcDts;\n      var foundHole = delta > averageSampleDuration;\n      var foundOverlap = delta < -1;\n\n      if (foundHole || foundOverlap) {\n        if (foundHole) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(\"AVC: \" + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__[\"toMsFromMpegTsClock\"])(delta, true) + \" ms (\" + delta + \"dts) hole between fragments detected, filling it\");\n        } else {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(\"AVC: \" + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__[\"toMsFromMpegTsClock\"])(-delta, true) + \" ms (\" + delta + \"dts) overlapping between fragments detected\");\n        }\n\n        firstDTS = nextAvcDts;\n        var firstPTS = inputSamples[0].pts - delta;\n        inputSamples[0].dts = firstDTS;\n        inputSamples[0].pts = firstPTS;\n        _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].log(\"Video: First PTS/DTS adjusted: \" + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__[\"toMsFromMpegTsClock\"])(firstPTS, true) + \"/\" + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__[\"toMsFromMpegTsClock\"])(firstDTS, true) + \", delta: \" + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__[\"toMsFromMpegTsClock\"])(delta, true) + \" ms\");\n      }\n    }\n\n    if (requiresPositiveDts) {\n      firstDTS = Math.max(0, firstDTS);\n    }\n\n    var nbNalu = 0;\n    var naluLen = 0;\n\n    for (var _i3 = 0; _i3 < nbSamples; _i3++) {\n      // compute total/avc sample length and nb of NAL units\n      var _sample = inputSamples[_i3];\n      var units = _sample.units;\n      var nbUnits = units.length;\n      var sampleLen = 0;\n\n      for (var j = 0; j < nbUnits; j++) {\n        sampleLen += units[j].data.length;\n      }\n\n      naluLen += sampleLen;\n      nbNalu += nbUnits;\n      _sample.length = sampleLen; // normalize PTS/DTS\n      // ensure sample monotonic DTS\n\n      _sample.dts = Math.max(_sample.dts, firstDTS); // ensure that computed value is greater or equal than sample DTS\n\n      _sample.pts = Math.max(_sample.pts, _sample.dts, 0);\n      minPTS = Math.min(_sample.pts, minPTS);\n      maxPTS = Math.max(_sample.pts, maxPTS);\n    }\n\n    lastDTS = inputSamples[nbSamples - 1].dts;\n    /* concatenate the video data and construct the mdat in place\n      (need 8 more bytes to fill length and mpdat type) */\n\n    var mdatSize = naluLen + 4 * nbNalu + 8;\n    var mdat;\n\n    try {\n      mdat = new Uint8Array(mdatSize);\n    } catch (err) {\n      this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].ERROR, _events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorTypes\"].MUX_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorDetails\"].REMUX_ALLOC_ERROR,\n        fatal: false,\n        bytes: mdatSize,\n        reason: \"fail allocating video mdat \" + mdatSize\n      });\n      return;\n    }\n\n    var view = new DataView(mdat.buffer);\n    view.setUint32(0, mdatSize);\n    mdat.set(_mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].types.mdat, 4);\n    var stretchedLastFrame = false;\n\n    for (var _i4 = 0; _i4 < nbSamples; _i4++) {\n      var avcSample = inputSamples[_i4];\n      var avcSampleUnits = avcSample.units;\n      var mp4SampleLength = 0; // convert NALU bitstream to MP4 format (prepend NALU with size field)\n\n      for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {\n        var unit = avcSampleUnits[_j];\n        var unitData = unit.data;\n        var unitDataLen = unit.data.byteLength;\n        view.setUint32(offset, unitDataLen);\n        offset += 4;\n        mdat.set(unitData, offset);\n        offset += unitDataLen;\n        mp4SampleLength += 4 + unitDataLen;\n      } // expected sample duration is the Decoding Timestamp diff of consecutive samples\n\n\n      if (_i4 < nbSamples - 1) {\n        mp4SampleDuration = inputSamples[_i4 + 1].dts - avcSample.dts;\n      } else {\n        var config = this.config;\n        var lastFrameDuration = _i4 > 0 ? avcSample.dts - inputSamples[_i4 - 1].dts : averageSampleDuration;\n\n        if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {\n          // In some cases, a segment's audio track duration may exceed the video track duration.\n          // Since we've already remuxed audio, and we know how long the audio track is, we look to\n          // see if the delta to the next segment is longer than maxBufferHole.\n          // If so, playback would potentially get stuck, so we artificially inflate\n          // the duration of the last frame to minimize any potential gap between segments.\n          var gapTolerance = Math.floor(config.maxBufferHole * timeScale);\n          var deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;\n\n          if (deltaToFrameEnd > gapTolerance) {\n            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n\n            if (mp4SampleDuration < 0) {\n              mp4SampleDuration = lastFrameDuration;\n            } else {\n              stretchedLastFrame = true;\n            }\n\n            _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].log(\"[mp4-remuxer]: It is approximately \" + deltaToFrameEnd / 90 + \" ms to the next segment; using duration \" + mp4SampleDuration / 90 + \" ms for the last video frame.\");\n          } else {\n            mp4SampleDuration = lastFrameDuration;\n          }\n        } else {\n          mp4SampleDuration = lastFrameDuration;\n        }\n      }\n\n      var compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);\n      outputSamples.push(new Mp4Sample(avcSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));\n    }\n\n    if (outputSamples.length && chromeVersion && chromeVersion < 70) {\n      // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\n      // https://code.google.com/p/chromium/issues/detail?id=229412\n      var flags = outputSamples[0].flags;\n      flags.dependsOn = 2;\n      flags.isNonSync = 0;\n    }\n\n    console.assert(mp4SampleDuration !== null, 'mp4SampleDuration must be computed'); // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n\n    mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;\n    this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;\n    this.videoSampleDuration = mp4SampleDuration;\n    this.isVideoContiguous = true;\n    var moof = _mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].moof(track.sequenceNumber++, firstDTS, _extends({}, track, {\n      samples: outputSamples\n    }));\n    var type = 'video';\n    var data = {\n      data1: moof,\n      data2: mdat,\n      startPTS: minPTS / timeScale,\n      endPTS: (maxPTS + mp4SampleDuration) / timeScale,\n      startDTS: firstDTS / timeScale,\n      endDTS: nextAvcDts / timeScale,\n      type: type,\n      hasAudio: false,\n      hasVideo: true,\n      nb: outputSamples.length,\n      dropped: track.dropped\n    };\n    track.samples = [];\n    track.dropped = 0;\n    console.assert(mdat.length, 'MDAT length must not be zero');\n    return data;\n  };\n\n  _proto.remuxAudio = function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {\n    var inputTimeScale = track.inputTimeScale;\n    var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n    var scaleFactor = inputTimeScale / mp4timeScale;\n    var mp4SampleDuration = track.segmentCodec === 'aac' ? AAC_SAMPLES_PER_FRAME : MPEG_AUDIO_SAMPLE_PER_FRAME;\n    var inputSampleDuration = mp4SampleDuration * scaleFactor;\n    var initPTS = this._initPTS;\n    var rawMPEG = track.segmentCodec === 'mp3' && this.typeSupported.mpeg;\n    var outputSamples = [];\n    var alignedWithVideo = videoTimeOffset !== undefined;\n    var inputSamples = track.samples;\n    var offset = rawMPEG ? 0 : 8;\n    var nextAudioPts = this.nextAudioPts || -1; // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\n    // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n    // for sake of clarity:\n    // consecutive fragments are frags with\n    //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n    //  - less than 20 audio frames distance\n    // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n    // this helps ensuring audio continuity\n    // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n\n    var timeOffsetMpegTS = timeOffset * inputTimeScale;\n    this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000 || Math.abs(normalizePts(inputSamples[0].pts - initPTS, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration); // compute normalized PTS\n\n    inputSamples.forEach(function (sample) {\n      sample.pts = normalizePts(sample.pts - initPTS, timeOffsetMpegTS);\n    });\n\n    if (!contiguous || nextAudioPts < 0) {\n      // filter out sample with negative PTS that are not playable anyway\n      // if we don't remove these negative samples, they will shift all audio samples forward.\n      // leading to audio overlap between current / next fragment\n      inputSamples = inputSamples.filter(function (sample) {\n        return sample.pts >= 0;\n      }); // in case all samples have negative PTS, and have been filtered out, return now\n\n      if (!inputSamples.length) {\n        return;\n      }\n\n      if (videoTimeOffset === 0) {\n        // Set the start to 0 to match video so that start gaps larger than inputSampleDuration are filled with silence\n        nextAudioPts = 0;\n      } else if (accurateTimeOffset && !alignedWithVideo) {\n        // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\n        nextAudioPts = Math.max(0, timeOffsetMpegTS);\n      } else {\n        // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n        nextAudioPts = inputSamples[0].pts;\n      }\n    } // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n    // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n    // In an effort to prevent this from happening, we inject frames here where there are gaps.\n    // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n    // frame.\n\n\n    if (track.segmentCodec === 'aac') {\n      var maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n\n      for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {\n        // First, let's see how far off this frame is from where we expect it to be\n        var sample = inputSamples[i];\n        var pts = sample.pts;\n        var delta = pts - nextPts;\n        var duration = Math.abs(1000 * delta / inputTimeScale); // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\n\n        if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {\n          if (i === 0) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(\"Audio frame @ \" + (pts / inputTimeScale).toFixed(3) + \"s overlaps nextAudioPts by \" + Math.round(1000 * delta / inputTimeScale) + \" ms.\");\n            this.nextAudioPts = nextAudioPts = nextPts = pts;\n          }\n        } // eslint-disable-line brace-style\n        // Insert missing frames if:\n        // 1: We're more than maxAudioFramesDrift frame away\n        // 2: Not more than MAX_SILENT_FRAME_DURATION away\n        // 3: currentTime (aka nextPtsNorm) is not 0\n        // 4: remuxing with video (videoTimeOffset !== undefined)\n        else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {\n          var missing = Math.round(delta / inputSampleDuration); // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\n          // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\n\n          nextPts = pts - missing * inputSampleDuration;\n\n          if (nextPts < 0) {\n            missing--;\n            nextPts += inputSampleDuration;\n          }\n\n          if (i === 0) {\n            this.nextAudioPts = nextAudioPts = nextPts;\n          }\n\n          _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(\"[mp4-remuxer]: Injecting \" + missing + \" audio frame @ \" + (nextPts / inputTimeScale).toFixed(3) + \"s due to \" + Math.round(1000 * delta / inputTimeScale) + \" ms gap.\");\n\n          for (var j = 0; j < missing; j++) {\n            var newStamp = Math.max(nextPts, 0);\n            var fillFrame = _aac_helper__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n\n            if (!fillFrame) {\n              _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].log('[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.');\n              fillFrame = sample.unit.subarray();\n            }\n\n            inputSamples.splice(i, 0, {\n              unit: fillFrame,\n              pts: newStamp\n            });\n            nextPts += inputSampleDuration;\n            i++;\n          }\n        }\n\n        sample.pts = nextPts;\n        nextPts += inputSampleDuration;\n      }\n    }\n\n    var firstPTS = null;\n    var lastPTS = null;\n    var mdat;\n    var mdatSize = 0;\n    var sampleLength = inputSamples.length;\n\n    while (sampleLength--) {\n      mdatSize += inputSamples[sampleLength].unit.byteLength;\n    }\n\n    for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {\n      var audioSample = inputSamples[_j2];\n      var unit = audioSample.unit;\n      var _pts = audioSample.pts;\n\n      if (lastPTS !== null) {\n        // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\n        // the previous sample\n        var prevSample = outputSamples[_j2 - 1];\n        prevSample.duration = Math.round((_pts - lastPTS) / scaleFactor);\n      } else {\n        if (contiguous && track.segmentCodec === 'aac') {\n          // set PTS/DTS to expected PTS/DTS\n          _pts = nextAudioPts;\n        } // remember first PTS of our audioSamples\n\n\n        firstPTS = _pts;\n\n        if (mdatSize > 0) {\n          /* concatenate the audio data and construct the mdat in place\n            (need 8 more bytes to fill length and mdat type) */\n          mdatSize += offset;\n\n          try {\n            mdat = new Uint8Array(mdatSize);\n          } catch (err) {\n            this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].ERROR, _events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].ERROR, {\n              type: _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorTypes\"].MUX_ERROR,\n              details: _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorDetails\"].REMUX_ALLOC_ERROR,\n              fatal: false,\n              bytes: mdatSize,\n              reason: \"fail allocating audio mdat \" + mdatSize\n            });\n            return;\n          }\n\n          if (!rawMPEG) {\n            var view = new DataView(mdat.buffer);\n            view.setUint32(0, mdatSize);\n            mdat.set(_mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].types.mdat, 4);\n          }\n        } else {\n          // no audio samples\n          return;\n        }\n      }\n\n      mdat.set(unit, offset);\n      var unitLen = unit.byteLength;\n      offset += unitLen; // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\n      // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\n      // becomes the PTS diff with the previous sample\n\n      outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));\n      lastPTS = _pts;\n    } // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\n\n\n    var nbSamples = outputSamples.length;\n\n    if (!nbSamples) {\n      return;\n    } // The next audio sample PTS should be equal to last sample PTS + duration\n\n\n    var lastSample = outputSamples[outputSamples.length - 1];\n    this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration; // Set the track samples from inputSamples to outputSamples before remuxing\n\n    var moof = rawMPEG ? new Uint8Array(0) : _mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {\n      samples: outputSamples\n    })); // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\n\n    track.samples = [];\n    var start = firstPTS / inputTimeScale;\n    var end = nextAudioPts / inputTimeScale;\n    var type = 'audio';\n    var audioData = {\n      data1: moof,\n      data2: mdat,\n      startPTS: start,\n      endPTS: end,\n      startDTS: start,\n      endDTS: end,\n      type: type,\n      hasAudio: true,\n      hasVideo: false,\n      nb: nbSamples\n    };\n    this.isAudioContiguous = true;\n    console.assert(mdat.length, 'MDAT length must not be zero');\n    return audioData;\n  };\n\n  _proto.remuxEmptyAudio = function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {\n    var inputTimeScale = track.inputTimeScale;\n    var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n    var scaleFactor = inputTimeScale / mp4timeScale;\n    var nextAudioPts = this.nextAudioPts; // sync with video's timestamp\n\n    var startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS;\n    var endDTS = videoData.endDTS * inputTimeScale + this._initDTS; // one sample's duration value\n\n    var frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME; // samples count of this segment's duration\n\n    var nbSamples = Math.ceil((endDTS - startDTS) / frameDuration); // silent frame\n\n    var silentFrame = _aac_helper__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n    _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn('[mp4-remuxer]: remux empty Audio'); // Can't remux if we can't generate a silent frame...\n\n    if (!silentFrame) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].trace('[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec');\n      return;\n    }\n\n    var samples = [];\n\n    for (var i = 0; i < nbSamples; i++) {\n      var stamp = startDTS + i * frameDuration;\n      samples.push({\n        unit: silentFrame,\n        pts: stamp,\n        dts: stamp\n      });\n    }\n\n    track.samples = samples;\n    return this.remuxAudio(track, timeOffset, contiguous, false);\n  };\n\n  return MP4Remuxer;\n}();\n\n\nfunction normalizePts(value, reference) {\n  var offset;\n\n  if (reference === null) {\n    return value;\n  }\n\n  if (reference < value) {\n    // - 2^33\n    offset = -8589934592;\n  } else {\n    // + 2^33\n    offset = 8589934592;\n  }\n  /* PTS is 33bit (from 0 to 2^33 -1)\n    if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n    PTS looping occured. fill the gap */\n\n\n  while (Math.abs(value - reference) > 4294967296) {\n    value += offset;\n  }\n\n  return value;\n}\n\nfunction findKeyframeIndex(samples) {\n  for (var i = 0; i < samples.length; i++) {\n    if (samples[i].key) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {\n  var length = track.samples.length;\n\n  if (!length) {\n    return;\n  }\n\n  var inputTimeScale = track.inputTimeScale;\n\n  for (var index = 0; index < length; index++) {\n    var sample = track.samples[index]; // setting id3 pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n\n    sample.pts = normalizePts(sample.pts - initPTS, timeOffset * inputTimeScale) / inputTimeScale;\n    sample.dts = normalizePts(sample.dts - initDTS, timeOffset * inputTimeScale) / inputTimeScale;\n  }\n\n  var samples = track.samples;\n  track.samples = [];\n  return {\n    samples: samples\n  };\n}\nfunction flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {\n  var length = track.samples.length;\n\n  if (!length) {\n    return;\n  }\n\n  var inputTimeScale = track.inputTimeScale;\n\n  for (var index = 0; index < length; index++) {\n    var sample = track.samples[index]; // setting text pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n\n    sample.pts = normalizePts(sample.pts - initPTS, timeOffset * inputTimeScale) / inputTimeScale;\n  }\n\n  track.samples.sort(function (a, b) {\n    return a.pts - b.pts;\n  });\n  var samples = track.samples;\n  track.samples = [];\n  return {\n    samples: samples\n  };\n}\n\nvar Mp4Sample = function Mp4Sample(isKeyframe, duration, size, cts) {\n  this.size = void 0;\n  this.duration = void 0;\n  this.cts = void 0;\n  this.flags = void 0;\n  this.duration = duration;\n  this.size = size;\n  this.cts = cts;\n  this.flags = new Mp4SampleFlags(isKeyframe);\n};\n\nvar Mp4SampleFlags = function Mp4SampleFlags(isKeyframe) {\n  this.isLeading = 0;\n  this.isDependedOn = 0;\n  this.hasRedundancy = 0;\n  this.degradPrio = 0;\n  this.dependsOn = 1;\n  this.isNonSync = 1;\n  this.dependsOn = isKeyframe ? 2 : 1;\n  this.isNonSync = isKeyframe ? 0 : 1;\n};\n\n/***/ }),\n\n/***/ \"./src/remux/passthrough-remuxer.ts\":\n/*!******************************************!*\\\n  !*** ./src/remux/passthrough-remuxer.ts ***!\n  \\******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_838266__) {\n\n\"use strict\";\n__nested_webpack_require_838266__.r(__webpack_exports__);\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_838266__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _mp4_remuxer__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_838266__(/*! ./mp4-remuxer */ \"./src/remux/mp4-remuxer.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_838266__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_838266__(/*! ../loader/fragment */ \"./src/loader/fragment.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_838266__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\n\n\n\n\nvar PassThroughRemuxer = /*#__PURE__*/function () {\n  function PassThroughRemuxer() {\n    this.emitInitSegment = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this.initData = void 0;\n    this.initPTS = void 0;\n    this.initTracks = void 0;\n    this.lastEndDTS = null;\n  }\n\n  var _proto = PassThroughRemuxer.prototype;\n\n  _proto.destroy = function destroy() {};\n\n  _proto.resetTimeStamp = function resetTimeStamp(defaultInitPTS) {\n    this.initPTS = defaultInitPTS;\n    this.lastEndDTS = null;\n  };\n\n  _proto.resetNextTimestamp = function resetNextTimestamp() {\n    this.lastEndDTS = null;\n  };\n\n  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec) {\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.generateInitSegment(initSegment);\n    this.emitInitSegment = true;\n  };\n\n  _proto.generateInitSegment = function generateInitSegment(initSegment) {\n    var audioCodec = this.audioCodec,\n        videoCodec = this.videoCodec;\n\n    if (!initSegment || !initSegment.byteLength) {\n      this.initTracks = undefined;\n      this.initData = undefined;\n      return;\n    }\n\n    var initData = this.initData = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__[\"parseInitSegment\"])(initSegment); // Get codec from initSegment or fallback to default\n\n    if (!audioCodec) {\n      audioCodec = getParsedTrackCodec(initData.audio, _loader_fragment__WEBPACK_IMPORTED_MODULE_3__[\"ElementaryStreamTypes\"].AUDIO);\n    }\n\n    if (!videoCodec) {\n      videoCodec = getParsedTrackCodec(initData.video, _loader_fragment__WEBPACK_IMPORTED_MODULE_3__[\"ElementaryStreamTypes\"].VIDEO);\n    }\n\n    var tracks = {};\n\n    if (initData.audio && initData.video) {\n      tracks.audiovideo = {\n        container: 'video/mp4',\n        codec: audioCodec + ',' + videoCodec,\n        initSegment: initSegment,\n        id: 'main'\n      };\n    } else if (initData.audio) {\n      tracks.audio = {\n        container: 'audio/mp4',\n        codec: audioCodec,\n        initSegment: initSegment,\n        id: 'audio'\n      };\n    } else if (initData.video) {\n      tracks.video = {\n        container: 'video/mp4',\n        codec: videoCodec,\n        initSegment: initSegment,\n        id: 'main'\n      };\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_4__[\"logger\"].warn('[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.');\n    }\n\n    this.initTracks = tracks;\n  };\n\n  _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset) {\n    var _this$initPTS;\n\n    var initPTS = this.initPTS,\n        lastEndDTS = this.lastEndDTS;\n    var result = {\n      audio: undefined,\n      video: undefined,\n      text: textTrack,\n      id3: id3Track,\n      initSegment: undefined\n    }; // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the\n    // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update\n    // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.\n\n    if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(lastEndDTS)) {\n      lastEndDTS = this.lastEndDTS = timeOffset || 0;\n    } // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only\n    // audio or video (or both); adding it to video was an arbitrary choice.\n\n\n    var data = videoTrack.samples;\n\n    if (!data || !data.length) {\n      return result;\n    }\n\n    var initSegment = {\n      initPTS: undefined,\n      timescale: 1\n    };\n    var initData = this.initData;\n\n    if (!initData || !initData.length) {\n      this.generateInitSegment(data);\n      initData = this.initData;\n    }\n\n    if (!initData || !initData.length) {\n      // We can't remux if the initSegment could not be generated\n      _utils_logger__WEBPACK_IMPORTED_MODULE_4__[\"logger\"].warn('[passthrough-remuxer.ts]: Failed to generate initSegment.');\n      return result;\n    }\n\n    if (this.emitInitSegment) {\n      initSegment.tracks = this.initTracks;\n      this.emitInitSegment = false;\n    }\n\n    if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(initPTS)) {\n      this.initPTS = initSegment.initPTS = initPTS = computeInitPTS(initData, data, lastEndDTS);\n    }\n\n    var duration = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__[\"getDuration\"])(data, initData);\n    var startDTS = lastEndDTS;\n    var endDTS = duration + startDTS;\n    Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__[\"offsetStartDTS\"])(initData, data, initPTS);\n\n    if (duration > 0) {\n      this.lastEndDTS = endDTS;\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_4__[\"logger\"].warn('Duration parsed from mp4 should be greater than zero');\n      this.resetNextTimestamp();\n    }\n\n    var hasAudio = !!initData.audio;\n    var hasVideo = !!initData.video;\n    var type = '';\n\n    if (hasAudio) {\n      type += 'audio';\n    }\n\n    if (hasVideo) {\n      type += 'video';\n    }\n\n    var track = {\n      data1: data,\n      startPTS: startDTS,\n      startDTS: startDTS,\n      endPTS: endDTS,\n      endDTS: endDTS,\n      type: type,\n      hasAudio: hasAudio,\n      hasVideo: hasVideo,\n      nb: 1,\n      dropped: 0\n    };\n    result.audio = track.type === 'audio' ? track : undefined;\n    result.video = track.type !== 'audio' ? track : undefined;\n    result.initSegment = initSegment;\n    var initPtsNum = (_this$initPTS = this.initPTS) != null ? _this$initPTS : 0;\n    result.id3 = Object(_mp4_remuxer__WEBPACK_IMPORTED_MODULE_1__[\"flushTextTrackMetadataCueSamples\"])(id3Track, timeOffset, initPtsNum, initPtsNum);\n\n    if (textTrack.samples.length) {\n      result.text = Object(_mp4_remuxer__WEBPACK_IMPORTED_MODULE_1__[\"flushTextTrackUserdataCueSamples\"])(textTrack, timeOffset, initPtsNum);\n    }\n\n    return result;\n  };\n\n  return PassThroughRemuxer;\n}();\n\nvar computeInitPTS = function computeInitPTS(initData, data, timeOffset) {\n  return Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__[\"getStartDTS\"])(initData, data) - timeOffset;\n};\n\nfunction getParsedTrackCodec(track, type) {\n  var parsedCodec = track === null || track === void 0 ? void 0 : track.codec;\n\n  if (parsedCodec && parsedCodec.length > 4) {\n    return parsedCodec;\n  } // Since mp4-tools cannot parse full codec string (see 'TODO: Parse codec details'... in mp4-tools)\n  // Provide defaults based on codec type\n  // This allows for some playback of some fmp4 playlists without CODECS defined in manifest\n\n\n  if (parsedCodec === 'hvc1' || parsedCodec === 'hev1') {\n    return 'hvc1.1.c.L120.90';\n  }\n\n  if (parsedCodec === 'av01') {\n    return 'av01.0.04M.08';\n  }\n\n  if (parsedCodec === 'avc1' || type === _loader_fragment__WEBPACK_IMPORTED_MODULE_3__[\"ElementaryStreamTypes\"].VIDEO) {\n    return 'avc1.42e01e';\n  }\n\n  return 'mp4a.40.5';\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (PassThroughRemuxer);\n\n/***/ }),\n\n/***/ \"./src/task-loop.ts\":\n/*!**************************!*\\\n  !*** ./src/task-loop.ts ***!\n  \\**************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_846399__) {\n\n\"use strict\";\n__nested_webpack_require_846399__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_846399__.d(__webpack_exports__, \"default\", function() { return TaskLoop; });\n/**\n * Sub-class specialization of EventHandler base class.\n *\n * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,\n * scheduled asynchroneously, avoiding recursive calls in the same tick.\n *\n * The task itself is implemented in `doTick`. It can be requested and called for single execution\n * using the `tick` method.\n *\n * It will be assured that the task execution method (`tick`) only gets called once per main loop \"tick\",\n * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.\n *\n * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,\n * and cancelled with `clearNextTick`.\n *\n * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).\n *\n * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.\n *\n * Further explanations:\n *\n * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously\n * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.\n *\n * When the task execution (`tick` method) is called in re-entrant way this is detected and\n * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further\n * task processing on the next main loop iteration (also known as \"next tick\" in the Node/JS runtime lingo).\n */\nvar TaskLoop = /*#__PURE__*/function () {\n  function TaskLoop() {\n    this._boundTick = void 0;\n    this._tickTimer = null;\n    this._tickInterval = null;\n    this._tickCallCount = 0;\n    this._boundTick = this.tick.bind(this);\n  }\n\n  var _proto = TaskLoop.prototype;\n\n  _proto.destroy = function destroy() {\n    this.onHandlerDestroying();\n    this.onHandlerDestroyed();\n  };\n\n  _proto.onHandlerDestroying = function onHandlerDestroying() {\n    // clear all timers before unregistering from event bus\n    this.clearNextTick();\n    this.clearInterval();\n  };\n\n  _proto.onHandlerDestroyed = function onHandlerDestroyed() {}\n  /**\n   * @returns {boolean}\n   */\n  ;\n\n  _proto.hasInterval = function hasInterval() {\n    return !!this._tickInterval;\n  }\n  /**\n   * @returns {boolean}\n   */\n  ;\n\n  _proto.hasNextTick = function hasNextTick() {\n    return !!this._tickTimer;\n  }\n  /**\n   * @param {number} millis Interval time (ms)\n   * @returns {boolean} True when interval has been scheduled, false when already scheduled (no effect)\n   */\n  ;\n\n  _proto.setInterval = function setInterval(millis) {\n    if (!this._tickInterval) {\n      this._tickInterval = self.setInterval(this._boundTick, millis);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @returns {boolean} True when interval was cleared, false when none was set (no effect)\n   */\n  ;\n\n  _proto.clearInterval = function clearInterval() {\n    if (this._tickInterval) {\n      self.clearInterval(this._tickInterval);\n      this._tickInterval = null;\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @returns {boolean} True when timeout was cleared, false when none was set (no effect)\n   */\n  ;\n\n  _proto.clearNextTick = function clearNextTick() {\n    if (this._tickTimer) {\n      self.clearTimeout(this._tickTimer);\n      this._tickTimer = null;\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Will call the subclass doTick implementation in this main loop tick\n   * or in the next one (via setTimeout(,0)) in case it has already been called\n   * in this tick (in case this is a re-entrant call).\n   */\n  ;\n\n  _proto.tick = function tick() {\n    this._tickCallCount++;\n\n    if (this._tickCallCount === 1) {\n      this.doTick(); // re-entrant call to tick from previous doTick call stack\n      // -> schedule a call on the next main loop iteration to process this task processing request\n\n      if (this._tickCallCount > 1) {\n        // make sure only one timer exists at any time at max\n        this.tickImmediate();\n      }\n\n      this._tickCallCount = 0;\n    }\n  };\n\n  _proto.tickImmediate = function tickImmediate() {\n    this.clearNextTick();\n    this._tickTimer = self.setTimeout(this._boundTick, 0);\n  }\n  /**\n   * For subclass to implement task logic\n   * @abstract\n   */\n  ;\n\n  _proto.doTick = function doTick() {};\n\n  return TaskLoop;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/types/cmcd.ts\":\n/*!***************************!*\\\n  !*** ./src/types/cmcd.ts ***!\n  \\***************************/\n/*! exports provided: CMCDVersion, CMCDObjectType, CMCDStreamingFormat, CMCDStreamType */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_851256__) {\n\n\"use strict\";\n__nested_webpack_require_851256__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_851256__.d(__webpack_exports__, \"CMCDVersion\", function() { return CMCDVersion; });\n/* harmony export (binding) */ __nested_webpack_require_851256__.d(__webpack_exports__, \"CMCDObjectType\", function() { return CMCDObjectType; });\n/* harmony export (binding) */ __nested_webpack_require_851256__.d(__webpack_exports__, \"CMCDStreamingFormat\", function() { return CMCDStreamingFormat; });\n/* harmony export (binding) */ __nested_webpack_require_851256__.d(__webpack_exports__, \"CMCDStreamType\", function() { return CMCDStreamType; });\n/**\n * CMCD spec version\n */\nvar CMCDVersion = 1;\n/**\n * CMCD Object Type\n */\n\nvar CMCDObjectType;\n/**\n * CMCD Streaming Format\n */\n\n(function (CMCDObjectType) {\n  CMCDObjectType[\"MANIFEST\"] = \"m\";\n  CMCDObjectType[\"AUDIO\"] = \"a\";\n  CMCDObjectType[\"VIDEO\"] = \"v\";\n  CMCDObjectType[\"MUXED\"] = \"av\";\n  CMCDObjectType[\"INIT\"] = \"i\";\n  CMCDObjectType[\"CAPTION\"] = \"c\";\n  CMCDObjectType[\"TIMED_TEXT\"] = \"tt\";\n  CMCDObjectType[\"KEY\"] = \"k\";\n  CMCDObjectType[\"OTHER\"] = \"o\";\n})(CMCDObjectType || (CMCDObjectType = {}));\n\nvar CMCDStreamingFormat;\n/**\n * CMCD Streaming Type\n */\n\n(function (CMCDStreamingFormat) {\n  CMCDStreamingFormat[\"DASH\"] = \"d\";\n  CMCDStreamingFormat[\"HLS\"] = \"h\";\n  CMCDStreamingFormat[\"SMOOTH\"] = \"s\";\n  CMCDStreamingFormat[\"OTHER\"] = \"o\";\n})(CMCDStreamingFormat || (CMCDStreamingFormat = {}));\n\nvar CMCDStreamType;\n/**\n * CMCD Headers\n */\n\n(function (CMCDStreamType) {\n  CMCDStreamType[\"VOD\"] = \"v\";\n  CMCDStreamType[\"LIVE\"] = \"l\";\n})(CMCDStreamType || (CMCDStreamType = {}));\n\n/***/ }),\n\n/***/ \"./src/types/demuxer.ts\":\n/*!******************************!*\\\n  !*** ./src/types/demuxer.ts ***!\n  \\******************************/\n/*! exports provided: MetadataSchema */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_853099__) {\n\n\"use strict\";\n__nested_webpack_require_853099__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_853099__.d(__webpack_exports__, \"MetadataSchema\", function() { return MetadataSchema; });\nvar MetadataSchema;\n\n(function (MetadataSchema) {\n  MetadataSchema[\"audioId3\"] = \"org.id3\";\n  MetadataSchema[\"dateRange\"] = \"com.apple.quicktime.HLS\";\n  MetadataSchema[\"emsg\"] = \"https://aomedia.org/emsg/ID3\";\n})(MetadataSchema || (MetadataSchema = {}));\n\n/***/ }),\n\n/***/ \"./src/types/level.ts\":\n/*!****************************!*\\\n  !*** ./src/types/level.ts ***!\n  \\****************************/\n/*! exports provided: HlsSkip, getSkipValue, HlsUrlParameters, Level */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_853828__) {\n\n\"use strict\";\n__nested_webpack_require_853828__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_853828__.d(__webpack_exports__, \"HlsSkip\", function() { return HlsSkip; });\n/* harmony export (binding) */ __nested_webpack_require_853828__.d(__webpack_exports__, \"getSkipValue\", function() { return getSkipValue; });\n/* harmony export (binding) */ __nested_webpack_require_853828__.d(__webpack_exports__, \"HlsUrlParameters\", function() { return HlsUrlParameters; });\n/* harmony export (binding) */ __nested_webpack_require_853828__.d(__webpack_exports__, \"Level\", function() { return Level; });\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar HlsSkip;\n\n(function (HlsSkip) {\n  HlsSkip[\"No\"] = \"\";\n  HlsSkip[\"Yes\"] = \"YES\";\n  HlsSkip[\"v2\"] = \"v2\";\n})(HlsSkip || (HlsSkip = {}));\n\nfunction getSkipValue(details, msn) {\n  var canSkipUntil = details.canSkipUntil,\n      canSkipDateRanges = details.canSkipDateRanges,\n      endSN = details.endSN;\n  var snChangeGoal = msn !== undefined ? msn - endSN : 0;\n\n  if (canSkipUntil && snChangeGoal < canSkipUntil) {\n    if (canSkipDateRanges) {\n      return HlsSkip.v2;\n    }\n\n    return HlsSkip.Yes;\n  }\n\n  return HlsSkip.No;\n}\nvar HlsUrlParameters = /*#__PURE__*/function () {\n  function HlsUrlParameters(msn, part, skip) {\n    this.msn = void 0;\n    this.part = void 0;\n    this.skip = void 0;\n    this.msn = msn;\n    this.part = part;\n    this.skip = skip;\n  }\n\n  var _proto = HlsUrlParameters.prototype;\n\n  _proto.addDirectives = function addDirectives(uri) {\n    var url = new self.URL(uri);\n\n    if (this.msn !== undefined) {\n      url.searchParams.set('_HLS_msn', this.msn.toString());\n    }\n\n    if (this.part !== undefined) {\n      url.searchParams.set('_HLS_part', this.part.toString());\n    }\n\n    if (this.skip) {\n      url.searchParams.set('_HLS_skip', this.skip);\n    }\n\n    return url.toString();\n  };\n\n  return HlsUrlParameters;\n}();\nvar Level = /*#__PURE__*/function () {\n  function Level(data) {\n    this.attrs = void 0;\n    this.audioCodec = void 0;\n    this.bitrate = void 0;\n    this.codecSet = void 0;\n    this.height = void 0;\n    this.id = void 0;\n    this.name = void 0;\n    this.videoCodec = void 0;\n    this.width = void 0;\n    this.unknownCodecs = void 0;\n    this.audioGroupIds = void 0;\n    this.details = void 0;\n    this.fragmentError = 0;\n    this.loadError = 0;\n    this.loaded = void 0;\n    this.realBitrate = 0;\n    this.textGroupIds = void 0;\n    this.url = void 0;\n    this._urlId = 0;\n    this.url = [data.url];\n    this.attrs = data.attrs;\n    this.bitrate = data.bitrate;\n\n    if (data.details) {\n      this.details = data.details;\n    }\n\n    this.id = data.id || 0;\n    this.name = data.name;\n    this.width = data.width || 0;\n    this.height = data.height || 0;\n    this.audioCodec = data.audioCodec;\n    this.videoCodec = data.videoCodec;\n    this.unknownCodecs = data.unknownCodecs;\n    this.codecSet = [data.videoCodec, data.audioCodec].filter(function (c) {\n      return c;\n    }).join(',').replace(/\\.[^.,]+/g, '');\n  }\n\n  _createClass(Level, [{\n    key: \"maxBitrate\",\n    get: function get() {\n      return Math.max(this.realBitrate, this.bitrate);\n    }\n  }, {\n    key: \"uri\",\n    get: function get() {\n      return this.url[this._urlId] || '';\n    }\n  }, {\n    key: \"urlId\",\n    get: function get() {\n      return this._urlId;\n    },\n    set: function set(value) {\n      var newValue = value % this.url.length;\n\n      if (this._urlId !== newValue) {\n        this.details = undefined;\n        this._urlId = newValue;\n      }\n    }\n  }]);\n\n  return Level;\n}();\n\n/***/ }),\n\n/***/ \"./src/types/loader.ts\":\n/*!*****************************!*\\\n  !*** ./src/types/loader.ts ***!\n  \\*****************************/\n/*! exports provided: PlaylistContextType, PlaylistLevelType */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_858178__) {\n\n\"use strict\";\n__nested_webpack_require_858178__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_858178__.d(__webpack_exports__, \"PlaylistContextType\", function() { return PlaylistContextType; });\n/* harmony export (binding) */ __nested_webpack_require_858178__.d(__webpack_exports__, \"PlaylistLevelType\", function() { return PlaylistLevelType; });\nvar PlaylistContextType;\n\n(function (PlaylistContextType) {\n  PlaylistContextType[\"MANIFEST\"] = \"manifest\";\n  PlaylistContextType[\"LEVEL\"] = \"level\";\n  PlaylistContextType[\"AUDIO_TRACK\"] = \"audioTrack\";\n  PlaylistContextType[\"SUBTITLE_TRACK\"] = \"subtitleTrack\";\n})(PlaylistContextType || (PlaylistContextType = {}));\n\nvar PlaylistLevelType;\n\n(function (PlaylistLevelType) {\n  PlaylistLevelType[\"MAIN\"] = \"main\";\n  PlaylistLevelType[\"AUDIO\"] = \"audio\";\n  PlaylistLevelType[\"SUBTITLE\"] = \"subtitle\";\n})(PlaylistLevelType || (PlaylistLevelType = {}));\n\n/***/ }),\n\n/***/ \"./src/types/transmuxer.ts\":\n/*!*********************************!*\\\n  !*** ./src/types/transmuxer.ts ***!\n  \\*********************************/\n/*! exports provided: ChunkMetadata */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_859336__) {\n\n\"use strict\";\n__nested_webpack_require_859336__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_859336__.d(__webpack_exports__, \"ChunkMetadata\", function() { return ChunkMetadata; });\nvar ChunkMetadata = function ChunkMetadata(level, sn, id, size, part, partial) {\n  if (size === void 0) {\n    size = 0;\n  }\n\n  if (part === void 0) {\n    part = -1;\n  }\n\n  if (partial === void 0) {\n    partial = false;\n  }\n\n  this.level = void 0;\n  this.sn = void 0;\n  this.part = void 0;\n  this.id = void 0;\n  this.size = void 0;\n  this.partial = void 0;\n  this.transmuxing = getNewPerformanceTiming();\n  this.buffering = {\n    audio: getNewPerformanceTiming(),\n    video: getNewPerformanceTiming(),\n    audiovideo: getNewPerformanceTiming()\n  };\n  this.level = level;\n  this.sn = sn;\n  this.id = id;\n  this.size = size;\n  this.part = part;\n  this.partial = partial;\n};\n\nfunction getNewPerformanceTiming() {\n  return {\n    start: 0,\n    executeStart: 0,\n    executeEnd: 0,\n    end: 0\n  };\n}\n\n/***/ }),\n\n/***/ \"./src/utils/attr-list.ts\":\n/*!********************************!*\\\n  !*** ./src/utils/attr-list.ts ***!\n  \\********************************/\n/*! exports provided: AttrList */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_860578__) {\n\n\"use strict\";\n__nested_webpack_require_860578__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_860578__.d(__webpack_exports__, \"AttrList\", function() { return AttrList; });\nvar DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/; // eslint-disable-line no-useless-escape\n\nvar ATTR_LIST_REGEX = /\\s*(.+?)\\s*=((?:\\\".*?\\\")|.*?)(?:,|$)/g; // eslint-disable-line no-useless-escape\n// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\n\nvar AttrList = /*#__PURE__*/function () {\n  function AttrList(attrs) {\n    if (typeof attrs === 'string') {\n      attrs = AttrList.parseAttrList(attrs);\n    }\n\n    for (var attr in attrs) {\n      if (attrs.hasOwnProperty(attr)) {\n        this[attr] = attrs[attr];\n      }\n    }\n  }\n\n  var _proto = AttrList.prototype;\n\n  _proto.decimalInteger = function decimalInteger(attrName) {\n    var intValue = parseInt(this[attrName], 10);\n\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n\n    return intValue;\n  };\n\n  _proto.hexadecimalInteger = function hexadecimalInteger(attrName) {\n    if (this[attrName]) {\n      var stringValue = (this[attrName] || '0x').slice(2);\n      stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;\n      var value = new Uint8Array(stringValue.length / 2);\n\n      for (var i = 0; i < stringValue.length / 2; i++) {\n        value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n      }\n\n      return value;\n    } else {\n      return null;\n    }\n  };\n\n  _proto.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {\n    var intValue = parseInt(this[attrName], 16);\n\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n\n    return intValue;\n  };\n\n  _proto.decimalFloatingPoint = function decimalFloatingPoint(attrName) {\n    return parseFloat(this[attrName]);\n  };\n\n  _proto.optionalFloat = function optionalFloat(attrName, defaultValue) {\n    var value = this[attrName];\n    return value ? parseFloat(value) : defaultValue;\n  };\n\n  _proto.enumeratedString = function enumeratedString(attrName) {\n    return this[attrName];\n  };\n\n  _proto.bool = function bool(attrName) {\n    return this[attrName] === 'YES';\n  };\n\n  _proto.decimalResolution = function decimalResolution(attrName) {\n    var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n\n    if (res === null) {\n      return undefined;\n    }\n\n    return {\n      width: parseInt(res[1], 10),\n      height: parseInt(res[2], 10)\n    };\n  };\n\n  AttrList.parseAttrList = function parseAttrList(input) {\n    var match;\n    var attrs = {};\n    var quote = '\"';\n    ATTR_LIST_REGEX.lastIndex = 0;\n\n    while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {\n      var value = match[2];\n\n      if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {\n        value = value.slice(1, -1);\n      }\n\n      attrs[match[1]] = value;\n    }\n\n    return attrs;\n  };\n\n  return AttrList;\n}();\n\n/***/ }),\n\n/***/ \"./src/utils/binary-search.ts\":\n/*!************************************!*\\\n  !*** ./src/utils/binary-search.ts ***!\n  \\************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_863779__) {\n\n\"use strict\";\n__nested_webpack_require_863779__.r(__webpack_exports__);\nvar BinarySearch = {\n  /**\n   * Searches for an item in an array which matches a certain condition.\n   * This requires the condition to only match one item in the array,\n   * and for the array to be ordered.\n   *\n   * @param {Array<T>} list The array to search.\n   * @param {BinarySearchComparison<T>} comparisonFn\n   *      Called and provided a candidate item as the first argument.\n   *      Should return:\n   *          > -1 if the item should be located at a lower index than the provided item.\n   *          > 1 if the item should be located at a higher index than the provided item.\n   *          > 0 if the item is the item you're looking for.\n   *\n   * @return {T | null} The object if it is found or null otherwise.\n   */\n  search: function search(list, comparisonFn) {\n    var minIndex = 0;\n    var maxIndex = list.length - 1;\n    var currentIndex = null;\n    var currentElement = null;\n\n    while (minIndex <= maxIndex) {\n      currentIndex = (minIndex + maxIndex) / 2 | 0;\n      currentElement = list[currentIndex];\n      var comparisonResult = comparisonFn(currentElement);\n\n      if (comparisonResult > 0) {\n        minIndex = currentIndex + 1;\n      } else if (comparisonResult < 0) {\n        maxIndex = currentIndex - 1;\n      } else {\n        return currentElement;\n      }\n    }\n\n    return null;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (BinarySearch);\n\n/***/ }),\n\n/***/ \"./src/utils/buffer-helper.ts\":\n/*!************************************!*\\\n  !*** ./src/utils/buffer-helper.ts ***!\n  \\************************************/\n/*! exports provided: BufferHelper */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_865520__) {\n\n\"use strict\";\n__nested_webpack_require_865520__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_865520__.d(__webpack_exports__, \"BufferHelper\", function() { return BufferHelper; });\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_865520__(/*! ./logger */ \"./src/utils/logger.ts\");\n/**\n * @module BufferHelper\n *\n * Providing methods dealing with buffer length retrieval for example.\n *\n * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.\n *\n * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered\n */\n\nvar noopBuffered = {\n  length: 0,\n  start: function start() {\n    return 0;\n  },\n  end: function end() {\n    return 0;\n  }\n};\nvar BufferHelper = /*#__PURE__*/function () {\n  function BufferHelper() {}\n\n  /**\n   * Return true if `media`'s buffered include `position`\n   * @param {Bufferable} media\n   * @param {number} position\n   * @returns {boolean}\n   */\n  BufferHelper.isBuffered = function isBuffered(media, position) {\n    try {\n      if (media) {\n        var buffered = BufferHelper.getBuffered(media);\n\n        for (var i = 0; i < buffered.length; i++) {\n          if (position >= buffered.start(i) && position <= buffered.end(i)) {\n            return true;\n          }\n        }\n      }\n    } catch (error) {// this is to catch\n      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n      // This SourceBuffer has been removed from the parent media source\n    }\n\n    return false;\n  };\n\n  BufferHelper.bufferInfo = function bufferInfo(media, pos, maxHoleDuration) {\n    try {\n      if (media) {\n        var vbuffered = BufferHelper.getBuffered(media);\n        var buffered = [];\n        var i;\n\n        for (i = 0; i < vbuffered.length; i++) {\n          buffered.push({\n            start: vbuffered.start(i),\n            end: vbuffered.end(i)\n          });\n        }\n\n        return this.bufferedInfo(buffered, pos, maxHoleDuration);\n      }\n    } catch (error) {// this is to catch\n      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n      // This SourceBuffer has been removed from the parent media source\n    }\n\n    return {\n      len: 0,\n      start: pos,\n      end: pos,\n      nextStart: undefined\n    };\n  };\n\n  BufferHelper.bufferedInfo = function bufferedInfo(buffered, pos, maxHoleDuration) {\n    pos = Math.max(0, pos); // sort on buffer.start/smaller end (IE does not always return sorted buffered range)\n\n    buffered.sort(function (a, b) {\n      var diff = a.start - b.start;\n\n      if (diff) {\n        return diff;\n      } else {\n        return b.end - a.end;\n      }\n    });\n    var buffered2 = [];\n\n    if (maxHoleDuration) {\n      // there might be some small holes between buffer time range\n      // consider that holes smaller than maxHoleDuration are irrelevant and build another\n      // buffer time range representations that discards those holes\n      for (var i = 0; i < buffered.length; i++) {\n        var buf2len = buffered2.length;\n\n        if (buf2len) {\n          var buf2end = buffered2[buf2len - 1].end; // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)\n\n          if (buffered[i].start - buf2end < maxHoleDuration) {\n            // merge overlapping time ranges\n            // update lastRange.end only if smaller than item.end\n            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)\n            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])\n            if (buffered[i].end > buf2end) {\n              buffered2[buf2len - 1].end = buffered[i].end;\n            }\n          } else {\n            // big hole\n            buffered2.push(buffered[i]);\n          }\n        } else {\n          // first value\n          buffered2.push(buffered[i]);\n        }\n      }\n    } else {\n      buffered2 = buffered;\n    }\n\n    var bufferLen = 0; // bufferStartNext can possibly be undefined based on the conditional logic below\n\n    var bufferStartNext; // bufferStart and bufferEnd are buffer boundaries around current video position\n\n    var bufferStart = pos;\n    var bufferEnd = pos;\n\n    for (var _i = 0; _i < buffered2.length; _i++) {\n      var start = buffered2[_i].start;\n      var end = buffered2[_i].end; // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));\n\n      if (pos + maxHoleDuration >= start && pos < end) {\n        // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length\n        bufferStart = start;\n        bufferEnd = end;\n        bufferLen = bufferEnd - pos;\n      } else if (pos + maxHoleDuration < start) {\n        bufferStartNext = start;\n        break;\n      }\n    }\n\n    return {\n      len: bufferLen,\n      start: bufferStart || 0,\n      end: bufferEnd || 0,\n      nextStart: bufferStartNext\n    };\n  }\n  /**\n   * Safe method to get buffered property.\n   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource\n   */\n  ;\n\n  BufferHelper.getBuffered = function getBuffered(media) {\n    try {\n      return media.buffered;\n    } catch (e) {\n      _logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].log('failed to get media.buffered', e);\n      return noopBuffered;\n    }\n  };\n\n  return BufferHelper;\n}();\n\n/***/ }),\n\n/***/ \"./src/utils/cea-608-parser.ts\":\n/*!*************************************!*\\\n  !*** ./src/utils/cea-608-parser.ts ***!\n  \\*************************************/\n/*! exports provided: Row, CaptionScreen, default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_871150__) {\n\n\"use strict\";\n__nested_webpack_require_871150__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_871150__.d(__webpack_exports__, \"Row\", function() { return Row; });\n/* harmony export (binding) */ __nested_webpack_require_871150__.d(__webpack_exports__, \"CaptionScreen\", function() { return CaptionScreen; });\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_871150__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n/**\n *\n * This code was ported from the dash.js project at:\n *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js\n *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2\n *\n * The original copyright appears below:\n *\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2015-2016, DASH Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  1. Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  2. Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n */\n\nvar specialCea608CharsCodes = {\n  0x2a: 0xe1,\n  // lowercase a, acute accent\n  0x5c: 0xe9,\n  // lowercase e, acute accent\n  0x5e: 0xed,\n  // lowercase i, acute accent\n  0x5f: 0xf3,\n  // lowercase o, acute accent\n  0x60: 0xfa,\n  // lowercase u, acute accent\n  0x7b: 0xe7,\n  // lowercase c with cedilla\n  0x7c: 0xf7,\n  // division symbol\n  0x7d: 0xd1,\n  // uppercase N tilde\n  0x7e: 0xf1,\n  // lowercase n tilde\n  0x7f: 0x2588,\n  // Full block\n  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n  // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n  0x80: 0xae,\n  // Registered symbol (R)\n  0x81: 0xb0,\n  // degree sign\n  0x82: 0xbd,\n  // 1/2 symbol\n  0x83: 0xbf,\n  // Inverted (open) question mark\n  0x84: 0x2122,\n  // Trademark symbol (TM)\n  0x85: 0xa2,\n  // Cents symbol\n  0x86: 0xa3,\n  // Pounds sterling\n  0x87: 0x266a,\n  // Music 8'th note\n  0x88: 0xe0,\n  // lowercase a, grave accent\n  0x89: 0x20,\n  // transparent space (regular)\n  0x8a: 0xe8,\n  // lowercase e, grave accent\n  0x8b: 0xe2,\n  // lowercase a, circumflex accent\n  0x8c: 0xea,\n  // lowercase e, circumflex accent\n  0x8d: 0xee,\n  // lowercase i, circumflex accent\n  0x8e: 0xf4,\n  // lowercase o, circumflex accent\n  0x8f: 0xfb,\n  // lowercase u, circumflex accent\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n  0x90: 0xc1,\n  // capital letter A with acute\n  0x91: 0xc9,\n  // capital letter E with acute\n  0x92: 0xd3,\n  // capital letter O with acute\n  0x93: 0xda,\n  // capital letter U with acute\n  0x94: 0xdc,\n  // capital letter U with diaresis\n  0x95: 0xfc,\n  // lowercase letter U with diaeresis\n  0x96: 0x2018,\n  // opening single quote\n  0x97: 0xa1,\n  // inverted exclamation mark\n  0x98: 0x2a,\n  // asterisk\n  0x99: 0x2019,\n  // closing single quote\n  0x9a: 0x2501,\n  // box drawings heavy horizontal\n  0x9b: 0xa9,\n  // copyright sign\n  0x9c: 0x2120,\n  // Service mark\n  0x9d: 0x2022,\n  // (round) bullet\n  0x9e: 0x201c,\n  // Left double quotation mark\n  0x9f: 0x201d,\n  // Right double quotation mark\n  0xa0: 0xc0,\n  // uppercase A, grave accent\n  0xa1: 0xc2,\n  // uppercase A, circumflex\n  0xa2: 0xc7,\n  // uppercase C with cedilla\n  0xa3: 0xc8,\n  // uppercase E, grave accent\n  0xa4: 0xca,\n  // uppercase E, circumflex\n  0xa5: 0xcb,\n  // capital letter E with diaresis\n  0xa6: 0xeb,\n  // lowercase letter e with diaresis\n  0xa7: 0xce,\n  // uppercase I, circumflex\n  0xa8: 0xcf,\n  // uppercase I, with diaresis\n  0xa9: 0xef,\n  // lowercase i, with diaresis\n  0xaa: 0xd4,\n  // uppercase O, circumflex\n  0xab: 0xd9,\n  // uppercase U, grave accent\n  0xac: 0xf9,\n  // lowercase u, grave accent\n  0xad: 0xdb,\n  // uppercase U, circumflex\n  0xae: 0xab,\n  // left-pointing double angle quotation mark\n  0xaf: 0xbb,\n  // right-pointing double angle quotation mark\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n  0xb0: 0xc3,\n  // Uppercase A, tilde\n  0xb1: 0xe3,\n  // Lowercase a, tilde\n  0xb2: 0xcd,\n  // Uppercase I, acute accent\n  0xb3: 0xcc,\n  // Uppercase I, grave accent\n  0xb4: 0xec,\n  // Lowercase i, grave accent\n  0xb5: 0xd2,\n  // Uppercase O, grave accent\n  0xb6: 0xf2,\n  // Lowercase o, grave accent\n  0xb7: 0xd5,\n  // Uppercase O, tilde\n  0xb8: 0xf5,\n  // Lowercase o, tilde\n  0xb9: 0x7b,\n  // Open curly brace\n  0xba: 0x7d,\n  // Closing curly brace\n  0xbb: 0x5c,\n  // Backslash\n  0xbc: 0x5e,\n  // Caret\n  0xbd: 0x5f,\n  // Underscore\n  0xbe: 0x7c,\n  // Pipe (vertical line)\n  0xbf: 0x223c,\n  // Tilde operator\n  0xc0: 0xc4,\n  // Uppercase A, umlaut\n  0xc1: 0xe4,\n  // Lowercase A, umlaut\n  0xc2: 0xd6,\n  // Uppercase O, umlaut\n  0xc3: 0xf6,\n  // Lowercase o, umlaut\n  0xc4: 0xdf,\n  // Esszett (sharp S)\n  0xc5: 0xa5,\n  // Yen symbol\n  0xc6: 0xa4,\n  // Generic currency sign\n  0xc7: 0x2503,\n  // Box drawings heavy vertical\n  0xc8: 0xc5,\n  // Uppercase A, ring\n  0xc9: 0xe5,\n  // Lowercase A, ring\n  0xca: 0xd8,\n  // Uppercase O, stroke\n  0xcb: 0xf8,\n  // Lowercase o, strok\n  0xcc: 0x250f,\n  // Box drawings heavy down and right\n  0xcd: 0x2513,\n  // Box drawings heavy down and left\n  0xce: 0x2517,\n  // Box drawings heavy up and right\n  0xcf: 0x251b // Box drawings heavy up and left\n\n};\n/**\n * Utils\n */\n\nvar getCharForByte = function getCharForByte(_byte) {\n  var charCode = _byte;\n\n  if (specialCea608CharsCodes.hasOwnProperty(_byte)) {\n    charCode = specialCea608CharsCodes[_byte];\n  }\n\n  return String.fromCharCode(charCode);\n};\n\nvar NR_ROWS = 15;\nvar NR_COLS = 100; // Tables to look up row from PAC data\n\nvar rowsLowCh1 = {\n  0x11: 1,\n  0x12: 3,\n  0x15: 5,\n  0x16: 7,\n  0x17: 9,\n  0x10: 11,\n  0x13: 12,\n  0x14: 14\n};\nvar rowsHighCh1 = {\n  0x11: 2,\n  0x12: 4,\n  0x15: 6,\n  0x16: 8,\n  0x17: 10,\n  0x13: 13,\n  0x14: 15\n};\nvar rowsLowCh2 = {\n  0x19: 1,\n  0x1a: 3,\n  0x1d: 5,\n  0x1e: 7,\n  0x1f: 9,\n  0x18: 11,\n  0x1b: 12,\n  0x1c: 14\n};\nvar rowsHighCh2 = {\n  0x19: 2,\n  0x1a: 4,\n  0x1d: 6,\n  0x1e: 8,\n  0x1f: 10,\n  0x1b: 13,\n  0x1c: 15\n};\nvar backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];\nvar VerboseLevel;\n\n(function (VerboseLevel) {\n  VerboseLevel[VerboseLevel[\"ERROR\"] = 0] = \"ERROR\";\n  VerboseLevel[VerboseLevel[\"TEXT\"] = 1] = \"TEXT\";\n  VerboseLevel[VerboseLevel[\"WARNING\"] = 2] = \"WARNING\";\n  VerboseLevel[VerboseLevel[\"INFO\"] = 2] = \"INFO\";\n  VerboseLevel[VerboseLevel[\"DEBUG\"] = 3] = \"DEBUG\";\n  VerboseLevel[VerboseLevel[\"DATA\"] = 3] = \"DATA\";\n})(VerboseLevel || (VerboseLevel = {}));\n\nvar CaptionsLogger = /*#__PURE__*/function () {\n  function CaptionsLogger() {\n    this.time = null;\n    this.verboseLevel = VerboseLevel.ERROR;\n  }\n\n  var _proto = CaptionsLogger.prototype;\n\n  _proto.log = function log(severity, msg) {\n    if (this.verboseLevel >= severity) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].log(this.time + \" [\" + severity + \"] \" + msg);\n    }\n  };\n\n  return CaptionsLogger;\n}();\n\nvar numArrayToHexArray = function numArrayToHexArray(numArray) {\n  var hexArray = [];\n\n  for (var j = 0; j < numArray.length; j++) {\n    hexArray.push(numArray[j].toString(16));\n  }\n\n  return hexArray;\n};\n\nvar PenState = /*#__PURE__*/function () {\n  function PenState(foreground, underline, italics, background, flash) {\n    this.foreground = void 0;\n    this.underline = void 0;\n    this.italics = void 0;\n    this.background = void 0;\n    this.flash = void 0;\n    this.foreground = foreground || 'white';\n    this.underline = underline || false;\n    this.italics = italics || false;\n    this.background = background || 'black';\n    this.flash = flash || false;\n  }\n\n  var _proto2 = PenState.prototype;\n\n  _proto2.reset = function reset() {\n    this.foreground = 'white';\n    this.underline = false;\n    this.italics = false;\n    this.background = 'black';\n    this.flash = false;\n  };\n\n  _proto2.setStyles = function setStyles(styles) {\n    var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];\n\n    for (var i = 0; i < attribs.length; i++) {\n      var style = attribs[i];\n\n      if (styles.hasOwnProperty(style)) {\n        this[style] = styles[style];\n      }\n    }\n  };\n\n  _proto2.isDefault = function isDefault() {\n    return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;\n  };\n\n  _proto2.equals = function equals(other) {\n    return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;\n  };\n\n  _proto2.copy = function copy(newPenState) {\n    this.foreground = newPenState.foreground;\n    this.underline = newPenState.underline;\n    this.italics = newPenState.italics;\n    this.background = newPenState.background;\n    this.flash = newPenState.flash;\n  };\n\n  _proto2.toString = function toString() {\n    return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;\n  };\n\n  return PenState;\n}();\n/**\n * Unicode character with styling and background.\n * @constructor\n */\n\n\nvar StyledUnicodeChar = /*#__PURE__*/function () {\n  function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {\n    this.uchar = void 0;\n    this.penState = void 0;\n    this.uchar = uchar || ' '; // unicode character\n\n    this.penState = new PenState(foreground, underline, italics, background, flash);\n  }\n\n  var _proto3 = StyledUnicodeChar.prototype;\n\n  _proto3.reset = function reset() {\n    this.uchar = ' ';\n    this.penState.reset();\n  };\n\n  _proto3.setChar = function setChar(uchar, newPenState) {\n    this.uchar = uchar;\n    this.penState.copy(newPenState);\n  };\n\n  _proto3.setPenState = function setPenState(newPenState) {\n    this.penState.copy(newPenState);\n  };\n\n  _proto3.equals = function equals(other) {\n    return this.uchar === other.uchar && this.penState.equals(other.penState);\n  };\n\n  _proto3.copy = function copy(newChar) {\n    this.uchar = newChar.uchar;\n    this.penState.copy(newChar.penState);\n  };\n\n  _proto3.isEmpty = function isEmpty() {\n    return this.uchar === ' ' && this.penState.isDefault();\n  };\n\n  return StyledUnicodeChar;\n}();\n/**\n * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n * @constructor\n */\n\n\nvar Row = /*#__PURE__*/function () {\n  function Row(logger) {\n    this.chars = void 0;\n    this.pos = void 0;\n    this.currPenState = void 0;\n    this.cueStartTime = void 0;\n    this.logger = void 0;\n    this.chars = [];\n\n    for (var i = 0; i < NR_COLS; i++) {\n      this.chars.push(new StyledUnicodeChar());\n    }\n\n    this.logger = logger;\n    this.pos = 0;\n    this.currPenState = new PenState();\n  }\n\n  var _proto4 = Row.prototype;\n\n  _proto4.equals = function equals(other) {\n    var equal = true;\n\n    for (var i = 0; i < NR_COLS; i++) {\n      if (!this.chars[i].equals(other.chars[i])) {\n        equal = false;\n        break;\n      }\n    }\n\n    return equal;\n  };\n\n  _proto4.copy = function copy(other) {\n    for (var i = 0; i < NR_COLS; i++) {\n      this.chars[i].copy(other.chars[i]);\n    }\n  };\n\n  _proto4.isEmpty = function isEmpty() {\n    var empty = true;\n\n    for (var i = 0; i < NR_COLS; i++) {\n      if (!this.chars[i].isEmpty()) {\n        empty = false;\n        break;\n      }\n    }\n\n    return empty;\n  }\n  /**\n   *  Set the cursor to a valid column.\n   */\n  ;\n\n  _proto4.setCursor = function setCursor(absPos) {\n    if (this.pos !== absPos) {\n      this.pos = absPos;\n    }\n\n    if (this.pos < 0) {\n      this.logger.log(VerboseLevel.DEBUG, 'Negative cursor position ' + this.pos);\n      this.pos = 0;\n    } else if (this.pos > NR_COLS) {\n      this.logger.log(VerboseLevel.DEBUG, 'Too large cursor position ' + this.pos);\n      this.pos = NR_COLS;\n    }\n  }\n  /**\n   * Move the cursor relative to current position.\n   */\n  ;\n\n  _proto4.moveCursor = function moveCursor(relPos) {\n    var newPos = this.pos + relPos;\n\n    if (relPos > 1) {\n      for (var i = this.pos + 1; i < newPos + 1; i++) {\n        this.chars[i].setPenState(this.currPenState);\n      }\n    }\n\n    this.setCursor(newPos);\n  }\n  /**\n   * Backspace, move one step back and clear character.\n   */\n  ;\n\n  _proto4.backSpace = function backSpace() {\n    this.moveCursor(-1);\n    this.chars[this.pos].setChar(' ', this.currPenState);\n  };\n\n  _proto4.insertChar = function insertChar(_byte2) {\n    if (_byte2 >= 0x90) {\n      // Extended char\n      this.backSpace();\n    }\n\n    var _char = getCharForByte(_byte2);\n\n    if (this.pos >= NR_COLS) {\n      this.logger.log(VerboseLevel.ERROR, 'Cannot insert ' + _byte2.toString(16) + ' (' + _char + ') at position ' + this.pos + '. Skipping it!');\n      return;\n    }\n\n    this.chars[this.pos].setChar(_char, this.currPenState);\n    this.moveCursor(1);\n  };\n\n  _proto4.clearFromPos = function clearFromPos(startPos) {\n    var i;\n\n    for (i = startPos; i < NR_COLS; i++) {\n      this.chars[i].reset();\n    }\n  };\n\n  _proto4.clear = function clear() {\n    this.clearFromPos(0);\n    this.pos = 0;\n    this.currPenState.reset();\n  };\n\n  _proto4.clearToEndOfRow = function clearToEndOfRow() {\n    this.clearFromPos(this.pos);\n  };\n\n  _proto4.getTextString = function getTextString() {\n    var chars = [];\n    var empty = true;\n\n    for (var i = 0; i < NR_COLS; i++) {\n      var _char2 = this.chars[i].uchar;\n\n      if (_char2 !== ' ') {\n        empty = false;\n      }\n\n      chars.push(_char2);\n    }\n\n    if (empty) {\n      return '';\n    } else {\n      return chars.join('');\n    }\n  };\n\n  _proto4.setPenStyles = function setPenStyles(styles) {\n    this.currPenState.setStyles(styles);\n    var currChar = this.chars[this.pos];\n    currChar.setPenState(this.currPenState);\n  };\n\n  return Row;\n}();\n/**\n * Keep a CEA-608 screen of 32x15 styled characters\n * @constructor\n */\n\nvar CaptionScreen = /*#__PURE__*/function () {\n  function CaptionScreen(logger) {\n    this.rows = void 0;\n    this.currRow = void 0;\n    this.nrRollUpRows = void 0;\n    this.lastOutputScreen = void 0;\n    this.logger = void 0;\n    this.rows = [];\n\n    for (var i = 0; i < NR_ROWS; i++) {\n      this.rows.push(new Row(logger));\n    } // Note that we use zero-based numbering (0-14)\n\n\n    this.logger = logger;\n    this.currRow = NR_ROWS - 1;\n    this.nrRollUpRows = null;\n    this.lastOutputScreen = null;\n    this.reset();\n  }\n\n  var _proto5 = CaptionScreen.prototype;\n\n  _proto5.reset = function reset() {\n    for (var i = 0; i < NR_ROWS; i++) {\n      this.rows[i].clear();\n    }\n\n    this.currRow = NR_ROWS - 1;\n  };\n\n  _proto5.equals = function equals(other) {\n    var equal = true;\n\n    for (var i = 0; i < NR_ROWS; i++) {\n      if (!this.rows[i].equals(other.rows[i])) {\n        equal = false;\n        break;\n      }\n    }\n\n    return equal;\n  };\n\n  _proto5.copy = function copy(other) {\n    for (var i = 0; i < NR_ROWS; i++) {\n      this.rows[i].copy(other.rows[i]);\n    }\n  };\n\n  _proto5.isEmpty = function isEmpty() {\n    var empty = true;\n\n    for (var i = 0; i < NR_ROWS; i++) {\n      if (!this.rows[i].isEmpty()) {\n        empty = false;\n        break;\n      }\n    }\n\n    return empty;\n  };\n\n  _proto5.backSpace = function backSpace() {\n    var row = this.rows[this.currRow];\n    row.backSpace();\n  };\n\n  _proto5.clearToEndOfRow = function clearToEndOfRow() {\n    var row = this.rows[this.currRow];\n    row.clearToEndOfRow();\n  }\n  /**\n   * Insert a character (without styling) in the current row.\n   */\n  ;\n\n  _proto5.insertChar = function insertChar(_char3) {\n    var row = this.rows[this.currRow];\n    row.insertChar(_char3);\n  };\n\n  _proto5.setPen = function setPen(styles) {\n    var row = this.rows[this.currRow];\n    row.setPenStyles(styles);\n  };\n\n  _proto5.moveCursor = function moveCursor(relPos) {\n    var row = this.rows[this.currRow];\n    row.moveCursor(relPos);\n  };\n\n  _proto5.setCursor = function setCursor(absPos) {\n    this.logger.log(VerboseLevel.INFO, 'setCursor: ' + absPos);\n    var row = this.rows[this.currRow];\n    row.setCursor(absPos);\n  };\n\n  _proto5.setPAC = function setPAC(pacData) {\n    this.logger.log(VerboseLevel.INFO, 'pacData = ' + JSON.stringify(pacData));\n    var newRow = pacData.row - 1;\n\n    if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {\n      newRow = this.nrRollUpRows - 1;\n    } // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows\n\n\n    if (this.nrRollUpRows && this.currRow !== newRow) {\n      // clear all rows first\n      for (var i = 0; i < NR_ROWS; i++) {\n        this.rows[i].clear();\n      } // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location\n      // topRowIndex - the start of rows to copy (inclusive index)\n\n\n      var topRowIndex = this.currRow + 1 - this.nrRollUpRows; // We only copy if the last position was already shown.\n      // We use the cueStartTime value to check this.\n\n      var lastOutputScreen = this.lastOutputScreen;\n\n      if (lastOutputScreen) {\n        var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;\n        var time = this.logger.time;\n\n        if (prevLineTime && time !== null && prevLineTime < time) {\n          for (var _i = 0; _i < this.nrRollUpRows; _i++) {\n            this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);\n          }\n        }\n      }\n    }\n\n    this.currRow = newRow;\n    var row = this.rows[this.currRow];\n\n    if (pacData.indent !== null) {\n      var indent = pacData.indent;\n      var prevPos = Math.max(indent - 1, 0);\n      row.setCursor(pacData.indent);\n      pacData.color = row.chars[prevPos].penState.foreground;\n    }\n\n    var styles = {\n      foreground: pacData.color,\n      underline: pacData.underline,\n      italics: pacData.italics,\n      background: 'black',\n      flash: false\n    };\n    this.setPen(styles);\n  }\n  /**\n   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n   */\n  ;\n\n  _proto5.setBkgData = function setBkgData(bkgData) {\n    this.logger.log(VerboseLevel.INFO, 'bkgData = ' + JSON.stringify(bkgData));\n    this.backSpace();\n    this.setPen(bkgData);\n    this.insertChar(0x20); // Space\n  };\n\n  _proto5.setRollUpRows = function setRollUpRows(nrRows) {\n    this.nrRollUpRows = nrRows;\n  };\n\n  _proto5.rollUp = function rollUp() {\n    if (this.nrRollUpRows === null) {\n      this.logger.log(VerboseLevel.DEBUG, 'roll_up but nrRollUpRows not set yet');\n      return; // Not properly setup\n    }\n\n    this.logger.log(VerboseLevel.TEXT, this.getDisplayText());\n    var topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n    var topRow = this.rows.splice(topRowIndex, 1)[0];\n    topRow.clear();\n    this.rows.splice(this.currRow, 0, topRow);\n    this.logger.log(VerboseLevel.INFO, 'Rolling up'); // this.logger.log(VerboseLevel.TEXT, this.get_display_text())\n  }\n  /**\n   * Get all non-empty rows with as unicode text.\n   */\n  ;\n\n  _proto5.getDisplayText = function getDisplayText(asOneRow) {\n    asOneRow = asOneRow || false;\n    var displayText = [];\n    var text = '';\n    var rowNr = -1;\n\n    for (var i = 0; i < NR_ROWS; i++) {\n      var rowText = this.rows[i].getTextString();\n\n      if (rowText) {\n        rowNr = i + 1;\n\n        if (asOneRow) {\n          displayText.push('Row ' + rowNr + \": '\" + rowText + \"'\");\n        } else {\n          displayText.push(rowText.trim());\n        }\n      }\n    }\n\n    if (displayText.length > 0) {\n      if (asOneRow) {\n        text = '[' + displayText.join(' | ') + ']';\n      } else {\n        text = displayText.join('\\n');\n      }\n    }\n\n    return text;\n  };\n\n  _proto5.getTextAndFormat = function getTextAndFormat() {\n    return this.rows;\n  };\n\n  return CaptionScreen;\n}(); // var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];\n\nvar Cea608Channel = /*#__PURE__*/function () {\n  function Cea608Channel(channelNumber, outputFilter, logger) {\n    this.chNr = void 0;\n    this.outputFilter = void 0;\n    this.mode = void 0;\n    this.verbose = void 0;\n    this.displayedMemory = void 0;\n    this.nonDisplayedMemory = void 0;\n    this.lastOutputScreen = void 0;\n    this.currRollUpRow = void 0;\n    this.writeScreen = void 0;\n    this.cueStartTime = void 0;\n    this.logger = void 0;\n    this.chNr = channelNumber;\n    this.outputFilter = outputFilter;\n    this.mode = null;\n    this.verbose = 0;\n    this.displayedMemory = new CaptionScreen(logger);\n    this.nonDisplayedMemory = new CaptionScreen(logger);\n    this.lastOutputScreen = new CaptionScreen(logger);\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null; // Keeps track of where a cue started.\n\n    this.logger = logger;\n  }\n\n  var _proto6 = Cea608Channel.prototype;\n\n  _proto6.reset = function reset() {\n    this.mode = null;\n    this.displayedMemory.reset();\n    this.nonDisplayedMemory.reset();\n    this.lastOutputScreen.reset();\n    this.outputFilter.reset();\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null;\n  };\n\n  _proto6.getHandler = function getHandler() {\n    return this.outputFilter;\n  };\n\n  _proto6.setHandler = function setHandler(newHandler) {\n    this.outputFilter = newHandler;\n  };\n\n  _proto6.setPAC = function setPAC(pacData) {\n    this.writeScreen.setPAC(pacData);\n  };\n\n  _proto6.setBkgData = function setBkgData(bkgData) {\n    this.writeScreen.setBkgData(bkgData);\n  };\n\n  _proto6.setMode = function setMode(newMode) {\n    if (newMode === this.mode) {\n      return;\n    }\n\n    this.mode = newMode;\n    this.logger.log(VerboseLevel.INFO, 'MODE=' + newMode);\n\n    if (this.mode === 'MODE_POP-ON') {\n      this.writeScreen = this.nonDisplayedMemory;\n    } else {\n      this.writeScreen = this.displayedMemory;\n      this.writeScreen.reset();\n    }\n\n    if (this.mode !== 'MODE_ROLL-UP') {\n      this.displayedMemory.nrRollUpRows = null;\n      this.nonDisplayedMemory.nrRollUpRows = null;\n    }\n\n    this.mode = newMode;\n  };\n\n  _proto6.insertChars = function insertChars(chars) {\n    for (var i = 0; i < chars.length; i++) {\n      this.writeScreen.insertChar(chars[i]);\n    }\n\n    var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';\n    this.logger.log(VerboseLevel.INFO, screen + ': ' + this.writeScreen.getDisplayText(true));\n\n    if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {\n      this.logger.log(VerboseLevel.TEXT, 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));\n      this.outputDataUpdate();\n    }\n  };\n\n  _proto6.ccRCL = function ccRCL() {\n    // Resume Caption Loading (switch mode to Pop On)\n    this.logger.log(VerboseLevel.INFO, 'RCL - Resume Caption Loading');\n    this.setMode('MODE_POP-ON');\n  };\n\n  _proto6.ccBS = function ccBS() {\n    // BackSpace\n    this.logger.log(VerboseLevel.INFO, 'BS - BackSpace');\n\n    if (this.mode === 'MODE_TEXT') {\n      return;\n    }\n\n    this.writeScreen.backSpace();\n\n    if (this.writeScreen === this.displayedMemory) {\n      this.outputDataUpdate();\n    }\n  };\n\n  _proto6.ccAOF = function ccAOF() {// Reserved (formerly Alarm Off)\n  };\n\n  _proto6.ccAON = function ccAON() {// Reserved (formerly Alarm On)\n  };\n\n  _proto6.ccDER = function ccDER() {\n    // Delete to End of Row\n    this.logger.log(VerboseLevel.INFO, 'DER- Delete to End of Row');\n    this.writeScreen.clearToEndOfRow();\n    this.outputDataUpdate();\n  };\n\n  _proto6.ccRU = function ccRU(nrRows) {\n    // Roll-Up Captions-2,3,or 4 Rows\n    this.logger.log(VerboseLevel.INFO, 'RU(' + nrRows + ') - Roll Up');\n    this.writeScreen = this.displayedMemory;\n    this.setMode('MODE_ROLL-UP');\n    this.writeScreen.setRollUpRows(nrRows);\n  };\n\n  _proto6.ccFON = function ccFON() {\n    // Flash On\n    this.logger.log(VerboseLevel.INFO, 'FON - Flash On');\n    this.writeScreen.setPen({\n      flash: true\n    });\n  };\n\n  _proto6.ccRDC = function ccRDC() {\n    // Resume Direct Captioning (switch mode to PaintOn)\n    this.logger.log(VerboseLevel.INFO, 'RDC - Resume Direct Captioning');\n    this.setMode('MODE_PAINT-ON');\n  };\n\n  _proto6.ccTR = function ccTR() {\n    // Text Restart in text mode (not supported, however)\n    this.logger.log(VerboseLevel.INFO, 'TR');\n    this.setMode('MODE_TEXT');\n  };\n\n  _proto6.ccRTD = function ccRTD() {\n    // Resume Text Display in Text mode (not supported, however)\n    this.logger.log(VerboseLevel.INFO, 'RTD');\n    this.setMode('MODE_TEXT');\n  };\n\n  _proto6.ccEDM = function ccEDM() {\n    // Erase Displayed Memory\n    this.logger.log(VerboseLevel.INFO, 'EDM - Erase Displayed Memory');\n    this.displayedMemory.reset();\n    this.outputDataUpdate(true);\n  };\n\n  _proto6.ccCR = function ccCR() {\n    // Carriage Return\n    this.logger.log(VerboseLevel.INFO, 'CR - Carriage Return');\n    this.writeScreen.rollUp();\n    this.outputDataUpdate(true);\n  };\n\n  _proto6.ccENM = function ccENM() {\n    // Erase Non-Displayed Memory\n    this.logger.log(VerboseLevel.INFO, 'ENM - Erase Non-displayed Memory');\n    this.nonDisplayedMemory.reset();\n  };\n\n  _proto6.ccEOC = function ccEOC() {\n    // End of Caption (Flip Memories)\n    this.logger.log(VerboseLevel.INFO, 'EOC - End Of Caption');\n\n    if (this.mode === 'MODE_POP-ON') {\n      var tmp = this.displayedMemory;\n      this.displayedMemory = this.nonDisplayedMemory;\n      this.nonDisplayedMemory = tmp;\n      this.writeScreen = this.nonDisplayedMemory;\n      this.logger.log(VerboseLevel.TEXT, 'DISP: ' + this.displayedMemory.getDisplayText());\n    }\n\n    this.outputDataUpdate(true);\n  };\n\n  _proto6.ccTO = function ccTO(nrCols) {\n    // Tab Offset 1,2, or 3 columns\n    this.logger.log(VerboseLevel.INFO, 'TO(' + nrCols + ') - Tab Offset');\n    this.writeScreen.moveCursor(nrCols);\n  };\n\n  _proto6.ccMIDROW = function ccMIDROW(secondByte) {\n    // Parse MIDROW command\n    var styles = {\n      flash: false\n    };\n    styles.underline = secondByte % 2 === 1;\n    styles.italics = secondByte >= 0x2e;\n\n    if (!styles.italics) {\n      var colorIndex = Math.floor(secondByte / 2) - 0x10;\n      var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];\n      styles.foreground = colors[colorIndex];\n    } else {\n      styles.foreground = 'white';\n    }\n\n    this.logger.log(VerboseLevel.INFO, 'MIDROW: ' + JSON.stringify(styles));\n    this.writeScreen.setPen(styles);\n  };\n\n  _proto6.outputDataUpdate = function outputDataUpdate(dispatch) {\n    if (dispatch === void 0) {\n      dispatch = false;\n    }\n\n    var time = this.logger.time;\n\n    if (time === null) {\n      return;\n    }\n\n    if (this.outputFilter) {\n      if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {\n        // Start of a new cue\n        this.cueStartTime = time;\n      } else {\n        if (!this.displayedMemory.equals(this.lastOutputScreen)) {\n          this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);\n\n          if (dispatch && this.outputFilter.dispatchCue) {\n            this.outputFilter.dispatchCue();\n          }\n\n          this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;\n        }\n      }\n\n      this.lastOutputScreen.copy(this.displayedMemory);\n    }\n  };\n\n  _proto6.cueSplitAtTime = function cueSplitAtTime(t) {\n    if (this.outputFilter) {\n      if (!this.displayedMemory.isEmpty()) {\n        if (this.outputFilter.newCue) {\n          this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n        }\n\n        this.cueStartTime = t;\n      }\n    }\n  };\n\n  return Cea608Channel;\n}();\n\nvar Cea608Parser = /*#__PURE__*/function () {\n  function Cea608Parser(field, out1, out2) {\n    this.channels = void 0;\n    this.currentChannel = 0;\n    this.cmdHistory = void 0;\n    this.logger = void 0;\n    var logger = new CaptionsLogger();\n    this.channels = [null, new Cea608Channel(field, out1, logger), new Cea608Channel(field + 1, out2, logger)];\n    this.cmdHistory = createCmdHistory();\n    this.logger = logger;\n  }\n\n  var _proto7 = Cea608Parser.prototype;\n\n  _proto7.getHandler = function getHandler(channel) {\n    return this.channels[channel].getHandler();\n  };\n\n  _proto7.setHandler = function setHandler(channel, newHandler) {\n    this.channels[channel].setHandler(newHandler);\n  }\n  /**\n   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n   */\n  ;\n\n  _proto7.addData = function addData(time, byteList) {\n    var cmdFound;\n    var a;\n    var b;\n    var charsFound = false;\n    this.logger.time = time;\n\n    for (var i = 0; i < byteList.length; i += 2) {\n      a = byteList[i] & 0x7f;\n      b = byteList[i + 1] & 0x7f;\n\n      if (a === 0 && b === 0) {\n        continue;\n      } else {\n        this.logger.log(VerboseLevel.DATA, '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');\n      }\n\n      cmdFound = this.parseCmd(a, b);\n\n      if (!cmdFound) {\n        cmdFound = this.parseMidrow(a, b);\n      }\n\n      if (!cmdFound) {\n        cmdFound = this.parsePAC(a, b);\n      }\n\n      if (!cmdFound) {\n        cmdFound = this.parseBackgroundAttributes(a, b);\n      }\n\n      if (!cmdFound) {\n        charsFound = this.parseChars(a, b);\n\n        if (charsFound) {\n          var currChNr = this.currentChannel;\n\n          if (currChNr && currChNr > 0) {\n            var channel = this.channels[currChNr];\n            channel.insertChars(charsFound);\n          } else {\n            this.logger.log(VerboseLevel.WARNING, 'No channel found yet. TEXT-MODE?');\n          }\n        }\n      }\n\n      if (!cmdFound && !charsFound) {\n        this.logger.log(VerboseLevel.WARNING, \"Couldn't parse cleaned data \" + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));\n      }\n    }\n  }\n  /**\n   * Parse Command.\n   * @returns {Boolean} Tells if a command was found\n   */\n  ;\n\n  _proto7.parseCmd = function parseCmd(a, b) {\n    var cmdHistory = this.cmdHistory;\n    var cond1 = (a === 0x14 || a === 0x1c || a === 0x15 || a === 0x1d) && b >= 0x20 && b <= 0x2f;\n    var cond2 = (a === 0x17 || a === 0x1f) && b >= 0x21 && b <= 0x23;\n\n    if (!(cond1 || cond2)) {\n      return false;\n    }\n\n    if (hasCmdRepeated(a, b, cmdHistory)) {\n      setLastCmd(null, null, cmdHistory);\n      this.logger.log(VerboseLevel.DEBUG, 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');\n      return true;\n    }\n\n    var chNr = a === 0x14 || a === 0x15 || a === 0x17 ? 1 : 2;\n    var channel = this.channels[chNr];\n\n    if (a === 0x14 || a === 0x15 || a === 0x1c || a === 0x1d) {\n      if (b === 0x20) {\n        channel.ccRCL();\n      } else if (b === 0x21) {\n        channel.ccBS();\n      } else if (b === 0x22) {\n        channel.ccAOF();\n      } else if (b === 0x23) {\n        channel.ccAON();\n      } else if (b === 0x24) {\n        channel.ccDER();\n      } else if (b === 0x25) {\n        channel.ccRU(2);\n      } else if (b === 0x26) {\n        channel.ccRU(3);\n      } else if (b === 0x27) {\n        channel.ccRU(4);\n      } else if (b === 0x28) {\n        channel.ccFON();\n      } else if (b === 0x29) {\n        channel.ccRDC();\n      } else if (b === 0x2a) {\n        channel.ccTR();\n      } else if (b === 0x2b) {\n        channel.ccRTD();\n      } else if (b === 0x2c) {\n        channel.ccEDM();\n      } else if (b === 0x2d) {\n        channel.ccCR();\n      } else if (b === 0x2e) {\n        channel.ccENM();\n      } else if (b === 0x2f) {\n        channel.ccEOC();\n      }\n    } else {\n      // a == 0x17 || a == 0x1F\n      channel.ccTO(b - 0x20);\n    }\n\n    setLastCmd(a, b, cmdHistory);\n    this.currentChannel = chNr;\n    return true;\n  }\n  /**\n   * Parse midrow styling command\n   * @returns {Boolean}\n   */\n  ;\n\n  _proto7.parseMidrow = function parseMidrow(a, b) {\n    var chNr = 0;\n\n    if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {\n      if (a === 0x11) {\n        chNr = 1;\n      } else {\n        chNr = 2;\n      }\n\n      if (chNr !== this.currentChannel) {\n        this.logger.log(VerboseLevel.ERROR, 'Mismatch channel in midrow parsing');\n        return false;\n      }\n\n      var channel = this.channels[chNr];\n\n      if (!channel) {\n        return false;\n      }\n\n      channel.ccMIDROW(b);\n      this.logger.log(VerboseLevel.DEBUG, 'MIDROW (' + numArrayToHexArray([a, b]) + ')');\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Parse Preable Access Codes (Table 53).\n   * @returns {Boolean} Tells if PAC found\n   */\n  ;\n\n  _proto7.parsePAC = function parsePAC(a, b) {\n    var row;\n    var cmdHistory = this.cmdHistory;\n    var case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1f) && b >= 0x40 && b <= 0x7f;\n    var case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5f;\n\n    if (!(case1 || case2)) {\n      return false;\n    }\n\n    if (hasCmdRepeated(a, b, cmdHistory)) {\n      setLastCmd(null, null, cmdHistory);\n      return true; // Repeated commands are dropped (once)\n    }\n\n    var chNr = a <= 0x17 ? 1 : 2;\n\n    if (b >= 0x40 && b <= 0x5f) {\n      row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];\n    } else {\n      // 0x60 <= b <= 0x7F\n      row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];\n    }\n\n    var channel = this.channels[chNr];\n\n    if (!channel) {\n      return false;\n    }\n\n    channel.setPAC(this.interpretPAC(row, b));\n    setLastCmd(a, b, cmdHistory);\n    this.currentChannel = chNr;\n    return true;\n  }\n  /**\n   * Interpret the second byte of the pac, and return the information.\n   * @returns {Object} pacData with style parameters.\n   */\n  ;\n\n  _proto7.interpretPAC = function interpretPAC(row, _byte3) {\n    var pacIndex;\n    var pacData = {\n      color: null,\n      italics: false,\n      indent: null,\n      underline: false,\n      row: row\n    };\n\n    if (_byte3 > 0x5f) {\n      pacIndex = _byte3 - 0x60;\n    } else {\n      pacIndex = _byte3 - 0x40;\n    }\n\n    pacData.underline = (pacIndex & 1) === 1;\n\n    if (pacIndex <= 0xd) {\n      pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];\n    } else if (pacIndex <= 0xf) {\n      pacData.italics = true;\n      pacData.color = 'white';\n    } else {\n      pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;\n    }\n\n    return pacData; // Note that row has zero offset. The spec uses 1.\n  }\n  /**\n   * Parse characters.\n   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n   */\n  ;\n\n  _proto7.parseChars = function parseChars(a, b) {\n    var channelNr;\n    var charCodes = null;\n    var charCode1 = null;\n\n    if (a >= 0x19) {\n      channelNr = 2;\n      charCode1 = a - 8;\n    } else {\n      channelNr = 1;\n      charCode1 = a;\n    }\n\n    if (charCode1 >= 0x11 && charCode1 <= 0x13) {\n      // Special character\n      var oneCode;\n\n      if (charCode1 === 0x11) {\n        oneCode = b + 0x50;\n      } else if (charCode1 === 0x12) {\n        oneCode = b + 0x70;\n      } else {\n        oneCode = b + 0x90;\n      }\n\n      this.logger.log(VerboseLevel.INFO, \"Special char '\" + getCharForByte(oneCode) + \"' in channel \" + channelNr);\n      charCodes = [oneCode];\n    } else if (a >= 0x20 && a <= 0x7f) {\n      charCodes = b === 0 ? [a] : [a, b];\n    }\n\n    if (charCodes) {\n      var hexCodes = numArrayToHexArray(charCodes);\n      this.logger.log(VerboseLevel.DEBUG, 'Char codes =  ' + hexCodes.join(','));\n      setLastCmd(a, b, this.cmdHistory);\n    }\n\n    return charCodes;\n  }\n  /**\n   * Parse extended background attributes as well as new foreground color black.\n   * @returns {Boolean} Tells if background attributes are found\n   */\n  ;\n\n  _proto7.parseBackgroundAttributes = function parseBackgroundAttributes(a, b) {\n    var case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;\n    var case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;\n\n    if (!(case1 || case2)) {\n      return false;\n    }\n\n    var index;\n    var bkgData = {};\n\n    if (a === 0x10 || a === 0x18) {\n      index = Math.floor((b - 0x20) / 2);\n      bkgData.background = backgroundColors[index];\n\n      if (b % 2 === 1) {\n        bkgData.background = bkgData.background + '_semi';\n      }\n    } else if (b === 0x2d) {\n      bkgData.background = 'transparent';\n    } else {\n      bkgData.foreground = 'black';\n\n      if (b === 0x2f) {\n        bkgData.underline = true;\n      }\n    }\n\n    var chNr = a <= 0x17 ? 1 : 2;\n    var channel = this.channels[chNr];\n    channel.setBkgData(bkgData);\n    setLastCmd(a, b, this.cmdHistory);\n    return true;\n  }\n  /**\n   * Reset state of parser and its channels.\n   */\n  ;\n\n  _proto7.reset = function reset() {\n    for (var i = 0; i < Object.keys(this.channels).length; i++) {\n      var channel = this.channels[i];\n\n      if (channel) {\n        channel.reset();\n      }\n    }\n\n    this.cmdHistory = createCmdHistory();\n  }\n  /**\n   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n   */\n  ;\n\n  _proto7.cueSplitAtTime = function cueSplitAtTime(t) {\n    for (var i = 0; i < this.channels.length; i++) {\n      var channel = this.channels[i];\n\n      if (channel) {\n        channel.cueSplitAtTime(t);\n      }\n    }\n  };\n\n  return Cea608Parser;\n}();\n\nfunction setLastCmd(a, b, cmdHistory) {\n  cmdHistory.a = a;\n  cmdHistory.b = b;\n}\n\nfunction hasCmdRepeated(a, b, cmdHistory) {\n  return cmdHistory.a === a && cmdHistory.b === b;\n}\n\nfunction createCmdHistory() {\n  return {\n    a: null,\n    b: null\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Cea608Parser);\n\n/***/ }),\n\n/***/ \"./src/utils/codecs.ts\":\n/*!*****************************!*\\\n  !*** ./src/utils/codecs.ts ***!\n  \\*****************************/\n/*! exports provided: isCodecType, isCodecSupportedInMp4 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_910664__) {\n\n\"use strict\";\n__nested_webpack_require_910664__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_910664__.d(__webpack_exports__, \"isCodecType\", function() { return isCodecType; });\n/* harmony export (binding) */ __nested_webpack_require_910664__.d(__webpack_exports__, \"isCodecSupportedInMp4\", function() { return isCodecSupportedInMp4; });\n// from http://mp4ra.org/codecs.html\nvar sampleEntryCodesISO = {\n  audio: {\n    a3ds: true,\n    'ac-3': true,\n    'ac-4': true,\n    alac: true,\n    alaw: true,\n    dra1: true,\n    'dts+': true,\n    'dts-': true,\n    dtsc: true,\n    dtse: true,\n    dtsh: true,\n    'ec-3': true,\n    enca: true,\n    g719: true,\n    g726: true,\n    m4ae: true,\n    mha1: true,\n    mha2: true,\n    mhm1: true,\n    mhm2: true,\n    mlpa: true,\n    mp4a: true,\n    'raw ': true,\n    Opus: true,\n    samr: true,\n    sawb: true,\n    sawp: true,\n    sevc: true,\n    sqcp: true,\n    ssmv: true,\n    twos: true,\n    ulaw: true\n  },\n  video: {\n    avc1: true,\n    avc2: true,\n    avc3: true,\n    avc4: true,\n    avcp: true,\n    av01: true,\n    drac: true,\n    dvav: true,\n    dvhe: true,\n    encv: true,\n    hev1: true,\n    hvc1: true,\n    mjp2: true,\n    mp4v: true,\n    mvc1: true,\n    mvc2: true,\n    mvc3: true,\n    mvc4: true,\n    resv: true,\n    rv60: true,\n    s263: true,\n    svc1: true,\n    svc2: true,\n    'vc-1': true,\n    vp08: true,\n    vp09: true\n  },\n  text: {\n    stpp: true,\n    wvtt: true\n  }\n};\nfunction isCodecType(codec, type) {\n  var typeCodes = sampleEntryCodesISO[type];\n  return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;\n}\nfunction isCodecSupportedInMp4(codec, type) {\n  return MediaSource.isTypeSupported((type || 'video') + \"/mp4;codecs=\\\"\" + codec + \"\\\"\");\n}\n\n/***/ }),\n\n/***/ \"./src/utils/cues.ts\":\n/*!***************************!*\\\n  !*** ./src/utils/cues.ts ***!\n  \\***************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_912605__) {\n\n\"use strict\";\n__nested_webpack_require_912605__.r(__webpack_exports__);\n/* harmony import */ var _vttparser__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_912605__(/*! ./vttparser */ \"./src/utils/vttparser.ts\");\n/* harmony import */ var _webvtt_parser__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_912605__(/*! ./webvtt-parser */ \"./src/utils/webvtt-parser.ts\");\n/* harmony import */ var _texttrack_utils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_912605__(/*! ./texttrack-utils */ \"./src/utils/texttrack-utils.ts\");\n\n\n\nvar WHITESPACE_CHAR = /\\s/;\nvar Cues = {\n  newCue: function newCue(track, startTime, endTime, captionScreen) {\n    var result = [];\n    var row; // the type data states this is VTTCue, but it can potentially be a TextTrackCue on old browsers\n\n    var cue;\n    var indenting;\n    var indent;\n    var text;\n    var Cue = self.VTTCue || self.TextTrackCue;\n\n    for (var r = 0; r < captionScreen.rows.length; r++) {\n      row = captionScreen.rows[r];\n      indenting = true;\n      indent = 0;\n      text = '';\n\n      if (!row.isEmpty()) {\n        for (var c = 0; c < row.chars.length; c++) {\n          if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {\n            indent++;\n          } else {\n            text += row.chars[c].uchar;\n            indenting = false;\n          }\n        } // To be used for cleaning-up orphaned roll-up captions\n\n\n        row.cueStartTime = startTime; // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE\n\n        if (startTime === endTime) {\n          endTime += 0.0001;\n        }\n\n        if (indent >= 16) {\n          indent--;\n        } else {\n          indent++;\n        }\n\n        var cueText = Object(_vttparser__WEBPACK_IMPORTED_MODULE_0__[\"fixLineBreaks\"])(text.trim());\n        var id = Object(_webvtt_parser__WEBPACK_IMPORTED_MODULE_1__[\"generateCueId\"])(startTime, endTime, cueText); // If this cue already exists in the track do not push it\n\n        if (!track || !track.cues || !track.cues.getCueById(id)) {\n          cue = new Cue(startTime, endTime, cueText);\n          cue.id = id;\n          cue.line = r + 1;\n          cue.align = 'left'; // Clamp the position between 10 and 80 percent (CEA-608 PAC indent code)\n          // https://dvcs.w3.org/hg/text-tracks/raw-file/default/608toVTT/608toVTT.html#positioning-in-cea-608\n          // Firefox throws an exception and captions break with out of bounds 0-100 values\n\n          cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);\n          result.push(cue);\n        }\n      }\n    }\n\n    if (track && result.length) {\n      // Sort bottom cues in reverse order so that they render in line order when overlapping in Chrome\n      result.sort(function (cueA, cueB) {\n        if (cueA.line === 'auto' || cueB.line === 'auto') {\n          return 0;\n        }\n\n        if (cueA.line > 8 && cueB.line > 8) {\n          return cueB.line - cueA.line;\n        }\n\n        return cueA.line - cueB.line;\n      });\n      result.forEach(function (cue) {\n        return Object(_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__[\"addCueToTrack\"])(track, cue);\n      });\n    }\n\n    return result;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Cues);\n\n/***/ }),\n\n/***/ \"./src/utils/discontinuities.ts\":\n/*!**************************************!*\\\n  !*** ./src/utils/discontinuities.ts ***!\n  \\**************************************/\n/*! exports provided: findFirstFragWithCC, shouldAlignOnDiscontinuities, findDiscontinuousReferenceFrag, adjustSlidingStart, alignStream, alignPDT, alignFragmentByPDTDelta, alignMediaPlaylistByPDT */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_916262__) {\n\n\"use strict\";\n__nested_webpack_require_916262__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_916262__.d(__webpack_exports__, \"findFirstFragWithCC\", function() { return findFirstFragWithCC; });\n/* harmony export (binding) */ __nested_webpack_require_916262__.d(__webpack_exports__, \"shouldAlignOnDiscontinuities\", function() { return shouldAlignOnDiscontinuities; });\n/* harmony export (binding) */ __nested_webpack_require_916262__.d(__webpack_exports__, \"findDiscontinuousReferenceFrag\", function() { return findDiscontinuousReferenceFrag; });\n/* harmony export (binding) */ __nested_webpack_require_916262__.d(__webpack_exports__, \"adjustSlidingStart\", function() { return adjustSlidingStart; });\n/* harmony export (binding) */ __nested_webpack_require_916262__.d(__webpack_exports__, \"alignStream\", function() { return alignStream; });\n/* harmony export (binding) */ __nested_webpack_require_916262__.d(__webpack_exports__, \"alignPDT\", function() { return alignPDT; });\n/* harmony export (binding) */ __nested_webpack_require_916262__.d(__webpack_exports__, \"alignFragmentByPDTDelta\", function() { return alignFragmentByPDTDelta; });\n/* harmony export (binding) */ __nested_webpack_require_916262__.d(__webpack_exports__, \"alignMediaPlaylistByPDT\", function() { return alignMediaPlaylistByPDT; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_916262__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_916262__(/*! ./logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _controller_level_helper__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_916262__(/*! ../controller/level-helper */ \"./src/controller/level-helper.ts\");\n\n\n\n\nfunction findFirstFragWithCC(fragments, cc) {\n  var firstFrag = null;\n\n  for (var i = 0, len = fragments.length; i < len; i++) {\n    var currentFrag = fragments[i];\n\n    if (currentFrag && currentFrag.cc === cc) {\n      firstFrag = currentFrag;\n      break;\n    }\n  }\n\n  return firstFrag;\n}\nfunction shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {\n  if (lastLevel.details) {\n    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {\n      return true;\n    }\n  }\n\n  return false;\n} // Find the first frag in the previous level which matches the CC of the first frag of the new level\n\nfunction findDiscontinuousReferenceFrag(prevDetails, curDetails) {\n  var prevFrags = prevDetails.fragments;\n  var curFrags = curDetails.fragments;\n\n  if (!curFrags.length || !prevFrags.length) {\n    _logger__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].log('No fragments to align');\n    return;\n  }\n\n  var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);\n\n  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {\n    _logger__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].log('No frag in previous level to align on');\n    return;\n  }\n\n  return prevStartFrag;\n}\n\nfunction adjustFragmentStart(frag, sliding) {\n  if (frag) {\n    var start = frag.start + sliding;\n    frag.start = frag.startPTS = start;\n    frag.endPTS = start + frag.duration;\n  }\n}\n\nfunction adjustSlidingStart(sliding, details) {\n  // Update segments\n  var fragments = details.fragments;\n\n  for (var i = 0, len = fragments.length; i < len; i++) {\n    adjustFragmentStart(fragments[i], sliding);\n  } // Update LL-HLS parts at the end of the playlist\n\n\n  if (details.fragmentHint) {\n    adjustFragmentStart(details.fragmentHint, sliding);\n  }\n\n  details.alignedSliding = true;\n}\n/**\n * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a\n * contiguous stream with the last fragments.\n * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to\n * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time\n * and an extra download.\n * @param lastFrag\n * @param lastLevel\n * @param details\n */\n\nfunction alignStream(lastFrag, lastLevel, details) {\n  if (!lastLevel) {\n    return;\n  }\n\n  alignDiscontinuities(lastFrag, details, lastLevel);\n\n  if (!details.alignedSliding && lastLevel.details) {\n    // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.\n    // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same\n    // discontinuity sequence.\n    alignPDT(details, lastLevel.details);\n  }\n\n  if (!details.alignedSliding && lastLevel.details && !details.skippedSegments) {\n    // Try to align on sn so that we pick a better start fragment.\n    // Do not perform this on playlists with delta updates as this is only to align levels on switch\n    // and adjustSliding only adjusts fragments after skippedSegments.\n    Object(_controller_level_helper__WEBPACK_IMPORTED_MODULE_2__[\"adjustSliding\"])(lastLevel.details, details);\n  }\n}\n/**\n * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same\n * discontinuity sequence.\n * @param lastFrag - The last Fragment which shares the same discontinuity sequence\n * @param lastLevel - The details of the last loaded level\n * @param details - The details of the new level\n */\n\nfunction alignDiscontinuities(lastFrag, details, lastLevel) {\n  if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {\n    var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);\n\n    if (referenceFrag && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(referenceFrag.start)) {\n      _logger__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].log(\"Adjusting PTS using last level due to CC increase within current level \" + details.url);\n      adjustSlidingStart(referenceFrag.start, details);\n    }\n  }\n}\n/**\n * Computes the PTS of a new level's fragments using the difference in Program Date Time from the last level.\n * @param details - The details of the new level\n * @param lastDetails - The details of the last loaded level\n */\n\n\nfunction alignPDT(details, lastDetails) {\n  // This check protects the unsafe \"!\" usage below for null program date time access.\n  if (!lastDetails.fragments.length || !details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {\n    return;\n  } // if last level sliding is 1000 and its first frag PROGRAM-DATE-TIME is 2017-08-20 1:10:00 AM\n  // and if new details first frag PROGRAM DATE-TIME is 2017-08-20 1:10:08 AM\n  // then we can deduce that playlist B sliding is 1000+8 = 1008s\n\n\n  var lastPDT = lastDetails.fragments[0].programDateTime; // hasProgramDateTime check above makes this safe.\n\n  var newPDT = details.fragments[0].programDateTime; // date diff is in ms. frag.start is in seconds\n\n  var sliding = (newPDT - lastPDT) / 1000 + lastDetails.fragments[0].start;\n\n  if (sliding && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(sliding)) {\n    _logger__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].log(\"Adjusting PTS using programDateTime delta \" + (newPDT - lastPDT) + \"ms, sliding:\" + sliding.toFixed(3) + \" \" + details.url + \" \");\n    adjustSlidingStart(sliding, details);\n  }\n}\nfunction alignFragmentByPDTDelta(frag, delta) {\n  var programDateTime = frag.programDateTime;\n  if (!programDateTime) return;\n  var start = (programDateTime - delta) / 1000;\n  frag.start = frag.startPTS = start;\n  frag.endPTS = start + frag.duration;\n}\n/**\n * Ensures appropriate time-alignment between renditions based on PDT. Unlike `alignPDT`, which adjusts\n * the timeline based on the delta between PDTs of the 0th fragment of two playlists/`LevelDetails`,\n * this function assumes the timelines represented in `refDetails` are accurate, including the PDTs,\n * and uses the \"wallclock\"/PDT timeline as a cross-reference to `details`, adjusting the presentation\n * times/timelines of `details` accordingly.\n * Given the asynchronous nature of fetches and initial loads of live `main` and audio/subtitle tracks,\n * the primary purpose of this function is to ensure the \"local timelines\" of audio/subtitle tracks\n * are aligned to the main/video timeline, using PDT as the cross-reference/\"anchor\" that should\n * be consistent across playlists, per the HLS spec.\n * @param details - The details of the rendition you'd like to time-align (e.g. an audio rendition).\n * @param refDetails - The details of the reference rendition with start and PDT times for alignment.\n */\n\nfunction alignMediaPlaylistByPDT(details, refDetails) {\n  // This check protects the unsafe \"!\" usage below for null program date time access.\n  if (!refDetails.fragments.length || !details.hasProgramDateTime || !refDetails.hasProgramDateTime) {\n    return;\n  }\n\n  var refPDT = refDetails.fragments[0].programDateTime; // hasProgramDateTime check above makes this safe.\n\n  var refStart = refDetails.fragments[0].start; // Use the delta between the reference details' presentation timeline's start time and its PDT\n  // to align the other rendition's timeline.\n\n  var delta = refPDT - refStart * 1000; // Per spec: \"If any Media Playlist in a Master Playlist contains an EXT-X-PROGRAM-DATE-TIME tag, then all\n  // Media Playlists in that Master Playlist MUST contain EXT-X-PROGRAM-DATE-TIME tags with consistent mappings\n  // of date and time to media timestamps.\"\n  // So we should be able to use each rendition's PDT as a reference time and use the delta to compute our relevant\n  // start and end times.\n  // NOTE: This code assumes each level/details timelines have already been made \"internally consistent\"\n\n  details.fragments.forEach(function (frag) {\n    alignFragmentByPDTDelta(frag, delta);\n  });\n\n  if (details.fragmentHint) {\n    alignFragmentByPDTDelta(details.fragmentHint, delta);\n  }\n\n  details.alignedSliding = true;\n}\n\n/***/ }),\n\n/***/ \"./src/utils/ewma-bandwidth-estimator.ts\":\n/*!***********************************************!*\\\n  !*** ./src/utils/ewma-bandwidth-estimator.ts ***!\n  \\***********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_926421__) {\n\n\"use strict\";\n__nested_webpack_require_926421__.r(__webpack_exports__);\n/* harmony import */ var _utils_ewma__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_926421__(/*! ../utils/ewma */ \"./src/utils/ewma.ts\");\n/*\n * EWMA Bandwidth Estimator\n *  - heavily inspired from shaka-player\n * Tracks bandwidth samples and estimates available bandwidth.\n * Based on the minimum of two exponentially-weighted moving averages with\n * different half-lives.\n */\n\n\nvar EwmaBandWidthEstimator = /*#__PURE__*/function () {\n  function EwmaBandWidthEstimator(slow, fast, defaultEstimate) {\n    this.defaultEstimate_ = void 0;\n    this.minWeight_ = void 0;\n    this.minDelayMs_ = void 0;\n    this.slow_ = void 0;\n    this.fast_ = void 0;\n    this.defaultEstimate_ = defaultEstimate;\n    this.minWeight_ = 0.001;\n    this.minDelayMs_ = 50;\n    this.slow_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__[\"default\"](slow);\n    this.fast_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__[\"default\"](fast);\n  }\n\n  var _proto = EwmaBandWidthEstimator.prototype;\n\n  _proto.update = function update(slow, fast) {\n    var slow_ = this.slow_,\n        fast_ = this.fast_;\n\n    if (this.slow_.halfLife !== slow) {\n      this.slow_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__[\"default\"](slow, slow_.getEstimate(), slow_.getTotalWeight());\n    }\n\n    if (this.fast_.halfLife !== fast) {\n      this.fast_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__[\"default\"](fast, fast_.getEstimate(), fast_.getTotalWeight());\n    }\n  };\n\n  _proto.sample = function sample(durationMs, numBytes) {\n    durationMs = Math.max(durationMs, this.minDelayMs_);\n    var numBits = 8 * numBytes; // weight is duration in seconds\n\n    var durationS = durationMs / 1000; // value is bandwidth in bits/s\n\n    var bandwidthInBps = numBits / durationS;\n    this.fast_.sample(durationS, bandwidthInBps);\n    this.slow_.sample(durationS, bandwidthInBps);\n  };\n\n  _proto.canEstimate = function canEstimate() {\n    var fast = this.fast_;\n    return fast && fast.getTotalWeight() >= this.minWeight_;\n  };\n\n  _proto.getEstimate = function getEstimate() {\n    if (this.canEstimate()) {\n      // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));\n      // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));\n      // Take the minimum of these two estimates.  This should have the effect of\n      // adapting down quickly, but up more slowly.\n      return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n    } else {\n      return this.defaultEstimate_;\n    }\n  };\n\n  _proto.destroy = function destroy() {};\n\n  return EwmaBandWidthEstimator;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (EwmaBandWidthEstimator);\n\n/***/ }),\n\n/***/ \"./src/utils/ewma.ts\":\n/*!***************************!*\\\n  !*** ./src/utils/ewma.ts ***!\n  \\***************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_929357__) {\n\n\"use strict\";\n__nested_webpack_require_929357__.r(__webpack_exports__);\n/*\n * compute an Exponential Weighted moving average\n * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n *  - heavily inspired from shaka-player\n */\nvar EWMA = /*#__PURE__*/function () {\n  //  About half of the estimated value will be from the last |halfLife| samples by weight.\n  function EWMA(halfLife, estimate, weight) {\n    if (estimate === void 0) {\n      estimate = 0;\n    }\n\n    if (weight === void 0) {\n      weight = 0;\n    }\n\n    this.halfLife = void 0;\n    this.alpha_ = void 0;\n    this.estimate_ = void 0;\n    this.totalWeight_ = void 0;\n    this.halfLife = halfLife; // Larger values of alpha expire historical data more slowly.\n\n    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;\n    this.estimate_ = estimate;\n    this.totalWeight_ = weight;\n  }\n\n  var _proto = EWMA.prototype;\n\n  _proto.sample = function sample(weight, value) {\n    var adjAlpha = Math.pow(this.alpha_, weight);\n    this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n    this.totalWeight_ += weight;\n  };\n\n  _proto.getTotalWeight = function getTotalWeight() {\n    return this.totalWeight_;\n  };\n\n  _proto.getEstimate = function getEstimate() {\n    if (this.alpha_) {\n      var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n\n      if (zeroFactor) {\n        return this.estimate_ / zeroFactor;\n      }\n    }\n\n    return this.estimate_;\n  };\n\n  return EWMA;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (EWMA);\n\n/***/ }),\n\n/***/ \"./src/utils/fetch-loader.ts\":\n/*!***********************************!*\\\n  !*** ./src/utils/fetch-loader.ts ***!\n  \\***********************************/\n/*! exports provided: fetchSupported, default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_931195__) {\n\n\"use strict\";\n__nested_webpack_require_931195__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_931195__.d(__webpack_exports__, \"fetchSupported\", function() { return fetchSupported; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_931195__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_931195__(/*! ../loader/load-stats */ \"./src/loader/load-stats.ts\");\n/* harmony import */ var _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_931195__(/*! ../demux/chunk-cache */ \"./src/demux/chunk-cache.ts\");\n\n\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\nfunction fetchSupported() {\n  if ( // @ts-ignore\n  self.fetch && self.AbortController && self.ReadableStream && self.Request) {\n    try {\n      new self.ReadableStream({}); // eslint-disable-line no-new\n\n      return true;\n    } catch (e) {\n      /* noop */\n    }\n  }\n\n  return false;\n}\n\nvar FetchLoader = /*#__PURE__*/function () {\n  function FetchLoader(config\n  /* HlsConfig */\n  ) {\n    this.fetchSetup = void 0;\n    this.requestTimeout = void 0;\n    this.request = void 0;\n    this.response = void 0;\n    this.controller = void 0;\n    this.context = void 0;\n    this.config = null;\n    this.callbacks = null;\n    this.stats = void 0;\n    this.loader = null;\n    this.fetchSetup = config.fetchSetup || getRequest;\n    this.controller = new self.AbortController();\n    this.stats = new _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__[\"LoadStats\"]();\n  }\n\n  var _proto = FetchLoader.prototype;\n\n  _proto.destroy = function destroy() {\n    this.loader = this.callbacks = null;\n    this.abortInternal();\n  };\n\n  _proto.abortInternal = function abortInternal() {\n    var response = this.response;\n\n    if (!response || !response.ok) {\n      this.stats.aborted = true;\n      this.controller.abort();\n    }\n  };\n\n  _proto.abort = function abort() {\n    var _this$callbacks;\n\n    this.abortInternal();\n\n    if ((_this$callbacks = this.callbacks) !== null && _this$callbacks !== void 0 && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.response);\n    }\n  };\n\n  _proto.load = function load(context, config, callbacks) {\n    var _this = this;\n\n    var stats = this.stats;\n\n    if (stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n\n    stats.loading.start = self.performance.now();\n    var initParams = getRequestParameters(context, this.controller.signal);\n    var onProgress = callbacks.onProgress;\n    var isArrayBuffer = context.responseType === 'arraybuffer';\n    var LENGTH = isArrayBuffer ? 'byteLength' : 'length';\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.request = this.fetchSetup(context, initParams);\n    self.clearTimeout(this.requestTimeout);\n    this.requestTimeout = self.setTimeout(function () {\n      _this.abortInternal();\n\n      callbacks.onTimeout(stats, context, _this.response);\n    }, config.timeout);\n    self.fetch(this.request).then(function (response) {\n      _this.response = _this.loader = response;\n\n      if (!response.ok) {\n        var status = response.status,\n            statusText = response.statusText;\n        throw new FetchError(statusText || 'fetch, bad network response', status, response);\n      }\n\n      stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n      stats.total = parseInt(response.headers.get('Content-Length') || '0');\n\n      if (onProgress && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(config.highWaterMark)) {\n        return _this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);\n      }\n\n      if (isArrayBuffer) {\n        return response.arrayBuffer();\n      }\n\n      return response.text();\n    }).then(function (responseData) {\n      var response = _this.response;\n      self.clearTimeout(_this.requestTimeout);\n      stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n      stats.loaded = stats.total = responseData[LENGTH];\n      var loaderResponse = {\n        url: response.url,\n        data: responseData\n      };\n\n      if (onProgress && !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(config.highWaterMark)) {\n        onProgress(stats, context, responseData, response);\n      }\n\n      callbacks.onSuccess(loaderResponse, stats, context, response);\n    }).catch(function (error) {\n      self.clearTimeout(_this.requestTimeout);\n\n      if (stats.aborted) {\n        return;\n      } // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior\n      // when destroying, 'error' itself can be undefined\n\n\n      var code = !error ? 0 : error.code || 0;\n      var text = !error ? null : error.message;\n      callbacks.onError({\n        code: code,\n        text: text\n      }, context, error ? error.details : null);\n    });\n  };\n\n  _proto.getCacheAge = function getCacheAge() {\n    var result = null;\n\n    if (this.response) {\n      var ageHeader = this.response.headers.get('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n\n    return result;\n  };\n\n  _proto.loadProgressively = function loadProgressively(response, stats, context, highWaterMark, onProgress) {\n    if (highWaterMark === void 0) {\n      highWaterMark = 0;\n    }\n\n    var chunkCache = new _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n    var reader = response.body.getReader();\n\n    var pump = function pump() {\n      return reader.read().then(function (data) {\n        if (data.done) {\n          if (chunkCache.dataLength) {\n            onProgress(stats, context, chunkCache.flush(), response);\n          }\n\n          return Promise.resolve(new ArrayBuffer(0));\n        }\n\n        var chunk = data.value;\n        var len = chunk.length;\n        stats.loaded += len;\n\n        if (len < highWaterMark || chunkCache.dataLength) {\n          // The current chunk is too small to to be emitted or the cache already has data\n          // Push it to the cache\n          chunkCache.push(chunk);\n\n          if (chunkCache.dataLength >= highWaterMark) {\n            // flush in order to join the typed arrays\n            onProgress(stats, context, chunkCache.flush(), response);\n          }\n        } else {\n          // If there's nothing cached already, and the chache is large enough\n          // just emit the progress event\n          onProgress(stats, context, chunk, response);\n        }\n\n        return pump();\n      }).catch(function () {\n        /* aborted */\n        return Promise.reject();\n      });\n    };\n\n    return pump();\n  };\n\n  return FetchLoader;\n}();\n\nfunction getRequestParameters(context, signal) {\n  var initParams = {\n    method: 'GET',\n    mode: 'cors',\n    credentials: 'same-origin',\n    signal: signal,\n    headers: new self.Headers(_extends({}, context.headers))\n  };\n\n  if (context.rangeEnd) {\n    initParams.headers.set('Range', 'bytes=' + context.rangeStart + '-' + String(context.rangeEnd - 1));\n  }\n\n  return initParams;\n}\n\nfunction getRequest(context, initParams) {\n  return new self.Request(context.url, initParams);\n}\n\nvar FetchError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(FetchError, _Error);\n\n  function FetchError(message, code, details) {\n    var _this2;\n\n    _this2 = _Error.call(this, message) || this;\n    _this2.code = void 0;\n    _this2.details = void 0;\n    _this2.code = code;\n    _this2.details = details;\n    return _this2;\n  }\n\n  return FetchError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (FetchLoader);\n\n/***/ }),\n\n/***/ \"./src/utils/imsc1-ttml-parser.ts\":\n/*!****************************************!*\\\n  !*** ./src/utils/imsc1-ttml-parser.ts ***!\n  \\****************************************/\n/*! exports provided: IMSC1_CODEC, parseIMSC1 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_941813__) {\n\n\"use strict\";\n__nested_webpack_require_941813__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_941813__.d(__webpack_exports__, \"IMSC1_CODEC\", function() { return IMSC1_CODEC; });\n/* harmony export (binding) */ __nested_webpack_require_941813__.d(__webpack_exports__, \"parseIMSC1\", function() { return parseIMSC1; });\n/* harmony import */ var _mp4_tools__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_941813__(/*! ./mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _vttparser__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_941813__(/*! ./vttparser */ \"./src/utils/vttparser.ts\");\n/* harmony import */ var _vttcue__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_941813__(/*! ./vttcue */ \"./src/utils/vttcue.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_941813__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\n/* harmony import */ var _timescale_conversion__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_941813__(/*! ./timescale-conversion */ \"./src/utils/timescale-conversion.ts\");\n/* harmony import */ var _webvtt_parser__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_941813__(/*! ./webvtt-parser */ \"./src/utils/webvtt-parser.ts\");\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\n\n\n\n\nvar IMSC1_CODEC = 'stpp.ttml.im1t'; // Time format: h:m:s:frames(.subframes)\n\nvar HMSF_REGEX = /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/; // Time format: hours, minutes, seconds, milliseconds, frames, ticks\n\nvar TIME_UNIT_REGEX = /^(\\d*(?:\\.\\d*)?)(h|m|s|ms|f|t)$/;\nvar textAlignToLineAlign = {\n  left: 'start',\n  center: 'center',\n  right: 'end',\n  start: 'start',\n  end: 'end'\n};\nfunction parseIMSC1(payload, initPTS, timescale, callBack, errorCallBack) {\n  var results = Object(_mp4_tools__WEBPACK_IMPORTED_MODULE_0__[\"findBox\"])(new Uint8Array(payload), ['mdat']);\n\n  if (results.length === 0) {\n    errorCallBack(new Error('Could not parse IMSC1 mdat'));\n    return;\n  }\n\n  var ttmlList = results.map(function (mdat) {\n    return Object(_demux_id3__WEBPACK_IMPORTED_MODULE_3__[\"utf8ArrayToStr\"])(mdat);\n  });\n  var syncTime = Object(_timescale_conversion__WEBPACK_IMPORTED_MODULE_4__[\"toTimescaleFromScale\"])(initPTS, 1, timescale);\n\n  try {\n    ttmlList.forEach(function (ttml) {\n      return callBack(parseTTML(ttml, syncTime));\n    });\n  } catch (error) {\n    errorCallBack(error);\n  }\n}\n\nfunction parseTTML(ttml, syncTime) {\n  var parser = new DOMParser();\n  var xmlDoc = parser.parseFromString(ttml, 'text/xml');\n  var tt = xmlDoc.getElementsByTagName('tt')[0];\n\n  if (!tt) {\n    throw new Error('Invalid ttml');\n  }\n\n  var defaultRateInfo = {\n    frameRate: 30,\n    subFrameRate: 1,\n    frameRateMultiplier: 0,\n    tickRate: 0\n  };\n  var rateInfo = Object.keys(defaultRateInfo).reduce(function (result, key) {\n    result[key] = tt.getAttribute(\"ttp:\" + key) || defaultRateInfo[key];\n    return result;\n  }, {});\n  var trim = tt.getAttribute('xml:space') !== 'preserve';\n  var styleElements = collectionToDictionary(getElementCollection(tt, 'styling', 'style'));\n  var regionElements = collectionToDictionary(getElementCollection(tt, 'layout', 'region'));\n  var cueElements = getElementCollection(tt, 'body', '[begin]');\n  return [].map.call(cueElements, function (cueElement) {\n    var cueText = getTextContent(cueElement, trim);\n\n    if (!cueText || !cueElement.hasAttribute('begin')) {\n      return null;\n    }\n\n    var startTime = parseTtmlTime(cueElement.getAttribute('begin'), rateInfo);\n    var duration = parseTtmlTime(cueElement.getAttribute('dur'), rateInfo);\n    var endTime = parseTtmlTime(cueElement.getAttribute('end'), rateInfo);\n\n    if (startTime === null) {\n      throw timestampParsingError(cueElement);\n    }\n\n    if (endTime === null) {\n      if (duration === null) {\n        throw timestampParsingError(cueElement);\n      }\n\n      endTime = startTime + duration;\n    }\n\n    var cue = new _vttcue__WEBPACK_IMPORTED_MODULE_2__[\"default\"](startTime - syncTime, endTime - syncTime, cueText);\n    cue.id = Object(_webvtt_parser__WEBPACK_IMPORTED_MODULE_5__[\"generateCueId\"])(cue.startTime, cue.endTime, cue.text);\n    var region = regionElements[cueElement.getAttribute('region')];\n    var style = styleElements[cueElement.getAttribute('style')]; // TODO: Add regions to track and cue (origin and extend)\n    // These values are hard-coded (for now) to simulate region settings in the demo\n\n    cue.position = 10;\n    cue.size = 80; // Apply styles to cue\n\n    var styles = getTtmlStyles(region, style, styleElements);\n    var textAlign = styles.textAlign;\n\n    if (textAlign) {\n      // cue.positionAlign not settable in FF~2016\n      var lineAlign = textAlignToLineAlign[textAlign];\n\n      if (lineAlign) {\n        cue.lineAlign = lineAlign;\n      }\n\n      cue.align = textAlign;\n    }\n\n    _extends(cue, styles);\n\n    return cue;\n  }).filter(function (cue) {\n    return cue !== null;\n  });\n}\n\nfunction getElementCollection(fromElement, parentName, childName) {\n  var parent = fromElement.getElementsByTagName(parentName)[0];\n\n  if (parent) {\n    return [].slice.call(parent.querySelectorAll(childName));\n  }\n\n  return [];\n}\n\nfunction collectionToDictionary(elementsWithId) {\n  return elementsWithId.reduce(function (dict, element) {\n    var id = element.getAttribute('xml:id');\n\n    if (id) {\n      dict[id] = element;\n    }\n\n    return dict;\n  }, {});\n}\n\nfunction getTextContent(element, trim) {\n  return [].slice.call(element.childNodes).reduce(function (str, node, i) {\n    var _node$childNodes;\n\n    if (node.nodeName === 'br' && i) {\n      return str + '\\n';\n    }\n\n    if ((_node$childNodes = node.childNodes) !== null && _node$childNodes !== void 0 && _node$childNodes.length) {\n      return getTextContent(node, trim);\n    } else if (trim) {\n      return str + node.textContent.trim().replace(/\\s+/g, ' ');\n    }\n\n    return str + node.textContent;\n  }, '');\n}\n\nfunction getTtmlStyles(region, style, styleElements) {\n  var ttsNs = 'http://www.w3.org/ns/ttml#styling';\n  var regionStyle = null;\n  var styleAttributes = ['displayAlign', 'textAlign', 'color', 'backgroundColor', 'fontSize', 'fontFamily' // 'fontWeight',\n  // 'lineHeight',\n  // 'wrapOption',\n  // 'fontStyle',\n  // 'direction',\n  // 'writingMode'\n  ];\n  var regionStyleName = region !== null && region !== void 0 && region.hasAttribute('style') ? region.getAttribute('style') : null;\n\n  if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {\n    regionStyle = styleElements[regionStyleName];\n  }\n\n  return styleAttributes.reduce(function (styles, name) {\n    var value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);\n\n    if (value) {\n      styles[name] = value;\n    }\n\n    return styles;\n  }, {});\n}\n\nfunction getAttributeNS(element, ns, name) {\n  if (!element) {\n    return null;\n  }\n\n  return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;\n}\n\nfunction timestampParsingError(node) {\n  return new Error(\"Could not parse ttml timestamp \" + node);\n}\n\nfunction parseTtmlTime(timeAttributeValue, rateInfo) {\n  if (!timeAttributeValue) {\n    return null;\n  }\n\n  var seconds = Object(_vttparser__WEBPACK_IMPORTED_MODULE_1__[\"parseTimeStamp\"])(timeAttributeValue);\n\n  if (seconds === null) {\n    if (HMSF_REGEX.test(timeAttributeValue)) {\n      seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);\n    } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {\n      seconds = parseTimeUnits(timeAttributeValue, rateInfo);\n    }\n  }\n\n  return seconds;\n}\n\nfunction parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {\n  var m = HMSF_REGEX.exec(timeAttributeValue);\n  var frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;\n  return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;\n}\n\nfunction parseTimeUnits(timeAttributeValue, rateInfo) {\n  var m = TIME_UNIT_REGEX.exec(timeAttributeValue);\n  var value = Number(m[1]);\n  var unit = m[2];\n\n  switch (unit) {\n    case 'h':\n      return value * 3600;\n\n    case 'm':\n      return value * 60;\n\n    case 'ms':\n      return value * 1000;\n\n    case 'f':\n      return value / rateInfo.frameRate;\n\n    case 't':\n      return value / rateInfo.tickRate;\n  }\n\n  return value;\n}\n\n/***/ }),\n\n/***/ \"./src/utils/logger.ts\":\n/*!*****************************!*\\\n  !*** ./src/utils/logger.ts ***!\n  \\*****************************/\n/*! exports provided: enableLogs, logger */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_950564__) {\n\n\"use strict\";\n__nested_webpack_require_950564__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_950564__.d(__webpack_exports__, \"enableLogs\", function() { return enableLogs; });\n/* harmony export (binding) */ __nested_webpack_require_950564__.d(__webpack_exports__, \"logger\", function() { return logger; });\nvar noop = function noop() {};\n\nvar fakeLogger = {\n  trace: noop,\n  debug: noop,\n  log: noop,\n  warn: noop,\n  info: noop,\n  error: noop\n};\nvar exportedLogger = fakeLogger; // let lastCallTime;\n// function formatMsgWithTimeInfo(type, msg) {\n//   const now = Date.now();\n//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n//   lastCallTime = now;\n//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n//   return msg;\n// }\n\nfunction consolePrintFn(type) {\n  var func = self.console[type];\n\n  if (func) {\n    return func.bind(self.console, \"[\" + type + \"] >\");\n  }\n\n  return noop;\n}\n\nfunction exportLoggerFunctions(debugConfig) {\n  for (var _len = arguments.length, functions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    functions[_key - 1] = arguments[_key];\n  }\n\n  functions.forEach(function (type) {\n    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);\n  });\n}\n\nfunction enableLogs(debugConfig) {\n  // check that console is available\n  if (self.console && debugConfig === true || typeof debugConfig === 'object') {\n    exportLoggerFunctions(debugConfig, // Remove out from list here to hard-disable a log-level\n    // 'trace',\n    'debug', 'log', 'info', 'warn', 'error'); // Some browsers don't allow to use bind on console object anyway\n    // fallback to default if needed\n\n    try {\n      exportedLogger.log();\n    } catch (e) {\n      exportedLogger = fakeLogger;\n    }\n  } else {\n    exportedLogger = fakeLogger;\n  }\n}\nvar logger = exportedLogger;\n\n/***/ }),\n\n/***/ \"./src/utils/mediakeys-helper.ts\":\n/*!***************************************!*\\\n  !*** ./src/utils/mediakeys-helper.ts ***!\n  \\***************************************/\n/*! exports provided: KeySystems, requestMediaKeySystemAccess */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_952781__) {\n\n\"use strict\";\n__nested_webpack_require_952781__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_952781__.d(__webpack_exports__, \"KeySystems\", function() { return KeySystems; });\n/* harmony export (binding) */ __nested_webpack_require_952781__.d(__webpack_exports__, \"requestMediaKeySystemAccess\", function() { return requestMediaKeySystemAccess; });\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess\n */\nvar KeySystems;\n\n(function (KeySystems) {\n  KeySystems[\"WIDEVINE\"] = \"com.widevine.alpha\";\n  KeySystems[\"PLAYREADY\"] = \"com.microsoft.playready\";\n})(KeySystems || (KeySystems = {}));\n\nvar requestMediaKeySystemAccess = function () {\n  if (typeof self !== 'undefined' && self.navigator && self.navigator.requestMediaKeySystemAccess) {\n    return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);\n  } else {\n    return null;\n  }\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/utils/mediasource-helper.ts\":\n/*!*****************************************!*\\\n  !*** ./src/utils/mediasource-helper.ts ***!\n  \\*****************************************/\n/*! exports provided: getMediaSource */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_953976__) {\n\n\"use strict\";\n__nested_webpack_require_953976__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_953976__.d(__webpack_exports__, \"getMediaSource\", function() { return getMediaSource; });\n/**\n * MediaSource helper\n */\nfunction getMediaSource() {\n  return self.MediaSource || self.WebKitMediaSource;\n}\n\n/***/ }),\n\n/***/ \"./src/utils/mp4-tools.ts\":\n/*!********************************!*\\\n  !*** ./src/utils/mp4-tools.ts ***!\n  \\********************************/\n/*! exports provided: RemuxerTrackIdConfig, bin2str, readUint16, readUint32, readSint32, writeUint32, findBox, parseSegmentIndex, parseInitSegment, getStartDTS, getDuration, computeRawDurationFromSamples, offsetStartDTS, segmentValidRange, appendUint8Array, parseSamples, parseSEIMessageFromNALu, parseEmsg */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_954817__) {\n\n\"use strict\";\n__nested_webpack_require_954817__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"RemuxerTrackIdConfig\", function() { return RemuxerTrackIdConfig; });\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"bin2str\", function() { return bin2str; });\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"readUint16\", function() { return readUint16; });\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"readUint32\", function() { return readUint32; });\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"readSint32\", function() { return readSint32; });\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"writeUint32\", function() { return writeUint32; });\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"findBox\", function() { return findBox; });\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"parseSegmentIndex\", function() { return parseSegmentIndex; });\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"parseInitSegment\", function() { return parseInitSegment; });\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"getStartDTS\", function() { return getStartDTS; });\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"getDuration\", function() { return getDuration; });\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"computeRawDurationFromSamples\", function() { return computeRawDurationFromSamples; });\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"offsetStartDTS\", function() { return offsetStartDTS; });\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"segmentValidRange\", function() { return segmentValidRange; });\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"appendUint8Array\", function() { return appendUint8Array; });\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"parseSamples\", function() { return parseSamples; });\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"parseSEIMessageFromNALu\", function() { return parseSEIMessageFromNALu; });\n/* harmony export (binding) */ __nested_webpack_require_954817__.d(__webpack_exports__, \"parseEmsg\", function() { return parseEmsg; });\n/* harmony import */ var _typed_array__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_954817__(/*! ./typed-array */ \"./src/utils/typed-array.ts\");\n/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_954817__(/*! ../loader/fragment */ \"./src/loader/fragment.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_954817__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\n\n\n\nvar UINT32_MAX = Math.pow(2, 32) - 1;\nvar push = [].push; // We are using fixed track IDs for driving the MP4 remuxer\n// instead of following the TS PIDs.\n// There is no reason not to do this and some browsers/SourceBuffer-demuxers\n// may not like if there are TrackID \"switches\"\n// See https://github.com/video-dev/hls.js/issues/1331\n// Here we are mapping our internal track types to constant MP4 track IDs\n// With MSE currently one can only have one track of each, and we are muxing\n// whatever video/audio rendition in them.\n\nvar RemuxerTrackIdConfig = {\n  video: 1,\n  audio: 2,\n  id3: 3,\n  text: 4\n};\nfunction bin2str(data) {\n  return String.fromCharCode.apply(null, data);\n}\nfunction readUint16(buffer, offset) {\n  var val = buffer[offset] << 8 | buffer[offset + 1];\n  return val < 0 ? 65536 + val : val;\n}\nfunction readUint32(buffer, offset) {\n  var val = readSint32(buffer, offset);\n  return val < 0 ? 4294967296 + val : val;\n}\nfunction readSint32(buffer, offset) {\n  return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];\n}\nfunction writeUint32(buffer, offset, value) {\n  buffer[offset] = value >> 24;\n  buffer[offset + 1] = value >> 16 & 0xff;\n  buffer[offset + 2] = value >> 8 & 0xff;\n  buffer[offset + 3] = value & 0xff;\n} // Find the data for a box specified by its path\n\nfunction findBox(data, path) {\n  var results = [];\n\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n\n  var end = data.byteLength;\n\n  for (var i = 0; i < end;) {\n    var size = readUint32(data, i);\n    var type = bin2str(data.subarray(i + 4, i + 8));\n    var endbox = size > 1 ? i + size : end;\n\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, endbox));\n      } else {\n        // recursively search for the next box along the path\n        var subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));\n\n        if (subresults.length) {\n          push.apply(results, subresults);\n        }\n      }\n    }\n\n    i = endbox;\n  } // we've finished searching all of data\n\n\n  return results;\n}\nfunction parseSegmentIndex(initSegment) {\n  var moovBox = findBox(initSegment, ['moov']);\n  var moov = moovBox[0];\n  var moovEndOffset = moov ? moov.length : null; // we need this in case we need to chop of garbage of the end of current data\n\n  var sidxBox = findBox(initSegment, ['sidx']);\n\n  if (!sidxBox || !sidxBox[0]) {\n    return null;\n  }\n\n  var references = [];\n  var sidx = sidxBox[0];\n  var version = sidx[0]; // set initial offset, we skip the reference ID (not needed)\n\n  var index = 8;\n  var timescale = readUint32(sidx, index);\n  index += 4; // TODO: parse earliestPresentationTime and firstOffset\n  // usually zero in our case\n\n  var earliestPresentationTime = 0;\n  var firstOffset = 0;\n\n  if (version === 0) {\n    index += 8;\n  } else {\n    index += 16;\n  } // skip reserved\n\n\n  index += 2;\n  var startByte = sidx.length + firstOffset;\n  var referencesCount = readUint16(sidx, index);\n  index += 2;\n\n  for (var i = 0; i < referencesCount; i++) {\n    var referenceIndex = index;\n    var referenceInfo = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    var referenceSize = referenceInfo & 0x7fffffff;\n    var referenceType = (referenceInfo & 0x80000000) >>> 31;\n\n    if (referenceType === 1) {\n      // eslint-disable-next-line no-console\n      console.warn('SIDX has hierarchical references (not supported)');\n      return null;\n    }\n\n    var subsegmentDuration = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    references.push({\n      referenceSize: referenceSize,\n      subsegmentDuration: subsegmentDuration,\n      // unscaled\n      info: {\n        duration: subsegmentDuration / timescale,\n        start: startByte,\n        end: startByte + referenceSize - 1\n      }\n    });\n    startByte += referenceSize; // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n    // for |sapDelta|.\n\n    referenceIndex += 4; // skip to next ref\n\n    index = referenceIndex;\n  }\n\n  return {\n    earliestPresentationTime: earliestPresentationTime,\n    timescale: timescale,\n    version: version,\n    referencesCount: referencesCount,\n    references: references,\n    moovEndOffset: moovEndOffset\n  };\n}\n/**\n * Parses an MP4 initialization segment and extracts stream type and\n * timescale values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * moov > trak > mdia > hdlr\n * ```\n * @param initSegment {Uint8Array} the bytes of the init segment\n * @return {InitData} a hash of track type to timescale values or null if\n * the init segment is malformed.\n */\n\nfunction parseInitSegment(initSegment) {\n  var result = [];\n  var traks = findBox(initSegment, ['moov', 'trak']);\n\n  for (var i = 0; i < traks.length; i++) {\n    var trak = traks[i];\n    var tkhd = findBox(trak, ['tkhd'])[0];\n\n    if (tkhd) {\n      var version = tkhd[0];\n\n      var _index = version === 0 ? 12 : 20;\n\n      var trackId = readUint32(tkhd, _index);\n      var mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n\n      if (mdhd) {\n        version = mdhd[0];\n        _index = version === 0 ? 12 : 20;\n        var timescale = readUint32(mdhd, _index);\n        var hdlr = findBox(trak, ['mdia', 'hdlr'])[0];\n\n        if (hdlr) {\n          var hdlrType = bin2str(hdlr.subarray(8, 12));\n          var type = {\n            soun: _loader_fragment__WEBPACK_IMPORTED_MODULE_1__[\"ElementaryStreamTypes\"].AUDIO,\n            vide: _loader_fragment__WEBPACK_IMPORTED_MODULE_1__[\"ElementaryStreamTypes\"].VIDEO\n          }[hdlrType];\n\n          if (type) {\n            // Parse codec details\n            var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n            var codec = void 0;\n\n            if (stsd) {\n              codec = bin2str(stsd.subarray(12, 16)); // TODO: Parse codec details to be able to build MIME type.\n              // stsd.start += 8;\n              // const codecBox = findBox(stsd, [codec])[0];\n              // if (codecBox) {\n              //   TODO: Codec parsing support for avc1, mp4a, hevc, av01...\n              // }\n            }\n\n            result[trackId] = {\n              timescale: timescale,\n              type: type\n            };\n            result[type] = {\n              timescale: timescale,\n              id: trackId,\n              codec: codec\n            };\n          }\n        }\n      }\n    }\n  }\n\n  var trex = findBox(initSegment, ['moov', 'mvex', 'trex']);\n  trex.forEach(function (trex) {\n    var trackId = readUint32(trex, 4);\n    var track = result[trackId];\n\n    if (track) {\n      track.default = {\n        duration: readUint32(trex, 12),\n        flags: readUint32(trex, 20)\n      };\n    }\n  });\n  return result;\n}\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param initData {InitData} a hash of track type to timescale values\n * @param fmp4 {Uint8Array} the bytes of the mp4 fragment\n * @return {number} the earliest base media decode start time for the\n * fragment, in seconds\n */\n\nfunction getStartDTS(initData, fmp4) {\n  // we need info from two children of each track fragment box\n  return findBox(fmp4, ['moof', 'traf']).reduce(function (result, traf) {\n    var tfdt = findBox(traf, ['tfdt'])[0];\n    var version = tfdt[0];\n    var start = findBox(traf, ['tfhd']).reduce(function (result, tfhd) {\n      // get the track id from the tfhd\n      var id = readUint32(tfhd, 4);\n      var track = initData[id];\n\n      if (track) {\n        var baseTime = readUint32(tfdt, 4);\n\n        if (version === 1) {\n          baseTime *= Math.pow(2, 32);\n          baseTime += readUint32(tfdt, 8);\n        } // assume a 90kHz clock if no timescale was specified\n\n\n        var scale = track.timescale || 90e3; // convert base time to seconds\n\n        var startTime = baseTime / scale;\n\n        if (isFinite(startTime) && (result === null || startTime < result)) {\n          return startTime;\n        }\n      }\n\n      return result;\n    }, null);\n\n    if (start !== null && isFinite(start) && (result === null || start < result)) {\n      return start;\n    }\n\n    return result;\n  }, null) || 0;\n}\n/*\n  For Reference:\n  aligned(8) class TrackFragmentHeaderBox\n           extends FullBox(tfhd, 0, tf_flags){\n     unsigned int(32)  track_ID;\n     // all the following are optional fields\n     unsigned int(64)  base_data_offset;\n     unsigned int(32)  sample_description_index;\n     unsigned int(32)  default_sample_duration;\n     unsigned int(32)  default_sample_size;\n     unsigned int(32)  default_sample_flags\n  }\n */\n\nfunction getDuration(data, initData) {\n  var rawDuration = 0;\n  var videoDuration = 0;\n  var audioDuration = 0;\n  var trafs = findBox(data, ['moof', 'traf']);\n\n  for (var i = 0; i < trafs.length; i++) {\n    var traf = trafs[i]; // There is only one tfhd & trun per traf\n    // This is true for CMAF style content, and we should perhaps check the ftyp\n    // and only look for a single trun then, but for ISOBMFF we should check\n    // for multiple track runs.\n\n    var tfhd = findBox(traf, ['tfhd'])[0]; // get the track id from the tfhd\n\n    var id = readUint32(tfhd, 4);\n    var track = initData[id];\n\n    if (!track) {\n      continue;\n    }\n\n    var trackDefault = track.default;\n    var tfhdFlags = readUint32(tfhd, 0) | (trackDefault === null || trackDefault === void 0 ? void 0 : trackDefault.flags);\n    var sampleDuration = trackDefault === null || trackDefault === void 0 ? void 0 : trackDefault.duration;\n\n    if (tfhdFlags & 0x000008) {\n      // 0x000008 indicates the presence of the default_sample_duration field\n      if (tfhdFlags & 0x000002) {\n        // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\n        // If present, the default_sample_duration exists at byte offset 12\n        sampleDuration = readUint32(tfhd, 12);\n      } else {\n        // Otherwise, the duration is at byte offset 8\n        sampleDuration = readUint32(tfhd, 8);\n      }\n    } // assume a 90kHz clock if no timescale was specified\n\n\n    var timescale = track.timescale || 90e3;\n    var truns = findBox(traf, ['trun']);\n\n    for (var j = 0; j < truns.length; j++) {\n      rawDuration = computeRawDurationFromSamples(truns[j]);\n\n      if (!rawDuration && sampleDuration) {\n        var sampleCount = readUint32(truns[j], 4);\n        rawDuration = sampleDuration * sampleCount;\n      }\n\n      if (track.type === _loader_fragment__WEBPACK_IMPORTED_MODULE_1__[\"ElementaryStreamTypes\"].VIDEO) {\n        videoDuration += rawDuration / timescale;\n      } else if (track.type === _loader_fragment__WEBPACK_IMPORTED_MODULE_1__[\"ElementaryStreamTypes\"].AUDIO) {\n        audioDuration += rawDuration / timescale;\n      }\n    }\n  }\n\n  if (videoDuration === 0 && audioDuration === 0) {\n    // If duration samples are not available in the traf use sidx subsegment_duration\n    var sidx = parseSegmentIndex(data);\n\n    if (sidx !== null && sidx !== void 0 && sidx.references) {\n      return sidx.references.reduce(function (dur, ref) {\n        return dur + ref.info.duration || 0;\n      }, 0);\n    }\n  }\n\n  if (videoDuration) {\n    return videoDuration;\n  }\n\n  return audioDuration;\n}\n/*\n  For Reference:\n  aligned(8) class TrackRunBox\n           extends FullBox(trun, version, tr_flags) {\n     unsigned int(32)  sample_count;\n     // the following are optional fields\n     signed int(32) data_offset;\n     unsigned int(32)  first_sample_flags;\n     // all fields in the following array are optional\n     {\n        unsigned int(32)  sample_duration;\n        unsigned int(32)  sample_size;\n        unsigned int(32)  sample_flags\n        if (version == 0)\n           { unsigned int(32)\n        else\n           { signed int(32)\n     }[ sample_count ]\n  }\n */\n\nfunction computeRawDurationFromSamples(trun) {\n  var flags = readUint32(trun, 0); // Flags are at offset 0, non-optional sample_count is at offset 4. Therefore we start 8 bytes in.\n  // Each field is an int32, which is 4 bytes\n\n  var offset = 8; // data-offset-present flag\n\n  if (flags & 0x000001) {\n    offset += 4;\n  } // first-sample-flags-present flag\n\n\n  if (flags & 0x000004) {\n    offset += 4;\n  }\n\n  var duration = 0;\n  var sampleCount = readUint32(trun, 4);\n\n  for (var i = 0; i < sampleCount; i++) {\n    // sample-duration-present flag\n    if (flags & 0x000100) {\n      var sampleDuration = readUint32(trun, offset);\n      duration += sampleDuration;\n      offset += 4;\n    } // sample-size-present flag\n\n\n    if (flags & 0x000200) {\n      offset += 4;\n    } // sample-flags-present flag\n\n\n    if (flags & 0x000400) {\n      offset += 4;\n    } // sample-composition-time-offsets-present flag\n\n\n    if (flags & 0x000800) {\n      offset += 4;\n    }\n  }\n\n  return duration;\n}\nfunction offsetStartDTS(initData, fmp4, timeOffset) {\n  findBox(fmp4, ['moof', 'traf']).forEach(function (traf) {\n    findBox(traf, ['tfhd']).forEach(function (tfhd) {\n      // get the track id from the tfhd\n      var id = readUint32(tfhd, 4);\n      var track = initData[id];\n\n      if (!track) {\n        return;\n      } // assume a 90kHz clock if no timescale was specified\n\n\n      var timescale = track.timescale || 90e3; // get the base media decode time from the tfdt\n\n      findBox(traf, ['tfdt']).forEach(function (tfdt) {\n        var version = tfdt[0];\n        var baseMediaDecodeTime = readUint32(tfdt, 4);\n\n        if (version === 0) {\n          baseMediaDecodeTime -= timeOffset * timescale;\n          baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n          writeUint32(tfdt, 4, baseMediaDecodeTime);\n        } else {\n          baseMediaDecodeTime *= Math.pow(2, 32);\n          baseMediaDecodeTime += readUint32(tfdt, 8);\n          baseMediaDecodeTime -= timeOffset * timescale;\n          baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n          var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n          var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n          writeUint32(tfdt, 4, upper);\n          writeUint32(tfdt, 8, lower);\n        }\n      });\n    });\n  });\n} // TODO: Check if the last moof+mdat pair is part of the valid range\n\nfunction segmentValidRange(data) {\n  var segmentedRange = {\n    valid: null,\n    remainder: null\n  };\n  var moofs = findBox(data, ['moof']);\n\n  if (!moofs) {\n    return segmentedRange;\n  } else if (moofs.length < 2) {\n    segmentedRange.remainder = data;\n    return segmentedRange;\n  }\n\n  var last = moofs[moofs.length - 1]; // Offset by 8 bytes; findBox offsets the start by as much\n\n  segmentedRange.valid = Object(_typed_array__WEBPACK_IMPORTED_MODULE_0__[\"sliceUint8\"])(data, 0, last.byteOffset - 8);\n  segmentedRange.remainder = Object(_typed_array__WEBPACK_IMPORTED_MODULE_0__[\"sliceUint8\"])(data, last.byteOffset - 8);\n  return segmentedRange;\n}\nfunction appendUint8Array(data1, data2) {\n  var temp = new Uint8Array(data1.length + data2.length);\n  temp.set(data1);\n  temp.set(data2, data1.length);\n  return temp;\n}\nfunction parseSamples(timeOffset, track) {\n  var seiSamples = [];\n  var videoData = track.samples;\n  var timescale = track.timescale;\n  var trackId = track.id;\n  var isHEVCFlavor = false;\n  var moofs = findBox(videoData, ['moof']);\n  moofs.map(function (moof) {\n    var moofOffset = moof.byteOffset - 8;\n    var trafs = findBox(moof, ['traf']);\n    trafs.map(function (traf) {\n      // get the base media decode time from the tfdt\n      var baseTime = findBox(traf, ['tfdt']).map(function (tfdt) {\n        var version = tfdt[0];\n        var result = readUint32(tfdt, 4);\n\n        if (version === 1) {\n          result *= Math.pow(2, 32);\n          result += readUint32(tfdt, 8);\n        }\n\n        return result / timescale;\n      })[0];\n\n      if (baseTime !== undefined) {\n        timeOffset = baseTime;\n      }\n\n      return findBox(traf, ['tfhd']).map(function (tfhd) {\n        var id = readUint32(tfhd, 4);\n        var tfhdFlags = readUint32(tfhd, 0) & 0xffffff;\n        var baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;\n        var sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;\n        var defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;\n        var defaultSampleDuration = 0;\n        var defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;\n        var defaultSampleSize = 0;\n        var defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;\n        var tfhdOffset = 8;\n\n        if (id === trackId) {\n          if (baseDataOffsetPresent) {\n            tfhdOffset += 8;\n          }\n\n          if (sampleDescriptionIndexPresent) {\n            tfhdOffset += 4;\n          }\n\n          if (defaultSampleDurationPresent) {\n            defaultSampleDuration = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n\n          if (defaultSampleSizePresent) {\n            defaultSampleSize = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n\n          if (defaultSampleFlagsPresent) {\n            tfhdOffset += 4;\n          }\n\n          if (track.type === 'video') {\n            isHEVCFlavor = isHEVC(track.codec);\n          }\n\n          findBox(traf, ['trun']).map(function (trun) {\n            var version = trun[0];\n            var flags = readUint32(trun, 0) & 0xffffff;\n            var dataOffsetPresent = (flags & 0x000001) !== 0;\n            var dataOffset = 0;\n            var firstSampleFlagsPresent = (flags & 0x000004) !== 0;\n            var sampleDurationPresent = (flags & 0x000100) !== 0;\n            var sampleDuration = 0;\n            var sampleSizePresent = (flags & 0x000200) !== 0;\n            var sampleSize = 0;\n            var sampleFlagsPresent = (flags & 0x000400) !== 0;\n            var sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;\n            var compositionOffset = 0;\n            var sampleCount = readUint32(trun, 4);\n            var trunOffset = 8; // past version, flags, and sample count\n\n            if (dataOffsetPresent) {\n              dataOffset = readUint32(trun, trunOffset);\n              trunOffset += 4;\n            }\n\n            if (firstSampleFlagsPresent) {\n              trunOffset += 4;\n            }\n\n            var sampleOffset = dataOffset + moofOffset;\n\n            for (var ix = 0; ix < sampleCount; ix++) {\n              if (sampleDurationPresent) {\n                sampleDuration = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleDuration = defaultSampleDuration;\n              }\n\n              if (sampleSizePresent) {\n                sampleSize = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleSize = defaultSampleSize;\n              }\n\n              if (sampleFlagsPresent) {\n                trunOffset += 4;\n              }\n\n              if (sampleCompositionOffsetsPresent) {\n                if (version === 0) {\n                  compositionOffset = readUint32(trun, trunOffset);\n                } else {\n                  compositionOffset = readSint32(trun, trunOffset);\n                }\n\n                trunOffset += 4;\n              }\n\n              if (track.type === _loader_fragment__WEBPACK_IMPORTED_MODULE_1__[\"ElementaryStreamTypes\"].VIDEO) {\n                var naluTotalSize = 0;\n\n                while (naluTotalSize < sampleSize) {\n                  var naluSize = readUint32(videoData, sampleOffset);\n                  sampleOffset += 4;\n                  var naluType = videoData[sampleOffset] & 0x1f;\n\n                  if (isSEIMessage(isHEVCFlavor, naluType)) {\n                    var data = videoData.subarray(sampleOffset, sampleOffset + naluSize);\n                    parseSEIMessageFromNALu(data, timeOffset + compositionOffset / timescale, seiSamples);\n                  }\n\n                  sampleOffset += naluSize;\n                  naluTotalSize += naluSize + 4;\n                }\n              }\n\n              timeOffset += sampleDuration / timescale;\n            }\n          });\n        }\n      });\n    });\n  });\n  return seiSamples;\n}\n\nfunction isHEVC(codec) {\n  if (!codec) {\n    return false;\n  }\n\n  var delimit = codec.indexOf('.');\n  var baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);\n  return baseCodec === 'hvc1' || baseCodec === 'hev1' || // Dolby Vision\n  baseCodec === 'dvh1' || baseCodec === 'dvhe';\n}\n\nfunction isSEIMessage(isHEVCFlavor, naluType) {\n  return isHEVCFlavor ? naluType === 39 || naluType === 40 : naluType === 6;\n}\n\nfunction parseSEIMessageFromNALu(unescapedData, pts, samples) {\n  var data = discardEPB(unescapedData);\n  var seiPtr = 0; // skip frameType\n\n  seiPtr++;\n  var payloadType = 0;\n  var payloadSize = 0;\n  var endOfCaptions = false;\n  var b = 0;\n\n  while (seiPtr < data.length) {\n    payloadType = 0;\n\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n\n      b = data[seiPtr++];\n      payloadType += b;\n    } while (b === 0xff); // Parse payload size.\n\n\n    payloadSize = 0;\n\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n\n      b = data[seiPtr++];\n      payloadSize += b;\n    } while (b === 0xff);\n\n    var leftOver = data.length - seiPtr;\n\n    if (!endOfCaptions && payloadType === 4 && seiPtr < data.length) {\n      endOfCaptions = true;\n      var countryCode = data[seiPtr++];\n\n      if (countryCode === 181) {\n        var providerCode = readUint16(data, seiPtr);\n        seiPtr += 2;\n\n        if (providerCode === 49) {\n          var userStructure = readUint32(data, seiPtr);\n          seiPtr += 4;\n\n          if (userStructure === 0x47413934) {\n            var userDataType = data[seiPtr++]; // Raw CEA-608 bytes wrapped in CEA-708 packet\n\n            if (userDataType === 3) {\n              var firstByte = data[seiPtr++];\n              var totalCCs = 0x1f & firstByte;\n              var enabled = 0x40 & firstByte;\n              var totalBytes = enabled ? 2 + totalCCs * 3 : 0;\n              var byteArray = new Uint8Array(totalBytes);\n\n              if (enabled) {\n                byteArray[0] = firstByte;\n\n                for (var i = 1; i < totalBytes; i++) {\n                  byteArray[i] = data[seiPtr++];\n                }\n              }\n\n              samples.push({\n                type: userDataType,\n                payloadType: payloadType,\n                pts: pts,\n                bytes: byteArray\n              });\n            }\n          }\n        }\n      }\n    } else if (payloadType === 5 && payloadSize < leftOver) {\n      endOfCaptions = true;\n\n      if (payloadSize > 16) {\n        var uuidStrArray = [];\n\n        for (var _i = 0; _i < 16; _i++) {\n          var _b = data[seiPtr++].toString(16);\n\n          uuidStrArray.push(_b.length == 1 ? '0' + _b : _b);\n\n          if (_i === 3 || _i === 5 || _i === 7 || _i === 9) {\n            uuidStrArray.push('-');\n          }\n        }\n\n        var length = payloadSize - 16;\n        var userDataBytes = new Uint8Array(length);\n\n        for (var _i2 = 0; _i2 < length; _i2++) {\n          userDataBytes[_i2] = data[seiPtr++];\n        }\n\n        samples.push({\n          payloadType: payloadType,\n          pts: pts,\n          uuid: uuidStrArray.join(''),\n          userData: Object(_demux_id3__WEBPACK_IMPORTED_MODULE_2__[\"utf8ArrayToStr\"])(userDataBytes),\n          userDataBytes: userDataBytes\n        });\n      }\n    } else if (payloadSize < leftOver) {\n      seiPtr += payloadSize;\n    } else if (payloadSize > leftOver) {\n      break;\n    }\n  }\n}\n/**\n * remove Emulation Prevention bytes from a RBSP\n */\n\nfunction discardEPB(data) {\n  var length = data.byteLength;\n  var EPBPositions = [];\n  var i = 1; // Find all `Emulation Prevention Bytes`\n\n  while (i < length - 2) {\n    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n      EPBPositions.push(i + 2);\n      i += 2;\n    } else {\n      i++;\n    }\n  } // If no Emulation Prevention Bytes were found just return the original\n  // array\n\n\n  if (EPBPositions.length === 0) {\n    return data;\n  } // Create a new array to hold the NAL unit data\n\n\n  var newLength = length - EPBPositions.length;\n  var newData = new Uint8Array(newLength);\n  var sourceIndex = 0;\n\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === EPBPositions[0]) {\n      // Skip this byte\n      sourceIndex++; // Remove this position index\n\n      EPBPositions.shift();\n    }\n\n    newData[i] = data[sourceIndex];\n  }\n\n  return newData;\n}\n\nfunction parseEmsg(data) {\n  var version = data[0];\n  var schemeIdUri = '';\n  var value = '';\n  var timeScale = 0;\n  var presentationTimeDelta = 0;\n  var presentationTime = 0;\n  var eventDuration = 0;\n  var id = 0;\n  var offset = 0;\n\n  if (version === 0) {\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    timeScale = readUint32(data, 12);\n    presentationTimeDelta = readUint32(data, 16);\n    eventDuration = readUint32(data, 20);\n    id = readUint32(data, 24);\n    offset = 28;\n  } else if (version === 1) {\n    offset += 4;\n    timeScale = readUint32(data, offset);\n    offset += 4;\n    var leftPresentationTime = readUint32(data, offset);\n    offset += 4;\n    var rightPresentationTime = readUint32(data, offset);\n    offset += 4;\n    presentationTime = Math.pow(2, 32) * leftPresentationTime + rightPresentationTime;\n\n    if (!Number.isSafeInteger(presentationTime)) {\n      presentationTime = Number.MAX_SAFE_INTEGER; // eslint-disable-next-line no-console\n\n      console.warn('Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box');\n    }\n\n    eventDuration = readUint32(data, offset);\n    offset += 4;\n    id = readUint32(data, offset);\n    offset += 4;\n\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n  }\n\n  var payload = data.subarray(offset, data.byteLength);\n  return {\n    schemeIdUri: schemeIdUri,\n    value: value,\n    timeScale: timeScale,\n    presentationTime: presentationTime,\n    presentationTimeDelta: presentationTimeDelta,\n    eventDuration: eventDuration,\n    id: id,\n    payload: payload\n  };\n}\n\n/***/ }),\n\n/***/ \"./src/utils/output-filter.ts\":\n/*!************************************!*\\\n  !*** ./src/utils/output-filter.ts ***!\n  \\************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_985496__) {\n\n\"use strict\";\n__nested_webpack_require_985496__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_985496__.d(__webpack_exports__, \"default\", function() { return OutputFilter; });\nvar OutputFilter = /*#__PURE__*/function () {\n  function OutputFilter(timelineController, trackName) {\n    this.timelineController = void 0;\n    this.cueRanges = [];\n    this.trackName = void 0;\n    this.startTime = null;\n    this.endTime = null;\n    this.screen = null;\n    this.timelineController = timelineController;\n    this.trackName = trackName;\n  }\n\n  var _proto = OutputFilter.prototype;\n\n  _proto.dispatchCue = function dispatchCue() {\n    if (this.startTime === null) {\n      return;\n    }\n\n    this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);\n    this.startTime = null;\n  };\n\n  _proto.newCue = function newCue(startTime, endTime, screen) {\n    if (this.startTime === null || this.startTime > startTime) {\n      this.startTime = startTime;\n    }\n\n    this.endTime = endTime;\n    this.screen = screen;\n    this.timelineController.createCaptionsTrack(this.trackName);\n  };\n\n  _proto.reset = function reset() {\n    this.cueRanges = [];\n    this.startTime = null;\n  };\n\n  return OutputFilter;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/utils/texttrack-utils.ts\":\n/*!**************************************!*\\\n  !*** ./src/utils/texttrack-utils.ts ***!\n  \\**************************************/\n/*! exports provided: sendAddTrackEvent, addCueToTrack, clearCurrentCues, removeCuesInRange, getCuesInRange */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_987106__) {\n\n\"use strict\";\n__nested_webpack_require_987106__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_987106__.d(__webpack_exports__, \"sendAddTrackEvent\", function() { return sendAddTrackEvent; });\n/* harmony export (binding) */ __nested_webpack_require_987106__.d(__webpack_exports__, \"addCueToTrack\", function() { return addCueToTrack; });\n/* harmony export (binding) */ __nested_webpack_require_987106__.d(__webpack_exports__, \"clearCurrentCues\", function() { return clearCurrentCues; });\n/* harmony export (binding) */ __nested_webpack_require_987106__.d(__webpack_exports__, \"removeCuesInRange\", function() { return removeCuesInRange; });\n/* harmony export (binding) */ __nested_webpack_require_987106__.d(__webpack_exports__, \"getCuesInRange\", function() { return getCuesInRange; });\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_987106__(/*! ./logger */ \"./src/utils/logger.ts\");\n\nfunction sendAddTrackEvent(track, videoEl) {\n  var event;\n\n  try {\n    event = new Event('addtrack');\n  } catch (err) {\n    // for IE11\n    event = document.createEvent('Event');\n    event.initEvent('addtrack', false, false);\n  }\n\n  event.track = track;\n  videoEl.dispatchEvent(event);\n}\nfunction addCueToTrack(track, cue) {\n  // Sometimes there are cue overlaps on segmented vtts so the same\n  // cue can appear more than once in different vtt files.\n  // This avoid showing duplicated cues with same timecode and text.\n  var mode = track.mode;\n\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n\n  if (track.cues && !track.cues.getCueById(cue.id)) {\n    try {\n      track.addCue(cue);\n\n      if (!track.cues.getCueById(cue.id)) {\n        throw new Error(\"addCue is failed for: \" + cue);\n      }\n    } catch (err) {\n      _logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].debug(\"[texttrack-utils]: \" + err);\n      var textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);\n      textTrackCue.id = cue.id;\n      track.addCue(textTrackCue);\n    }\n  }\n\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\nfunction clearCurrentCues(track) {\n  // When track.mode is disabled, track.cues will be null.\n  // To guarantee the removal of cues, we need to temporarily\n  // change the mode to hidden\n  var mode = track.mode;\n\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n\n  if (track.cues) {\n    for (var i = track.cues.length; i--;) {\n      track.removeCue(track.cues[i]);\n    }\n  }\n\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\nfunction removeCuesInRange(track, start, end, predicate) {\n  var mode = track.mode;\n\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n\n  if (track.cues && track.cues.length > 0) {\n    var cues = getCuesInRange(track.cues, start, end);\n\n    for (var i = 0; i < cues.length; i++) {\n      if (!predicate || predicate(cues[i])) {\n        track.removeCue(cues[i]);\n      }\n    }\n  }\n\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n} // Find first cue starting after given time.\n// Modified version of binary search O(log(n)).\n\nfunction getFirstCueIndexAfterTime(cues, time) {\n  // If first cue starts after time, start there\n  if (time < cues[0].startTime) {\n    return 0;\n  } // If the last cue ends before time there is no overlap\n\n\n  var len = cues.length - 1;\n\n  if (time > cues[len].endTime) {\n    return -1;\n  }\n\n  var left = 0;\n  var right = len;\n\n  while (left <= right) {\n    var mid = Math.floor((right + left) / 2);\n\n    if (time < cues[mid].startTime) {\n      right = mid - 1;\n    } else if (time > cues[mid].startTime && left < len) {\n      left = mid + 1;\n    } else {\n      // If it's not lower or higher, it must be equal.\n      return mid;\n    }\n  } // At this point, left and right have swapped.\n  // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.\n\n\n  return cues[left].startTime - time < time - cues[right].startTime ? left : right;\n}\n\nfunction getCuesInRange(cues, start, end) {\n  var cuesFound = [];\n  var firstCueInRange = getFirstCueIndexAfterTime(cues, start);\n\n  if (firstCueInRange > -1) {\n    for (var i = firstCueInRange, len = cues.length; i < len; i++) {\n      var _cue = cues[i];\n\n      if (_cue.startTime >= start && _cue.endTime <= end) {\n        cuesFound.push(_cue);\n      } else if (_cue.startTime > end) {\n        return cuesFound;\n      }\n    }\n  }\n\n  return cuesFound;\n}\n\n/***/ }),\n\n/***/ \"./src/utils/time-ranges.ts\":\n/*!**********************************!*\\\n  !*** ./src/utils/time-ranges.ts ***!\n  \\**********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_991703__) {\n\n\"use strict\";\n__nested_webpack_require_991703__.r(__webpack_exports__);\n/**\n *  TimeRanges to string helper\n */\nvar TimeRanges = {\n  toString: function toString(r) {\n    var log = '';\n    var len = r.length;\n\n    for (var i = 0; i < len; i++) {\n      log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';\n    }\n\n    return log;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (TimeRanges);\n\n/***/ }),\n\n/***/ \"./src/utils/timescale-conversion.ts\":\n/*!*******************************************!*\\\n  !*** ./src/utils/timescale-conversion.ts ***!\n  \\*******************************************/\n/*! exports provided: toTimescaleFromBase, toTimescaleFromScale, toMsFromMpegTsClock, toMpegTsClockFromTimescale */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_992504__) {\n\n\"use strict\";\n__nested_webpack_require_992504__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_992504__.d(__webpack_exports__, \"toTimescaleFromBase\", function() { return toTimescaleFromBase; });\n/* harmony export (binding) */ __nested_webpack_require_992504__.d(__webpack_exports__, \"toTimescaleFromScale\", function() { return toTimescaleFromScale; });\n/* harmony export (binding) */ __nested_webpack_require_992504__.d(__webpack_exports__, \"toMsFromMpegTsClock\", function() { return toMsFromMpegTsClock; });\n/* harmony export (binding) */ __nested_webpack_require_992504__.d(__webpack_exports__, \"toMpegTsClockFromTimescale\", function() { return toMpegTsClockFromTimescale; });\nvar MPEG_TS_CLOCK_FREQ_HZ = 90000;\nfunction toTimescaleFromBase(value, destScale, srcBase, round) {\n  if (srcBase === void 0) {\n    srcBase = 1;\n  }\n\n  if (round === void 0) {\n    round = false;\n  }\n\n  var result = value * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\n\n  return round ? Math.round(result) : result;\n}\nfunction toTimescaleFromScale(value, destScale, srcScale, round) {\n  if (srcScale === void 0) {\n    srcScale = 1;\n  }\n\n  if (round === void 0) {\n    round = false;\n  }\n\n  return toTimescaleFromBase(value, destScale, 1 / srcScale, round);\n}\nfunction toMsFromMpegTsClock(value, round) {\n  if (round === void 0) {\n    round = false;\n  }\n\n  return toTimescaleFromBase(value, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\n}\nfunction toMpegTsClockFromTimescale(value, srcScale) {\n  if (srcScale === void 0) {\n    srcScale = 1;\n  }\n\n  return toTimescaleFromBase(value, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);\n}\n\n/***/ }),\n\n/***/ \"./src/utils/typed-array.ts\":\n/*!**********************************!*\\\n  !*** ./src/utils/typed-array.ts ***!\n  \\**********************************/\n/*! exports provided: sliceUint8 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_994356__) {\n\n\"use strict\";\n__nested_webpack_require_994356__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_994356__.d(__webpack_exports__, \"sliceUint8\", function() { return sliceUint8; });\nfunction sliceUint8(array, start, end) {\n  // @ts-expect-error This polyfills IE11 usage of Uint8Array slice.\n  // It always exists in the TypeScript definition so fails, but it fails at runtime on IE11.\n  return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));\n}\n\n/***/ }),\n\n/***/ \"./src/utils/vttcue.ts\":\n/*!*****************************!*\\\n  !*** ./src/utils/vttcue.ts ***!\n  \\*****************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_995120__) {\n\n\"use strict\";\n__nested_webpack_require_995120__.r(__webpack_exports__);\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* harmony default export */ __webpack_exports__[\"default\"] = ((function () {\n  if (typeof self !== 'undefined' && self.VTTCue) {\n    return self.VTTCue;\n  }\n\n  var AllowedDirections = ['', 'lr', 'rl'];\n  var AllowedAlignments = ['start', 'middle', 'end', 'left', 'right'];\n\n  function isAllowedValue(allowed, value) {\n    if (typeof value !== 'string') {\n      return false;\n    } // necessary for assuring the generic conforms to the Array interface\n\n\n    if (!Array.isArray(allowed)) {\n      return false;\n    } // reset the type so that the next narrowing works well\n\n\n    var lcValue = value.toLowerCase(); // use the allow list to narrow the type to a specific subset of strings\n\n    if (~allowed.indexOf(lcValue)) {\n      return lcValue;\n    }\n\n    return false;\n  }\n\n  function findDirectionSetting(value) {\n    return isAllowedValue(AllowedDirections, value);\n  }\n\n  function findAlignSetting(value) {\n    return isAllowedValue(AllowedAlignments, value);\n  }\n\n  function extend(obj) {\n    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n\n    var i = 1;\n\n    for (; i < arguments.length; i++) {\n      var cobj = arguments[i];\n\n      for (var p in cobj) {\n        obj[p] = cobj[p];\n      }\n    }\n\n    return obj;\n  }\n\n  function VTTCue(startTime, endTime, text) {\n    var cue = this;\n    var baseObj = {\n      enumerable: true\n    };\n    /**\n     * Shim implementation specific properties. These properties are not in\n     * the spec.\n     */\n    // Lets us know when the VTTCue's data has changed in such a way that we need\n    // to recompute its display state. This lets us compute its display state\n    // lazily.\n\n    cue.hasBeenReset = false;\n    /**\n     * VTTCue and TextTrackCue properties\n     * http://dev.w3.org/html5/webvtt/#vttcue-interface\n     */\n\n    var _id = '';\n    var _pauseOnExit = false;\n    var _startTime = startTime;\n    var _endTime = endTime;\n    var _text = text;\n    var _region = null;\n    var _vertical = '';\n    var _snapToLines = true;\n    var _line = 'auto';\n    var _lineAlign = 'start';\n    var _position = 50;\n    var _positionAlign = 'middle';\n    var _size = 50;\n    var _align = 'middle';\n    Object.defineProperty(cue, 'id', extend({}, baseObj, {\n      get: function get() {\n        return _id;\n      },\n      set: function set(value) {\n        _id = '' + value;\n      }\n    }));\n    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {\n      get: function get() {\n        return _pauseOnExit;\n      },\n      set: function set(value) {\n        _pauseOnExit = !!value;\n      }\n    }));\n    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {\n      get: function get() {\n        return _startTime;\n      },\n      set: function set(value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('Start time must be set to a number.');\n        }\n\n        _startTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {\n      get: function get() {\n        return _endTime;\n      },\n      set: function set(value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('End time must be set to a number.');\n        }\n\n        _endTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'text', extend({}, baseObj, {\n      get: function get() {\n        return _text;\n      },\n      set: function set(value) {\n        _text = '' + value;\n        this.hasBeenReset = true;\n      }\n    })); // todo: implement VTTRegion polyfill?\n\n    Object.defineProperty(cue, 'region', extend({}, baseObj, {\n      get: function get() {\n        return _region;\n      },\n      set: function set(value) {\n        _region = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {\n      get: function get() {\n        return _vertical;\n      },\n      set: function set(value) {\n        var setting = findDirectionSetting(value); // Have to check for false because the setting an be an empty string.\n\n        if (setting === false) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n\n        _vertical = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {\n      get: function get() {\n        return _snapToLines;\n      },\n      set: function set(value) {\n        _snapToLines = !!value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'line', extend({}, baseObj, {\n      get: function get() {\n        return _line;\n      },\n      set: function set(value) {\n        if (typeof value !== 'number' && value !== 'auto') {\n          throw new SyntaxError('An invalid number or illegal string was specified.');\n        }\n\n        _line = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {\n      get: function get() {\n        return _lineAlign;\n      },\n      set: function set(value) {\n        var setting = findAlignSetting(value);\n\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n\n        _lineAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'position', extend({}, baseObj, {\n      get: function get() {\n        return _position;\n      },\n      set: function set(value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Position must be between 0 and 100.');\n        }\n\n        _position = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {\n      get: function get() {\n        return _positionAlign;\n      },\n      set: function set(value) {\n        var setting = findAlignSetting(value);\n\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n\n        _positionAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'size', extend({}, baseObj, {\n      get: function get() {\n        return _size;\n      },\n      set: function set(value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Size must be between 0 and 100.');\n        }\n\n        _size = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'align', extend({}, baseObj, {\n      get: function get() {\n        return _align;\n      },\n      set: function set(value) {\n        var setting = findAlignSetting(value);\n\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n\n        _align = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    /**\n     * Other <track> spec defined properties\n     */\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n\n    cue.displayState = undefined;\n  }\n  /**\n   * VTTCue methods\n   */\n\n\n  VTTCue.prototype.getCueAsHTML = function () {\n    // Assume WebVTT.convertCueToDOMTree is on the global.\n    var WebVTT = self.WebVTT;\n    return WebVTT.convertCueToDOMTree(self, this.text);\n  }; // this is a polyfill hack\n\n\n  return VTTCue;\n})());\n\n/***/ }),\n\n/***/ \"./src/utils/vttparser.ts\":\n/*!********************************!*\\\n  !*** ./src/utils/vttparser.ts ***!\n  \\********************************/\n/*! exports provided: parseTimeStamp, fixLineBreaks, VTTParser */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_1003497__) {\n\n\"use strict\";\n__nested_webpack_require_1003497__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_1003497__.d(__webpack_exports__, \"parseTimeStamp\", function() { return parseTimeStamp; });\n/* harmony export (binding) */ __nested_webpack_require_1003497__.d(__webpack_exports__, \"fixLineBreaks\", function() { return fixLineBreaks; });\n/* harmony export (binding) */ __nested_webpack_require_1003497__.d(__webpack_exports__, \"VTTParser\", function() { return VTTParser; });\n/* harmony import */ var _vttcue__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1003497__(/*! ./vttcue */ \"./src/utils/vttcue.ts\");\n/*\n * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js\n */\n\n\nvar StringDecoder = /*#__PURE__*/function () {\n  function StringDecoder() {}\n\n  var _proto = StringDecoder.prototype;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _proto.decode = function decode(data, options) {\n    if (!data) {\n      return '';\n    }\n\n    if (typeof data !== 'string') {\n      throw new Error('Error - expected string data.');\n    }\n\n    return decodeURIComponent(encodeURIComponent(data));\n  };\n\n  return StringDecoder;\n}(); // Try to parse input as a time stamp.\n\n\nfunction parseTimeStamp(input) {\n  function computeSeconds(h, m, s, f) {\n    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + parseFloat(f || 0);\n  }\n\n  var m = input.match(/^(?:(\\d+):)?(\\d{2}):(\\d{2})(\\.\\d+)?/);\n\n  if (!m) {\n    return null;\n  }\n\n  if (parseFloat(m[2]) > 59) {\n    // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n    // First position is hours as it's over 59.\n    return computeSeconds(m[2], m[3], 0, m[4]);\n  } // Timestamp takes the form of [hours (optional)]:[minutes]:[seconds].[milliseconds]\n\n\n  return computeSeconds(m[1], m[2], m[3], m[4]);\n} // A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\n\nvar Settings = /*#__PURE__*/function () {\n  function Settings() {\n    this.values = Object.create(null);\n  }\n\n  var _proto2 = Settings.prototype;\n\n  // Only accept the first assignment to any key.\n  _proto2.set = function set(k, v) {\n    if (!this.get(k) && v !== '') {\n      this.values[k] = v;\n    }\n  } // Return the value for a key, or a default value.\n  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n  // a number of possible default values as properties where 'defaultKey' is\n  // the key of the property that will be chosen; otherwise it's assumed to be\n  // a single value.\n  ;\n\n  _proto2.get = function get(k, dflt, defaultKey) {\n    if (defaultKey) {\n      return this.has(k) ? this.values[k] : dflt[defaultKey];\n    }\n\n    return this.has(k) ? this.values[k] : dflt;\n  } // Check whether we have a value for a key.\n  ;\n\n  _proto2.has = function has(k) {\n    return k in this.values;\n  } // Accept a setting if its one of the given alternatives.\n  ;\n\n  _proto2.alt = function alt(k, v, a) {\n    for (var n = 0; n < a.length; ++n) {\n      if (v === a[n]) {\n        this.set(k, v);\n        break;\n      }\n    }\n  } // Accept a setting if its a valid (signed) integer.\n  ;\n\n  _proto2.integer = function integer(k, v) {\n    if (/^-?\\d+$/.test(v)) {\n      // integer\n      this.set(k, parseInt(v, 10));\n    }\n  } // Accept a setting if its a valid percentage.\n  ;\n\n  _proto2.percent = function percent(k, v) {\n    if (/^([\\d]{1,3})(\\.[\\d]*)?%$/.test(v)) {\n      var percent = parseFloat(v);\n\n      if (percent >= 0 && percent <= 100) {\n        this.set(k, percent);\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  return Settings;\n}(); // Helper function to parse input into groups separated by 'groupDelim', and\n// interpret each group as a key/value pair separated by 'keyValueDelim'.\n\n\nfunction parseOptions(input, callback, keyValueDelim, groupDelim) {\n  var groups = groupDelim ? input.split(groupDelim) : [input];\n\n  for (var i in groups) {\n    if (typeof groups[i] !== 'string') {\n      continue;\n    }\n\n    var kv = groups[i].split(keyValueDelim);\n\n    if (kv.length !== 2) {\n      continue;\n    }\n\n    var _k = kv[0];\n    var _v = kv[1];\n    callback(_k, _v);\n  }\n}\n\nvar defaults = new _vttcue__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0, ''); // 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244\n//  Safari doesn't yet support this change, but FF and Chrome do.\n\nvar center = defaults.align === 'middle' ? 'middle' : 'center';\n\nfunction parseCue(input, cue, regionList) {\n  // Remember the original input if we need to throw an error.\n  var oInput = input; // 4.1 WebVTT timestamp\n\n  function consumeTimeStamp() {\n    var ts = parseTimeStamp(input);\n\n    if (ts === null) {\n      throw new Error('Malformed timestamp: ' + oInput);\n    } // Remove time stamp from input.\n\n\n    input = input.replace(/^[^\\sa-zA-Z-]+/, '');\n    return ts;\n  } // 4.4.2 WebVTT cue settings\n\n\n  function consumeCueSettings(input, cue) {\n    var settings = new Settings();\n    parseOptions(input, function (k, v) {\n      var vals;\n\n      switch (k) {\n        case 'region':\n          // Find the last region we parsed with the same region id.\n          for (var i = regionList.length - 1; i >= 0; i--) {\n            if (regionList[i].id === v) {\n              settings.set(k, regionList[i].region);\n              break;\n            }\n          }\n\n          break;\n\n        case 'vertical':\n          settings.alt(k, v, ['rl', 'lr']);\n          break;\n\n        case 'line':\n          vals = v.split(',');\n          settings.integer(k, vals[0]);\n\n          if (settings.percent(k, vals[0])) {\n            settings.set('snapToLines', false);\n          }\n\n          settings.alt(k, vals[0], ['auto']);\n\n          if (vals.length === 2) {\n            settings.alt('lineAlign', vals[1], ['start', center, 'end']);\n          }\n\n          break;\n\n        case 'position':\n          vals = v.split(',');\n          settings.percent(k, vals[0]);\n\n          if (vals.length === 2) {\n            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);\n          }\n\n          break;\n\n        case 'size':\n          settings.percent(k, v);\n          break;\n\n        case 'align':\n          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);\n          break;\n      }\n    }, /:/, /\\s/); // Apply default values for any missing fields.\n\n    cue.region = settings.get('region', null);\n    cue.vertical = settings.get('vertical', '');\n    var line = settings.get('line', 'auto');\n\n    if (line === 'auto' && defaults.line === -1) {\n      // set numeric line number for Safari\n      line = -1;\n    }\n\n    cue.line = line;\n    cue.lineAlign = settings.get('lineAlign', 'start');\n    cue.snapToLines = settings.get('snapToLines', true);\n    cue.size = settings.get('size', 100);\n    cue.align = settings.get('align', center);\n    var position = settings.get('position', 'auto');\n\n    if (position === 'auto' && defaults.position === 50) {\n      // set numeric position for Safari\n      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;\n    }\n\n    cue.position = position;\n  }\n\n  function skipWhitespace() {\n    input = input.replace(/^\\s+/, '');\n  } // 4.1 WebVTT cue timings.\n\n\n  skipWhitespace();\n  cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n\n  skipWhitespace();\n\n  if (input.slice(0, 3) !== '-->') {\n    // (3) next characters must match '-->'\n    throw new Error(\"Malformed time stamp (time stamps must be separated by '-->'): \" + oInput);\n  }\n\n  input = input.slice(3);\n  skipWhitespace();\n  cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n  // 4.1 WebVTT cue settings list.\n\n  skipWhitespace();\n  consumeCueSettings(input, cue);\n}\n\nfunction fixLineBreaks(input) {\n  return input.replace(/<br(?: \\/)?>/gi, '\\n');\n}\nvar VTTParser = /*#__PURE__*/function () {\n  function VTTParser() {\n    this.state = 'INITIAL';\n    this.buffer = '';\n    this.decoder = new StringDecoder();\n    this.regionList = [];\n    this.cue = null;\n    this.oncue = void 0;\n    this.onparsingerror = void 0;\n    this.onflush = void 0;\n  }\n\n  var _proto3 = VTTParser.prototype;\n\n  _proto3.parse = function parse(data) {\n    var _this = this; // If there is no data then we won't decode it, but will just try to parse\n    // whatever is in buffer already. This may occur in circumstances, for\n    // example when flush() is called.\n\n\n    if (data) {\n      // Try to decode the data that we received.\n      _this.buffer += _this.decoder.decode(data, {\n        stream: true\n      });\n    }\n\n    function collectNextLine() {\n      var buffer = _this.buffer;\n      var pos = 0;\n      buffer = fixLineBreaks(buffer);\n\n      while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n        ++pos;\n      }\n\n      var line = buffer.slice(0, pos); // Advance the buffer early in case we fail below.\n\n      if (buffer[pos] === '\\r') {\n        ++pos;\n      }\n\n      if (buffer[pos] === '\\n') {\n        ++pos;\n      }\n\n      _this.buffer = buffer.slice(pos);\n      return line;\n    } // 3.2 WebVTT metadata header syntax\n\n\n    function parseHeader(input) {\n      parseOptions(input, function (k, v) {// switch (k) {\n        // case 'region':\n        // 3.3 WebVTT region metadata header syntax\n        // console.log('parse region', v);\n        // parseRegion(v);\n        // break;\n        // }\n      }, /:/);\n    } // 5.1 WebVTT file parsing.\n\n\n    try {\n      var line = '';\n\n      if (_this.state === 'INITIAL') {\n        // We can't start parsing until we have the first line.\n        if (!/\\r\\n|\\n/.test(_this.buffer)) {\n          return this;\n        }\n\n        line = collectNextLine(); // strip of UTF-8 BOM if any\n        // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8\n\n        var m = line.match(/^()?WEBVTT([ \\t].*)?$/);\n\n        if (!m || !m[0]) {\n          throw new Error('Malformed WebVTT signature.');\n        }\n\n        _this.state = 'HEADER';\n      }\n\n      var alreadyCollectedLine = false;\n\n      while (_this.buffer) {\n        // We can't parse a line until we have the full line.\n        if (!/\\r\\n|\\n/.test(_this.buffer)) {\n          return this;\n        }\n\n        if (!alreadyCollectedLine) {\n          line = collectNextLine();\n        } else {\n          alreadyCollectedLine = false;\n        }\n\n        switch (_this.state) {\n          case 'HEADER':\n            // 13-18 - Allow a header (metadata) under the WEBVTT line.\n            if (/:/.test(line)) {\n              parseHeader(line);\n            } else if (!line) {\n              // An empty line terminates the header and starts the body (cues).\n              _this.state = 'ID';\n            }\n\n            continue;\n\n          case 'NOTE':\n            // Ignore NOTE blocks.\n            if (!line) {\n              _this.state = 'ID';\n            }\n\n            continue;\n\n          case 'ID':\n            // Check for the start of NOTE blocks.\n            if (/^NOTE($|[ \\t])/.test(line)) {\n              _this.state = 'NOTE';\n              break;\n            } // 19-29 - Allow any number of line terminators, then initialize new cue values.\n\n\n            if (!line) {\n              continue;\n            }\n\n            _this.cue = new _vttcue__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0, '');\n            _this.state = 'CUE'; // 30-39 - Check if self line contains an optional identifier or timing data.\n\n            if (line.indexOf('-->') === -1) {\n              _this.cue.id = line;\n              continue;\n            }\n\n          // Process line as start of a cue.\n\n          /* falls through */\n\n          case 'CUE':\n            // 40 - Collect cue timings and settings.\n            if (!_this.cue) {\n              _this.state = 'BADCUE';\n              continue;\n            }\n\n            try {\n              parseCue(line, _this.cue, _this.regionList);\n            } catch (e) {\n              // In case of an error ignore rest of the cue.\n              _this.cue = null;\n              _this.state = 'BADCUE';\n              continue;\n            }\n\n            _this.state = 'CUETEXT';\n            continue;\n\n          case 'CUETEXT':\n            {\n              var hasSubstring = line.indexOf('-->') !== -1; // 34 - If we have an empty line then report the cue.\n              // 35 - If we have the special substring '-->' then report the cue,\n              // but do not collect the line as we need to process the current\n              // one as a new cue.\n\n              if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n                // We are done parsing self cue.\n                if (_this.oncue && _this.cue) {\n                  _this.oncue(_this.cue);\n                }\n\n                _this.cue = null;\n                _this.state = 'ID';\n                continue;\n              }\n\n              if (_this.cue === null) {\n                continue;\n              }\n\n              if (_this.cue.text) {\n                _this.cue.text += '\\n';\n              }\n\n              _this.cue.text += line;\n            }\n            continue;\n\n          case 'BADCUE':\n            // 54-62 - Collect and discard the remaining cue.\n            if (!line) {\n              _this.state = 'ID';\n            }\n\n        }\n      }\n    } catch (e) {\n      // If we are currently parsing a cue, report what we have.\n      if (_this.state === 'CUETEXT' && _this.cue && _this.oncue) {\n        _this.oncue(_this.cue);\n      }\n\n      _this.cue = null; // Enter BADWEBVTT state if header was not parsed correctly otherwise\n      // another exception occurred so enter BADCUE state.\n\n      _this.state = _this.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';\n    }\n\n    return this;\n  };\n\n  _proto3.flush = function flush() {\n    var _this = this;\n\n    try {\n      // Finish decoding the stream.\n      // _this.buffer += _this.decoder.decode();\n      // Synthesize the end of the current cue or region.\n      if (_this.cue || _this.state === 'HEADER') {\n        _this.buffer += '\\n\\n';\n\n        _this.parse();\n      } // If we've flushed, parsed, and we're still on the INITIAL state then\n      // that means we don't have enough of the stream to parse the first\n      // line.\n\n\n      if (_this.state === 'INITIAL' || _this.state === 'BADWEBVTT') {\n        throw new Error('Malformed WebVTT signature.');\n      }\n    } catch (e) {\n      if (_this.onparsingerror) {\n        _this.onparsingerror(e);\n      }\n    }\n\n    if (_this.onflush) {\n      _this.onflush();\n    }\n\n    return this;\n  };\n\n  return VTTParser;\n}();\n\n/***/ }),\n\n/***/ \"./src/utils/webvtt-parser.ts\":\n/*!************************************!*\\\n  !*** ./src/utils/webvtt-parser.ts ***!\n  \\************************************/\n/*! exports provided: generateCueId, parseWebVTT */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_1018261__) {\n\n\"use strict\";\n__nested_webpack_require_1018261__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_1018261__.d(__webpack_exports__, \"generateCueId\", function() { return generateCueId; });\n/* harmony export (binding) */ __nested_webpack_require_1018261__.d(__webpack_exports__, \"parseWebVTT\", function() { return parseWebVTT; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1018261__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _vttparser__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1018261__(/*! ./vttparser */ \"./src/utils/vttparser.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1018261__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\n/* harmony import */ var _timescale_conversion__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1018261__(/*! ./timescale-conversion */ \"./src/utils/timescale-conversion.ts\");\n/* harmony import */ var _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_1018261__(/*! ../remux/mp4-remuxer */ \"./src/remux/mp4-remuxer.ts\");\n\n\n\n\n\n\n\n\nvar LINEBREAKS = /\\r\\n|\\n\\r|\\n|\\r/g; // String.prototype.startsWith is not supported in IE11\n\nvar startsWith = function startsWith(inputString, searchString, position) {\n  if (position === void 0) {\n    position = 0;\n  }\n\n  return inputString.slice(position, position + searchString.length) === searchString;\n};\n\nvar cueString2millis = function cueString2millis(timeString) {\n  var ts = parseInt(timeString.slice(-3));\n  var secs = parseInt(timeString.slice(-6, -4));\n  var mins = parseInt(timeString.slice(-9, -7));\n  var hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(':'))) : 0;\n\n  if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(ts) || !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(secs) || !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(mins) || !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(hours)) {\n    throw Error(\"Malformed X-TIMESTAMP-MAP: Local:\" + timeString);\n  }\n\n  ts += 1000 * secs;\n  ts += 60 * 1000 * mins;\n  ts += 60 * 60 * 1000 * hours;\n  return ts;\n}; // From https://github.com/darkskyapp/string-hash\n\n\nvar hash = function hash(text) {\n  var hash = 5381;\n  var i = text.length;\n\n  while (i) {\n    hash = hash * 33 ^ text.charCodeAt(--i);\n  }\n\n  return (hash >>> 0).toString();\n}; // Create a unique hash id for a cue based on start/end times and text.\n// This helps timeline-controller to avoid showing repeated captions.\n\n\nfunction generateCueId(startTime, endTime, text) {\n  return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);\n}\n\nvar calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {\n  var currCC = vttCCs[cc];\n  var prevCC = vttCCs[currCC.prevCC]; // This is the first discontinuity or cues have been processed since the last discontinuity\n  // Offset = current discontinuity time\n\n  if (!prevCC || !prevCC.new && currCC.new) {\n    vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;\n    currCC.new = false;\n    return;\n  } // There have been discontinuities since cues were last parsed.\n  // Offset = time elapsed\n\n\n  while ((_prevCC = prevCC) !== null && _prevCC !== void 0 && _prevCC.new) {\n    var _prevCC;\n\n    vttCCs.ccOffset += currCC.start - prevCC.start;\n    currCC.new = false;\n    currCC = prevCC;\n    prevCC = vttCCs[currCC.prevCC];\n  }\n\n  vttCCs.presentationOffset = presentationTime;\n};\n\nfunction parseWebVTT(vttByteArray, initPTS, timescale, vttCCs, cc, timeOffset, callBack, errorCallBack) {\n  var parser = new _vttparser__WEBPACK_IMPORTED_MODULE_1__[\"VTTParser\"](); // Convert byteArray into string, replacing any somewhat exotic linefeeds with \"\\n\", then split on that character.\n  // Uint8Array.prototype.reduce is not implemented in IE11\n\n  var vttLines = Object(_demux_id3__WEBPACK_IMPORTED_MODULE_2__[\"utf8ArrayToStr\"])(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, '\\n').split('\\n');\n  var cues = [];\n  var initPTS90Hz = Object(_timescale_conversion__WEBPACK_IMPORTED_MODULE_3__[\"toMpegTsClockFromTimescale\"])(initPTS, timescale);\n  var cueTime = '00:00.000';\n  var timestampMapMPEGTS = 0;\n  var timestampMapLOCAL = 0;\n  var parsingError;\n  var inHeader = true;\n\n  parser.oncue = function (cue) {\n    // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.\n    var currCC = vttCCs[cc];\n    var cueOffset = vttCCs.ccOffset; // Calculate subtitle PTS offset\n\n    var webVttMpegTsMapOffset = (timestampMapMPEGTS - initPTS90Hz) / 90000; // Update offsets for new discontinuities\n\n    if (currCC !== null && currCC !== void 0 && currCC.new) {\n      if (timestampMapLOCAL !== undefined) {\n        // When local time is provided, offset = discontinuity start time - local time\n        cueOffset = vttCCs.ccOffset = currCC.start;\n      } else {\n        calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);\n      }\n    }\n\n    if (webVttMpegTsMapOffset) {\n      // If we have MPEGTS, offset = presentation time + discontinuity offset\n      cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;\n    }\n\n    var duration = cue.endTime - cue.startTime;\n    var startTime = Object(_remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_4__[\"normalizePts\"])((cue.startTime + cueOffset - timestampMapLOCAL) * 90000, timeOffset * 90000) / 90000;\n    cue.startTime = Math.max(startTime, 0);\n    cue.endTime = Math.max(startTime + duration, 0); //trim trailing webvtt block whitespaces\n\n    var text = cue.text.trim(); // Fix encoding of special characters\n\n    cue.text = decodeURIComponent(encodeURIComponent(text)); // If the cue was not assigned an id from the VTT file (line above the content), create one.\n\n    if (!cue.id) {\n      cue.id = generateCueId(cue.startTime, cue.endTime, text);\n    }\n\n    if (cue.endTime > 0) {\n      cues.push(cue);\n    }\n  };\n\n  parser.onparsingerror = function (error) {\n    parsingError = error;\n  };\n\n  parser.onflush = function () {\n    if (parsingError) {\n      errorCallBack(parsingError);\n      return;\n    }\n\n    callBack(cues);\n  }; // Go through contents line by line.\n\n\n  vttLines.forEach(function (line) {\n    if (inHeader) {\n      // Look for X-TIMESTAMP-MAP in header.\n      if (startsWith(line, 'X-TIMESTAMP-MAP=')) {\n        // Once found, no more are allowed anyway, so stop searching.\n        inHeader = false; // Extract LOCAL and MPEGTS.\n\n        line.slice(16).split(',').forEach(function (timestamp) {\n          if (startsWith(timestamp, 'LOCAL:')) {\n            cueTime = timestamp.slice(6);\n          } else if (startsWith(timestamp, 'MPEGTS:')) {\n            timestampMapMPEGTS = parseInt(timestamp.slice(7));\n          }\n        });\n\n        try {\n          // Convert cue time to seconds\n          timestampMapLOCAL = cueString2millis(cueTime) / 1000;\n        } catch (error) {\n          parsingError = error;\n        } // Return without parsing X-TIMESTAMP-MAP line.\n\n\n        return;\n      } else if (line === '') {\n        inHeader = false;\n      }\n    } // Parse line by default.\n\n\n    parser.parse(line + '\\n');\n  });\n  parser.flush();\n}\n\n/***/ }),\n\n/***/ \"./src/utils/xhr-loader.ts\":\n/*!*********************************!*\\\n  !*** ./src/utils/xhr-loader.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_1025870__) {\n\n\"use strict\";\n__nested_webpack_require_1025870__.r(__webpack_exports__);\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1025870__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1025870__(/*! ../loader/load-stats */ \"./src/loader/load-stats.ts\");\n\n\nvar AGE_HEADER_LINE_REGEX = /^age:\\s*[\\d.]+\\s*$/m;\n\nvar XhrLoader = /*#__PURE__*/function () {\n  function XhrLoader(config\n  /* HlsConfig */\n  ) {\n    this.xhrSetup = void 0;\n    this.requestTimeout = void 0;\n    this.retryTimeout = void 0;\n    this.retryDelay = void 0;\n    this.config = null;\n    this.callbacks = null;\n    this.context = void 0;\n    this.loader = null;\n    this.stats = void 0;\n    this.xhrSetup = config ? config.xhrSetup : null;\n    this.stats = new _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__[\"LoadStats\"]();\n    this.retryDelay = 0;\n  }\n\n  var _proto = XhrLoader.prototype;\n\n  _proto.destroy = function destroy() {\n    this.callbacks = null;\n    this.abortInternal();\n    this.loader = null;\n    this.config = null;\n  };\n\n  _proto.abortInternal = function abortInternal() {\n    var loader = this.loader;\n    self.clearTimeout(this.requestTimeout);\n    self.clearTimeout(this.retryTimeout);\n\n    if (loader) {\n      loader.onreadystatechange = null;\n      loader.onprogress = null;\n\n      if (loader.readyState !== 4) {\n        this.stats.aborted = true;\n        loader.abort();\n      }\n    }\n  };\n\n  _proto.abort = function abort() {\n    var _this$callbacks;\n\n    this.abortInternal();\n\n    if ((_this$callbacks = this.callbacks) !== null && _this$callbacks !== void 0 && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.loader);\n    }\n  };\n\n  _proto.load = function load(context, config, callbacks) {\n    if (this.stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n\n    this.stats.loading.start = self.performance.now();\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.retryDelay = config.retryDelay;\n    this.loadInternal();\n  };\n\n  _proto.loadInternal = function loadInternal() {\n    var config = this.config,\n        context = this.context;\n\n    if (!config) {\n      return;\n    }\n\n    var xhr = this.loader = new self.XMLHttpRequest();\n    var stats = this.stats;\n    stats.loading.first = 0;\n    stats.loaded = 0;\n    var xhrSetup = this.xhrSetup;\n\n    try {\n      if (xhrSetup) {\n        try {\n          xhrSetup(xhr, context.url);\n        } catch (e) {\n          // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader(\"Content-Language\", \"test\");}\n          // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN\n          xhr.open('GET', context.url, true);\n          xhrSetup(xhr, context.url);\n        }\n      }\n\n      if (!xhr.readyState) {\n        xhr.open('GET', context.url, true);\n      }\n\n      var headers = this.context.headers;\n\n      if (headers) {\n        for (var header in headers) {\n          xhr.setRequestHeader(header, headers[header]);\n        }\n      }\n    } catch (e) {\n      // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n      this.callbacks.onError({\n        code: xhr.status,\n        text: e.message\n      }, context, xhr);\n      return;\n    }\n\n    if (context.rangeEnd) {\n      xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));\n    }\n\n    xhr.onreadystatechange = this.readystatechange.bind(this);\n    xhr.onprogress = this.loadprogress.bind(this);\n    xhr.responseType = context.responseType; // setup timeout before we perform request\n\n    self.clearTimeout(this.requestTimeout);\n    this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n    xhr.send();\n  };\n\n  _proto.readystatechange = function readystatechange() {\n    var context = this.context,\n        xhr = this.loader,\n        stats = this.stats;\n\n    if (!context || !xhr) {\n      return;\n    }\n\n    var readyState = xhr.readyState;\n    var config = this.config; // don't proceed if xhr has been aborted\n\n    if (stats.aborted) {\n      return;\n    } // >= HEADERS_RECEIVED\n\n\n    if (readyState >= 2) {\n      // clear xhr timeout and rearm it if readyState less than 4\n      self.clearTimeout(this.requestTimeout);\n\n      if (stats.loading.first === 0) {\n        stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n      }\n\n      if (readyState === 4) {\n        xhr.onreadystatechange = null;\n        xhr.onprogress = null;\n        var status = xhr.status; // http status between 200 to 299 are all successful\n\n        if (status >= 200 && status < 300) {\n          stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n          var data;\n          var len;\n\n          if (context.responseType === 'arraybuffer') {\n            data = xhr.response;\n            len = data.byteLength;\n          } else {\n            data = xhr.responseText;\n            len = data.length;\n          }\n\n          stats.loaded = stats.total = len;\n\n          if (!this.callbacks) {\n            return;\n          }\n\n          var onProgress = this.callbacks.onProgress;\n\n          if (onProgress) {\n            onProgress(stats, context, data, xhr);\n          }\n\n          if (!this.callbacks) {\n            return;\n          }\n\n          var response = {\n            url: xhr.responseURL,\n            data: data\n          };\n          this.callbacks.onSuccess(response, stats, context, xhr);\n        } else {\n          // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n          if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].error(status + \" while loading \" + context.url);\n            this.callbacks.onError({\n              code: status,\n              text: xhr.statusText\n            }, context, xhr);\n          } else {\n            // retry\n            _utils_logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].warn(status + \" while loading \" + context.url + \", retrying in \" + this.retryDelay + \"...\"); // abort and reset internal state\n\n            this.abortInternal();\n            this.loader = null; // schedule retry\n\n            self.clearTimeout(this.retryTimeout);\n            this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay); // set exponential backoff\n\n            this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);\n            stats.retry++;\n          }\n        }\n      } else {\n        // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n        self.clearTimeout(this.requestTimeout);\n        this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n      }\n    }\n  };\n\n  _proto.loadtimeout = function loadtimeout() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].warn(\"timeout while loading \" + this.context.url);\n    var callbacks = this.callbacks;\n\n    if (callbacks) {\n      this.abortInternal();\n      callbacks.onTimeout(this.stats, this.context, this.loader);\n    }\n  };\n\n  _proto.loadprogress = function loadprogress(event) {\n    var stats = this.stats;\n    stats.loaded = event.loaded;\n\n    if (event.lengthComputable) {\n      stats.total = event.total;\n    }\n  };\n\n  _proto.getCacheAge = function getCacheAge() {\n    var result = null;\n\n    if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {\n      var ageHeader = this.loader.getResponseHeader('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n\n    return result;\n  };\n\n  return XhrLoader;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (XhrLoader);\n\n/***/ })\n\n/******/ })[\"default\"];\n});\n//# sourceMappingURL=hls.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLElBQUksTUFBTSxpQkFBaUIsR0FBRyxjQUFjLFVBQVUsUUFBUTtBQUMvRjtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNklBQTZJO0FBQzdJOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRztBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQ0FBbUI7O0FBRWhFO0FBQ0EsZ0NBQW1CO0FBQ25CLGdFQUFnRSxnQ0FBbUI7QUFDbkYsZ0VBQWdFLGdDQUFtQjtBQUNuRixrRkFBa0YsZ0NBQW1CO0FBQ3JHLHNFQUFzRSxnQ0FBbUI7QUFDekYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7O0FBRS9QLDhEQUE4RCxzRUFBc0UsOERBQThELGtEQUFrRCxpQkFBaUIsR0FBRzs7QUFFeFEsZ0RBQWdELDBEQUEwRCwyQ0FBMkM7O0FBRXJKLGlDQUFpQywwR0FBMEcsaUJBQWlCLGFBQWE7Ozs7Ozs7QUFPeks7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7O0FBRVY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHdCQUF3QjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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c0RBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxtQ0FBbUM7OztBQUczQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4UkFBOFI7O0FBRTlSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwSUFBMEk7O0FBRTFJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvRUFBb0U7QUFDOUU7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5RUFBeUU7QUFDekU7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHOztBQUUxRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGdJQUFnSTs7QUFFaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOzs7O0FB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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEdBQTBHOztBQUUxRztBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7O0FBRWQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0RBQXNEO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQW1COztBQUVoRTtBQUNBLGlDQUFtQjtBQUNuQiwrQkFBK0IsaUNBQW1CLGdEQUFnRCx3QkFBd0I7QUFDMUgsZ0VBQWdFLGlDQUFtQjtBQUNuRixvRUFBb0UsaUNBQW1CO0FBQ3ZGLDZFQUE2RSxpQ0FBbUI7QUFDaEcsc0VBQXNFLGlDQUFtQjtBQUN6Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDs7QUFFL1AsOERBQThELHNFQUFzRSw4REFBOEQsa0RBQWtELGlCQUFpQixHQUFHOztBQUV4USw4REFBOEQsaUZBQWlGLGdEQUFnRCx3SEFBd0gsZ0JBQWdCLFdBQVcscUJBQXFCLDRCQUE0QixjQUFjLFNBQVMsbUNBQW1DOztBQUU3YixrREFBa0QsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRDs7QUFFN1MsdUNBQXVDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjs7QUFFekssc0JBQXNCLHNFQUFzRSxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsaUNBQWlDLGtCQUFrQjs7Ozs7O0FBTTFTO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOzs7O0FBSUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlDQUFtQjs7QUFFaEU7QUFDQSxpQ0FBbUI7QUFDbkIsK0JBQStCLGlDQUFtQixnREFBZ0QseUJBQXlCO0FBQzNILHFFQUFxRSxpQ0FBbUI7QUFDeEYsZ0VBQWdFLGlDQUFtQjtBQUNuRixnRUFBZ0UsaUNBQW1CO0FBQ25GLHNFQUFzRSxpQ0FBbUI7QUFDekYsc0VBQXNFLGlDQUFtQjtBQUN6RixrRkFBa0YsaUNBQW1CO0FBQ3JHLHNFQUFzRSxpQ0FBbUI7QUFDekYsc0JBQXNCLHNFQUFzRSxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsaUNBQWlDLGtCQUFrQjs7QUFFMVMsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7O0FBRS9QLDhEQUE4RCxzRUFBc0UsOERBQThELGtEQUFrRCxpQkFBaUIsR0FBRzs7QUFFeFEsZ0RBQWdELDBEQUEwRCwyQ0FBMkM7O0FBRXJKLGlDQUFpQywwR0FBMEcsaUJBQWlCLGFBQWE7O0FBRXpLO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTyxHQUFHOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBLE9BQU87QUFDUCw2QkFBNkI7O0FBRTdCLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLCtGQUErRjs7QUFFL0Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHVDQUF1QztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUEsMkxBQTJMO0FBQzNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxzQkFBc0I7QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJLHNEQUFzRCw0Q0FBNEM7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlDQUFtQjs7QUFFaEU7QUFDQSxpQ0FBbUI7QUFDbkIsK0JBQStCLGlDQUFtQixnREFBZ0QsMEJBQTBCO0FBQzVILDZHQUE2RyxpQ0FBbUI7QUFDaEksZ0ZBQWdGLGlDQUFtQjtBQUNuRyxzRUFBc0UsaUNBQW1CO0FBQ3pGLGdFQUFnRSxpQ0FBbUI7QUFDbkYsNkVBQTZFLGlDQUFtQjtBQUNoRywwRUFBMEUsaUNBQW1CO0FBQzdGLHNFQUFzRSxpQ0FBbUI7QUFDekYseUVBQXlFLGlDQUFtQjtBQUM1RixvRkFBb0YsaUNBQW1CO0FBQ3ZHLDBFQUEwRSxpQ0FBbUI7QUFDN0YseUVBQXlFLGlDQUFtQjtBQUM1RixpRUFBaUUsaUNBQW1CO0FBQ3BGLHVFQUF1RSxpQ0FBbUI7Ozs7OztBQU0xRiw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDs7QUFFL1AsOERBQThELHNFQUFzRSw4REFBOEQsa0RBQWtELGlCQUFpQixHQUFHOztBQUV4USxnREFBZ0QsMERBQTBELDJDQUEyQzs7QUFFckosaUNBQWlDLDBHQUEwRyxpQkFBaUIsYUFBYTs7Ozs7Ozs7Ozs7Ozs7QUFjeksseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7OztBQUdBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7O0FBRXBDLG1FQUFtRTs7QUFFbkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRTs7QUFFckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDOztBQUU5QztBQUNBOztBQUVBLHdEQUF3RDtBQUN4RCwrQkFBK0IsU0FBUyxNQUFNLGlCQUFpQixHQUFHLGNBQWMsVUFBVSxXQUFXLE9BQU8sUUFBUTs7O0FBR3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWLGdDQUFnQzs7QUFFaEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSUFBc0k7QUFDdEk7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGOztBQUUvRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFGQUFxRjtBQUNyRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQywrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7OztBQUdkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRGQUE0Rjs7QUFFNUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7Ozs7QUFJRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQW1COztBQUVoRTtBQUNBLGlDQUFtQjtBQUNuQiwrQkFBK0IsaUNBQW1CLGlFQUFpRSxrQ0FBa0M7QUFDckosZ0VBQWdFLGlDQUFtQjtBQUNuRiw2RUFBNkUsaUNBQW1CO0FBQ2hHLDBFQUEwRSxpQ0FBbUI7QUFDN0YsK0VBQStFLGlDQUFtQjtBQUNsRyxzRUFBc0UsaUNBQW1CO0FBQ3pGLDBFQUEwRSxpQ0FBbUI7QUFDN0YsZ0ZBQWdGLGlDQUFtQjtBQUNuRyxzRUFBc0UsaUNBQW1CO0FBQ3pGLHFFQUFxRSxpQ0FBbUI7QUFDeEYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7O0FBRS9QLDhEQUE4RCxzRUFBc0UsOERBQThELGtEQUFrRCxpQkFBaUIsR0FBRzs7QUFFeFEsZ0RBQWdELDBEQUEwRCwyQ0FBMkM7O0FBRXJKLGlDQUFpQywwR0FBMEcsaUJBQWlCLGFBQWE7Ozs7Ozs7Ozs7O0FBV3pLLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DOztBQUVwQyxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlDQUFtQjs7QUFFaEU7QUFDQSxpQ0FBbUI7QUFDbkIsZ0VBQWdFLGlDQUFtQjtBQUNuRiwrRUFBK0UsaUNBQW1CO0FBQ2xHLGtGQUFrRixpQ0FBbUI7QUFDckcsc0VBQXNFLGlDQUFtQjtBQUN6Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDs7QUFFL1AsOERBQThELHNFQUFzRSw4REFBOEQsa0RBQWtELGlCQUFpQixHQUFHOztBQUV4USxnREFBZ0QsMERBQTBELDJDQUEyQzs7QUFFckosaUNBQWlDLDBHQUEwRyxpQkFBaUIsYUFBYTs7Ozs7OztBQU96SztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0VBQWtFOztBQUVsRTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsdUJBQXVCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLG9CQUFvQjtBQUN6QztB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QTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUFtQjs7Ozs7Ozs7QUFROUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QiwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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Q0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJDQUEyQyx1Q0FBdUM7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7O0FBRUEsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQW1COztBQUVoRTtBQUNBLGlDQUFtQjtBQUNuQiwrQkFBK0IsaUNBQW1CLG1EQUFtRCxvQkFBb0I7QUFDekgsOERBQThELGlDQUFtQjtBQUNqRixtRUFBbUUsaUNBQW1CO0FBQ3RGLG9FQUFvRSxpQ0FBbUI7QUFDdkYsb0VBQW9FLGlDQUFtQjtBQUN2RixnRUFBZ0UsaUNBQW1CO0FBQ25GLHlFQUF5RSxpQ0FBbUI7QUFDNUYsc0VBQXNFLGlDQUFtQjtBQUN6RixnRUFBZ0UsaUNBQW1CO0FBQ25GLHVFQUF1RSxpQ0FBbUI7QUFDMUYsc0JBQXNCLHNFQUFzRSxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsaUNBQWlDLGtCQUFrQjs7QUFFMVM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUEsaUNBQWlDLGFBQWE7QUFDOUM7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0EsaURBQWlEOztBQUVqRDs7QUFFQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7O0FBRUEsK0VBQStFOztBQUUvRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDhGQUE4Rjs7QUFFOUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsVUFBVTtBQUNWO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxj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QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2RkFBNkYsYUFBYTtBQUMxRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQ0FBbUI7O0FBRWhFO0FBQ0EsaUNBQW1CO0FBQ25CLCtCQUErQixpQ0FBbUIsOERBQThELCtCQUErQjtBQUMvSSwrQkFBK0IsaUNBQW1CLG9EQUFvRCxxQkFBcUI7QUFDM0gsK0JBQStCLGlDQUFtQixpREFBaUQsa0JBQWtCO0FBQ3JILCtCQUErQixpQ0FBbUIsNkNBQTZDLGNBQWM7QUFDN0csNkdBQTZHLGlDQUFtQjtBQUNoSSxvRUFBb0UsaUNBQW1CO0FBQ3ZGLHlGQUF5RixpQ0FBbUI7QUFDNUcsc0VBQXNFLGlDQUFtQjtBQUN6RixtRUFBbUUsaUNBQW1CO0FBQ3RGLG9FQUFvRSxpQ0FBbUI7Ozs7QUFJdkYsZ0RBQWdELDBEQUEwRCwyQ0FBMkM7O0FBRXJKLGlDQUFpQywwR0FBMEcsaUJBQWlCLGFBQWE7O0FBRXpLLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RCxrREFBa0QsaUJBQWlCLEdBQUc7Ozs7OztBQU14UTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7O0FBR04sMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhIQUE4SDs7QUFFOUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhFQUE4RTs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0EsOEZBQThGOztBQUU5RjtBQUNBLE1BQU07QUFDTjs7O0FBR0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLG9CQUFvQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDOztBQUVBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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OztBQUVBLDBDQUEwQyxTQUFTO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0EsMERBQTBEOztBQUUxRCxxREFBcUQ7O0FBRXJEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEOztBQUV4RCxnREFBZ0Q7QUFDaEQ7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBLDhKQUE4Sjs7QUFFOUo7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0EsZ0dBQWdHOztBQUVoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTzs7QUFFUCxVQUFVO0FBQ1YsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9obHMuanMvZGlzdC9obHMuanM/ZjdjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJIbHNcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiSGxzXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9kaXN0L1wiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2hscy50c1wiKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAodHJ1ZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy91cmwtdG9vbGtpdC9zcmMvdXJsLXRvb2xraXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxODA4XG5cbihmdW5jdGlvbiAocm9vdCkge1xuICB2YXIgVVJMX1JFR0VYID1cbiAgICAvXig/PSgoPzpbYS16QS1aMC05K1xcLS5dKzopPykpXFwxKD89KCg/OlxcL1xcL1teXFwvPyNdKik/KSlcXDIoPz0oKD86KD86W14/I1xcL10qXFwvKSpbXjs/I1xcL10qKT8pKVxcMygoPzo7W14/I10qKT8pKFxcP1teI10qKT8oI1teXSopPyQvO1xuICB2YXIgRklSU1RfU0VHTUVOVF9SRUdFWCA9IC9eKD89KFteXFwvPyNdKikpXFwxKFteXSopJC87XG4gIHZhciBTTEFTSF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuKD89XFwvKS9nO1xuICB2YXIgU0xBU0hfRE9UX0RPVF9SRUdFWCA9IC8oPzpcXC98XilcXC5cXC5cXC8oPyFcXC5cXC5cXC8pW15cXC9dKig/PVxcLykvZztcblxuICB2YXIgVVJMVG9vbGtpdCA9IHtcbiAgICAvLyBJZiBvcHRzLmFsd2F5c05vcm1hbGl6ZSBpcyB0cnVlIHRoZW4gdGhlIHBhdGggd2lsbCBhbHdheXMgYmUgbm9ybWFsaXplZCBldmVuIHdoZW4gaXQgc3RhcnRzIHdpdGggLyBvciAvL1xuICAgIC8vIEUuZ1xuICAgIC8vIFdpdGggb3B0cy5hbHdheXNOb3JtYWxpemUgPSBmYWxzZSAoZGVmYXVsdCwgc3BlYyBjb21wbGlhbnQpXG4gICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZi8uLi9nXG4gICAgLy8gV2l0aCBvcHRzLmFsd2F5c05vcm1hbGl6ZSA9IHRydWUgKG5vdCBzcGVjIGNvbXBsaWFudClcbiAgICAvLyBodHRwOi8vYS5jb20vYi9jZCArIC9lL2YvLi4vZyA9PiBodHRwOi8vYS5jb20vZS9nXG4gICAgYnVpbGRBYnNvbHV0ZVVSTDogZnVuY3Rpb24gKGJhc2VVUkwsIHJlbGF0aXZlVVJMLCBvcHRzKSB7XG4gICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgIC8vIHJlbW92ZSBhbnkgcmVtYWluaW5nIHNwYWNlIGFuZCBDUkxGXG4gICAgICBiYXNlVVJMID0gYmFzZVVSTC50cmltKCk7XG4gICAgICByZWxhdGl2ZVVSTCA9IHJlbGF0aXZlVVJMLnRyaW0oKTtcbiAgICAgIGlmICghcmVsYXRpdmVVUkwpIHtcbiAgICAgICAgLy8gMmEpIElmIHRoZSBlbWJlZGRlZCBVUkwgaXMgZW50aXJlbHkgZW1wdHksIGl0IGluaGVyaXRzIHRoZVxuICAgICAgICAvLyBlbnRpcmUgYmFzZSBVUkwgKGkuZS4sIGlzIHNldCBlcXVhbCB0byB0aGUgYmFzZSBVUkwpXG4gICAgICAgIC8vIGFuZCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuICAgICAgICAgIHJldHVybiBiYXNlVVJMO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXNlUGFydHNGb3JOb3JtYWxpc2UgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xuICAgICAgICBpZiAoIWJhc2VQYXJ0c0Zvck5vcm1hbGlzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xuICAgICAgICB9XG4gICAgICAgIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZS5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKFxuICAgICAgICAgIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZS5wYXRoXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKGJhc2VQYXJ0c0Zvck5vcm1hbGlzZSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVsYXRpdmVQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwocmVsYXRpdmVVUkwpO1xuICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIHJlbGF0aXZlIFVSTC4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnNjaGVtZSkge1xuICAgICAgICAvLyAyYikgSWYgdGhlIGVtYmVkZGVkIFVSTCBzdGFydHMgd2l0aCBhIHNjaGVtZSBuYW1lLCBpdCBpc1xuICAgICAgICAvLyBpbnRlcnByZXRlZCBhcyBhbiBhYnNvbHV0ZSBVUkwgYW5kIHdlIGFyZSBkb25lLlxuICAgICAgICBpZiAoIW9wdHMuYWx3YXlzTm9ybWFsaXplKSB7XG4gICAgICAgICAgcmV0dXJuIHJlbGF0aXZlVVJMO1xuICAgICAgICB9XG4gICAgICAgIHJlbGF0aXZlUGFydHMucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChyZWxhdGl2ZVBhcnRzLnBhdGgpO1xuICAgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhyZWxhdGl2ZVBhcnRzKTtcbiAgICAgIH1cbiAgICAgIHZhciBiYXNlUGFydHMgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xuICAgICAgaWYgKCFiYXNlUGFydHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWJhc2VQYXJ0cy5uZXRMb2MgJiYgYmFzZVBhcnRzLnBhdGggJiYgYmFzZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xuICAgICAgICAvLyBJZiBuZXRMb2MgbWlzc2luZyBhbmQgcGF0aCBkb2Vzbid0IHN0YXJ0IHdpdGggJy8nLCBhc3N1bWUgZXZlcnRoaW5nIGJlZm9yZSB0aGUgZmlyc3QgJy8nIGlzIHRoZSBuZXRMb2NcbiAgICAgICAgLy8gVGhpcyBjYXVzZXMgJ2V4YW1wbGUuY29tL2EnIHRvIGJlIGhhbmRsZWQgYXMgJy8vZXhhbXBsZS5jb20vYScgaW5zdGVhZCBvZiAnL2V4YW1wbGUuY29tL2EnXG4gICAgICAgIHZhciBwYXRoUGFydHMgPSBGSVJTVF9TRUdNRU5UX1JFR0VYLmV4ZWMoYmFzZVBhcnRzLnBhdGgpO1xuICAgICAgICBiYXNlUGFydHMubmV0TG9jID0gcGF0aFBhcnRzWzFdO1xuICAgICAgICBiYXNlUGFydHMucGF0aCA9IHBhdGhQYXJ0c1syXTtcbiAgICAgIH1cbiAgICAgIGlmIChiYXNlUGFydHMubmV0TG9jICYmICFiYXNlUGFydHMucGF0aCkge1xuICAgICAgICBiYXNlUGFydHMucGF0aCA9ICcvJztcbiAgICAgIH1cbiAgICAgIHZhciBidWlsdFBhcnRzID0ge1xuICAgICAgICAvLyAyYykgT3RoZXJ3aXNlLCB0aGUgZW1iZWRkZWQgVVJMIGluaGVyaXRzIHRoZSBzY2hlbWUgb2ZcbiAgICAgICAgLy8gdGhlIGJhc2UgVVJMLlxuICAgICAgICBzY2hlbWU6IGJhc2VQYXJ0cy5zY2hlbWUsXG4gICAgICAgIG5ldExvYzogcmVsYXRpdmVQYXJ0cy5uZXRMb2MsXG4gICAgICAgIHBhdGg6IG51bGwsXG4gICAgICAgIHBhcmFtczogcmVsYXRpdmVQYXJ0cy5wYXJhbXMsXG4gICAgICAgIHF1ZXJ5OiByZWxhdGl2ZVBhcnRzLnF1ZXJ5LFxuICAgICAgICBmcmFnbWVudDogcmVsYXRpdmVQYXJ0cy5mcmFnbWVudCxcbiAgICAgIH07XG4gICAgICBpZiAoIXJlbGF0aXZlUGFydHMubmV0TG9jKSB7XG4gICAgICAgIC8vIDMpIElmIHRoZSBlbWJlZGRlZCBVUkwncyA8bmV0X2xvYz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG4gICAgICAgIC8vIFN0ZXAgNy4gIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgPG5ldF9sb2M+XG4gICAgICAgIC8vIChpZiBhbnkpIG9mIHRoZSBiYXNlIFVSTC5cbiAgICAgICAgYnVpbHRQYXJ0cy5uZXRMb2MgPSBiYXNlUGFydHMubmV0TG9jO1xuICAgICAgICAvLyA0KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgcHJlY2VkZWQgYnkgYSBzbGFzaCBcIi9cIiwgdGhlXG4gICAgICAgIC8vIHBhdGggaXMgbm90IHJlbGF0aXZlIGFuZCB3ZSBza2lwIHRvIFN0ZXAgNy5cbiAgICAgICAgaWYgKHJlbGF0aXZlUGFydHMucGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhdGgpIHtcbiAgICAgICAgICAgIC8vIDUpIElmIHRoZSBlbWJlZGRlZCBVUkwgcGF0aCBpcyBlbXB0eSAoYW5kIG5vdCBwcmVjZWRlZCBieSBhXG4gICAgICAgICAgICAvLyBzbGFzaCksIHRoZW4gdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgYmFzZSBVUkwgcGF0aFxuICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gYmFzZVBhcnRzLnBhdGg7XG4gICAgICAgICAgICAvLyA1YSkgaWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxwYXJhbXM+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cGFyYW1zPiBvZiB0aGUgYmFzZVxuICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZFxuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhcmFtcykge1xuICAgICAgICAgICAgICBidWlsdFBhcnRzLnBhcmFtcyA9IGJhc2VQYXJ0cy5wYXJhbXM7XG4gICAgICAgICAgICAgIC8vIDViKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHF1ZXJ5PiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cXVlcnk+IG9mIHRoZSBiYXNlXG4gICAgICAgICAgICAgIC8vIFVSTCAoaWYgYW55KSBhbmQgd2Ugc2tpcCB0byBzdGVwIDcuXG4gICAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5xdWVyeSkge1xuICAgICAgICAgICAgICAgIGJ1aWx0UGFydHMucXVlcnkgPSBiYXNlUGFydHMucXVlcnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gNikgVGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgYmFzZSBVUkwncyBwYXRoIChhbnl0aGluZ1xuICAgICAgICAgICAgLy8gZm9sbG93aW5nIHRoZSByaWdodG1vc3Qgc2xhc2ggXCIvXCIsIG9yIHRoZSBlbnRpcmUgcGF0aCBpZiBub1xuICAgICAgICAgICAgLy8gc2xhc2ggaXMgcHJlc2VudCkgaXMgcmVtb3ZlZCBhbmQgdGhlIGVtYmVkZGVkIFVSTCdzIHBhdGggaXNcbiAgICAgICAgICAgIC8vIGFwcGVuZGVkIGluIGl0cyBwbGFjZS5cbiAgICAgICAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgdmFyIG5ld1BhdGggPVxuICAgICAgICAgICAgICBiYXNlVVJMUGF0aC5zdWJzdHJpbmcoMCwgYmFzZVVSTFBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpICtcbiAgICAgICAgICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJ1aWx0UGFydHMucGF0aCA9PT0gbnVsbCkge1xuICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBvcHRzLmFsd2F5c05vcm1hbGl6ZVxuICAgICAgICAgID8gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKHJlbGF0aXZlUGFydHMucGF0aClcbiAgICAgICAgICA6IHJlbGF0aXZlUGFydHMucGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKGJ1aWx0UGFydHMpO1xuICAgIH0sXG4gICAgcGFyc2VVUkw6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFVSTF9SRUdFWC5leGVjKHVybCk7XG4gICAgICBpZiAoIXBhcnRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NoZW1lOiBwYXJ0c1sxXSB8fCAnJyxcbiAgICAgICAgbmV0TG9jOiBwYXJ0c1syXSB8fCAnJyxcbiAgICAgICAgcGF0aDogcGFydHNbM10gfHwgJycsXG4gICAgICAgIHBhcmFtczogcGFydHNbNF0gfHwgJycsXG4gICAgICAgIHF1ZXJ5OiBwYXJ0c1s1XSB8fCAnJyxcbiAgICAgICAgZnJhZ21lbnQ6IHBhcnRzWzZdIHx8ICcnLFxuICAgICAgfTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZVBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG9wZXJhdGlvbnMgYXJlXG4gICAgICAvLyB0aGVuIGFwcGxpZWQsIGluIG9yZGVyLCB0byB0aGUgbmV3IHBhdGg6XG4gICAgICAvLyA2YSkgQWxsIG9jY3VycmVuY2VzIG9mIFwiLi9cIiwgd2hlcmUgXCIuXCIgaXMgYSBjb21wbGV0ZSBwYXRoXG4gICAgICAvLyBzZWdtZW50LCBhcmUgcmVtb3ZlZC5cbiAgICAgIC8vIDZiKSBJZiB0aGUgcGF0aCBlbmRzIHdpdGggXCIuXCIgYXMgYSBjb21wbGV0ZSBwYXRoIHNlZ21lbnQsXG4gICAgICAvLyB0aGF0IFwiLlwiIGlzIHJlbW92ZWQuXG4gICAgICBwYXRoID0gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpLnJlcGxhY2UoU0xBU0hfRE9UX1JFR0VYLCAnJyk7XG4gICAgICAvLyA2YykgQWxsIG9jY3VycmVuY2VzIG9mIFwiPHNlZ21lbnQ+Ly4uL1wiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuICAgICAgLy8gY29tcGxldGUgcGF0aCBzZWdtZW50IG5vdCBlcXVhbCB0byBcIi4uXCIsIGFyZSByZW1vdmVkLlxuICAgICAgLy8gUmVtb3ZhbCBvZiB0aGVzZSBwYXRoIHNlZ21lbnRzIGlzIHBlcmZvcm1lZCBpdGVyYXRpdmVseSxcbiAgICAgIC8vIHJlbW92aW5nIHRoZSBsZWZ0bW9zdCBtYXRjaGluZyBwYXR0ZXJuIG9uIGVhY2ggaXRlcmF0aW9uLFxuICAgICAgLy8gdW50aWwgbm8gbWF0Y2hpbmcgcGF0dGVybiByZW1haW5zLlxuICAgICAgLy8gNmQpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIjxzZWdtZW50Pi8uLlwiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuICAgICAgLy8gY29tcGxldGUgcGF0aCBzZWdtZW50IG5vdCBlcXVhbCB0byBcIi4uXCIsIHRoYXRcbiAgICAgIC8vIFwiPHNlZ21lbnQ+Ly4uXCIgaXMgcmVtb3ZlZC5cbiAgICAgIHdoaWxlIChcbiAgICAgICAgcGF0aC5sZW5ndGggIT09IChwYXRoID0gcGF0aC5yZXBsYWNlKFNMQVNIX0RPVF9ET1RfUkVHRVgsICcnKSkubGVuZ3RoXG4gICAgICApIHt9XG4gICAgICByZXR1cm4gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xuICAgIH0sXG4gICAgYnVpbGRVUkxGcm9tUGFydHM6IGZ1bmN0aW9uIChwYXJ0cykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgcGFydHMuc2NoZW1lICtcbiAgICAgICAgcGFydHMubmV0TG9jICtcbiAgICAgICAgcGFydHMucGF0aCArXG4gICAgICAgIHBhcnRzLnBhcmFtcyArXG4gICAgICAgIHBhcnRzLnF1ZXJ5ICtcbiAgICAgICAgcGFydHMuZnJhZ21lbnRcbiAgICAgICk7XG4gICAgfSxcbiAgfTtcblxuICBpZiAodHJ1ZSlcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFVSTFRvb2xraXQ7XG4gIGVsc2Uge31cbn0pKHRoaXMpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3dlYndvcmtpZnktd2VicGFjay9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvd2Vid29ya2lmeS13ZWJwYWNrL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiB3ZWJwYWNrQm9vdHN0cmFwRnVuYyAobW9kdWxlcykge1xuLyoqKioqKi8gIC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovICB2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyAgLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovICBmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovICAgIC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gICAgaWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyAgICAgIHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyAgICAvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gICAgdmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gICAgICBpOiBtb2R1bGVJZCxcbi8qKioqKiovICAgICAgbDogZmFsc2UsXG4vKioqKioqLyAgICAgIGV4cG9ydHM6IHt9XG4vKioqKioqLyAgICB9O1xuXG4vKioqKioqLyAgICAvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovICAgIG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyAgICAvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyAgICBtb2R1bGUubCA9IHRydWU7XG5cbi8qKioqKiovICAgIC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyAgfVxuXG4vKioqKioqLyAgLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyAgLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyAgLy8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuLyoqKioqKi8gIC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gICAgaWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovICAgICAgICBnZXQ6IGdldHRlclxuLyoqKioqKi8gICAgICB9KTtcbi8qKioqKiovICAgIH1cbi8qKioqKiovICB9O1xuXG4vKioqKioqLyAgLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyAgfTtcblxuLyoqKioqKi8gIC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyAgICB2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovICAgICAgZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovICAgICAgZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovICAgIF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovICAgIHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyAgfTtcblxuLyoqKioqKi8gIC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuLyoqKioqKi8gIC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvXCI7XG5cbi8qKioqKiovICAvLyBvbiBlcnJvciBmdW5jdGlvbiBmb3IgYXN5bmMgbG9hZGluZ1xuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ub2UgPSBmdW5jdGlvbihlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB0aHJvdyBlcnI7IH07XG5cbiAgdmFyIGYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IEVOVFJZX01PRFVMRSlcbiAgcmV0dXJuIGYuZGVmYXVsdCB8fCBmIC8vIHRyeSB0byBjYWxsIGRlZmF1bHQgaWYgZGVmaW5lZCB0byBhbHNvIHN1cHBvcnQgYmFiZWwgZXNtb2R1bGUgZXhwb3J0c1xufVxuXG52YXIgbW9kdWxlTmFtZVJlcUV4cCA9ICdbXFxcXC58XFxcXC18XFxcXCt8XFxcXHd8XFwvfEBdKydcbnZhciBkZXBlbmRlbmN5UmVnRXhwID0gJ1xcXFwoXFxcXHMqKFxcL1xcXFwqLio/XFxcXCpcXC8pP1xcXFxzKi4qPygnICsgbW9kdWxlTmFtZVJlcUV4cCArICcpLio/XFxcXCknIC8vIGFkZGl0aW9uYWwgY2hhcnMgd2hlbiBvdXRwdXQucGF0aGluZm8gaXMgdHJ1ZVxuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNTkzNjYxLzEzMDQ0MlxuZnVuY3Rpb24gcXVvdGVSZWdFeHAgKHN0cikge1xuICByZXR1cm4gKHN0ciArICcnKS5yZXBsYWNlKC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2csICdcXFxcJCYnKVxufVxuXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gIWlzTmFOKDEgKiBuKTsgLy8gMSAqIG4gY29udmVydHMgaW50ZWdlcnMsIGludGVnZXJzIGFzIHN0cmluZyAoXCIxMjNcIiksIDFlMyBhbmQgXCIxZTNcIiB0byBpbnRlZ2VycyBhbmQgc3RyaW5ncyB0byBOYU5cbn1cblxuZnVuY3Rpb24gZ2V0TW9kdWxlRGVwZW5kZW5jaWVzIChzb3VyY2VzLCBtb2R1bGUsIHF1ZXVlTmFtZSkge1xuICB2YXIgcmV0dmFsID0ge31cbiAgcmV0dmFsW3F1ZXVlTmFtZV0gPSBbXVxuXG4gIHZhciBmblN0cmluZyA9IG1vZHVsZS50b1N0cmluZygpXG4gIHZhciB3cmFwcGVyU2lnbmF0dXJlID0gZm5TdHJpbmcubWF0Y2goL15mdW5jdGlvblxccz9cXHcqXFwoXFx3KyxcXHMqXFx3KyxcXHMqKFxcdyspXFwpLylcbiAgaWYgKCF3cmFwcGVyU2lnbmF0dXJlKSByZXR1cm4gcmV0dmFsXG4gIHZhciB3ZWJwYWNrUmVxdWlyZU5hbWUgPSB3cmFwcGVyU2lnbmF0dXJlWzFdXG5cbiAgLy8gbWFpbiBidW5kbGUgZGVwc1xuICB2YXIgcmUgPSBuZXcgUmVnRXhwKCcoXFxcXFxcXFxufFxcXFxXKScgKyBxdW90ZVJlZ0V4cCh3ZWJwYWNrUmVxdWlyZU5hbWUpICsgZGVwZW5kZW5jeVJlZ0V4cCwgJ2cnKVxuICB2YXIgbWF0Y2hcbiAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoZm5TdHJpbmcpKSkge1xuICAgIGlmIChtYXRjaFszXSA9PT0gJ2RsbC1yZWZlcmVuY2UnKSBjb250aW51ZVxuICAgIHJldHZhbFtxdWV1ZU5hbWVdLnB1c2gobWF0Y2hbM10pXG4gIH1cblxuICAvLyBkbGwgZGVwc1xuICByZSA9IG5ldyBSZWdFeHAoJ1xcXFwoJyArIHF1b3RlUmVnRXhwKHdlYnBhY2tSZXF1aXJlTmFtZSkgKyAnXFxcXChcIihkbGwtcmVmZXJlbmNlXFxcXHMoJyArIG1vZHVsZU5hbWVSZXFFeHAgKyAnKSlcIlxcXFwpXFxcXCknICsgZGVwZW5kZW5jeVJlZ0V4cCwgJ2cnKVxuICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhmblN0cmluZykpKSB7XG4gICAgaWYgKCFzb3VyY2VzW21hdGNoWzJdXSkge1xuICAgICAgcmV0dmFsW3F1ZXVlTmFtZV0ucHVzaChtYXRjaFsxXSlcbiAgICAgIHNvdXJjZXNbbWF0Y2hbMl1dID0gX193ZWJwYWNrX3JlcXVpcmVfXyhtYXRjaFsxXSkubVxuICAgIH1cbiAgICByZXR2YWxbbWF0Y2hbMl1dID0gcmV0dmFsW21hdGNoWzJdXSB8fCBbXVxuICAgIHJldHZhbFttYXRjaFsyXV0ucHVzaChtYXRjaFs0XSlcbiAgfVxuXG4gIC8vIGNvbnZlcnQgMWUzIGJhY2sgdG8gMTAwMCAtIHRoaXMgY2FuIGJlIGltcG9ydGFudCBhZnRlciB1Z2xpZnktanMgY29udmVydGVkIDEwMDAgdG8gMWUzXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmV0dmFsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXR2YWxba2V5c1tpXV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChpc051bWVyaWMocmV0dmFsW2tleXNbaV1dW2pdKSkge1xuICAgICAgICByZXR2YWxba2V5c1tpXV1bal0gPSAxICogcmV0dmFsW2tleXNbaV1dW2pdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR2YWxcbn1cblxuZnVuY3Rpb24gaGFzVmFsdWVzSW5RdWV1ZXMgKHF1ZXVlcykge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHF1ZXVlcylcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNWYWx1ZXMsIGtleSkge1xuICAgIHJldHVybiBoYXNWYWx1ZXMgfHwgcXVldWVzW2tleV0ubGVuZ3RoID4gMFxuICB9LCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gZ2V0UmVxdWlyZWRNb2R1bGVzIChzb3VyY2VzLCBtb2R1bGVJZCkge1xuICB2YXIgbW9kdWxlc1F1ZXVlID0ge1xuICAgIG1haW46IFttb2R1bGVJZF1cbiAgfVxuICB2YXIgcmVxdWlyZWRNb2R1bGVzID0ge1xuICAgIG1haW46IFtdXG4gIH1cbiAgdmFyIHNlZW5Nb2R1bGVzID0ge1xuICAgIG1haW46IHt9XG4gIH1cblxuICB3aGlsZSAoaGFzVmFsdWVzSW5RdWV1ZXMobW9kdWxlc1F1ZXVlKSkge1xuICAgIHZhciBxdWV1ZXMgPSBPYmplY3Qua2V5cyhtb2R1bGVzUXVldWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxdWV1ZU5hbWUgPSBxdWV1ZXNbaV1cbiAgICAgIHZhciBxdWV1ZSA9IG1vZHVsZXNRdWV1ZVtxdWV1ZU5hbWVdXG4gICAgICB2YXIgbW9kdWxlVG9DaGVjayA9IHF1ZXVlLnBvcCgpXG4gICAgICBzZWVuTW9kdWxlc1txdWV1ZU5hbWVdID0gc2Vlbk1vZHVsZXNbcXVldWVOYW1lXSB8fCB7fVxuICAgICAgaWYgKHNlZW5Nb2R1bGVzW3F1ZXVlTmFtZV1bbW9kdWxlVG9DaGVja10gfHwgIXNvdXJjZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSkgY29udGludWVcbiAgICAgIHNlZW5Nb2R1bGVzW3F1ZXVlTmFtZV1bbW9kdWxlVG9DaGVja10gPSB0cnVlXG4gICAgICByZXF1aXJlZE1vZHVsZXNbcXVldWVOYW1lXSA9IHJlcXVpcmVkTW9kdWxlc1txdWV1ZU5hbWVdIHx8IFtdXG4gICAgICByZXF1aXJlZE1vZHVsZXNbcXVldWVOYW1lXS5wdXNoKG1vZHVsZVRvQ2hlY2spXG4gICAgICB2YXIgbmV3TW9kdWxlcyA9IGdldE1vZHVsZURlcGVuZGVuY2llcyhzb3VyY2VzLCBzb3VyY2VzW3F1ZXVlTmFtZV1bbW9kdWxlVG9DaGVja10sIHF1ZXVlTmFtZSlcbiAgICAgIHZhciBuZXdNb2R1bGVzS2V5cyA9IE9iamVjdC5rZXlzKG5ld01vZHVsZXMpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5ld01vZHVsZXNLZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0gPSBtb2R1bGVzUXVldWVbbmV3TW9kdWxlc0tleXNbal1dIHx8IFtdXG4gICAgICAgIG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0gPSBtb2R1bGVzUXVldWVbbmV3TW9kdWxlc0tleXNbal1dLmNvbmNhdChuZXdNb2R1bGVzW25ld01vZHVsZXNLZXlzW2pdXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZWRNb2R1bGVzXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1vZHVsZUlkLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBzb3VyY2VzID0ge1xuICAgIG1haW46IF9fd2VicGFja19yZXF1aXJlX18ubVxuICB9XG5cbiAgdmFyIHJlcXVpcmVkTW9kdWxlcyA9IG9wdGlvbnMuYWxsID8geyBtYWluOiBPYmplY3Qua2V5cyhzb3VyY2VzLm1haW4pIH0gOiBnZXRSZXF1aXJlZE1vZHVsZXMoc291cmNlcywgbW9kdWxlSWQpXG5cbiAgdmFyIHNyYyA9ICcnXG5cbiAgT2JqZWN0LmtleXMocmVxdWlyZWRNb2R1bGVzKS5maWx0ZXIoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0gIT09ICdtYWluJyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICB2YXIgZW50cnlNb2R1bGUgPSAwXG4gICAgd2hpbGUgKHJlcXVpcmVkTW9kdWxlc1ttb2R1bGVdW2VudHJ5TW9kdWxlXSkge1xuICAgICAgZW50cnlNb2R1bGUrK1xuICAgIH1cbiAgICByZXF1aXJlZE1vZHVsZXNbbW9kdWxlXS5wdXNoKGVudHJ5TW9kdWxlKVxuICAgIHNvdXJjZXNbbW9kdWxlXVtlbnRyeU1vZHVsZV0gPSAnKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgeyBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX187IH0pJ1xuICAgIHNyYyA9IHNyYyArICd2YXIgJyArIG1vZHVsZSArICcgPSAoJyArIHdlYnBhY2tCb290c3RyYXBGdW5jLnRvU3RyaW5nKCkucmVwbGFjZSgnRU5UUllfTU9EVUxFJywgSlNPTi5zdHJpbmdpZnkoZW50cnlNb2R1bGUpKSArICcpKHsnICsgcmVxdWlyZWRNb2R1bGVzW21vZHVsZV0ubWFwKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gJycgKyBKU09OLnN0cmluZ2lmeShpZCkgKyAnOiAnICsgc291cmNlc1ttb2R1bGVdW2lkXS50b1N0cmluZygpIH0pLmpvaW4oJywnKSArICd9KTtcXG4nXG4gIH0pXG5cbiAgc3JjID0gc3JjICsgJ25ldyAoKCcgKyB3ZWJwYWNrQm9vdHN0cmFwRnVuYy50b1N0cmluZygpLnJlcGxhY2UoJ0VOVFJZX01PRFVMRScsIEpTT04uc3RyaW5naWZ5KG1vZHVsZUlkKSkgKyAnKSh7JyArIHJlcXVpcmVkTW9kdWxlcy5tYWluLm1hcChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuICcnICsgSlNPTi5zdHJpbmdpZnkoaWQpICsgJzogJyArIHNvdXJjZXMubWFpbltpZF0udG9TdHJpbmcoKSB9KS5qb2luKCcsJykgKyAnfSkpKHNlbGYpOydcblxuICB2YXIgYmxvYiA9IG5ldyB3aW5kb3cuQmxvYihbc3JjXSwgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KVxuICBpZiAob3B0aW9ucy5iYXJlKSB7IHJldHVybiBibG9iIH1cblxuICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMXG5cbiAgdmFyIHdvcmtlclVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgdmFyIHdvcmtlciA9IG5ldyB3aW5kb3cuV29ya2VyKHdvcmtlclVybClcbiAgd29ya2VyLm9iamVjdFVSTCA9IHdvcmtlclVybFxuXG4gIHJldHVybiB3b3JrZXJcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb25maWcudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbmZpZy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogaGxzRGVmYXVsdENvbmZpZywgbWVyZ2VDb25maWcsIGVuYWJsZVN0cmVhbWluZ01vZGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaGxzRGVmYXVsdENvbmZpZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGhsc0RlZmF1bHRDb25maWc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1lcmdlQ29uZmlnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVyZ2VDb25maWc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVuYWJsZVN0cmVhbWluZ01vZGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBlbmFibGVTdHJlYW1pbmdNb2RlOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9hYnJfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2Fici1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9hYnItY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9hdWRpb19zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2F1ZGlvLXN0cmVhbS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9hdWRpb190cmFja19jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9zdWJ0aXRsZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9zdWJ0aXRsZV90cmFja19jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9idWZmZXJfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9idWZmZXItY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl90aW1lbGluZV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvdGltZWxpbmUtY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvdGltZWxpbmUtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9jYXBfbGV2ZWxfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9jYXAtbGV2ZWwtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9mcHNfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9mcHMtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9lbWVfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9lbWUtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9jbWNkX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvY21jZC1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9jbWNkLWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3hocl9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL3hoci1sb2FkZXIgKi8gXCIuL3NyYy91dGlscy94aHItbG9hZGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19mZXRjaF9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL2ZldGNoLWxvYWRlciAqLyBcIi4vc3JjL3V0aWxzL2ZldGNoLWxvYWRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY3Vlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvY3VlcyAqLyBcIi4vc3JjL3V0aWxzL2N1ZXMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21lZGlha2V5c19oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL21lZGlha2V5cy1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9tZWRpYWtleXMtaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8vIElmIHBvc3NpYmxlLCBrZWVwIGhsc0RlZmF1bHRDb25maWcgc2hhbGxvd1xuLy8gSXQgaXMgY2xvbmVkIHdoZW5ldmVyIGEgbmV3IEhscyBpbnN0YW5jZSBpcyBjcmVhdGVkLCBieSBrZWVwaW5nIHRoZSBjb25maWdcbi8vIHNoYWxsb3cgdGhlIHByb3BlcnRpZXMgYXJlIGNsb25lZCwgYW5kIHdlIGRvbid0IGVuZCB1cCBtYW5pcHVsYXRpbmcgdGhlIGRlZmF1bHRcbnZhciBobHNEZWZhdWx0Q29uZmlnID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgYXV0b1N0YXJ0TG9hZDogdHJ1ZSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBzdGFydFBvc2l0aW9uOiAtMSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBkZWZhdWx0QXVkaW9Db2RlYzogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGRlYnVnOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBsb2dnZXJcbiAgY2FwTGV2ZWxPbkZQU0Ryb3A6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGNhcExldmVsVG9QbGF5ZXJTaXplOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBjYXAtbGV2ZWwtY29udHJvbGxlclxuICBpZ25vcmVEZXZpY2VQaXhlbFJhdGlvOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBjYXAtbGV2ZWwtY29udHJvbGxlclxuICBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTogMSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhCdWZmZXJMZW5ndGg6IDMwLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGJhY2tCdWZmZXJMZW5ndGg6IEluZmluaXR5LFxuICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIG1heEJ1ZmZlclNpemU6IDYwICogMTAwMCAqIDEwMDAsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4QnVmZmVySG9sZTogMC4xLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZDogMixcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBudWRnZU9mZnNldDogMC4xLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG51ZGdlTWF4UmV0cnk6IDMsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTogMC4yNSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBsaXZlU3luY0R1cmF0aW9uQ291bnQ6IDMsXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudDogSW5maW5pdHksXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVTeW5jRHVyYXRpb246IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbjogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBtYXhMaXZlU3luY1BsYXliYWNrUmF0ZTogMSxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZUR1cmF0aW9uSW5maW5pdHk6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIGxpdmVCYWNrQnVmZmVyTGVuZ3RoOiBudWxsLFxuICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIG1heE1heEJ1ZmZlckxlbmd0aDogNjAwLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGVuYWJsZVdvcmtlcjogdHJ1ZSxcbiAgLy8gdXNlZCBieSBkZW11eGVyXG4gIGVuYWJsZVNvZnR3YXJlQUVTOiB0cnVlLFxuICAvLyB1c2VkIGJ5IGRlY3J5cHRlclxuICBtYW5pZmVzdExvYWRpbmdUaW1lT3V0OiAxMDAwMCxcbiAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk6IDEsXG4gIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIG1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIHN0YXJ0TGV2ZWw6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBsZXZlbC1jb250cm9sbGVyXG4gIGxldmVsTG9hZGluZ1RpbWVPdXQ6IDEwMDAwLFxuICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBsZXZlbExvYWRpbmdNYXhSZXRyeTogNCxcbiAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgbGV2ZWxMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgbGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCxcbiAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgZnJhZ0xvYWRpbmdUaW1lT3V0OiAyMDAwMCxcbiAgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgZnJhZ0xvYWRpbmdNYXhSZXRyeTogNixcbiAgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgZnJhZ0xvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBmcmFnTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gIHN0YXJ0RnJhZ1ByZWZldGNoOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBmcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZDogNTAwMCxcbiAgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBmcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZDogMC4yLFxuICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGFwcGVuZEVycm9yTWF4UmV0cnk6IDMsXG4gIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgbG9hZGVyOiBfdXRpbHNfeGhyX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcImRlZmF1bHRcIl0sXG4gIC8vIGxvYWRlcjogRmV0Y2hMb2FkZXIsXG4gIGZMb2FkZXI6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgcExvYWRlcjogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICB4aHJTZXR1cDogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IHhoci1sb2FkZXJcbiAgbGljZW5zZVhoclNldHVwOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgbGljZW5zZVJlc3BvbnNlQ2FsbGJhY2s6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBhYnJDb250cm9sbGVyOiBfY29udHJvbGxlcl9hYnJfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSxcbiAgYnVmZmVyQ29udHJvbGxlcjogX2NvbnRyb2xsZXJfYnVmZmVyX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0sXG4gIGNhcExldmVsQ29udHJvbGxlcjogX2NvbnRyb2xsZXJfY2FwX2xldmVsX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImRlZmF1bHRcIl0sXG4gIGZwc0NvbnRyb2xsZXI6IF9jb250cm9sbGVyX2Zwc19jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJkZWZhdWx0XCJdLFxuICBzdHJldGNoU2hvcnRWaWRlb1RyYWNrOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBtcDQtcmVtdXhlclxuICBtYXhBdWRpb0ZyYW1lc0RyaWZ0OiAxLFxuICAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXG4gIGZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHk6IHRydWUsXG4gIC8vIHVzZWQgYnkgdHMtZGVtdXhlclxuICBhYnJFd21hRmFzdExpdmU6IDMsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYVNsb3dMaXZlOiA5LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFGYXN0Vm9EOiAzLFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFTbG93Vm9EOiA5LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFEZWZhdWx0RXN0aW1hdGU6IDVlNSxcbiAgLy8gNTAwIGticHMgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyQmFuZFdpZHRoRmFjdG9yOiAwLjk1LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickJhbmRXaWR0aFVwRmFjdG9yOiAwLjcsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyTWF4V2l0aFJlYWxCaXRyYXRlOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtYXhTdGFydmF0aW9uRGVsYXk6IDQsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWF4TG9hZGluZ0RlbGF5OiA0LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1pbkF1dG9CaXRyYXRlOiAwLFxuICAvLyB1c2VkIGJ5IGhsc1xuICBlbWVFbmFibGVkOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICB3aWRldmluZUxpY2Vuc2VVcmw6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBkcm1TeXN0ZW1PcHRpb25zOiB7fSxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jOiBfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfX1tcInJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1wiXSxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICB0ZXN0QmFuZHdpZHRoOiB0cnVlLFxuICBwcm9ncmVzc2l2ZTogZmFsc2UsXG4gIGxvd0xhdGVuY3lNb2RlOiB0cnVlLFxuICBjbWNkOiB1bmRlZmluZWQsXG4gIGVuYWJsZURhdGVSYW5nZU1ldGFkYXRhQ3VlczogdHJ1ZSxcbiAgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlczogdHJ1ZSxcbiAgZW5hYmxlSUQzTWV0YWRhdGFDdWVzOiB0cnVlXG59LCB0aW1lbGluZUNvbmZpZygpKSwge30sIHtcbiAgc3VidGl0bGVTdHJlYW1Db250cm9sbGVyOiAgdHJ1ZSA/IF9jb250cm9sbGVyX3N1YnRpdGxlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJcIl0gOiB1bmRlZmluZWQsXG4gIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyOiAgdHJ1ZSA/IF9jb250cm9sbGVyX3N1YnRpdGxlX3RyYWNrX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0gOiB1bmRlZmluZWQsXG4gIHRpbWVsaW5lQ29udHJvbGxlcjogIHRydWUgPyBfY29udHJvbGxlcl90aW1lbGluZV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJUaW1lbGluZUNvbnRyb2xsZXJcIl0gOiB1bmRlZmluZWQsXG4gIGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogIHRydWUgPyBfY29udHJvbGxlcl9hdWRpb19zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSA6IHVuZGVmaW5lZCxcbiAgYXVkaW9UcmFja0NvbnRyb2xsZXI6ICB0cnVlID8gX2NvbnRyb2xsZXJfYXVkaW9fdHJhY2tfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSA6IHVuZGVmaW5lZCxcbiAgZW1lQ29udHJvbGxlcjogIHRydWUgPyBfY29udHJvbGxlcl9lbWVfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wiZGVmYXVsdFwiXSA6IHVuZGVmaW5lZCxcbiAgY21jZENvbnRyb2xsZXI6ICB0cnVlID8gX2NvbnRyb2xsZXJfY21jZF9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1wiZGVmYXVsdFwiXSA6IHVuZGVmaW5lZFxufSk7XG5cbmZ1bmN0aW9uIHRpbWVsaW5lQ29uZmlnKCkge1xuICByZXR1cm4ge1xuICAgIGN1ZUhhbmRsZXI6IF91dGlsc19jdWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wiZGVmYXVsdFwiXSxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBlbmFibGVXZWJWVFQ6IHRydWUsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgZW5hYmxlSU1TQzE6IHRydWUsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgZW5hYmxlQ0VBNzA4Q2FwdGlvbnM6IHRydWUsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWw6ICdFbmdsaXNoJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGU6ICdlbicsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2syTGFiZWw6ICdTcGFuaXNoJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGU6ICdlcycsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2szTGFiZWw6ICdVbmtub3duIENDJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazNMYW5ndWFnZUNvZGU6ICcnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrNExhYmVsOiAnVW5rbm93biBDQycsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2s0TGFuZ3VhZ2VDb2RlOiAnJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICByZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHk6IHRydWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VDb25maWcoZGVmYXVsdENvbmZpZywgdXNlckNvbmZpZykge1xuICBpZiAoKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50IHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50KSAmJiAodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGhscy5qcyBjb25maWc6IGRvbid0IG1peCB1cCBsaXZlU3luY0R1cmF0aW9uQ291bnQvbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IGFuZCBsaXZlU3luY0R1cmF0aW9uL2xpdmVNYXhMYXRlbmN5RHVyYXRpb25cIik7XG4gIH1cblxuICBpZiAodXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgIT09IHVuZGVmaW5lZCAmJiAodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgPT09IHVuZGVmaW5lZCB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCA8PSB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnRcIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBcImxpdmVTeW5jRHVyYXRpb25Db3VudFwiJyk7XG4gIH1cblxuICBpZiAodXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgJiYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA8PSB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvblwiIG11c3QgYmUgZ3JlYXRlciB0aGFuIFwibGl2ZVN5bmNEdXJhdGlvblwiJyk7XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGRlZmF1bHRDb25maWcsIHVzZXJDb25maWcpO1xufVxuZnVuY3Rpb24gZW5hYmxlU3RyZWFtaW5nTW9kZShjb25maWcpIHtcbiAgdmFyIGN1cnJlbnRMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuXG4gIGlmIChjdXJyZW50TG9hZGVyICE9PSBfdXRpbHNfZmV0Y2hfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1wiZGVmYXVsdFwiXSAmJiBjdXJyZW50TG9hZGVyICE9PSBfdXRpbHNfeGhyX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcImRlZmF1bHRcIl0pIHtcbiAgICAvLyBJZiBhIGRldmVsb3BlciBoYXMgY29uZmlndXJlZCB0aGVpciBvd24gbG9hZGVyLCByZXNwZWN0IHRoYXQgY2hvaWNlXG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX1tcImxvZ2dlclwiXS5sb2coJ1tjb25maWddOiBDdXN0b20gbG9hZGVyIGRldGVjdGVkLCBjYW5ub3QgZW5hYmxlIHByb2dyZXNzaXZlIHN0cmVhbWluZycpO1xuICAgIGNvbmZpZy5wcm9ncmVzc2l2ZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBjYW5TdHJlYW1Qcm9ncmVzc2l2ZWx5ID0gT2JqZWN0KF91dGlsc19mZXRjaF9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bXCJmZXRjaFN1cHBvcnRlZFwiXSkoKTtcblxuICAgIGlmIChjYW5TdHJlYW1Qcm9ncmVzc2l2ZWx5KSB7XG4gICAgICBjb25maWcubG9hZGVyID0gX3V0aWxzX2ZldGNoX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1tcImRlZmF1bHRcIl07XG4gICAgICBjb25maWcucHJvZ3Jlc3NpdmUgPSB0cnVlO1xuICAgICAgY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTID0gdHJ1ZTtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19bXCJsb2dnZXJcIl0ubG9nKCdbY29uZmlnXTogUHJvZ3Jlc3NpdmUgc3RyZWFtaW5nIGVuYWJsZWQsIHVzaW5nIEZldGNoTG9hZGVyJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2Fici1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZXdtYV9iYW5kd2lkdGhfZXN0aW1hdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9ld21hLWJhbmR3aWR0aC1lc3RpbWF0b3IgKi8gXCIuL3NyYy91dGlscy9ld21hLWJhbmR3aWR0aC1lc3RpbWF0b3IudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9idWZmZXItaGVscGVyICovIFwiLi9zcmMvdXRpbHMvYnVmZmVyLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvbG9hZGVyICovIFwiLi9zcmMvdHlwZXMvbG9hZGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcblxuXG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuXG5cblxuXG5cblxuXG52YXIgQWJyQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFickNvbnRyb2xsZXIoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gMDtcbiAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgdGhpcy50aW1lciA9IHZvaWQgMDtcbiAgICB0aGlzLm9uQ2hlY2sgPSB0aGlzLl9hYmFuZG9uUnVsZXNDaGVjay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMucGFydEN1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XG4gICAgdGhpcy5id0VzdGltYXRvciA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB2YXIgY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLmJ3RXN0aW1hdG9yID0gbmV3IF91dGlsc19ld21hX2JhbmR3aWR0aF9lc3RpbWF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0oY29uZmlnLmFickV3bWFTbG93Vm9ELCBjb25maWcuYWJyRXdtYUZhc3RWb0QsIGNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlKTtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQWJyQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnVucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuY2xlYXJUaW1lcigpOyAvLyBAdHMtaWdub3JlXG5cbiAgICB0aGlzLmhscyA9IHRoaXMub25DaGVjayA9IG51bGw7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IHRoaXMucGFydEN1cnJlbnQgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5vbkZyYWdMb2FkaW5nID0gZnVuY3Rpb24gb25GcmFnTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuXG4gICAgaWYgKGZyYWcudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uTUFJTikge1xuICAgICAgaWYgKCF0aGlzLnRpbWVyKSB7XG4gICAgICAgIHZhciBfZGF0YSRwYXJ0O1xuXG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgICB0aGlzLnBhcnRDdXJyZW50ID0gKF9kYXRhJHBhcnQgPSBkYXRhLnBhcnQpICE9IG51bGwgPyBfZGF0YSRwYXJ0IDogbnVsbDtcbiAgICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5vbkNoZWNrLCAxMDApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25MZXZlbExvYWRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuXG4gICAgaWYgKGRhdGEuZGV0YWlscy5saXZlKSB7XG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yLnVwZGF0ZShjb25maWcuYWJyRXdtYVNsb3dMaXZlLCBjb25maWcuYWJyRXdtYUZhc3RMaXZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5id0VzdGltYXRvci51cGRhdGUoY29uZmlnLmFickV3bWFTbG93Vm9ELCBjb25maWcuYWJyRXdtYUZhc3RWb0QpO1xuICAgIH1cbiAgfVxuICAvKlxuICAgICAgVGhpcyBtZXRob2QgbW9uaXRvcnMgdGhlIGRvd25sb2FkIHJhdGUgb2YgdGhlIGN1cnJlbnQgZnJhZ21lbnQsIGFuZCB3aWxsIGRvd25zd2l0Y2ggaWYgdGhhdCBmcmFnbWVudCB3aWxsIG5vdCBsb2FkXG4gICAgICBxdWlja2x5IGVub3VnaCB0byBwcmV2ZW50IHVuZGVyYnVmZmVyaW5nXG4gICAgKi9cbiAgO1xuXG4gIF9wcm90by5fYWJhbmRvblJ1bGVzQ2hlY2sgPSBmdW5jdGlvbiBfYWJhbmRvblJ1bGVzQ2hlY2soKSB7XG4gICAgdmFyIGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50LFxuICAgICAgICBwYXJ0ID0gdGhpcy5wYXJ0Q3VycmVudCxcbiAgICAgICAgaGxzID0gdGhpcy5obHM7XG4gICAgdmFyIGF1dG9MZXZlbEVuYWJsZWQgPSBobHMuYXV0b0xldmVsRW5hYmxlZCxcbiAgICAgICAgY29uZmlnID0gaGxzLmNvbmZpZyxcbiAgICAgICAgbWVkaWEgPSBobHMubWVkaWE7XG5cbiAgICBpZiAoIWZyYWcgfHwgIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgIHZhciBkdXJhdGlvbiA9IHBhcnQgPyBwYXJ0LmR1cmF0aW9uIDogZnJhZy5kdXJhdGlvbjsgLy8gSWYgbG9hZGluZyBoYXMgYmVlbiBhYm9ydGVkIGFuZCBub3QgaW4gbG93TGF0ZW5jeU1vZGUsIHN0b3AgdGltZXIgYW5kIHJldHVyblxuXG4gICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImxvZ2dlclwiXS53YXJuKCdmcmFnIGxvYWRlciBkZXN0cm95IG9yIGFib3J0ZWQsIGRpc2FybSBhYmFuZG9uUnVsZXMnKTtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpOyAvLyByZXNldCBmb3JjZWQgYXV0byBsZXZlbCB2YWx1ZSBzbyB0aGF0IG5leHQgbGV2ZWwgd2lsbCBiZSBzZWxlY3RlZFxuXG4gICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUaGlzIGNoZWNrIG9ubHkgcnVucyBpZiB3ZSdyZSBpbiBBQlIgbW9kZSBhbmQgYWN0dWFsbHkgcGxheWluZ1xuXG5cbiAgICBpZiAoIWF1dG9MZXZlbEVuYWJsZWQgfHwgbWVkaWEucGF1c2VkIHx8ICFtZWRpYS5wbGF5YmFja1JhdGUgfHwgIW1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdERlbGF5ID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0O1xuICAgIHZhciBwbGF5YmFja1JhdGUgPSBNYXRoLmFicyhtZWRpYS5wbGF5YmFja1JhdGUpOyAvLyBJbiBvcmRlciB0byB3b3JrIHdpdGggYSBzdGFibGUgYmFuZHdpZHRoLCBvbmx5IGJlZ2luIG1vbml0b3JpbmcgYmFuZHdpZHRoIGFmdGVyIGhhbGYgb2YgdGhlIGZyYWdtZW50IGhhcyBiZWVuIGxvYWRlZFxuXG4gICAgaWYgKHJlcXVlc3REZWxheSA8PSA1MDAgKiBkdXJhdGlvbiAvIHBsYXliYWNrUmF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsZXZlbHMgPSBobHMubGV2ZWxzLFxuICAgICAgICBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsO1xuICAgIHZhciBsZXZlbCA9IGxldmVsc1tmcmFnLmxldmVsXTtcbiAgICB2YXIgZXhwZWN0ZWRMZW4gPSBzdGF0cy50b3RhbCB8fCBNYXRoLm1heChzdGF0cy5sb2FkZWQsIE1hdGgucm91bmQoZHVyYXRpb24gKiBsZXZlbC5tYXhCaXRyYXRlIC8gOCkpO1xuICAgIHZhciBsb2FkUmF0ZSA9IE1hdGgubWF4KDEsIHN0YXRzLmJ3RXN0aW1hdGUgPyBzdGF0cy5id0VzdGltYXRlIC8gOCA6IHN0YXRzLmxvYWRlZCAqIDEwMDAgLyByZXF1ZXN0RGVsYXkpOyAvLyBmcmFnTG9hZERlbGF5IGlzIGFuIGVzdGltYXRlIG9mIHRoZSB0aW1lIChpbiBzZWNvbmRzKSBpdCB3aWxsIHRha2UgdG8gYnVmZmVyIHRoZSBlbnRpcmUgZnJhZ21lbnRcblxuICAgIHZhciBmcmFnTG9hZGVkRGVsYXkgPSAoZXhwZWN0ZWRMZW4gLSBzdGF0cy5sb2FkZWQpIC8gbG9hZFJhdGU7XG4gICAgdmFyIHBvcyA9IG1lZGlhLmN1cnJlbnRUaW1lOyAvLyBidWZmZXJTdGFydmF0aW9uRGVsYXkgaXMgYW4gZXN0aW1hdGUgb2YgdGhlIGFtb3VudCB0aW1lIChpbiBzZWNvbmRzKSBpdCB3aWxsIHRha2UgdG8gZXhoYXVzdCB0aGUgYnVmZmVyXG5cbiAgICB2YXIgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gKF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJCdWZmZXJIZWxwZXJcIl0uYnVmZmVySW5mbyhtZWRpYSwgcG9zLCBjb25maWcubWF4QnVmZmVySG9sZSkuZW5kIC0gcG9zKSAvIHBsYXliYWNrUmF0ZTsgLy8gQXR0ZW1wdCBhbiBlbWVyZ2VuY3kgZG93bnN3aXRjaCBvbmx5IGlmIGxlc3MgdGhhbiAyIGZyYWdtZW50IGxlbmd0aHMgYXJlIGJ1ZmZlcmVkLCBhbmQgdGhlIHRpbWUgdG8gZmluaXNoIGxvYWRpbmdcbiAgICAvLyB0aGUgY3VycmVudCBmcmFnbWVudCBpcyBncmVhdGVyIHRoYW4gdGhlIGFtb3VudCBvZiBidWZmZXIgd2UgaGF2ZSBsZWZ0XG5cbiAgICBpZiAoYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID49IDIgKiBkdXJhdGlvbiAvIHBsYXliYWNrUmF0ZSB8fCBmcmFnTG9hZGVkRGVsYXkgPD0gYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB2YXIgbmV4dExvYWRMZXZlbDsgLy8gSXRlcmF0ZSB0aHJvdWdoIGxvd2VyIGxldmVsIGFuZCB0cnkgdG8gZmluZCB0aGUgbGFyZ2VzdCBvbmUgdGhhdCBhdm9pZHMgcmVidWZmZXJpbmdcblxuICAgIGZvciAobmV4dExvYWRMZXZlbCA9IGZyYWcubGV2ZWwgLSAxOyBuZXh0TG9hZExldmVsID4gbWluQXV0b0xldmVsOyBuZXh0TG9hZExldmVsLS0pIHtcbiAgICAgIC8vIGNvbXB1dGUgdGltZSB0byBsb2FkIG5leHQgZnJhZ21lbnQgYXQgbG93ZXIgbGV2ZWxcbiAgICAgIC8vIDAuOCA6IGNvbnNpZGVyIG9ubHkgODAlIG9mIGN1cnJlbnQgYncgdG8gYmUgY29uc2VydmF0aXZlXG4gICAgICAvLyA4ID0gYml0cyBwZXIgYnl0ZSAoYnBzL0JwcylcbiAgICAgIHZhciBsZXZlbE5leHRCaXRyYXRlID0gbGV2ZWxzW25leHRMb2FkTGV2ZWxdLm1heEJpdHJhdGU7XG4gICAgICBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPSBkdXJhdGlvbiAqIGxldmVsTmV4dEJpdHJhdGUgLyAoOCAqIDAuOCAqIGxvYWRSYXRlKTtcblxuICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA8IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIE9ubHkgZW1lcmdlbmN5IHN3aXRjaCBkb3duIGlmIGl0IHRha2VzIGxlc3MgdGltZSB0byBsb2FkIGEgbmV3IGZyYWdtZW50IGF0IGxvd2VzdCBsZXZlbCBpbnN0ZWFkIG9mIGNvbnRpbnVpbmdcbiAgICAvLyB0byBsb2FkIHRoZSBjdXJyZW50IG9uZVxuXG5cbiAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID49IGZyYWdMb2FkZWREZWxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBid0VzdGltYXRlID0gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpO1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImxvZ2dlclwiXS53YXJuKFwiRnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgKHBhcnQgPyAnIHBhcnQgJyArIHBhcnQuaW5kZXggOiAnJykgKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiBpcyBsb2FkaW5nIHRvbyBzbG93bHkgYW5kIHdpbGwgY2F1c2UgYW4gdW5kZXJidWZmZXI7IGFib3J0aW5nIGFuZCBzd2l0Y2hpbmcgdG8gbGV2ZWwgXCIgKyBuZXh0TG9hZExldmVsICsgXCJcXG4gICAgICBDdXJyZW50IEJXIGVzdGltYXRlOiBcIiArIChPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGJ3RXN0aW1hdGUpID8gKGJ3RXN0aW1hdGUgLyAxMDI0KS50b0ZpeGVkKDMpIDogJ1Vua25vd24nKSArIFwiIEtiL3NcXG4gICAgICBFc3RpbWF0ZWQgbG9hZCB0aW1lIGZvciBjdXJyZW50IGZyYWdtZW50OiBcIiArIGZyYWdMb2FkZWREZWxheS50b0ZpeGVkKDMpICsgXCIgc1xcbiAgICAgIEVzdGltYXRlZCBsb2FkIHRpbWUgZm9yIHRoZSBuZXh0IGZyYWdtZW50OiBcIiArIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheS50b0ZpeGVkKDMpICsgXCIgc1xcbiAgICAgIFRpbWUgdG8gdW5kZXJidWZmZXI6IFwiICsgYnVmZmVyU3RhcnZhdGlvbkRlbGF5LnRvRml4ZWQoMykgKyBcIiBzXCIpO1xuICAgIGhscy5uZXh0TG9hZExldmVsID0gbmV4dExvYWRMZXZlbDtcbiAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZShyZXF1ZXN0RGVsYXksIHN0YXRzLmxvYWRlZCk7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG5cbiAgICBpZiAoZnJhZy5sb2FkZXIpIHtcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSB0aGlzLnBhcnRDdXJyZW50ID0gbnVsbDtcbiAgICAgIGZyYWcubG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCwge1xuICAgICAgZnJhZzogZnJhZyxcbiAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICBzdGF0czogc3RhdHNcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ub25GcmFnTG9hZGVkID0gZnVuY3Rpb24gb25GcmFnTG9hZGVkKGV2ZW50LCBfcmVmKSB7XG4gICAgdmFyIGZyYWcgPSBfcmVmLmZyYWcsXG4gICAgICAgIHBhcnQgPSBfcmVmLnBhcnQ7XG5cbiAgICBpZiAoZnJhZy50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5NQUlOICYmIE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoZnJhZy5zbikpIHtcbiAgICAgIHZhciBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICAgIHZhciBkdXJhdGlvbiA9IHBhcnQgPyBwYXJ0LmR1cmF0aW9uIDogZnJhZy5kdXJhdGlvbjsgLy8gc3RvcCBtb25pdG9yaW5nIGJ3IG9uY2UgZnJhZyBsb2FkZWRcblxuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7IC8vIHN0b3JlIGxldmVsIGlkIGFmdGVyIHN1Y2Nlc3NmdWwgZnJhZ21lbnQgbG9hZFxuXG4gICAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSBmcmFnLmxldmVsOyAvLyByZXNldCBmb3JjZWQgYXV0byBsZXZlbCB2YWx1ZSBzbyB0aGF0IG5leHQgbGV2ZWwgd2lsbCBiZSBzZWxlY3RlZFxuXG4gICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7IC8vIGNvbXB1dGUgbGV2ZWwgYXZlcmFnZSBiaXRyYXRlXG5cbiAgICAgIGlmICh0aGlzLmhscy5jb25maWcuYWJyTWF4V2l0aFJlYWxCaXRyYXRlKSB7XG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgICAgdmFyIGxvYWRlZEJ5dGVzID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5ieXRlcyA6IDApICsgc3RhdHMubG9hZGVkO1xuICAgICAgICB2YXIgbG9hZGVkRHVyYXRpb24gPSAobGV2ZWwubG9hZGVkID8gbGV2ZWwubG9hZGVkLmR1cmF0aW9uIDogMCkgKyBkdXJhdGlvbjtcbiAgICAgICAgbGV2ZWwubG9hZGVkID0ge1xuICAgICAgICAgIGJ5dGVzOiBsb2FkZWRCeXRlcyxcbiAgICAgICAgICBkdXJhdGlvbjogbG9hZGVkRHVyYXRpb25cbiAgICAgICAgfTtcbiAgICAgICAgbGV2ZWwucmVhbEJpdHJhdGUgPSBNYXRoLnJvdW5kKDggKiBsb2FkZWRCeXRlcyAvIGxvYWRlZER1cmF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgdmFyIGZyYWdCdWZmZXJlZERhdGEgPSB7XG4gICAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICBpZDogZnJhZy50eXBlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25GcmFnQnVmZmVyZWQoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkZSQUdfQlVGRkVSRUQsIGZyYWdCdWZmZXJlZERhdGEpO1xuICAgICAgICBmcmFnLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkZyYWdCdWZmZXJlZCA9IGZ1bmN0aW9uIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBkYXRhLnBhcnQ7XG4gICAgdmFyIHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuXG4gICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIE9ubHkgY291bnQgbm9uLWFsdC1hdWRpbyBmcmFncyB3aGljaCB3ZXJlIGFjdHVhbGx5IGJ1ZmZlcmVkIGluIG91ciBCVyBjYWxjdWxhdGlvbnNcblxuXG4gICAgaWYgKGZyYWcudHlwZSAhPT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uTUFJTiB8fCBmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBVc2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBwYXJzaW5nIGFuZCByZXF1ZXN0IGluc3RlYWQgb2YgYnVmZmVyaW5nIGFuZCByZXF1ZXN0IHRvIGNvbXB1dGUgZnJhZ0xvYWRpbmdQcm9jZXNzaW5nO1xuICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGJ1ZmZlciBhcHBlbmRpbmcgb25seSBoYXBwZW5zIG9uY2UgbWVkaWEgaXMgYXR0YWNoZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaFxuICAgIC8vIGlzIHVzZWQuIElmIHdlIHVzZWQgYnVmZmVyaW5nIGluIHRoYXQgY2FzZSwgb3VyIEJXIGVzdGltYXRlIHNhbXBsZSB3aWxsIGJlIHZlcnkgbGFyZ2UuXG5cblxuICAgIHZhciBwcm9jZXNzaW5nTXMgPSBzdGF0cy5wYXJzaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQ7XG4gICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGUocHJvY2Vzc2luZ01zLCBzdGF0cy5sb2FkZWQpO1xuICAgIHN0YXRzLmJ3RXN0aW1hdGUgPSB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCk7XG5cbiAgICBpZiAoZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gcHJvY2Vzc2luZ01zIC8gMTAwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gMDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgLy8gc3RvcCB0aW1lciBpbiBjYXNlIG9mIGZyYWcgbG9hZGluZyBlcnJvclxuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkVycm9yRGV0YWlsc1wiXS5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkVycm9yRGV0YWlsc1wiXS5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNsZWFyVGltZXIgPSBmdW5jdGlvbiBjbGVhclRpbWVyKCkge1xuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICB9IC8vIHJldHVybiBuZXh0IGF1dG8gbGV2ZWxcbiAgO1xuXG4gIF9wcm90by5nZXROZXh0QUJSQXV0b0xldmVsID0gZnVuY3Rpb24gZ2V0TmV4dEFCUkF1dG9MZXZlbCgpIHtcbiAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50LFxuICAgICAgICBwYXJ0Q3VycmVudCA9IHRoaXMucGFydEN1cnJlbnQsXG4gICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgIHZhciBtYXhBdXRvTGV2ZWwgPSBobHMubWF4QXV0b0xldmVsLFxuICAgICAgICBjb25maWcgPSBobHMuY29uZmlnLFxuICAgICAgICBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsLFxuICAgICAgICBtZWRpYSA9IGhscy5tZWRpYTtcbiAgICB2YXIgY3VycmVudEZyYWdEdXJhdGlvbiA9IHBhcnRDdXJyZW50ID8gcGFydEN1cnJlbnQuZHVyYXRpb24gOiBmcmFnQ3VycmVudCA/IGZyYWdDdXJyZW50LmR1cmF0aW9uIDogMDtcbiAgICB2YXIgcG9zID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IDA7IC8vIHBsYXliYWNrUmF0ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIHBsYXliYWNrIHJhdGU7IGlmIG1lZGlhLnBsYXliYWNrUmF0ZSBpcyAwLCB3ZSB1c2UgMSB0byBsb2FkIGFzXG4gICAgLy8gaWYgd2UncmUgcGxheWluZyBiYWNrIGF0IHRoZSBub3JtYWwgcmF0ZS5cblxuICAgIHZhciBwbGF5YmFja1JhdGUgPSBtZWRpYSAmJiBtZWRpYS5wbGF5YmFja1JhdGUgIT09IDAgPyBNYXRoLmFicyhtZWRpYS5wbGF5YmFja1JhdGUpIDogMS4wO1xuICAgIHZhciBhdmdidyA9IHRoaXMuYndFc3RpbWF0b3IgPyB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkgOiBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTsgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIHRoZSB3YWxsLWNsb2NrIHRpbWUgbGVmdCB1bnRpbCB0aGUgcGxheWJhY2sgYnVmZmVyIGlzIGV4aGF1c3RlZC5cblxuICAgIHZhciBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSAoX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkJ1ZmZlckhlbHBlclwiXS5idWZmZXJJbmZvKG1lZGlhLCBwb3MsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKS5lbmQgLSBwb3MpIC8gcGxheWJhY2tSYXRlOyAvLyBGaXJzdCwgbG9vayB0byBzZWUgaWYgd2UgY2FuIGZpbmQgYSBsZXZlbCBtYXRjaGluZyB3aXRoIG91ciBhdmcgYmFuZHdpZHRoIEFORCB0aGF0IGNvdWxkIGFsc28gZ3VhcmFudGVlIG5vIHJlYnVmZmVyaW5nIGF0IGFsbFxuXG4gICAgdmFyIGJlc3RMZXZlbCA9IHRoaXMuZmluZEJlc3RMZXZlbChhdmdidywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSwgY29uZmlnLmFickJhbmRXaWR0aEZhY3RvciwgY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yKTtcblxuICAgIGlmIChiZXN0TGV2ZWwgPj0gMCkge1xuICAgICAgcmV0dXJuIGJlc3RMZXZlbDtcbiAgICB9XG5cbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJsb2dnZXJcIl0udHJhY2UoKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA/ICdyZWJ1ZmZlcmluZyBleHBlY3RlZCcgOiAnYnVmZmVyIGlzIGVtcHR5JykgKyBcIiwgZmluZGluZyBvcHRpbWFsIHF1YWxpdHkgbGV2ZWxcIik7IC8vIG5vdCBwb3NzaWJsZSB0byBnZXQgcmlkIG9mIHJlYnVmZmVyaW5nIC4uLiBsZXQncyB0cnkgdG8gZmluZCBsZXZlbCB0aGF0IHdpbGwgZ3VhcmFudGVlIGxlc3MgdGhhbiBtYXhTdGFydmF0aW9uRGVsYXkgb2YgcmVidWZmZXJpbmdcbiAgICAvLyBpZiBubyBtYXRjaGluZyBsZXZlbCBmb3VuZCwgbG9naWMgd2lsbCByZXR1cm4gMFxuXG4gICAgdmFyIG1heFN0YXJ2YXRpb25EZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLCBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5KSA6IGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXk7XG4gICAgdmFyIGJ3RmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aEZhY3RvcjtcbiAgICB2YXIgYndVcEZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvcjtcblxuICAgIGlmICghYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAvLyBpbiBjYXNlIGJ1ZmZlciBpcyBlbXB0eSwgbGV0J3MgY2hlY2sgaWYgcHJldmlvdXMgZnJhZ21lbnQgd2FzIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0XG4gICAgICB2YXIgYml0cmF0ZVRlc3REZWxheSA9IHRoaXMuYml0cmF0ZVRlc3REZWxheTtcblxuICAgICAgaWYgKGJpdHJhdGVUZXN0RGVsYXkpIHtcbiAgICAgICAgLy8gaWYgaXQgaXMgdGhlIGNhc2UsIHRoZW4gd2UgbmVlZCB0byBhZGp1c3Qgb3VyIG1heCBzdGFydmF0aW9uIGRlbGF5IHVzaW5nIG1heExvYWRpbmdEZWxheSBjb25maWcgdmFsdWVcbiAgICAgICAgLy8gbWF4IHZpZGVvIGxvYWRpbmcgZGVsYXkgdXNlZCBpbiAgYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiA6XG4gICAgICAgIC8vIGluIHRoYXQgbW9kZSBBQlIgY29udHJvbGxlciB3aWxsIGVuc3VyZSB0aGF0IHZpZGVvIGxvYWRpbmcgdGltZSAoaWUgdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZpcnN0IGZyYWdtZW50IGF0IGxvd2VzdCBxdWFsaXR5IGxldmVsICtcbiAgICAgICAgLy8gdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZyYWdtZW50IGF0IHRoZSBhcHByb3ByaWF0ZSBxdWFsaXR5IGxldmVsIGlzIGxlc3MgdGhhbiBgYGBtYXhMb2FkaW5nRGVsYXlgYGAgKVxuICAgICAgICAvLyBjYXAgbWF4TG9hZGluZ0RlbGF5IGFuZCBlbnN1cmUgaXQgaXMgbm90IGJpZ2dlciAndGhhbiBiaXRyYXRlIHRlc3QnIGZyYWcgZHVyYXRpb25cbiAgICAgICAgdmFyIG1heExvYWRpbmdEZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLCBjb25maWcubWF4TG9hZGluZ0RlbGF5KSA6IGNvbmZpZy5tYXhMb2FkaW5nRGVsYXk7XG4gICAgICAgIG1heFN0YXJ2YXRpb25EZWxheSA9IG1heExvYWRpbmdEZWxheSAtIGJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImxvZ2dlclwiXS50cmFjZShcImJpdHJhdGUgdGVzdCB0b29rIFwiICsgTWF0aC5yb3VuZCgxMDAwICogYml0cmF0ZVRlc3REZWxheSkgKyBcIm1zLCBzZXQgZmlyc3QgZnJhZ21lbnQgbWF4IGZldGNoRHVyYXRpb24gdG8gXCIgKyBNYXRoLnJvdW5kKDEwMDAgKiBtYXhTdGFydmF0aW9uRGVsYXkpICsgXCIgbXNcIik7IC8vIGRvbid0IHVzZSBjb25zZXJ2YXRpdmUgZmFjdG9yIG9uIGJpdHJhdGUgdGVzdFxuXG4gICAgICAgIGJ3RmFjdG9yID0gYndVcEZhY3RvciA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYmVzdExldmVsID0gdGhpcy5maW5kQmVzdExldmVsKGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ICsgbWF4U3RhcnZhdGlvbkRlbGF5LCBid0ZhY3RvciwgYndVcEZhY3Rvcik7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJlc3RMZXZlbCwgMCk7XG4gIH07XG5cbiAgX3Byb3RvLmZpbmRCZXN0TGV2ZWwgPSBmdW5jdGlvbiBmaW5kQmVzdExldmVsKGN1cnJlbnRCdywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIG1heEZldGNoRHVyYXRpb24sIGJ3RmFjdG9yLCBid1VwRmFjdG9yKSB7XG4gICAgdmFyIF9sZXZlbCRkZXRhaWxzO1xuXG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgcGFydEN1cnJlbnQgPSB0aGlzLnBhcnRDdXJyZW50LFxuICAgICAgICBjdXJyZW50TGV2ZWwgPSB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWw7XG4gICAgdmFyIGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcbiAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbY3VycmVudExldmVsXTtcbiAgICB2YXIgbGl2ZSA9ICEhKGxldmVsICE9PSBudWxsICYmIGxldmVsICE9PSB2b2lkIDAgJiYgKF9sZXZlbCRkZXRhaWxzID0gbGV2ZWwuZGV0YWlscykgIT09IG51bGwgJiYgX2xldmVsJGRldGFpbHMgIT09IHZvaWQgMCAmJiBfbGV2ZWwkZGV0YWlscy5saXZlKTtcbiAgICB2YXIgY3VycmVudENvZGVjU2V0ID0gbGV2ZWwgPT09IG51bGwgfHwgbGV2ZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxldmVsLmNvZGVjU2V0O1xuICAgIHZhciBjdXJyZW50RnJhZ0R1cmF0aW9uID0gcGFydEN1cnJlbnQgPyBwYXJ0Q3VycmVudC5kdXJhdGlvbiA6IGZyYWdDdXJyZW50ID8gZnJhZ0N1cnJlbnQuZHVyYXRpb24gOiAwO1xuXG4gICAgZm9yICh2YXIgaSA9IG1heEF1dG9MZXZlbDsgaSA+PSBtaW5BdXRvTGV2ZWw7IGktLSkge1xuICAgICAgdmFyIGxldmVsSW5mbyA9IGxldmVsc1tpXTtcblxuICAgICAgaWYgKCFsZXZlbEluZm8gfHwgY3VycmVudENvZGVjU2V0ICYmIGxldmVsSW5mby5jb2RlY1NldCAhPT0gY3VycmVudENvZGVjU2V0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgICB2YXIgYXZnRHVyYXRpb24gPSAocGFydEN1cnJlbnQgPyBsZXZlbERldGFpbHMgPT09IG51bGwgfHwgbGV2ZWxEZXRhaWxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZXZlbERldGFpbHMucGFydFRhcmdldCA6IGxldmVsRGV0YWlscyA9PT0gbnVsbCB8fCBsZXZlbERldGFpbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxldmVsRGV0YWlscy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24pIHx8IGN1cnJlbnRGcmFnRHVyYXRpb247XG4gICAgICB2YXIgYWRqdXN0ZWRidyA9IHZvaWQgMDsgLy8gZm9sbG93IGFsZ29yaXRobSBjYXB0dXJlZCBmcm9tIHN0YWdlZnJpZ2h0IDpcbiAgICAgIC8vIGh0dHBzOi8vYW5kcm9pZC5nb29nbGVzb3VyY2UuY29tL3BsYXRmb3JtL2ZyYW1ld29ya3MvYXYvKy9tYXN0ZXIvbWVkaWEvbGlic3RhZ2VmcmlnaHQvaHR0cGxpdmUvTGl2ZVNlc3Npb24uY3BwXG4gICAgICAvLyBQaWNrIHRoZSBoaWdoZXN0IGJhbmR3aWR0aCBzdHJlYW0gYmVsb3cgb3IgZXF1YWwgdG8gZXN0aW1hdGVkIGJhbmR3aWR0aC5cbiAgICAgIC8vIGNvbnNpZGVyIG9ubHkgODAlIG9mIHRoZSBhdmFpbGFibGUgYmFuZHdpZHRoLCBidXQgaWYgd2UgYXJlIHN3aXRjaGluZyB1cCxcbiAgICAgIC8vIGJlIGV2ZW4gbW9yZSBjb25zZXJ2YXRpdmUgKDcwJSkgdG8gYXZvaWQgb3ZlcmVzdGltYXRpbmcgYW5kIGltbWVkaWF0ZWx5XG4gICAgICAvLyBzd2l0Y2hpbmcgYmFjay5cblxuICAgICAgaWYgKGkgPD0gY3VycmVudExldmVsKSB7XG4gICAgICAgIGFkanVzdGVkYncgPSBid0ZhY3RvciAqIGN1cnJlbnRCdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkanVzdGVkYncgPSBid1VwRmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgfVxuXG4gICAgICB2YXIgYml0cmF0ZSA9IGxldmVsc1tpXS5tYXhCaXRyYXRlO1xuICAgICAgdmFyIGZldGNoRHVyYXRpb24gPSBiaXRyYXRlICogYXZnRHVyYXRpb24gLyBhZGp1c3RlZGJ3O1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wibG9nZ2VyXCJdLnRyYWNlKFwibGV2ZWwvYWRqdXN0ZWRidy9iaXRyYXRlL2F2Z0R1cmF0aW9uL21heEZldGNoRHVyYXRpb24vZmV0Y2hEdXJhdGlvbjogXCIgKyBpICsgXCIvXCIgKyBNYXRoLnJvdW5kKGFkanVzdGVkYncpICsgXCIvXCIgKyBiaXRyYXRlICsgXCIvXCIgKyBhdmdEdXJhdGlvbiArIFwiL1wiICsgbWF4RmV0Y2hEdXJhdGlvbiArIFwiL1wiICsgZmV0Y2hEdXJhdGlvbik7IC8vIGlmIGFkanVzdGVkIGJ3IGlzIGdyZWF0ZXIgdGhhbiBsZXZlbCBiaXRyYXRlIEFORFxuXG4gICAgICBpZiAoYWRqdXN0ZWRidyA+IGJpdHJhdGUgJiYgKCAvLyBmcmFnbWVudCBmZXRjaER1cmF0aW9uIHVua25vd24gT1IgbGl2ZSBzdHJlYW0gT1IgZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiBsZXNzIHRoYW4gbWF4IGFsbG93ZWQgZmV0Y2ggZHVyYXRpb24sIHRoZW4gdGhpcyBsZXZlbCBtYXRjaGVzXG4gICAgICAvLyB3ZSBkb24ndCBhY2NvdW50IGZvciBtYXggRmV0Y2ggRHVyYXRpb24gZm9yIGxpdmUgc3RyZWFtcywgdGhpcyBpcyB0byBhdm9pZCBzd2l0Y2hpbmcgZG93biB3aGVuIG5lYXIgdGhlIGVkZ2Ugb2YgbGl2ZSBzbGlkaW5nIHdpbmRvdyAuLi5cbiAgICAgIC8vIHNwZWNpYWwgY2FzZSB0byBzdXBwb3J0IHN0YXJ0TGV2ZWwgPSAtMSAoYml0cmF0ZVRlc3QpIG9uIGxpdmUgc3RyZWFtcyA6IGluIHRoYXQgY2FzZSB3ZSBzaG91bGQgbm90IGV4aXQgbG9vcCBzbyB0aGF0IGZpbmRCZXN0TGV2ZWwgd2lsbCByZXR1cm4gLTFcbiAgICAgICFmZXRjaER1cmF0aW9uIHx8IGxpdmUgJiYgIXRoaXMuYml0cmF0ZVRlc3REZWxheSB8fCBmZXRjaER1cmF0aW9uIDwgbWF4RmV0Y2hEdXJhdGlvbikpIHtcbiAgICAgICAgLy8gYXMgd2UgYXJlIGxvb3BpbmcgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCwgdGhpcyB3aWxsIHJldHVybiB0aGUgYmVzdCBhY2hpZXZhYmxlIHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfSAvLyBub3QgZW5vdWdoIHRpbWUgYnVkZ2V0IGV2ZW4gd2l0aCBxdWFsaXR5IGxldmVsIDAgLi4uIHJlYnVmZmVyaW5nIG1pZ2h0IGhhcHBlblxuXG5cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKEFickNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiBcIm5leHRBdXRvTGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBmb3JjZWRBdXRvTGV2ZWwgPSB0aGlzLl9uZXh0QXV0b0xldmVsO1xuICAgICAgdmFyIGJ3RXN0aW1hdG9yID0gdGhpcy5id0VzdGltYXRvcjsgLy8gaW4gY2FzZSBuZXh0IGF1dG8gbGV2ZWwgaGFzIGJlZW4gZm9yY2VkLCBhbmQgYncgbm90IGF2YWlsYWJsZSBvciBub3QgcmVsaWFibGUsIHJldHVybiBmb3JjZWQgdmFsdWVcblxuICAgICAgaWYgKGZvcmNlZEF1dG9MZXZlbCAhPT0gLTEgJiYgKCFid0VzdGltYXRvciB8fCAhYndFc3RpbWF0b3IuY2FuRXN0aW1hdGUoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICAgIH0gLy8gY29tcHV0ZSBuZXh0IGxldmVsIHVzaW5nIEFCUiBsb2dpY1xuXG5cbiAgICAgIHZhciBuZXh0QUJSQXV0b0xldmVsID0gdGhpcy5nZXROZXh0QUJSQXV0b0xldmVsKCk7IC8vIGlmIGZvcmNlZCBhdXRvIGxldmVsIGhhcyBiZWVuIGRlZmluZWQsIHVzZSBpdCB0byBjYXAgQUJSIGNvbXB1dGVkIHF1YWxpdHkgbGV2ZWxcblxuICAgICAgaWYgKGZvcmNlZEF1dG9MZXZlbCAhPT0gLTEpIHtcbiAgICAgICAgbmV4dEFCUkF1dG9MZXZlbCA9IE1hdGgubWluKGZvcmNlZEF1dG9MZXZlbCwgbmV4dEFCUkF1dG9MZXZlbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0QUJSQXV0b0xldmVsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV4dExldmVsKSB7XG4gICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBYnJDb250cm9sbGVyO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKEFickNvbnRyb2xsZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2F1ZGlvLXN0cmVhbS1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYmFzZS1zdHJlYW0tY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYmFzZS1zdHJlYW0tY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2J1ZmZlci1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZyYWdtZW50LXRyYWNrZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LXRyYWNrZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xldmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sZXZlbCAqLyBcIi4vc3JjL3R5cGVzL2xldmVsLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xvYWRlciAqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2FkZXIvZnJhZ21lbnQgKi8gXCIuL3NyYy9sb2FkZXIvZnJhZ21lbnQudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X2NodW5rX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9jaHVuay1jYWNoZSAqLyBcIi4vc3JjL2RlbXV4L2NodW5rLWNhY2hlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF90cmFuc211eGVyX2ludGVyZmFjZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvdHJhbnNtdXhlci1pbnRlcmZhY2UgKi8gXCIuL3NyYy9kZW11eC90cmFuc211eGVyLWludGVyZmFjZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL3RyYW5zbXV4ZXIgKi8gXCIuL3NyYy90eXBlcy90cmFuc211eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mcmFnbWVudF9maW5kZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mcmFnbWVudC1maW5kZXJzICovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC1maW5kZXJzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19kaXNjb250aW51aXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9kaXNjb250aW51aXRpZXMgKi8gXCIuL3NyYy91dGlscy9kaXNjb250aW51aXRpZXMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuXG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBUSUNLX0lOVEVSVkFMID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG52YXIgQXVkaW9TdHJlYW1Db250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoQXVkaW9TdHJlYW1Db250cm9sbGVyLCBfQmFzZVN0cmVhbUNvbnRyb2xsZXIpO1xuXG4gIGZ1bmN0aW9uIEF1ZGlvU3RyZWFtQ29udHJvbGxlcihobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2VTdHJlYW1Db250cm9sbGVyLmNhbGwodGhpcywgaGxzLCBmcmFnbWVudFRyYWNrZXIsICdbYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXJdJykgfHwgdGhpcztcbiAgICBfdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgX3RoaXMudmlkZW9UcmFja0NDID0gLTE7XG4gICAgX3RoaXMud2FpdGluZ1ZpZGVvQ0MgPSAtMTtcbiAgICBfdGhpcy5hdWRpb1N3aXRjaCA9IGZhbHNlO1xuICAgIF90aGlzLnRyYWNrSWQgPSAtMTtcbiAgICBfdGhpcy53YWl0aW5nRGF0YSA9IG51bGw7XG4gICAgX3RoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICAgIF90aGlzLmJ1ZmZlckZsdXNoZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEgPSBudWxsO1xuXG4gICAgX3RoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQXVkaW9TdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ub25IYW5kbGVyRGVzdHJveWluZyA9IGZ1bmN0aW9uIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuXG4gICAgdGhpcy5tYWluRGV0YWlscyA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLl9yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS1NfVVBEQVRFRCwgdGhpcy5vbkF1ZGlvVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLklOSVRfUFRTX0ZPVU5ELCB0aGlzLm9uSW5pdFB0c0ZvdW5kLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5fdW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tTX1VQREFURUQsIHRoaXMub25BdWRpb1RyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9IC8vIElOSVRfUFRTX0ZPVU5EIGlzIHRyaWdnZXJlZCB3aGVuIHRoZSB2aWRlbyB0cmFjayBwYXJzZWQgaW4gdGhlIHN0cmVhbS1jb250cm9sbGVyIGhhcyBhIG5ldyBQVFMgdmFsdWVcbiAgO1xuXG4gIF9wcm90by5vbkluaXRQdHNGb3VuZCA9IGZ1bmN0aW9uIG9uSW5pdFB0c0ZvdW5kKGV2ZW50LCBfcmVmKSB7XG4gICAgdmFyIGZyYWcgPSBfcmVmLmZyYWcsXG4gICAgICAgIGlkID0gX3JlZi5pZCxcbiAgICAgICAgaW5pdFBUUyA9IF9yZWYuaW5pdFBUUztcblxuICAgIC8vIEFsd2F5cyB1cGRhdGUgdGhlIG5ldyBJTklUIFBUU1xuICAgIC8vIENhbiBjaGFuZ2UgZHVlIGxldmVsIHN3aXRjaFxuICAgIGlmIChpZCA9PT0gJ21haW4nKSB7XG4gICAgICB2YXIgY2MgPSBmcmFnLmNjO1xuICAgICAgdGhpcy5pbml0UFRTW2ZyYWcuY2NdID0gaW5pdFBUUztcbiAgICAgIHRoaXMubG9nKFwiSW5pdFBUUyBmb3IgY2M6IFwiICsgY2MgKyBcIiBmb3VuZCBmcm9tIG1haW46IFwiICsgaW5pdFBUUyk7XG4gICAgICB0aGlzLnZpZGVvVHJhY2tDQyA9IGNjOyAvLyBJZiB3ZSBhcmUgd2FpdGluZywgdGljayBpbW1lZGlhdGVseSB0byB1bmJsb2NrIGF1ZGlvIGZyYWdtZW50IHRyYW5zbXV4aW5nXG5cbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uV0FJVElOR19JTklUX1BUUykge1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmxldmVscykge1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uU1RPUFBFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGFzdEN1cnJlbnRUaW1lID0gdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcblxuICAgIGlmIChsYXN0Q3VycmVudFRpbWUgPiAwICYmIHN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICB0aGlzLmxvZyhcIk92ZXJyaWRlIHN0YXJ0UG9zaXRpb24gd2l0aCBsYXN0Q3VycmVudFRpbWUgQFwiICsgbGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoMykpO1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfVFJBQ0s7XG4gICAgfVxuXG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgIHRoaXMudGljaygpO1xuICB9O1xuXG4gIF9wcm90by5kb1RpY2sgPSBmdW5jdGlvbiBkb1RpY2soKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFOlxuICAgICAgICB0aGlzLmRvVGlja0lkbGUoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfVFJBQ0s6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2xldmVscyR0cmFja0lkO1xuXG4gICAgICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzLFxuICAgICAgICAgICAgICB0cmFja0lkID0gdGhpcy50cmFja0lkO1xuICAgICAgICAgIHZhciBkZXRhaWxzID0gbGV2ZWxzID09PSBudWxsIHx8IGxldmVscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9sZXZlbHMkdHJhY2tJZCA9IGxldmVsc1t0cmFja0lkXSkgPT09IG51bGwgfHwgX2xldmVscyR0cmFja0lkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGV2ZWxzJHRyYWNrSWQuZGV0YWlscztcblxuICAgICAgICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53YWl0Rm9yQ2RuVHVuZUluKGRldGFpbHMpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbWVkaWE7XG5cbiAgICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgdmFyIHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlOyAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuXG4gICAgICAgICAgaWYgKCFyZXRyeURhdGUgfHwgbm93ID49IHJldHJ5RGF0ZSB8fCAoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSAhPT0gbnVsbCAmJiBfdGhpcyRtZWRpYSAhPT0gdm9pZCAwICYmIF90aGlzJG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdSZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZScpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfSU5JVF9QVFM6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBFbnN1cmUgd2UgZG9uJ3QgZ2V0IHN0dWNrIGluIHRoZSBXQUlUSU5HX0lOSVRfUFRTIHN0YXRlIGlmIHRoZSB3YWl0aW5nIGZyYWcgQ0MgZG9lc24ndCBtYXRjaCBhbnkgaW5pdFBUU1xuICAgICAgICAgIHZhciB3YWl0aW5nRGF0YSA9IHRoaXMud2FpdGluZ0RhdGE7XG5cbiAgICAgICAgICBpZiAod2FpdGluZ0RhdGEpIHtcbiAgICAgICAgICAgIHZhciBmcmFnID0gd2FpdGluZ0RhdGEuZnJhZyxcbiAgICAgICAgICAgICAgICBwYXJ0ID0gd2FpdGluZ0RhdGEucGFydCxcbiAgICAgICAgICAgICAgICBjYWNoZSA9IHdhaXRpbmdEYXRhLmNhY2hlLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlID0gd2FpdGluZ0RhdGEuY29tcGxldGU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmluaXRQVFNbZnJhZy5jY10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLndhaXRpbmdEYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy53YWl0aW5nVmlkZW9DQyA9IC0xO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLkZSQUdfTE9BRElORztcbiAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBjYWNoZS5mbHVzaCgpO1xuICAgICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbnVsbFxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpO1xuXG4gICAgICAgICAgICAgIGlmIChjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlLmNhbGwodGhpcywgZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy52aWRlb1RyYWNrQ0MgIT09IHRoaXMud2FpdGluZ1ZpZGVvQ0MpIHtcbiAgICAgICAgICAgICAgLy8gRHJvcCB3YWl0aW5nIGZyYWdtZW50IGlmIHZpZGVvVHJhY2tDQyBoYXMgY2hhbmdlZCBzaW5jZSB3YWl0aW5nRnJhZ21lbnQgd2FzIHNldCBhbmQgaW5pdFBUUyB3YXMgbm90IGZvdW5kXG4gICAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X19bXCJsb2dnZXJcIl0ubG9nKFwiV2FpdGluZyBmcmFnbWVudCBjYyAoXCIgKyBmcmFnLmNjICsgXCIpIGNhbmNlbGxlZCBiZWNhdXNlIHZpZGVvIGlzIGF0IGNjIFwiICsgdGhpcy52aWRlb1RyYWNrQ0MpO1xuICAgICAgICAgICAgICB0aGlzLmNsZWFyV2FpdGluZ0ZyYWdtZW50KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBEcm9wIHdhaXRpbmcgZnJhZ21lbnQgaWYgYW4gZWFybGllciBmcmFnbWVudCBpcyBuZWVkZWRcbiAgICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgIHZhciBidWZmZXJJbmZvID0gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkJ1ZmZlckhlbHBlclwiXS5idWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIsIHBvcywgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZSk7XG4gICAgICAgICAgICAgIHZhciB3YWl0aW5nRnJhZ21lbnRBdFBvc2l0aW9uID0gT2JqZWN0KF9mcmFnbWVudF9maW5kZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wiZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0XCJdKShidWZmZXJJbmZvLmVuZCwgdGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZyk7XG5cbiAgICAgICAgICAgICAgaWYgKHdhaXRpbmdGcmFnbWVudEF0UG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfX1tcImxvZ2dlclwiXS5sb2coXCJXYWl0aW5nIGZyYWdtZW50IGNjIChcIiArIGZyYWcuY2MgKyBcIikgQCBcIiArIGZyYWcuc3RhcnQgKyBcIiBjYW5jZWxsZWQgYmVjYXVzZSBhbm90aGVyIGZyYWdtZW50IGF0IFwiICsgYnVmZmVySW5mby5lbmQgKyBcIiBpcyBuZWVkZWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcldhaXRpbmdGcmFnbWVudCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9uVGlja0VuZCgpO1xuICB9O1xuXG4gIF9wcm90by5jbGVhcldhaXRpbmdGcmFnbWVudCA9IGZ1bmN0aW9uIGNsZWFyV2FpdGluZ0ZyYWdtZW50KCkge1xuICAgIHZhciB3YWl0aW5nRGF0YSA9IHRoaXMud2FpdGluZ0RhdGE7XG5cbiAgICBpZiAod2FpdGluZ0RhdGEpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KHdhaXRpbmdEYXRhLmZyYWcpO1xuICAgICAgdGhpcy53YWl0aW5nRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLndhaXRpbmdWaWRlb0NDID0gLTE7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vblRpY2tFbmQgPSBmdW5jdGlvbiBvblRpY2tFbmQoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcblxuICAgIGlmICghbWVkaWEgfHwgIW1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBtZWRpYSBvciBpZiB0aGUgbWVkaWEgaGFzbid0IGJ1ZmZlcmVkIGFueXRoaW5nIHlldCAocmVhZHlTdGF0ZSAwKVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogbWVkaWE7XG4gICAgdmFyIGJ1ZmZlcmVkID0gbWVkaWFCdWZmZXIuYnVmZmVyZWQ7XG5cbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEgJiYgYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICB9O1xuXG4gIF9wcm90by5kb1RpY2tJZGxlID0gZnVuY3Rpb24gZG9UaWNrSWRsZSgpIHtcbiAgICB2YXIgX2ZyYWckZGVjcnlwdGRhdGEsIF9mcmFnJGRlY3J5cHRkYXRhMjtcblxuICAgIHZhciBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICAgIG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgICAgdHJhY2tJZCA9IHRoaXMudHJhY2tJZDtcbiAgICB2YXIgY29uZmlnID0gaGxzLmNvbmZpZztcblxuICAgIGlmICghbGV2ZWxzIHx8ICFsZXZlbHNbdHJhY2tJZF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkRcbiAgICAvLyBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIG5vdCBlbmFibGVkXG4gICAgLy8gZXhpdCBsb29wXG4gICAgLy8gPT4gaWYgbWVkaWEgbm90IGF0dGFjaGVkIGJ1dCBzdGFydCBmcmFnIHByZWZldGNoIGlzIGVuYWJsZWQgYW5kIHN0YXJ0IGZyYWcgbm90IHJlcXVlc3RlZCB5ZXQsIHdlIHdpbGwgbm90IGV4aXQgbG9vcFxuXG5cbiAgICBpZiAoIW1lZGlhICYmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCB8fCAhY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsZXZlbEluZm8gPSBsZXZlbHNbdHJhY2tJZF07XG4gICAgdmFyIHRyYWNrRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzO1xuXG4gICAgaWYgKCF0cmFja0RldGFpbHMgfHwgdHJhY2tEZXRhaWxzLmxpdmUgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IHRyYWNrSWQgfHwgdGhpcy53YWl0Rm9yQ2RuVHVuZUluKHRyYWNrRGV0YWlscykpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uV0FJVElOR19UUkFDSztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5idWZmZXJGbHVzaGVkKSB7XG4gICAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYSwgX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiRWxlbWVudGFyeVN0cmVhbVR5cGVzXCJdLkFVRElPLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5BVURJTyk7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlckluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8odGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5BVURJTyk7XG5cbiAgICBpZiAoYnVmZmVySW5mbyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtYWluQnVmZmVySW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLnZpZGVvQnVmZmVyID8gdGhpcy52aWRlb0J1ZmZlciA6IHRoaXMubWVkaWEsIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLk1BSU4pO1xuICAgIHZhciBidWZmZXJMZW4gPSBidWZmZXJJbmZvLmxlbjtcbiAgICB2YXIgbWF4QnVmTGVuID0gdGhpcy5nZXRNYXhCdWZmZXJMZW5ndGgobWFpbkJ1ZmZlckluZm8gPT09IG51bGwgfHwgbWFpbkJ1ZmZlckluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1haW5CdWZmZXJJbmZvLmxlbik7XG4gICAgdmFyIGF1ZGlvU3dpdGNoID0gdGhpcy5hdWRpb1N3aXRjaDsgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50XG5cbiAgICBpZiAoYnVmZmVyTGVuID49IG1heEJ1ZkxlbiAmJiAhYXVkaW9Td2l0Y2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWF1ZGlvU3dpdGNoICYmIHRoaXMuX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIHRyYWNrRGV0YWlscykpIHtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRU9TLCB7XG4gICAgICAgIHR5cGU6ICdhdWRpbydcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5FTkRFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cztcbiAgICB2YXIgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgdmFyIHRhcmdldEJ1ZmZlclRpbWUgPSBidWZmZXJJbmZvLmVuZDtcblxuICAgIGlmIChhdWRpb1N3aXRjaCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgICB0YXJnZXRCdWZmZXJUaW1lID0gcG9zOyAvLyBpZiBjdXJyZW50VGltZSAocG9zKSBpcyBsZXNzIHRoYW4gYWx0IGF1ZGlvIHBsYXlsaXN0IHN0YXJ0IHRpbWUsIGl0IG1lYW5zIHRoYXQgYWx0IGF1ZGlvIGlzIGFoZWFkIG9mIGN1cnJlbnRUaW1lXG5cbiAgICAgIGlmICh0cmFja0RldGFpbHMuUFRTS25vd24gJiYgcG9zIDwgc3RhcnQpIHtcbiAgICAgICAgLy8gaWYgZXZlcnl0aGluZyBpcyBidWZmZXJlZCBmcm9tIHBvcyB0byBzdGFydCBvciBpZiBhdWRpbyBidWZmZXIgdXBmcm9udCwgbGV0J3Mgc2VlayB0byBzdGFydFxuICAgICAgICBpZiAoYnVmZmVySW5mby5lbmQgPiBzdGFydCB8fCBidWZmZXJJbmZvLm5leHRTdGFydCkge1xuICAgICAgICAgIHRoaXMubG9nKCdBbHQgYXVkaW8gdHJhY2sgYWhlYWQgb2YgbWFpbiB0cmFjaywgc2VlayB0byBzdGFydCBvZiBhbHQgYXVkaW8gdHJhY2snKTtcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0ICsgMC4wNTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gYnVmZmVyIGF1ZGlvIHVwIHRvIG9uZSB0YXJnZXQgZHVyYXRpb24gYWhlYWQgb2YgbWFpbiBidWZmZXJcblxuXG4gICAgaWYgKG1haW5CdWZmZXJJbmZvICYmIHRhcmdldEJ1ZmZlclRpbWUgPiBtYWluQnVmZmVySW5mby5lbmQgKyB0cmFja0RldGFpbHMudGFyZ2V0ZHVyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHdhaXQgZm9yIG1haW4gYnVmZmVyIGFmdGVyIGJ1ZmZpbmcgc29tZSBhdWRpb1xuXG5cbiAgICBpZiAoKCFtYWluQnVmZmVySW5mbyB8fCAhbWFpbkJ1ZmZlckluZm8ubGVuKSAmJiBidWZmZXJJbmZvLmxlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnQodGFyZ2V0QnVmZmVyVGltZSwgdHJhY2tEZXRhaWxzKTtcblxuICAgIGlmICghZnJhZykge1xuICAgICAgdGhpcy5idWZmZXJGbHVzaGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoKChfZnJhZyRkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGEpID09PSBudWxsIHx8IF9mcmFnJGRlY3J5cHRkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZnJhZyRkZWNyeXB0ZGF0YS5rZXlGb3JtYXQpID09PSAnaWRlbnRpdHknICYmICEoKF9mcmFnJGRlY3J5cHRkYXRhMiA9IGZyYWcuZGVjcnlwdGRhdGEpICE9PSBudWxsICYmIF9mcmFnJGRlY3J5cHRkYXRhMiAhPT0gdm9pZCAwICYmIF9mcmFnJGRlY3J5cHRkYXRhMi5rZXkpKSB7XG4gICAgICB0aGlzLmxvYWRLZXkoZnJhZywgdHJhY2tEZXRhaWxzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2FkRnJhZ21lbnQoZnJhZywgdHJhY2tEZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldE1heEJ1ZmZlckxlbmd0aCA9IGZ1bmN0aW9uIGdldE1heEJ1ZmZlckxlbmd0aChtYWluQnVmZmVyTGVuZ3RoKSB7XG4gICAgdmFyIG1heENvbmZpZ0J1ZmZlciA9IF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0TWF4QnVmZmVyTGVuZ3RoLmNhbGwodGhpcyk7XG5cbiAgICBpZiAoIW1haW5CdWZmZXJMZW5ndGgpIHtcbiAgICAgIHJldHVybiBtYXhDb25maWdCdWZmZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgubWF4KG1heENvbmZpZ0J1ZmZlciwgbWFpbkJ1ZmZlckxlbmd0aCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuXG4gICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhRGV0YWNoaW5nLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uQXVkaW9UcmFja3NVcGRhdGVkID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrc1VwZGF0ZWQoZXZlbnQsIF9yZWYyKSB7XG4gICAgdmFyIGF1ZGlvVHJhY2tzID0gX3JlZjIuYXVkaW9UcmFja3M7XG4gICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB0aGlzLmxldmVscyA9IGF1ZGlvVHJhY2tzLm1hcChmdW5jdGlvbiAobWVkaWFQbGF5bGlzdCkge1xuICAgICAgcmV0dXJuIG5ldyBfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkxldmVsXCJdKG1lZGlhUGxheWxpc3QpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcgPSBmdW5jdGlvbiBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgdmFyIGFsdEF1ZGlvID0gISFkYXRhLnVybDtcbiAgICB0aGlzLnRyYWNrSWQgPSBkYXRhLmlkO1xuICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG5cbiAgICBpZiAoZnJhZ0N1cnJlbnQgIT09IG51bGwgJiYgZnJhZ0N1cnJlbnQgIT09IHZvaWQgMCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuY2xlYXJXYWl0aW5nRnJhZ21lbnQoKTsgLy8gZGVzdHJveSB1c2VsZXNzIHRyYW5zbXV4ZXIgd2hlbiBzd2l0Y2hpbmcgYXVkaW8gdG8gbWFpblxuXG4gICAgaWYgKCFhbHRBdWRpbykge1xuICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3dpdGNoaW5nIHRvIGF1ZGlvIHRyYWNrLCBzdGFydCB0aW1lciBpZiBub3QgYWxyZWFkeSBzdGFydGVkXG4gICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xuICAgIH0gLy8gc2hvdWxkIHdlIHN3aXRjaCB0cmFja3MgP1xuXG5cbiAgICBpZiAoYWx0QXVkaW8pIHtcbiAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSB0cnVlOyAvLyBtYWluIGF1ZGlvIHRyYWNrIGFyZSBoYW5kbGVkIGJ5IHN0cmVhbS1jb250cm9sbGVyLCBqdXN0IGRvIHNvbWV0aGluZyBpZiBzd2l0Y2hpbmcgdG8gYWx0IGF1ZGlvIHRyYWNrXG5cbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uSURMRTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5TVE9QUEVEO1xuICAgIH1cblxuICAgIHRoaXMudGljaygpO1xuICB9O1xuXG4gIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8ub25MZXZlbExvYWRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuXG4gICAgaWYgKHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19MT0FERUQsIHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhKTtcbiAgICAgIHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uQXVkaW9UcmFja0xvYWRlZCA9IGZ1bmN0aW9uIG9uQXVkaW9UcmFja0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdHJhY2skZGV0YWlscztcblxuICAgIGlmICh0aGlzLm1haW5EZXRhaWxzID09IG51bGwpIHtcbiAgICAgIHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gZGF0YTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHMsXG4gICAgICAgIHRyYWNrSWQgPSBkYXRhLmlkO1xuXG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihcIkF1ZGlvIHRyYWNrcyB3ZXJlIHJlc2V0IHdoaWxlIGxvYWRpbmcgbGV2ZWwgXCIgKyB0cmFja0lkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmxvZyhcIlRyYWNrIFwiICsgdHJhY2tJZCArIFwiIGxvYWRlZCBbXCIgKyBuZXdEZXRhaWxzLnN0YXJ0U04gKyBcIixcIiArIG5ld0RldGFpbHMuZW5kU04gKyBcIl0sZHVyYXRpb246XCIgKyBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb24pO1xuICAgIHZhciB0cmFjayA9IGxldmVsc1t0cmFja0lkXTtcbiAgICB2YXIgc2xpZGluZyA9IDA7XG5cbiAgICBpZiAobmV3RGV0YWlscy5saXZlIHx8IChfdHJhY2skZGV0YWlscyA9IHRyYWNrLmRldGFpbHMpICE9PSBudWxsICYmIF90cmFjayRkZXRhaWxzICE9PSB2b2lkIDAgJiYgX3RyYWNrJGRldGFpbHMubGl2ZSkge1xuICAgICAgdmFyIG1haW5EZXRhaWxzID0gdGhpcy5tYWluRGV0YWlscztcblxuICAgICAgaWYgKCFuZXdEZXRhaWxzLmZyYWdtZW50c1swXSkge1xuICAgICAgICBuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgfHwgIW1haW5EZXRhaWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0cmFjay5kZXRhaWxzICYmIG5ld0RldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lICYmIG1haW5EZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgb3VyIGF1ZGlvIHJlbmRpdGlvbiBpcyBhbGlnbmVkIHdpdGggdGhlIFwibWFpblwiIHJlbmRpdGlvbiwgdXNpbmdcbiAgICAgICAgLy8gcGR0IGFzIG91ciByZWZlcmVuY2UgdGltZXMuXG4gICAgICAgIE9iamVjdChfdXRpbHNfZGlzY29udGludWl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1wiYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFRcIl0pKG5ld0RldGFpbHMsIG1haW5EZXRhaWxzKTtcbiAgICAgICAgc2xpZGluZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xpZGluZyA9IHRoaXMuYWxpZ25QbGF5bGlzdHMobmV3RGV0YWlscywgdHJhY2suZGV0YWlscyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJhY2suZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSB0cmFja0lkOyAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uIGlmIHdlIGFyZSBhbGlnbmVkIHdpdGggdGhlIG1haW4gcGxheWxpc3RcblxuICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgKHRoaXMubWFpbkRldGFpbHMgfHwgIW5ld0RldGFpbHMubGl2ZSkpIHtcbiAgICAgIHRoaXMuc2V0U3RhcnRQb3NpdGlvbih0cmFjay5kZXRhaWxzLCBzbGlkaW5nKTtcbiAgICB9IC8vIG9ubHkgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIHRyYWNrIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG5cblxuICAgIGlmICh0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uV0FJVElOR19UUkFDSyAmJiAhdGhpcy53YWl0Rm9yQ2RuVHVuZUluKG5ld0RldGFpbHMpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7XG4gICAgfSAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG5cblxuICAgIHRoaXMudGljaygpO1xuICB9O1xuXG4gIF9wcm90by5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbiBfaGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSkge1xuICAgIHZhciBfZnJhZyRpbml0U2VnbWVudDtcblxuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZGF0YS5wYXJ0LFxuICAgICAgICBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgdHJhY2tJZCA9IHRoaXMudHJhY2tJZCxcbiAgICAgICAgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cbiAgICBpZiAoIWxldmVscykge1xuICAgICAgdGhpcy53YXJuKFwiQXVkaW8gdHJhY2tzIHdlcmUgcmVzZXQgd2hpbGUgZnJhZ21lbnQgbG9hZCB3YXMgaW4gcHJvZ3Jlc3MuIEZyYWdtZW50IFwiICsgZnJhZy5zbiArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIHdpbGwgbm90IGJlIGJ1ZmZlcmVkXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0cmFjayA9IGxldmVsc1t0cmFja0lkXTtcbiAgICBjb25zb2xlLmFzc2VydCh0cmFjaywgJ0F1ZGlvIHRyYWNrIGlzIGRlZmluZWQgb24gZnJhZ21lbnQgbG9hZCBwcm9ncmVzcycpO1xuICAgIHZhciBkZXRhaWxzID0gdHJhY2suZGV0YWlscztcbiAgICBjb25zb2xlLmFzc2VydChkZXRhaWxzLCAnQXVkaW8gdHJhY2sgZGV0YWlscyBhcmUgZGVmaW5lZCBvbiBmcmFnbWVudCBsb2FkIHByb2dyZXNzJyk7XG4gICAgdmFyIGF1ZGlvQ29kZWMgPSBjb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgdHJhY2suYXVkaW9Db2RlYyB8fCAnbXA0YS40MC4yJztcbiAgICB2YXIgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcblxuICAgIGlmICghdHJhbnNtdXhlcikge1xuICAgICAgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlciA9IG5ldyBfZGVtdXhfdHJhbnNtdXhlcl9pbnRlcmZhY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImRlZmF1bHRcIl0odGhpcy5obHMsIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLkFVRElPLCB0aGlzLl9oYW5kbGVUcmFuc211eENvbXBsZXRlLmJpbmQodGhpcyksIHRoaXMuX2hhbmRsZVRyYW5zbXV4ZXJGbHVzaC5iaW5kKHRoaXMpKTtcbiAgICB9IC8vIENoZWNrIGlmIHdlIGhhdmUgdmlkZW8gaW5pdFBUU1xuICAgIC8vIElmIG5vdCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGl0XG5cblxuICAgIHZhciBpbml0UFRTID0gdGhpcy5pbml0UFRTW2ZyYWcuY2NdO1xuICAgIHZhciBpbml0U2VnbWVudERhdGEgPSAoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSA9PT0gbnVsbCB8fCBfZnJhZyRpbml0U2VnbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZyYWckaW5pdFNlZ21lbnQuZGF0YTtcblxuICAgIGlmIChpbml0UFRTICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRoaXMubG9nKGBUcmFuc211eGluZyAke3NufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcbiAgICAgIHZhciBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBmYWxzZTsgLy8gZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xuXG4gICAgICB2YXIgcGFydEluZGV4ID0gcGFydCA/IHBhcnQuaW5kZXggOiAtMTtcbiAgICAgIHZhciBwYXJ0aWFsID0gcGFydEluZGV4ICE9PSAtMTtcbiAgICAgIHZhciBjaHVua01ldGEgPSBuZXcgX3R5cGVzX3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJDaHVua01ldGFkYXRhXCJdKGZyYWcubGV2ZWwsIGZyYWcuc24sIGZyYWcuc3RhdHMuY2h1bmtDb3VudCwgcGF5bG9hZC5ieXRlTGVuZ3RoLCBwYXJ0SW5kZXgsIHBhcnRpYWwpO1xuICAgICAgdHJhbnNtdXhlci5wdXNoKHBheWxvYWQsIGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgJycsIGZyYWcsIHBhcnQsIGRldGFpbHMudG90YWxkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEsIGluaXRQVFMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fW1wibG9nZ2VyXCJdLmxvZyhcIlVua25vd24gdmlkZW8gUFRTIGZvciBjYyBcIiArIGZyYWcuY2MgKyBcIiwgd2FpdGluZyBmb3IgdmlkZW8gUFRTIGJlZm9yZSBkZW11eGluZyBhdWRpbyBmcmFnIFwiICsgZnJhZy5zbiArIFwiIG9mIFtcIiArIGRldGFpbHMuc3RhcnRTTiArIFwiICxcIiArIGRldGFpbHMuZW5kU04gKyBcIl0sdHJhY2sgXCIgKyB0cmFja0lkKTtcblxuICAgICAgdmFyIF90aGlzJHdhaXRpbmdEYXRhID0gdGhpcy53YWl0aW5nRGF0YSA9IHRoaXMud2FpdGluZ0RhdGEgfHwge1xuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICBjYWNoZTogbmV3IF9kZW11eF9jaHVua19jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wiZGVmYXVsdFwiXSgpLFxuICAgICAgICBjb21wbGV0ZTogZmFsc2VcbiAgICAgIH0sXG4gICAgICAgICAgY2FjaGUgPSBfdGhpcyR3YWl0aW5nRGF0YS5jYWNoZTtcblxuICAgICAgY2FjaGUucHVzaChuZXcgVWludDhBcnJheShwYXlsb2FkKSk7XG4gICAgICB0aGlzLndhaXRpbmdWaWRlb0NDID0gdGhpcy52aWRlb1RyYWNrQ0M7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUgPSBmdW5jdGlvbiBfaGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZnJhZ0xvYWRlZERhdGEpIHtcbiAgICBpZiAodGhpcy53YWl0aW5nRGF0YSkge1xuICAgICAgdGhpcy53YWl0aW5nRGF0YS5jb21wbGV0ZSA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUuY2FsbCh0aGlzLCBmcmFnTG9hZGVkRGF0YSk7XG4gIH07XG5cbiAgX3Byb3RvLm9uQnVmZmVyUmVzZXQgPSBmdW5jdGlvblxuICAgIC8qIGV2ZW50OiBFdmVudHMuQlVGRkVSX1JFU0VUICovXG4gIG9uQnVmZmVyUmVzZXQoKSB7XG4gICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIHNvdXJjZWJ1ZmZlcnNcbiAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5vbkJ1ZmZlckNyZWF0ZWQgPSBmdW5jdGlvbiBvbkJ1ZmZlckNyZWF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgYXVkaW9UcmFjayA9IGRhdGEudHJhY2tzLmF1ZGlvO1xuXG4gICAgaWYgKGF1ZGlvVHJhY2spIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBhdWRpb1RyYWNrLmJ1ZmZlcjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS50cmFja3MudmlkZW8pIHtcbiAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSBkYXRhLnRyYWNrcy52aWRlby5idWZmZXI7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkZyYWdCdWZmZXJlZCA9IGZ1bmN0aW9uIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBkYXRhLnBhcnQ7XG5cbiAgICBpZiAoZnJhZy50eXBlICE9PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5BVURJTykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgLy8gSWYgYSBsZXZlbCBzd2l0Y2ggd2FzIHJlcXVlc3RlZCB3aGlsZSBhIGZyYWdtZW50IHdhcyBidWZmZXJpbmcsIGl0IHdpbGwgZW1pdCB0aGUgRlJBR19CVUZGRVJFRCBldmVudCB1cG9uIGNvbXBsZXRpb25cbiAgICAgIC8vIEF2b2lkIHNldHRpbmcgc3RhdGUgYmFjayB0byBJRExFIG9yIGNvbmNsdWRpbmcgdGhlIGF1ZGlvIHN3aXRjaDsgb3RoZXJ3aXNlLCB0aGUgc3dpdGNoZWQtdG8gdHJhY2sgd2lsbCBub3QgYnVmZmVyXG4gICAgICB0aGlzLndhcm4oXCJGcmFnbWVudCBcIiArIGZyYWcuc24gKyAocGFydCA/ICcgcDogJyArIHBhcnQuaW5kZXggOiAnJykgKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiBmaW5pc2hlZCBidWZmZXJpbmcsIGJ1dCB3YXMgYWJvcnRlZC4gc3RhdGU6IFwiICsgdGhpcy5zdGF0ZSArIFwiLCBhdWRpb1N3aXRjaDogXCIgKyB0aGlzLmF1ZGlvU3dpdGNoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuXG4gICAgICBpZiAodGhpcy5hdWRpb1N3aXRjaCkge1xuICAgICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX1NXSVRDSEVELCB7XG4gICAgICAgICAgaWQ6IHRoaXMudHJhY2tJZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZyYWdCdWZmZXJlZENvbXBsZXRlKGZyYWcsIHBhcnQpO1xuICB9O1xuXG4gIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wiRXJyb3JEZXRhaWxzXCJdLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIC8vIFRPRE86IFNraXAgZnJhZ21lbnRzIHRoYXQgZG8gbm90IGJlbG9uZyB0byB0aGlzLmZyYWdDdXJyZW50IGF1ZGlvLWdyb3VwIGlkXG4gICAgICAgIHRoaXMub25GcmFnbWVudE9yS2V5TG9hZEVycm9yKF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLkFVRElPLCBkYXRhKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1tcIkVycm9yRGV0YWlsc1wiXS5BVURJT19UUkFDS19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wiRXJyb3JEZXRhaWxzXCJdLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVDpcbiAgICAgICAgLy8gIHdoZW4gaW4gRVJST1Igc3RhdGUsIGRvbid0IHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgaW4gY2FzZSBhIG5vbi1mYXRhbCBlcnJvciBpcyByZWNlaXZlZFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLkVSUk9SICYmIHRoaXMuc3RhdGUgIT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5TVE9QUEVEKSB7XG4gICAgICAgICAgLy8gaWYgZmF0YWwgZXJyb3IsIHN0b3AgcHJvY2Vzc2luZywgb3RoZXJ3aXNlIG1vdmUgdG8gSURMRSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IGRhdGEuZmF0YWwgPyBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uRVJST1IgOiBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uSURMRTtcbiAgICAgICAgICB0aGlzLndhcm4oZGF0YS5kZXRhaWxzICsgXCIgd2hpbGUgbG9hZGluZyBmcmFnLCBzd2l0Y2hpbmcgdG8gXCIgKyB0aGlzLnN0YXRlICsgXCIgc3RhdGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wiRXJyb3JEZXRhaWxzXCJdLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgICAvLyBpZiBpbiBhcHBlbmRpbmcgc3RhdGVcbiAgICAgICAgaWYgKGRhdGEucGFyZW50ID09PSAnYXVkaW8nICYmICh0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uUEFSU0lORyB8fCB0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uUEFSU0VEKSkge1xuICAgICAgICAgIHZhciBmbHVzaEJ1ZmZlciA9IHRydWU7XG4gICAgICAgICAgdmFyIGJ1ZmZlcmVkSW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5BVURJTyk7IC8vIDAuNSA6IHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIGVuZFxuICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXG5cbiAgICAgICAgICBpZiAoYnVmZmVyZWRJbmZvICYmIGJ1ZmZlcmVkSW5mby5sZW4gPiAwLjUpIHtcbiAgICAgICAgICAgIGZsdXNoQnVmZmVyID0gIXRoaXMucmVkdWNlTWF4QnVmZmVyTGVuZ3RoKGJ1ZmZlcmVkSW5mby5sZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmbHVzaEJ1ZmZlcikge1xuICAgICAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsIGJ1dCBicm93c2VyIGlzIHN0aWxsIGNvbXBsYWluaW5nIGFib3V0IGJ1ZmZlciBmdWxsIGVycm9yXG4gICAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgb24gSUUvRWRnZSwgcmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvcHVsbC83MDhcbiAgICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSBmbHVzaCB0aGUgd2hvbGUgYXVkaW8gYnVmZmVyIHRvIHJlY292ZXJcbiAgICAgICAgICAgIHRoaXMud2FybignQnVmZmVyIGZ1bGwgZXJyb3IgYWxzbyBtZWRpYS5jdXJyZW50VGltZSBpcyBub3QgYnVmZmVyZWQsIGZsdXNoIGF1ZGlvIGJ1ZmZlcicpO1xuICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG5cbiAgICAgICAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuZmx1c2hNYWluQnVmZmVyLmNhbGwodGhpcywgMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCAnYXVkaW8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkJ1ZmZlckZsdXNoZWQgPSBmdW5jdGlvbiBvbkJ1ZmZlckZsdXNoZWQoZXZlbnQsIF9yZWYzKSB7XG4gICAgdmFyIHR5cGUgPSBfcmVmMy50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJTykge1xuICAgICAgdGhpcy5idWZmZXJGbHVzaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9oYW5kbGVUcmFuc211eENvbXBsZXRlID0gZnVuY3Rpb24gX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUodHJhbnNtdXhSZXN1bHQpIHtcbiAgICB2YXIgX2lkMyRzYW1wbGVzO1xuXG4gICAgdmFyIGlkID0gJ2F1ZGlvJztcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgdmFyIHJlbXV4UmVzdWx0ID0gdHJhbnNtdXhSZXN1bHQucmVtdXhSZXN1bHQsXG4gICAgICAgIGNodW5rTWV0YSA9IHRyYW5zbXV4UmVzdWx0LmNodW5rTWV0YTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoY2h1bmtNZXRhKTtcblxuICAgIGlmICghY29udGV4dCkge1xuICAgICAgdGhpcy53YXJuKFwiVGhlIGxvYWRpbmcgY29udGV4dCBjaGFuZ2VkIHdoaWxlIGJ1ZmZlcmluZyBmcmFnbWVudCBcIiArIGNodW5rTWV0YS5zbiArIFwiIG9mIGxldmVsIFwiICsgY2h1bmtNZXRhLmxldmVsICsgXCIuIFRoaXMgY2h1bmsgd2lsbCBub3QgYmUgYnVmZmVyZWQuXCIpO1xuICAgICAgdGhpcy5yZXNldExpdmVTdGFydFdoZW5Ob3RMb2FkZWQoY2h1bmtNZXRhLmxldmVsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZnJhZyA9IGNvbnRleHQuZnJhZyxcbiAgICAgICAgcGFydCA9IGNvbnRleHQucGFydCxcbiAgICAgICAgZGV0YWlscyA9IGNvbnRleHQubGV2ZWwuZGV0YWlscztcbiAgICB2YXIgYXVkaW8gPSByZW11eFJlc3VsdC5hdWRpbyxcbiAgICAgICAgdGV4dCA9IHJlbXV4UmVzdWx0LnRleHQsXG4gICAgICAgIGlkMyA9IHJlbXV4UmVzdWx0LmlkMyxcbiAgICAgICAgaW5pdFNlZ21lbnQgPSByZW11eFJlc3VsdC5pbml0U2VnbWVudDsgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZnJhZ21lbnQgaGFzIGJlZW4gYWJvcnRlZC4gV2UgY2hlY2sgdGhpcyBieSBmaXJzdCBzZWVpbmcgaWYgd2UncmUgc3RpbGwgcGxheWluZyB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAvLyBJZiB3ZSBhcmUsIHN1YnNlcXVlbnRseSBjaGVjayBpZiB0aGUgY3VycmVudGx5IGxvYWRpbmcgZnJhZ21lbnQgKGZyYWdDdXJyZW50KSBoYXMgY2hhbmdlZC5cblxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSB8fCAhZGV0YWlscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uUEFSU0lORztcblxuICAgIGlmICh0aGlzLmF1ZGlvU3dpdGNoICYmIGF1ZGlvKSB7XG4gICAgICB0aGlzLmNvbXBsZXRlQXVkaW9Td2l0Y2goKTtcbiAgICB9XG5cbiAgICBpZiAoaW5pdFNlZ21lbnQgIT09IG51bGwgJiYgaW5pdFNlZ21lbnQgIT09IHZvaWQgMCAmJiBpbml0U2VnbWVudC50cmFja3MpIHtcbiAgICAgIHRoaXMuX2J1ZmZlckluaXRTZWdtZW50KGluaXRTZWdtZW50LnRyYWNrcywgZnJhZywgY2h1bmtNZXRhKTtcblxuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIHtcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICB0cmFja3M6IGluaXRTZWdtZW50LnRyYWNrc1xuICAgICAgfSk7IC8vIE9ubHkgZmx1c2ggYXVkaW8gZnJvbSBvbGQgYXVkaW8gdHJhY2tzIHdoZW4gUFRTIGlzIGtub3duIG9uIG5ldyBhdWRpbyB0cmFja1xuICAgIH1cblxuICAgIGlmIChhdWRpbykge1xuICAgICAgdmFyIHN0YXJ0UFRTID0gYXVkaW8uc3RhcnRQVFMsXG4gICAgICAgICAgZW5kUFRTID0gYXVkaW8uZW5kUFRTLFxuICAgICAgICAgIHN0YXJ0RFRTID0gYXVkaW8uc3RhcnREVFMsXG4gICAgICAgICAgZW5kRFRTID0gYXVkaW8uZW5kRFRTO1xuXG4gICAgICBpZiAocGFydCkge1xuICAgICAgICBwYXJ0LmVsZW1lbnRhcnlTdHJlYW1zW19sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJT10gPSB7XG4gICAgICAgICAgc3RhcnRQVFM6IHN0YXJ0UFRTLFxuICAgICAgICAgIGVuZFBUUzogZW5kUFRTLFxuICAgICAgICAgIHN0YXJ0RFRTOiBzdGFydERUUyxcbiAgICAgICAgICBlbmREVFM6IGVuZERUU1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJTywgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUyk7XG4gICAgICB0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YShhdWRpbywgZnJhZywgcGFydCwgY2h1bmtNZXRhKTtcbiAgICB9XG5cbiAgICBpZiAoaWQzICE9PSBudWxsICYmIGlkMyAhPT0gdm9pZCAwICYmIChfaWQzJHNhbXBsZXMgPSBpZDMuc2FtcGxlcykgIT09IG51bGwgJiYgX2lkMyRzYW1wbGVzICE9PSB2b2lkIDAgJiYgX2lkMyRzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgdmFyIGVtaXR0ZWRJRDMgPSBfZXh0ZW5kcyh7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgZGV0YWlsczogZGV0YWlsc1xuICAgICAgfSwgaWQzKTtcblxuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgZW1pdHRlZElEMyk7XG4gICAgfVxuXG4gICAgaWYgKHRleHQpIHtcbiAgICAgIHZhciBlbWl0dGVkVGV4dCA9IF9leHRlbmRzKHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBkZXRhaWxzOiBkZXRhaWxzXG4gICAgICB9LCB0ZXh0KTtcblxuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZW1pdHRlZFRleHQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2J1ZmZlckluaXRTZWdtZW50ID0gZnVuY3Rpb24gX2J1ZmZlckluaXRTZWdtZW50KHRyYWNrcywgZnJhZywgY2h1bmtNZXRhKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5QQVJTSU5HKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBkZWxldGUgYW55IHZpZGVvIHRyYWNrIGZvdW5kIG9uIGF1ZGlvIHRyYW5zbXV4ZXJcblxuXG4gICAgaWYgKHRyYWNrcy52aWRlbykge1xuICAgICAgZGVsZXRlIHRyYWNrcy52aWRlbztcbiAgICB9IC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG5cblxuICAgIHZhciB0cmFjayA9IHRyYWNrcy5hdWRpbztcblxuICAgIGlmICghdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cmFjay5sZXZlbENvZGVjID0gdHJhY2suY29kZWM7XG4gICAgdHJhY2suaWQgPSAnYXVkaW8nO1xuICAgIHRoaXMubG9nKFwiSW5pdCBhdWRpbyBidWZmZXIsIGNvbnRhaW5lcjpcIiArIHRyYWNrLmNvbnRhaW5lciArIFwiLCBjb2RlY3NbcGFyc2VkXT1bXCIgKyB0cmFjay5jb2RlYyArIFwiXVwiKTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQ09ERUNTLCB0cmFja3MpO1xuICAgIHZhciBpbml0U2VnbWVudCA9IHRyYWNrLmluaXRTZWdtZW50O1xuXG4gICAgaWYgKGluaXRTZWdtZW50ICE9PSBudWxsICYmIGluaXRTZWdtZW50ICE9PSB2b2lkIDAgJiYgaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkge1xuICAgICAgdmFyIHNlZ21lbnQgPSB7XG4gICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhLFxuICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgICAgZGF0YTogaW5pdFNlZ21lbnRcbiAgICAgIH07XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQVBQRU5ESU5HLCBzZWdtZW50KTtcbiAgICB9IC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcblxuXG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRGcmFnbWVudCA9IGZ1bmN0aW9uIGxvYWRGcmFnbWVudChmcmFnLCB0cmFja0RldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAvLyBvbmx5IGxvYWQgaWYgZnJhZ21lbnQgaXMgbm90IGxvYWRlZCBvciBpZiBpbiBhdWRpbyBzd2l0Y2hcbiAgICB2YXIgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7IC8vIHdlIGZvcmNlIGEgZnJhZyBsb2FkaW5nIGluIGF1ZGlvIHN3aXRjaCBhcyBmcmFnbWVudCB0cmFja2VyIG1pZ2h0IG5vdCBoYXZlIGV2aWN0ZWQgcHJldmlvdXMgZnJhZ3MgaW4gY2FzZSBvZiBxdWljayBhdWRpbyBzd2l0Y2hcblxuICAgIGlmICh0aGlzLmF1ZGlvU3dpdGNoIHx8IGZyYWdTdGF0ZSA9PT0gX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkZyYWdtZW50U3RhdGVcIl0uTk9UX0xPQURFRCB8fCBmcmFnU3RhdGUgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJGcmFnbWVudFN0YXRlXCJdLlBBUlRJQUwpIHtcbiAgICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnKTtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tEZXRhaWxzLmxpdmUgJiYgIU9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkodGhpcy5pbml0UFRTW2ZyYWcuY2NdKSkge1xuICAgICAgICB0aGlzLmxvZyhcIldhaXRpbmcgZm9yIHZpZGVvIFBUUyBpbiBjb250aW51aXR5IGNvdW50ZXIgXCIgKyBmcmFnLmNjICsgXCIgb2YgbGl2ZSBzdHJlYW0gYmVmb3JlIGxvYWRpbmcgYXVkaW8gZnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgb2YgbGV2ZWwgXCIgKyB0aGlzLnRyYWNrSWQpO1xuICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG5cbiAgICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5sb2FkRnJhZ21lbnQuY2FsbCh0aGlzLCBmcmFnLCB0cmFja0RldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcGxldGVBdWRpb1N3aXRjaCA9IGZ1bmN0aW9uIGNvbXBsZXRlQXVkaW9Td2l0Y2goKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIHRyYWNrSWQgPSB0aGlzLnRyYWNrSWQ7XG5cbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgYXVkaW8gdHJhY2sgOiBmbHVzaGluZyBhbGwgYXVkaW8nKTtcblxuICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5mbHVzaE1haW5CdWZmZXIuY2FsbCh0aGlzLCAwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksICdhdWRpbycpO1xuICAgIH1cblxuICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSBmYWxzZTtcbiAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfU1dJVENIRUQsIHtcbiAgICAgIGlkOiB0cmFja0lkXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcbn0oX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0pO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKEF1ZGlvU3RyZWFtQ29udHJvbGxlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9hdWRpby10cmFjay1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2VfcGxheWxpc3RfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLXBsYXlsaXN0LWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2Jhc2UtcGxheWxpc3QtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sb2FkZXIgKi8gXCIuL3NyYy90eXBlcy9sb2FkZXIudHNcIik7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5cblxuXG5cblxudmFyIEF1ZGlvVHJhY2tDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVBsYXlsaXN0Q29udHJvbGwpIHtcbiAgX2luaGVyaXRzTG9vc2UoQXVkaW9UcmFja0NvbnRyb2xsZXIsIF9CYXNlUGxheWxpc3RDb250cm9sbCk7XG5cbiAgZnVuY3Rpb24gQXVkaW9UcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQmFzZVBsYXlsaXN0Q29udHJvbGwuY2FsbCh0aGlzLCBobHMsICdbYXVkaW8tdHJhY2stY29udHJvbGxlcl0nKSB8fCB0aGlzO1xuICAgIF90aGlzLnRyYWNrcyA9IFtdO1xuICAgIF90aGlzLmdyb3VwSWQgPSBudWxsO1xuICAgIF90aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICBfdGhpcy50cmFja0lkID0gLTE7XG4gICAgX3RoaXMudHJhY2tOYW1lID0gJyc7XG4gICAgX3RoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcblxuICAgIF90aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQXVkaW9UcmFja0NvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy50cmFja3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAubGVuZ3RoID0gMDtcblxuICAgIF9CYXNlUGxheWxpc3RDb250cm9sbC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5ncm91cElkID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLnRyYWNrTmFtZSA9ICcnO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8ub25NYW5pZmVzdFBhcnNlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MgfHwgW107XG4gIH07XG5cbiAgX3Byb3RvLm9uQXVkaW9UcmFja0xvYWRlZCA9IGZ1bmN0aW9uIG9uQXVkaW9UcmFja0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBpZCA9IGRhdGEuaWQsXG4gICAgICAgIGRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgdmFyIGN1cnJlbnRUcmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cFtpZF07XG5cbiAgICBpZiAoIWN1cnJlbnRUcmFjaykge1xuICAgICAgdGhpcy53YXJuKFwiSW52YWxpZCBhdWRpbyB0cmFjayBpZCBcIiArIGlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VyRGV0YWlscyA9IGN1cnJlbnRUcmFjay5kZXRhaWxzO1xuICAgIGN1cnJlbnRUcmFjay5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIHRoaXMubG9nKFwiYXVkaW9UcmFjayBcIiArIGlkICsgXCIgbG9hZGVkIFtcIiArIGRldGFpbHMuc3RhcnRTTiArIFwiLVwiICsgZGV0YWlscy5lbmRTTiArIFwiXVwiKTtcblxuICAgIGlmIChpZCA9PT0gdGhpcy50cmFja0lkKSB7XG4gICAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xuICAgICAgdGhpcy5wbGF5bGlzdExvYWRlZChpZCwgZGF0YSwgY3VyRGV0YWlscyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkxldmVsTG9hZGluZyA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLmxldmVsKTtcbiAgfTtcblxuICBfcHJvdG8ub25MZXZlbFN3aXRjaGluZyA9IGZ1bmN0aW9uIG9uTGV2ZWxTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEubGV2ZWwpO1xuICB9O1xuXG4gIF9wcm90by5zd2l0Y2hMZXZlbCA9IGZ1bmN0aW9uIHN3aXRjaExldmVsKGxldmVsSW5kZXgpIHtcbiAgICB2YXIgbGV2ZWxJbmZvID0gdGhpcy5obHMubGV2ZWxzW2xldmVsSW5kZXhdO1xuXG4gICAgaWYgKCEobGV2ZWxJbmZvICE9PSBudWxsICYmIGxldmVsSW5mbyAhPT0gdm9pZCAwICYmIGxldmVsSW5mby5hdWRpb0dyb3VwSWRzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdWRpb0dyb3VwSWQgPSBsZXZlbEluZm8uYXVkaW9Hcm91cElkc1tsZXZlbEluZm8udXJsSWRdO1xuXG4gICAgaWYgKHRoaXMuZ3JvdXBJZCAhPT0gYXVkaW9Hcm91cElkKSB7XG4gICAgICB0aGlzLmdyb3VwSWQgPSBhdWRpb0dyb3VwSWQ7XG4gICAgICB2YXIgYXVkaW9UcmFja3MgPSB0aGlzLnRyYWNrcy5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHJldHVybiAhYXVkaW9Hcm91cElkIHx8IHRyYWNrLmdyb3VwSWQgPT09IGF1ZGlvR3JvdXBJZDtcbiAgICAgIH0pOyAvLyBEaXNhYmxlIHNlbGVjdERlZmF1bHRUcmFjayBpZiB0aGVyZSBhcmUgbm8gZGVmYXVsdCB0cmFja3NcblxuICAgICAgaWYgKHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrICYmICFhdWRpb1RyYWNrcy5zb21lKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gdHJhY2suZGVmYXVsdDtcbiAgICAgIH0pKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IGF1ZGlvVHJhY2tzO1xuICAgICAgdmFyIGF1ZGlvVHJhY2tzVXBkYXRlZCA9IHtcbiAgICAgICAgYXVkaW9UcmFja3M6IGF1ZGlvVHJhY2tzXG4gICAgICB9O1xuICAgICAgdGhpcy5sb2coXCJVcGRhdGluZyBhdWRpbyB0cmFja3MsIFwiICsgYXVkaW9UcmFja3MubGVuZ3RoICsgXCIgdHJhY2socykgZm91bmQgaW4gXFxcIlwiICsgYXVkaW9Hcm91cElkICsgXCJcXFwiIGdyb3VwLWlkXCIpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tTX1VQREFURUQsIGF1ZGlvVHJhY2tzVXBkYXRlZCk7XG4gICAgICB0aGlzLnNlbGVjdEluaXRpYWxUcmFjaygpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBfQmFzZVBsYXlsaXN0Q29udHJvbGwucHJvdG90eXBlLm9uRXJyb3IuY2FsbCh0aGlzLCBldmVudCwgZGF0YSk7XG5cbiAgICBpZiAoZGF0YS5mYXRhbCB8fCAhZGF0YS5jb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuY29udGV4dC50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLkFVRElPX1RSQUNLICYmIGRhdGEuY29udGV4dC5pZCA9PT0gdGhpcy50cmFja0lkICYmIGRhdGEuY29udGV4dC5ncm91cElkID09PSB0aGlzLmdyb3VwSWQpIHtcbiAgICAgIHRoaXMucmV0cnlMb2FkaW5nT3JGYWlsKGRhdGEpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc2V0QXVkaW9UcmFjayA9IGZ1bmN0aW9uIHNldEF1ZGlvVHJhY2sobmV3SWQpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwOyAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcblxuICAgIGlmIChuZXdJZCA8IDAgfHwgbmV3SWQgPj0gdHJhY2tzLmxlbmd0aCkge1xuICAgICAgdGhpcy53YXJuKCdJbnZhbGlkIGlkIHBhc3NlZCB0byBhdWRpby10cmFjayBjb250cm9sbGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcblxuXG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgdmFyIGxhc3RUcmFjayA9IHRyYWNrc1t0aGlzLnRyYWNrSWRdO1xuICAgIHRoaXMubG9nKFwiTm93IHN3aXRjaGluZyB0byBhdWRpby10cmFjayBpbmRleCBcIiArIG5ld0lkKTtcbiAgICB2YXIgdHJhY2sgPSB0cmFja3NbbmV3SWRdO1xuICAgIHZhciBpZCA9IHRyYWNrLmlkLFxuICAgICAgICBfdHJhY2skZ3JvdXBJZCA9IHRyYWNrLmdyb3VwSWQsXG4gICAgICAgIGdyb3VwSWQgPSBfdHJhY2skZ3JvdXBJZCA9PT0gdm9pZCAwID8gJycgOiBfdHJhY2skZ3JvdXBJZCxcbiAgICAgICAgbmFtZSA9IHRyYWNrLm5hbWUsXG4gICAgICAgIHR5cGUgPSB0cmFjay50eXBlLFxuICAgICAgICB1cmwgPSB0cmFjay51cmw7XG4gICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgdGhpcy50cmFja05hbWUgPSBuYW1lO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfU1dJVENISU5HLCB7XG4gICAgICBpZDogaWQsXG4gICAgICBncm91cElkOiBncm91cElkLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICB1cmw6IHVybFxuICAgIH0pOyAvLyBEbyBub3QgcmVsb2FkIHRyYWNrIHVubGVzcyBsaXZlXG5cbiAgICBpZiAodHJhY2suZGV0YWlscyAmJiAhdHJhY2suZGV0YWlscy5saXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhsc1VybFBhcmFtZXRlcnMgPSB0aGlzLnN3aXRjaFBhcmFtcyh0cmFjay51cmwsIGxhc3RUcmFjayA9PT0gbnVsbCB8fCBsYXN0VHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RUcmFjay5kZXRhaWxzKTtcbiAgICB0aGlzLmxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKTtcbiAgfTtcblxuICBfcHJvdG8uc2VsZWN0SW5pdGlhbFRyYWNrID0gZnVuY3Rpb24gc2VsZWN0SW5pdGlhbFRyYWNrKCkge1xuICAgIHZhciBhdWRpb1RyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgICBjb25zb2xlLmFzc2VydChhdWRpb1RyYWNrcy5sZW5ndGgsICdJbml0aWFsIGF1ZGlvIHRyYWNrIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIHRyYWNrcyBhcmUga25vd24nKTtcbiAgICB2YXIgY3VycmVudEF1ZGlvVHJhY2tOYW1lID0gdGhpcy50cmFja05hbWU7XG4gICAgdmFyIHRyYWNrSWQgPSB0aGlzLmZpbmRUcmFja0lkKGN1cnJlbnRBdWRpb1RyYWNrTmFtZSkgfHwgdGhpcy5maW5kVHJhY2tJZCgpO1xuXG4gICAgaWYgKHRyYWNrSWQgIT09IC0xKSB7XG4gICAgICB0aGlzLnNldEF1ZGlvVHJhY2sodHJhY2tJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2FybihcIk5vIHRyYWNrIGZvdW5kIGZvciBydW5uaW5nIGF1ZGlvIGdyb3VwLUlEOiBcIiArIHRoaXMuZ3JvdXBJZCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uQVVESU9fVFJBQ0tfTE9BRF9FUlJPUixcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZmluZFRyYWNrSWQgPSBmdW5jdGlvbiBmaW5kVHJhY2tJZChuYW1lKSB7XG4gICAgdmFyIGF1ZGlvVHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdWRpb1RyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gYXVkaW9UcmFja3NbaV07XG5cbiAgICAgIGlmICghdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgfHwgdHJhY2suZGVmYXVsdCkge1xuICAgICAgICBpZiAoIW5hbWUgfHwgbmFtZSA9PT0gdHJhY2submFtZSkge1xuICAgICAgICAgIHJldHVybiB0cmFjay5pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBfcHJvdG8ubG9hZFBsYXlsaXN0ID0gZnVuY3Rpb24gbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICB2YXIgYXVkaW9UcmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cFt0aGlzLnRyYWNrSWRdO1xuXG4gICAgaWYgKHRoaXMuc2hvdWxkTG9hZFRyYWNrKGF1ZGlvVHJhY2spKSB7XG4gICAgICB2YXIgaWQgPSBhdWRpb1RyYWNrLmlkO1xuICAgICAgdmFyIGdyb3VwSWQgPSBhdWRpb1RyYWNrLmdyb3VwSWQ7XG4gICAgICB2YXIgdXJsID0gYXVkaW9UcmFjay51cmw7XG5cbiAgICAgIGlmIChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJsID0gaGxzVXJsUGFyYW1ldGVycy5hZGREaXJlY3RpdmVzKHVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy53YXJuKFwiQ291bGQgbm90IGNvbnN0cnVjdCBuZXcgVVJMIHdpdGggSExTIERlbGl2ZXJ5IERpcmVjdGl2ZXM6IFwiICsgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9IC8vIHRyYWNrIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcblxuXG4gICAgICB0aGlzLmxvZyhcImxvYWRpbmcgYXVkaW8tdHJhY2sgcGxheWxpc3QgZm9yIGlkOiBcIiArIGlkKTtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfTE9BRElORywge1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBncm91cElkOiBncm91cElkLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGhsc1VybFBhcmFtZXRlcnMgfHwgbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhBdWRpb1RyYWNrQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwiYXVkaW9UcmFja3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF1ZGlvVHJhY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdJZCkge1xuICAgICAgLy8gSWYgYXVkaW8gdHJhY2sgaXMgc2VsZWN0ZWQgZnJvbSBBUEkgdGhlbiBkb24ndCBjaG9vc2UgZnJvbSB0aGUgbWFuaWZlc3QgZGVmYXVsdCB0cmFja1xuICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2V0QXVkaW9UcmFjayhuZXdJZCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEF1ZGlvVHJhY2tDb250cm9sbGVyO1xufShfYmFzZV9wbGF5bGlzdF9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChBdWRpb1RyYWNrQ29udHJvbGxlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYmFzZS1wbGF5bGlzdC1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYmFzZS1wbGF5bGlzdC1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEJhc2VQbGF5bGlzdENvbnRyb2xsZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sZXZlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvbGV2ZWwgKi8gXCIuL3NyYy90eXBlcy9sZXZlbC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xldmVsLWhlbHBlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG5cblxuXG5cblxuXG5cbnZhciBCYXNlUGxheWxpc3RDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZVBsYXlsaXN0Q29udHJvbGxlcihobHMsIGxvZ1ByZWZpeCkge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMudGltZXIgPSAtMTtcbiAgICB0aGlzLmNhbkxvYWQgPSBmYWxzZTtcbiAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xuICAgIHRoaXMubG9nID0gdm9pZCAwO1xuICAgIHRoaXMud2FybiA9IHZvaWQgMDtcbiAgICB0aGlzLmxvZyA9IF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS5sb2cuYmluZChfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0sIGxvZ1ByZWZpeCArIFwiOlwiKTtcbiAgICB0aGlzLndhcm4gPSBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ud2Fybi5iaW5kKF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXSwgbG9nUHJlZml4ICsgXCI6XCIpO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEJhc2VQbGF5bGlzdENvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgdGhpcy5obHMgPSB0aGlzLmxvZyA9IHRoaXMud2FybiA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwgJiYgZGF0YS50eXBlID09PSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJFcnJvclR5cGVzXCJdLk5FVFdPUktfRVJST1IpIHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY2xlYXJUaW1lciA9IGZ1bmN0aW9uIGNsZWFyVGltZXIoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgIHRoaXMudGltZXIgPSAtMTtcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKCkge1xuICAgIHRoaXMuY2FuTG9hZCA9IHRydWU7XG4gICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICB0aGlzLmxvYWRQbGF5bGlzdCgpO1xuICB9O1xuXG4gIF9wcm90by5zdG9wTG9hZCA9IGZ1bmN0aW9uIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuY2FuTG9hZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9O1xuXG4gIF9wcm90by5zd2l0Y2hQYXJhbXMgPSBmdW5jdGlvbiBzd2l0Y2hQYXJhbXMocGxheWxpc3RVcmksIHByZXZpb3VzKSB7XG4gICAgdmFyIHJlbmRpdGlvblJlcG9ydHMgPSBwcmV2aW91cyA9PT0gbnVsbCB8fCBwcmV2aW91cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldmlvdXMucmVuZGl0aW9uUmVwb3J0cztcblxuICAgIGlmIChyZW5kaXRpb25SZXBvcnRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbmRpdGlvblJlcG9ydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGF0dHIgPSByZW5kaXRpb25SZXBvcnRzW2ldO1xuICAgICAgICB2YXIgdXJpID0gJycgKyBhdHRyLlVSSTtcblxuICAgICAgICBpZiAodXJpID09PSBwbGF5bGlzdFVyaS5zbGljZSgtdXJpLmxlbmd0aCkpIHtcbiAgICAgICAgICB2YXIgbXNuID0gcGFyc2VJbnQoYXR0clsnTEFTVC1NU04nXSk7XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJzZUludChhdHRyWydMQVNULVBBUlQnXSk7XG5cbiAgICAgICAgICBpZiAocHJldmlvdXMgJiYgdGhpcy5obHMuY29uZmlnLmxvd0xhdGVuY3lNb2RlKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEdvYWwgPSBNYXRoLm1pbihwcmV2aW91cy5hZ2UgLSBwcmV2aW91cy5wYXJ0VGFyZ2V0LCBwcmV2aW91cy50YXJnZXRkdXJhdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSB1bmRlZmluZWQgJiYgY3VycmVudEdvYWwgPiBwcmV2aW91cy5wYXJ0VGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHBhcnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShtc24pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IF90eXBlc19sZXZlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiSGxzVXJsUGFyYW1ldGVyc1wiXShtc24sIE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkocGFydCkgPyBwYXJ0IDogdW5kZWZpbmVkLCBfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkhsc1NraXBcIl0uTm8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ubG9hZFBsYXlsaXN0ID0gZnVuY3Rpb24gbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHt9O1xuXG4gIF9wcm90by5zaG91bGRMb2FkVHJhY2sgPSBmdW5jdGlvbiBzaG91bGRMb2FkVHJhY2sodHJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5jYW5Mb2FkICYmIHRyYWNrICYmICEhdHJhY2sudXJsICYmICghdHJhY2suZGV0YWlscyB8fCB0cmFjay5kZXRhaWxzLmxpdmUpO1xuICB9O1xuXG4gIF9wcm90by5wbGF5bGlzdExvYWRlZCA9IGZ1bmN0aW9uIHBsYXlsaXN0TG9hZGVkKGluZGV4LCBkYXRhLCBwcmV2aW91c0RldGFpbHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGRldGFpbHMgPSBkYXRhLmRldGFpbHMsXG4gICAgICAgIHN0YXRzID0gZGF0YS5zdGF0czsgLy8gU2V0IGxhc3QgdXBkYXRlZCBkYXRlLXRpbWVcblxuICAgIHZhciBlbGFwc2VkID0gc3RhdHMubG9hZGluZy5lbmQgPyBNYXRoLm1heCgwLCBzZWxmLnBlcmZvcm1hbmNlLm5vdygpIC0gc3RhdHMubG9hZGluZy5lbmQpIDogMDtcbiAgICBkZXRhaWxzLmFkdmFuY2VkRGF0ZVRpbWUgPSBEYXRlLm5vdygpIC0gZWxhcHNlZDsgLy8gaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3QsIGFybSBhIHRpbWVyIHRvIHJlbG9hZCBpdFxuXG4gICAgaWYgKGRldGFpbHMubGl2ZSB8fCBwcmV2aW91c0RldGFpbHMgIT09IG51bGwgJiYgcHJldmlvdXNEZXRhaWxzICE9PSB2b2lkIDAgJiYgcHJldmlvdXNEZXRhaWxzLmxpdmUpIHtcbiAgICAgIGRldGFpbHMucmVsb2FkZWQocHJldmlvdXNEZXRhaWxzKTtcblxuICAgICAgaWYgKHByZXZpb3VzRGV0YWlscykge1xuICAgICAgICB0aGlzLmxvZyhcImxpdmUgcGxheWxpc3QgXCIgKyBpbmRleCArIFwiIFwiICsgKGRldGFpbHMuYWR2YW5jZWQgPyAnUkVGUkVTSEVEICcgKyBkZXRhaWxzLmxhc3RQYXJ0U24gKyAnLScgKyBkZXRhaWxzLmxhc3RQYXJ0SW5kZXggOiAnTUlTU0VEJykpO1xuICAgICAgfSAvLyBNZXJnZSBsaXZlIHBsYXlsaXN0cyB0byBhZGp1c3QgZnJhZ21lbnQgc3RhcnRzIGFuZCBmaWxsIGluIGRlbHRhIHBsYXlsaXN0IHNraXBwZWQgc2VnbWVudHNcblxuXG4gICAgICBpZiAocHJldmlvdXNEZXRhaWxzICYmIGRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgT2JqZWN0KF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIm1lcmdlRGV0YWlsc1wiXSkocHJldmlvdXNEZXRhaWxzLCBkZXRhaWxzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmNhbkxvYWQgfHwgIWRldGFpbHMubGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWxpdmVyeURpcmVjdGl2ZXM7XG4gICAgICB2YXIgbXNuID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIHBhcnQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChkZXRhaWxzLmNhbkJsb2NrUmVsb2FkICYmIGRldGFpbHMuZW5kU04gJiYgZGV0YWlscy5hZHZhbmNlZCkge1xuICAgICAgICAvLyBMb2FkIGxldmVsIHdpdGggTEwtSExTIGRlbGl2ZXJ5IGRpcmVjdGl2ZXNcbiAgICAgICAgdmFyIGxvd0xhdGVuY3lNb2RlID0gdGhpcy5obHMuY29uZmlnLmxvd0xhdGVuY3lNb2RlO1xuICAgICAgICB2YXIgbGFzdFBhcnRTbiA9IGRldGFpbHMubGFzdFBhcnRTbjtcbiAgICAgICAgdmFyIGVuZFNuID0gZGV0YWlscy5lbmRTTjtcbiAgICAgICAgdmFyIGxhc3RQYXJ0SW5kZXggPSBkZXRhaWxzLmxhc3RQYXJ0SW5kZXg7XG4gICAgICAgIHZhciBoYXNQYXJ0cyA9IGxhc3RQYXJ0SW5kZXggIT09IC0xO1xuICAgICAgICB2YXIgbGFzdFBhcnQgPSBsYXN0UGFydFNuID09PSBlbmRTbjsgLy8gV2hlbiBsb3cgbGF0ZW5jeSBtb2RlIGlzIGRpc2FibGVkLCB3ZSdsbCBza2lwIHBhcnQgcmVxdWVzdHMgb25jZSB0aGUgbGFzdCBwYXJ0IGluZGV4IGlzIGZvdW5kXG5cbiAgICAgICAgdmFyIG5leHRTblN0YXJ0SW5kZXggPSBsb3dMYXRlbmN5TW9kZSA/IDAgOiBsYXN0UGFydEluZGV4O1xuXG4gICAgICAgIGlmIChoYXNQYXJ0cykge1xuICAgICAgICAgIG1zbiA9IGxhc3RQYXJ0ID8gZW5kU24gKyAxIDogbGFzdFBhcnRTbjtcbiAgICAgICAgICBwYXJ0ID0gbGFzdFBhcnQgPyBuZXh0U25TdGFydEluZGV4IDogbGFzdFBhcnRJbmRleCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXNuID0gZW5kU24gKyAxO1xuICAgICAgICB9IC8vIExvdy1MYXRlbmN5IENETiBUdW5lLWluOiBcImFnZVwiIGhlYWRlciBhbmQgdGltZSBzaW5jZSBsb2FkIGluZGljYXRlcyB3ZSdyZSBiZWhpbmQgYnkgbW9yZSB0aGFuIG9uZSBwYXJ0XG4gICAgICAgIC8vIFVwZGF0ZSBkaXJlY3RpdmVzIHRvIG9idGFpbiB0aGUgUGxheWxpc3QgdGhhdCBoYXMgdGhlIGVzdGltYXRlZCBhZGRpdGlvbmFsIGR1cmF0aW9uIG9mIG1lZGlhXG5cblxuICAgICAgICB2YXIgbGFzdEFkdmFuY2VkID0gZGV0YWlscy5hZ2U7XG4gICAgICAgIHZhciBjZG5BZ2UgPSBsYXN0QWR2YW5jZWQgKyBkZXRhaWxzLmFnZUhlYWRlcjtcbiAgICAgICAgdmFyIGN1cnJlbnRHb2FsID0gTWF0aC5taW4oY2RuQWdlIC0gZGV0YWlscy5wYXJ0VGFyZ2V0LCBkZXRhaWxzLnRhcmdldGR1cmF0aW9uICogMS41KTtcblxuICAgICAgICBpZiAoY3VycmVudEdvYWwgPiAwKSB7XG4gICAgICAgICAgaWYgKHByZXZpb3VzRGV0YWlscyAmJiBjdXJyZW50R29hbCA+IHByZXZpb3VzRGV0YWlscy50dW5lSW5Hb2FsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhdHRlbXB0ZWQgdG8gZ2V0IHRoZSBuZXh0IG9yIGxhdGVzdCBwbGF5bGlzdCB1cGRhdGUsIGJ1dCBjdXJyZW50R29hbCBpbmNyZWFzZWQsXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGVpdGhlciBjYW4ndCBjYXRjaHVwLCBvciB0aGUgXCJhZ2VcIiBoZWFkZXIgY2Fubm90IGJlIHRydXN0ZWQuXG4gICAgICAgICAgICB0aGlzLndhcm4oXCJDRE4gVHVuZS1pbiBnb2FsIGluY3JlYXNlZCBmcm9tOiBcIiArIHByZXZpb3VzRGV0YWlscy50dW5lSW5Hb2FsICsgXCIgdG86IFwiICsgY3VycmVudEdvYWwgKyBcIiB3aXRoIHBsYXlsaXN0IGFnZTogXCIgKyBkZXRhaWxzLmFnZSk7XG4gICAgICAgICAgICBjdXJyZW50R29hbCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50cyA9IE1hdGguZmxvb3IoY3VycmVudEdvYWwgLyBkZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICAgICAgICAgIG1zbiArPSBzZWdtZW50cztcblxuICAgICAgICAgICAgaWYgKHBhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgcGFydHMgPSBNYXRoLnJvdW5kKGN1cnJlbnRHb2FsICUgZGV0YWlscy50YXJnZXRkdXJhdGlvbiAvIGRldGFpbHMucGFydFRhcmdldCk7XG4gICAgICAgICAgICAgIHBhcnQgKz0gcGFydHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubG9nKFwiQ0ROIFR1bmUtaW4gYWdlOiBcIiArIGRldGFpbHMuYWdlSGVhZGVyICsgXCJzIGxhc3QgYWR2YW5jZWQgXCIgKyBsYXN0QWR2YW5jZWQudG9GaXhlZCgyKSArIFwicyBnb2FsOiBcIiArIGN1cnJlbnRHb2FsICsgXCIgc2tpcCBzbiBcIiArIHNlZ21lbnRzICsgXCIgdG8gcGFydCBcIiArIHBhcnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRldGFpbHMudHVuZUluR29hbCA9IGN1cnJlbnRHb2FsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzID0gdGhpcy5nZXREZWxpdmVyeURpcmVjdGl2ZXMoZGV0YWlscywgZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMsIG1zbiwgcGFydCk7XG5cbiAgICAgICAgaWYgKGxvd0xhdGVuY3lNb2RlIHx8ICFsYXN0UGFydCkge1xuICAgICAgICAgIHRoaXMubG9hZFBsYXlsaXN0KGRlbGl2ZXJ5RGlyZWN0aXZlcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSB0aGlzLmdldERlbGl2ZXJ5RGlyZWN0aXZlcyhkZXRhaWxzLCBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcywgbXNuLCBwYXJ0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbG9hZEludGVydmFsID0gT2JqZWN0KF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImNvbXB1dGVSZWxvYWRJbnRlcnZhbFwiXSkoZGV0YWlscywgc3RhdHMpO1xuXG4gICAgICBpZiAobXNuICE9PSB1bmRlZmluZWQgJiYgZGV0YWlscy5jYW5CbG9ja1JlbG9hZCkge1xuICAgICAgICByZWxvYWRJbnRlcnZhbCAtPSBkZXRhaWxzLnBhcnRUYXJnZXQgfHwgMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2coXCJyZWxvYWQgbGl2ZSBwbGF5bGlzdCBcIiArIGluZGV4ICsgXCIgaW4gXCIgKyBNYXRoLnJvdW5kKHJlbG9hZEludGVydmFsKSArIFwiIG1zXCIpO1xuICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5sb2FkUGxheWxpc3QoZGVsaXZlcnlEaXJlY3RpdmVzKTtcbiAgICAgIH0sIHJlbG9hZEludGVydmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXREZWxpdmVyeURpcmVjdGl2ZXMgPSBmdW5jdGlvbiBnZXREZWxpdmVyeURpcmVjdGl2ZXMoZGV0YWlscywgcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMsIG1zbiwgcGFydCkge1xuICAgIHZhciBza2lwID0gT2JqZWN0KF90eXBlc19sZXZlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZ2V0U2tpcFZhbHVlXCJdKShkZXRhaWxzLCBtc24pO1xuXG4gICAgaWYgKHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzICE9PSBudWxsICYmIHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzICE9PSB2b2lkIDAgJiYgcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMuc2tpcCAmJiBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICBtc24gPSBwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcy5tc247XG4gICAgICBwYXJ0ID0gcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMucGFydDtcbiAgICAgIHNraXAgPSBfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkhsc1NraXBcIl0uTm87XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkhsc1VybFBhcmFtZXRlcnNcIl0obXNuLCBwYXJ0LCBza2lwKTtcbiAgfTtcblxuICBfcHJvdG8ucmV0cnlMb2FkaW5nT3JGYWlsID0gZnVuY3Rpb24gcmV0cnlMb2FkaW5nT3JGYWlsKGVycm9yRXZlbnQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgdmFyIHJldHJ5ID0gdGhpcy5yZXRyeUNvdW50IDwgY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5O1xuXG4gICAgaWYgKHJldHJ5KSB7XG4gICAgICB2YXIgX2Vycm9yRXZlbnQkY29udGV4dDtcblxuICAgICAgdGhpcy5yZXRyeUNvdW50Kys7XG5cbiAgICAgIGlmIChlcnJvckV2ZW50LmRldGFpbHMuaW5kZXhPZignTG9hZFRpbWVPdXQnKSA+IC0xICYmIChfZXJyb3JFdmVudCRjb250ZXh0ID0gZXJyb3JFdmVudC5jb250ZXh0KSAhPT0gbnVsbCAmJiBfZXJyb3JFdmVudCRjb250ZXh0ICE9PSB2b2lkIDAgJiYgX2Vycm9yRXZlbnQkY29udGV4dC5kZWxpdmVyeURpcmVjdGl2ZXMpIHtcbiAgICAgICAgLy8gVGhlIExMLUhMUyByZXF1ZXN0IGFscmVhZHkgdGltZWQgb3V0IHNvIHJldHJ5IGltbWVkaWF0ZWx5XG4gICAgICAgIHRoaXMud2FybihcInJldHJ5IHBsYXlsaXN0IGxvYWRpbmcgI1wiICsgdGhpcy5yZXRyeUNvdW50ICsgXCIgYWZ0ZXIgXFxcIlwiICsgZXJyb3JFdmVudC5kZXRhaWxzICsgXCJcXFwiXCIpO1xuICAgICAgICB0aGlzLmxvYWRQbGF5bGlzdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gbWF4IHJldHJ5IHRpbWVvdXRcbiAgICAgICAgdmFyIGRlbGF5ID0gTWF0aC5taW4oTWF0aC5wb3coMiwgdGhpcy5yZXRyeUNvdW50KSAqIGNvbmZpZy5sZXZlbExvYWRpbmdSZXRyeURlbGF5LCBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTsgLy8gU2NoZWR1bGUgbGV2ZWwvdHJhY2sgcmVsb2FkXG5cbiAgICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5sb2FkUGxheWxpc3QoKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICB0aGlzLndhcm4oXCJyZXRyeSBwbGF5bGlzdCBsb2FkaW5nICNcIiArIHRoaXMucmV0cnlDb3VudCArIFwiIGluIFwiICsgZGVsYXkgKyBcIiBtcyBhZnRlciBcXFwiXCIgKyBlcnJvckV2ZW50LmRldGFpbHMgKyBcIlxcXCJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2FybihcImNhbm5vdCByZWNvdmVyIGZyb20gZXJyb3IgXFxcIlwiICsgZXJyb3JFdmVudC5kZXRhaWxzICsgXCJcXFwiXCIpOyAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcblxuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7IC8vIHN3aXRjaCBlcnJvciB0byBmYXRhbFxuXG4gICAgICBlcnJvckV2ZW50LmZhdGFsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0cnk7XG4gIH07XG5cbiAgcmV0dXJuIEJhc2VQbGF5bGlzdENvbnRyb2xsZXI7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYmFzZS1zdHJlYW0tY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogU3RhdGUsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiU3RhdGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTdGF0ZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEJhc2VTdHJlYW1Db250cm9sbGVyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdGFza19sb29wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90YXNrLWxvb3AgKi8gXCIuL3NyYy90YXNrLWxvb3AudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQtdHJhY2tlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYnVmZmVyLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL3RyYW5zbXV4ZXIgKi8gXCIuL3NyYy90eXBlcy90cmFuc211eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL21wNC10b29scyAqLyBcIi4vc3JjL3V0aWxzL21wNC10b29scy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZGlzY29udGludWl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9kaXNjb250aW51aXRpZXMgKi8gXCIuL3NyYy91dGlscy9kaXNjb250aW51aXRpZXMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZyYWdtZW50X2ZpbmRlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZyYWdtZW50LWZpbmRlcnMgKi8gXCIuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LWZpbmRlcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGV2ZWwtaGVscGVyICovIFwiLi9zcmMvY29udHJvbGxlci9sZXZlbC1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRlcl9mcmFnbWVudF9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2FkZXIvZnJhZ21lbnQtbG9hZGVyICovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LWxvYWRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY3J5cHRfZGVjcnlwdGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY3J5cHQvZGVjcnlwdGVyICovIFwiLi9zcmMvY3J5cHQvZGVjcnlwdGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc190aW1lX3Jhbmdlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3RpbWUtcmFuZ2VzICovIFwiLi9zcmMvdXRpbHMvdGltZS1yYW5nZXMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xvYWRlciAqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiKTtcblxuXG5cblxuXG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgU3RhdGUgPSB7XG4gIFNUT1BQRUQ6ICdTVE9QUEVEJyxcbiAgSURMRTogJ0lETEUnLFxuICBLRVlfTE9BRElORzogJ0tFWV9MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HOiAnRlJBR19MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6ICdGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWScsXG4gIFdBSVRJTkdfVFJBQ0s6ICdXQUlUSU5HX1RSQUNLJyxcbiAgUEFSU0lORzogJ1BBUlNJTkcnLFxuICBQQVJTRUQ6ICdQQVJTRUQnLFxuICBFTkRFRDogJ0VOREVEJyxcbiAgRVJST1I6ICdFUlJPUicsXG4gIFdBSVRJTkdfSU5JVF9QVFM6ICdXQUlUSU5HX0lOSVRfUFRTJyxcbiAgV0FJVElOR19MRVZFTDogJ1dBSVRJTkdfTEVWRUwnXG59O1xuXG52YXIgQmFzZVN0cmVhbUNvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UYXNrTG9vcCkge1xuICBfaW5oZXJpdHNMb29zZShCYXNlU3RyZWFtQ29udHJvbGxlciwgX1Rhc2tMb29wKTtcblxuICBmdW5jdGlvbiBCYXNlU3RyZWFtQ29udHJvbGxlcihobHMsIGZyYWdtZW50VHJhY2tlciwgbG9nUHJlZml4KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfVGFza0xvb3AuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLmhscyA9IHZvaWQgMDtcbiAgICBfdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIF90aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICBfdGhpcy5mcmFnbWVudFRyYWNrZXIgPSB2b2lkIDA7XG4gICAgX3RoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgX3RoaXMuX3N0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICBfdGhpcy5tZWRpYSA9IHZvaWQgMDtcbiAgICBfdGhpcy5tZWRpYUJ1ZmZlciA9IHZvaWQgMDtcbiAgICBfdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgX3RoaXMuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICBfdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIF90aGlzLm5leHRMb2FkUG9zaXRpb24gPSAwO1xuICAgIF90aGlzLnN0YXJ0UG9zaXRpb24gPSAwO1xuICAgIF90aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgX3RoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgX3RoaXMucmV0cnlEYXRlID0gMDtcbiAgICBfdGhpcy5sZXZlbHMgPSBudWxsO1xuICAgIF90aGlzLmZyYWdtZW50TG9hZGVyID0gdm9pZCAwO1xuICAgIF90aGlzLmxldmVsTGFzdExvYWRlZCA9IG51bGw7XG4gICAgX3RoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgX3RoaXMuZGVjcnlwdGVyID0gdm9pZCAwO1xuICAgIF90aGlzLmluaXRQVFMgPSBbXTtcbiAgICBfdGhpcy5vbnZzZWVraW5nID0gbnVsbDtcbiAgICBfdGhpcy5vbnZlbmRlZCA9IG51bGw7XG4gICAgX3RoaXMubG9nUHJlZml4ID0gJyc7XG4gICAgX3RoaXMubG9nID0gdm9pZCAwO1xuICAgIF90aGlzLndhcm4gPSB2b2lkIDA7XG4gICAgX3RoaXMubG9nUHJlZml4ID0gbG9nUHJlZml4O1xuICAgIF90aGlzLmxvZyA9IF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImxvZ2dlclwiXS5sb2cuYmluZChfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJsb2dnZXJcIl0sIGxvZ1ByZWZpeCArIFwiOlwiKTtcbiAgICBfdGhpcy53YXJuID0gX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wibG9nZ2VyXCJdLndhcm4uYmluZChfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJsb2dnZXJcIl0sIGxvZ1ByZWZpeCArIFwiOlwiKTtcbiAgICBfdGhpcy5obHMgPSBobHM7XG4gICAgX3RoaXMuZnJhZ21lbnRMb2FkZXIgPSBuZXcgX2xvYWRlcl9mcmFnbWVudF9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bXCJkZWZhdWx0XCJdKGhscy5jb25maWcpO1xuICAgIF90aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcbiAgICBfdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIF90aGlzLmRlY3J5cHRlciA9IG5ldyBfY3J5cHRfZGVjcnlwdGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wiZGVmYXVsdFwiXShobHMsIGhscy5jb25maWcpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJFdmVudHNcIl0uS0VZX0xPQURFRCwgX3RoaXMub25LZXlMb2FkZWQsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kb1RpY2sgPSBmdW5jdGlvbiBkb1RpY2soKSB7XG4gICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgfTtcblxuICBfcHJvdG8ub25UaWNrRW5kID0gZnVuY3Rpb24gb25UaWNrRW5kKCkge30gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICA7XG5cbiAgX3Byb3RvLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7fTtcblxuICBfcHJvdG8uc3RvcExvYWQgPSBmdW5jdGlvbiBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLmZyYWdtZW50TG9hZGVyLmFib3J0KCk7XG4gICAgdmFyIGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuXG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgIH1cblxuICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICB9O1xuXG4gIF9wcm90by5fc3RyZWFtRW5kZWQgPSBmdW5jdGlvbiBfc3RyZWFtRW5kZWQoYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgZnJhZ21lbnRUcmFja2VyID0gdGhpcy5mcmFnbWVudFRyYWNrZXI7IC8vIHdlIGp1c3QgZ290IGRvbmUgbG9hZGluZyB0aGUgZmluYWwgZnJhZ21lbnQgYW5kIHRoZXJlIGlzIG5vIG90aGVyIGJ1ZmZlcmVkIHJhbmdlIGFmdGVyIC4uLlxuICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGluIGNhc2UgdGhlcmUgYXJlIGFueSBidWZmZXJlZCByYW5nZXMgYWZ0ZXIsIGl0IG1lYW5zIHRoYXQgdGhlcmUgYXJlIHVuYnVmZmVyZWQgcG9ydGlvbiBpbiBiZXR3ZWVuXG4gICAgLy8gc28gd2Ugc2hvdWxkIG5vdCBzd2l0Y2ggdG8gRU5ERUQgaW4gdGhhdCBjYXNlLCB0byBiZSBhYmxlIHRvIGJ1ZmZlciB0aGVtXG5cbiAgICBpZiAoIWxldmVsRGV0YWlscy5saXZlICYmIGZyYWdDdXJyZW50ICYmIC8vIE5PVEU6IEJlY2F1c2Ugb2YgdGhlIHdheSBwYXJ0cyBhcmUgY3VycmVudGx5IHBhcnNlZC9yZXByZXNlbnRlZCBpbiB0aGUgcGxheWxpc3QsIHdlIGNhbiBlbmQgdXBcbiAgICAvLyBpbiBzaXR1YXRpb25zIHdoZXJlIHRoZSBjdXJyZW50IGZyYWdtZW50IGlzIGFjdHVhbGx5IGdyZWF0ZXIgdGhhbiBsZXZlbERldGFpbHMuZW5kU04uIFdoaWxlXG4gICAgLy8gdGhpcyBmZWVscyBsaWtlIHRoZSBcIndyb25nIHBsYWNlXCIgdG8gYWNjb3VudCBmb3IgdGhhdCwgdGhpcyBpcyBhIG5hcnJvd2VyL3NhZmVyIGNoYW5nZSB0aGFuXG4gICAgLy8gdXBkYXRpbmcgZS5nLiBNM1U4UGFyc2VyOjpwYXJzZUxldmVsUGxheWxpc3QoKS5cbiAgICBmcmFnQ3VycmVudC5zbiA+PSBsZXZlbERldGFpbHMuZW5kU04gJiYgIWJ1ZmZlckluZm8ubmV4dFN0YXJ0KSB7XG4gICAgICB2YXIgcGFydExpc3QgPSBsZXZlbERldGFpbHMucGFydExpc3Q7IC8vIFNpbmNlIHRoZSBsYXN0IHBhcnQgaXNuJ3QgZ3VhcmFudGVlZCB0byBjb3JyZXNwb25kIHRvIGZyYWdDdXJyZW50IGZvciBsbC1obHMsIGNoZWNrIGluc3RlYWQgaWYgdGhlIGxhc3QgcGFydCBpcyBidWZmZXJlZC5cblxuICAgICAgaWYgKHBhcnRMaXN0ICE9PSBudWxsICYmIHBhcnRMaXN0ICE9PSB2b2lkIDAgJiYgcGFydExpc3QubGVuZ3RoKSB7XG4gICAgICAgIHZhciBsYXN0UGFydCA9IHBhcnRMaXN0W3BhcnRMaXN0Lmxlbmd0aCAtIDFdOyAvLyBDaGVja2luZyB0aGUgbWlkcG9pbnQgb2YgdGhlIHBhcnQgZm9yIHBvdGVudGlhbCBtYXJnaW4gb2YgZXJyb3IgYW5kIHJlbGF0ZWQgaXNzdWVzLlxuICAgICAgICAvLyBOT1RFOiBUZWNobmljYWxseSBJIGJlbGlldmUgcGFydHMgY291bGQgeWllbGQgY29udGVudCB0aGF0IGlzIDwgdGhlIGNvbXB1dGVkIGR1cmF0aW9uIChpbmNsdWRpbmcgcG90ZW50aWFsIGEgZHVyYXRpb24gb2YgMClcbiAgICAgICAgLy8gYW5kIHN0aWxsIGJlIHNwZWMtY29tcGxpYW50LCBzbyB0aGVyZSBtYXkgc3RpbGwgYmUgZWRnZSBjYXNlcyBoZXJlLiBMaWtld2lzZSwgdGhlcmUgY291bGQgYmUgaXNzdWVzIGluIGVuZCBvZiBzdHJlYW1cbiAgICAgICAgLy8gcGFydCBtaXNtYXRjaGVzIGZvciBpbmRlcGVuZGVudCBhdWRpbyBhbmQgdmlkZW8gcGxheWxpc3RzL3NlZ21lbnRzLlxuXG4gICAgICAgIHZhciBsYXN0UGFydEJ1ZmZlcmVkID0gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkJ1ZmZlckhlbHBlclwiXS5pc0J1ZmZlcmVkKHRoaXMubWVkaWEsIGxhc3RQYXJ0LnN0YXJ0ICsgbGFzdFBhcnQuZHVyYXRpb24gLyAyKTtcbiAgICAgICAgcmV0dXJuIGxhc3RQYXJ0QnVmZmVyZWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBmcmFnU3RhdGUgPSBmcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZ0N1cnJlbnQpO1xuICAgICAgcmV0dXJuIGZyYWdTdGF0ZSA9PT0gX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkZyYWdtZW50U3RhdGVcIl0uUEFSVElBTCB8fCBmcmFnU3RhdGUgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJGcmFnbWVudFN0YXRlXCJdLk9LO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub25NZWRpYVNlZWtpbmcuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9udmVuZGVkID0gdGhpcy5vbk1lZGlhRW5kZWQuYmluZCh0aGlzKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgIGlmICh0aGlzLmxldmVscyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICB0aGlzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgaWYgKG1lZGlhICE9PSBudWxsICYmIG1lZGlhICE9PSB2b2lkIDAgJiYgbWVkaWEuZW5kZWQpIHtcbiAgICAgIHRoaXMubG9nKCdNU0UgZGV0YWNoaW5nIGFuZCB2aWRlbyBlbmRlZCwgcmVzZXQgc3RhcnRQb3NpdGlvbicpO1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH0gLy8gcmVtb3ZlIHZpZGVvIGxpc3RlbmVyc1xuXG5cbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhU2Vla2luZyA9IGZ1bmN0aW9uIG9uTWVkaWFTZWVraW5nKCkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50LFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIG1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlcixcbiAgICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiAwO1xuICAgIHZhciBidWZmZXJJbmZvID0gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkJ1ZmZlckhlbHBlclwiXS5idWZmZXJJbmZvKG1lZGlhQnVmZmVyIHx8IG1lZGlhLCBjdXJyZW50VGltZSwgY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgIHRoaXMubG9nKFwibWVkaWEgc2Vla2luZyB0byBcIiArIChPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGN1cnJlbnRUaW1lKSA/IGN1cnJlbnRUaW1lLnRvRml4ZWQoMykgOiBjdXJyZW50VGltZSkgKyBcIiwgc3RhdGU6IFwiICsgc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAoZnJhZ0N1cnJlbnQgJiYgIWJ1ZmZlckluZm8ubGVuKSB7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBhcmUgc2Vla2luZyB0byBhIHVuYnVmZmVyZWQgYXJlYSBBTkQgaWYgZnJhZyBsb2FkaW5nIGlzIGluIHByb2dyZXNzXG4gICAgICB2YXIgdG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICB2YXIgZnJhZ1N0YXJ0T2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgLSB0b2xlcmFuY2U7XG4gICAgICB2YXIgZnJhZ0VuZE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0ICsgZnJhZ0N1cnJlbnQuZHVyYXRpb24gKyB0b2xlcmFuY2U7XG4gICAgICB2YXIgcGFzdEZyYWdtZW50ID0gY3VycmVudFRpbWUgPiBmcmFnRW5kT2Zmc2V0OyAvLyBjaGVjayBpZiB0aGUgc2VlayBwb3NpdGlvbiBpcyBwYXN0IGN1cnJlbnQgZnJhZ21lbnQsIGFuZCBpZiBzbyBhYm9ydCBsb2FkaW5nXG5cbiAgICAgIGlmIChjdXJyZW50VGltZSA8IGZyYWdTdGFydE9mZnNldCB8fCBwYXN0RnJhZ21lbnQpIHtcbiAgICAgICAgaWYgKHBhc3RGcmFnbWVudCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICB0aGlzLmxvZygnc2Vla2luZyBvdXRzaWRlIG9mIGJ1ZmZlciB3aGlsZSBmcmFnbWVudCBsb2FkIGluIHByb2dyZXNzLCBjYW5jZWwgZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtZWRpYSkge1xuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9IC8vIGluIGNhc2Ugc2Vla2luZyBvY2N1cnMgYWx0aG91Z2ggbm8gbWVkaWEgYnVmZmVyZWQsIGFkanVzdCBzdGFydFBvc2l0aW9uIGFuZCBuZXh0TG9hZFBvc2l0aW9uIHRvIHNlZWsgdGFyZ2V0XG5cblxuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSAmJiAhYnVmZmVySW5mby5sZW4pIHtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IGN1cnJlbnRUaW1lO1xuICAgIH0gLy8gQXN5bmMgdGljayB0byBzcGVlZCB1cCBwcm9jZXNzaW5nXG5cblxuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhRW5kZWQgPSBmdW5jdGlvbiBvbk1lZGlhRW5kZWQoKSB7XG4gICAgLy8gcmVzZXQgc3RhcnRQb3NpdGlvbiBhbmQgbGFzdEN1cnJlbnRUaW1lIHRvIHJlc3RhcnQgcGxheWJhY2sgQCBzdHJlYW0gYmVnaW5uaW5nXG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICB9O1xuXG4gIF9wcm90by5vbktleUxvYWRlZCA9IGZ1bmN0aW9uIG9uS2V5TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLktFWV9MT0FESU5HIHx8IGRhdGEuZnJhZyAhPT0gdGhpcy5mcmFnQ3VycmVudCB8fCAhdGhpcy5sZXZlbHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB2YXIgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbHNbZGF0YS5mcmFnLmxldmVsXS5kZXRhaWxzO1xuXG4gICAgaWYgKGxldmVsRGV0YWlscykge1xuICAgICAgdGhpcy5sb2FkRnJhZ21lbnQoZGF0YS5mcmFnLCBsZXZlbERldGFpbHMsIGRhdGEuZnJhZy5zdGFydCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkhhbmRsZXJEZXN0cm95aW5nID0gZnVuY3Rpb24gb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG5cbiAgICBfVGFza0xvb3AucHJvdG90eXBlLm9uSGFuZGxlckRlc3Ryb3lpbmcuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ub25IYW5kbGVyRGVzdHJveWVkID0gZnVuY3Rpb24gb25IYW5kbGVyRGVzdHJveWVkKCkge1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIHRoaXMuaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJFdmVudHNcIl0uS0VZX0xPQURFRCwgdGhpcy5vbktleUxvYWRlZCwgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5mcmFnbWVudExvYWRlcikge1xuICAgICAgdGhpcy5mcmFnbWVudExvYWRlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGVjcnlwdGVyKSB7XG4gICAgICB0aGlzLmRlY3J5cHRlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5obHMgPSB0aGlzLmxvZyA9IHRoaXMud2FybiA9IHRoaXMuZGVjcnlwdGVyID0gdGhpcy5mcmFnbWVudExvYWRlciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyID0gbnVsbDtcblxuICAgIF9UYXNrTG9vcC5wcm90b3R5cGUub25IYW5kbGVyRGVzdHJveWVkLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRLZXkgPSBmdW5jdGlvbiBsb2FkS2V5KGZyYWcsIGRldGFpbHMpIHtcbiAgICB0aGlzLmxvZyhcIkxvYWRpbmcga2V5IGZvciBcIiArIGZyYWcuc24gKyBcIiBvZiBbXCIgKyBkZXRhaWxzLnN0YXJ0U04gKyBcIi1cIiArIGRldGFpbHMuZW5kU04gKyBcIl0sIFwiICsgKHRoaXMubG9nUHJlZml4ID09PSAnW3N0cmVhbS1jb250cm9sbGVyXScgPyAnbGV2ZWwnIDogJ3RyYWNrJykgKyBcIiBcIiArIGZyYWcubGV2ZWwpO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkV2ZW50c1wiXS5LRVlfTE9BRElORywge1xuICAgICAgZnJhZzogZnJhZ1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5sb2FkRnJhZ21lbnQgPSBmdW5jdGlvbiBsb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWxEZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgdGhpcy5fbG9hZEZyYWdGb3JQbGF5YmFjayhmcmFnLCBsZXZlbERldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICB9O1xuXG4gIF9wcm90by5fbG9hZEZyYWdGb3JQbGF5YmFjayA9IGZ1bmN0aW9uIF9sb2FkRnJhZ0ZvclBsYXliYWNrKGZyYWcsIGxldmVsRGV0YWlscywgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHByb2dyZXNzQ2FsbGJhY2sgPSBmdW5jdGlvbiBwcm9ncmVzc0NhbGxiYWNrKGRhdGEpIHtcbiAgICAgIGlmIChfdGhpczIuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAgIF90aGlzMi53YXJuKFwiRnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgKGRhdGEucGFydCA/ICcgcDogJyArIGRhdGEucGFydC5pbmRleCA6ICcnKSArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIHdhcyBkcm9wcGVkIGR1cmluZyBkb3dubG9hZC5cIik7XG5cbiAgICAgICAgX3RoaXMyLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZyYWcuc3RhdHMuY2h1bmtDb3VudCsrO1xuXG4gICAgICBfdGhpczIuX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpO1xuICAgIH07XG5cbiAgICB0aGlzLl9kb0ZyYWdMb2FkKGZyYWcsIGxldmVsRGV0YWlscywgdGFyZ2V0QnVmZmVyVGltZSwgcHJvZ3Jlc3NDYWxsYmFjaykudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIC8vIGlmIHdlJ3JlIGhlcmUgd2UgcHJvYmFibHkgbmVlZGVkIHRvIGJhY2t0cmFjayBvciBhcmUgd2FpdGluZyBmb3IgbW9yZSBwYXJ0c1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzMi5mcmFnTG9hZEVycm9yID0gMDtcbiAgICAgIHZhciBzdGF0ZSA9IF90aGlzMi5zdGF0ZTtcblxuICAgICAgaWYgKF90aGlzMi5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgaWYgKHN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgfHwgIV90aGlzMi5mcmFnQ3VycmVudCAmJiBzdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICAgIF90aGlzMi5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG5cbiAgICAgICAgICBfdGhpczIuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ3BheWxvYWQnIGluIGRhdGEpIHtcbiAgICAgICAgX3RoaXMyLmxvZyhcIkxvYWRlZCBmcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwpO1xuXG4gICAgICAgIF90aGlzMi5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJFdmVudHNcIl0uRlJBR19MT0FERUQsIGRhdGEpO1xuICAgICAgfSAvLyBQYXNzIHRocm91Z2ggdGhlIHdob2xlIHBheWxvYWQ7IGNvbnRyb2xsZXJzIG5vdCBpbXBsZW1lbnRpbmcgcHJvZ3Jlc3NpdmUgbG9hZGluZyByZWNlaXZlIGRhdGEgZnJvbSB0aGlzIGNhbGxiYWNrXG5cblxuICAgICAgX3RoaXMyLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShkYXRhKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBpZiAoX3RoaXMyLnN0YXRlID09PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMyLndhcm4ocmVhc29uKTtcblxuICAgICAgX3RoaXMyLnJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWcpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5mbHVzaE1haW5CdWZmZXIgPSBmdW5jdGlvbiBmbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdHlwZSkge1xuICAgIGlmICh0eXBlID09PSB2b2lkIDApIHtcbiAgICAgIHR5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghKHN0YXJ0T2Zmc2V0IC0gZW5kT2Zmc2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gV2hlbiBhbHRlcm5hdGUgYXVkaW8gaXMgcGxheWluZywgdGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgYXVkaW8gYnVmZmVyLiBPdGhlcndpc2UsXG4gICAgLy8gcGFzc2luZyBhIG51bGwgdHlwZSBmbHVzaGVzIGJvdGggYnVmZmVyc1xuXG5cbiAgICB2YXIgZmx1c2hTY29wZSA9IHtcbiAgICAgIHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgIGVuZE9mZnNldDogZW5kT2Zmc2V0LFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07IC8vIFJlc2V0IGxvYWQgZXJyb3JzIG9uIGZsdXNoXG5cbiAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSElORywgZmx1c2hTY29wZSk7XG4gIH07XG5cbiAgX3Byb3RvLl9sb2FkSW5pdFNlZ21lbnQgPSBmdW5jdGlvbiBfbG9hZEluaXRTZWdtZW50KGZyYWcpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHRoaXMuX2RvRnJhZ0xvYWQoZnJhZykudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYgKCFkYXRhIHx8IF90aGlzMy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykgfHwgIV90aGlzMy5sZXZlbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0IGxvYWQgYWJvcnRlZCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgaGxzID0gX3RoaXMzLmhscztcbiAgICAgIHZhciBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgICAgdmFyIGRlY3J5cHREYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTsgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSBwYXlsb2FkIG5lZWRzIHRvIGJlIGRlY3J5cHRlZFxuXG4gICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmJ5dGVMZW5ndGggPiAwICYmIGRlY3J5cHREYXRhICYmIGRlY3J5cHREYXRhLmtleSAmJiBkZWNyeXB0RGF0YS5pdiAmJiBkZWNyeXB0RGF0YS5tZXRob2QgPT09ICdBRVMtMTI4Jykge1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTsgLy8gZGVjcnlwdCB0aGUgc3VidGl0bGVzXG5cbiAgICAgICAgcmV0dXJuIF90aGlzMy5kZWNyeXB0ZXIud2ViQ3J5cHRvRGVjcnlwdChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgZGVjcnlwdERhdGEua2V5LmJ1ZmZlciwgZGVjcnlwdERhdGEuaXYuYnVmZmVyKS50aGVuKGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgICAgdmFyIGVuZFRpbWUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkV2ZW50c1wiXS5GUkFHX0RFQ1JZUFRFRCwge1xuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IGRlY3J5cHRlZERhdGEsXG4gICAgICAgICAgICBzdGF0czoge1xuICAgICAgICAgICAgICB0c3RhcnQ6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgdGRlY3J5cHQ6IGVuZFRpbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkYXRhLnBheWxvYWQgPSBkZWNyeXB0ZWREYXRhO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIGZyYWdDdXJyZW50ID0gX3RoaXMzLmZyYWdDdXJyZW50LFxuICAgICAgICAgIGhscyA9IF90aGlzMy5obHMsXG4gICAgICAgICAgbGV2ZWxzID0gX3RoaXMzLmxldmVscztcblxuICAgICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0IGxvYWQgYWJvcnRlZCwgbWlzc2luZyBsZXZlbHMnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRldGFpbHMgPSBsZXZlbHNbZnJhZy5sZXZlbF0uZGV0YWlscztcbiAgICAgIGNvbnNvbGUuYXNzZXJ0KGRldGFpbHMsICdMZXZlbCBkZXRhaWxzIGFyZSBkZWZpbmVkIHdoZW4gaW5pdCBzZWdtZW50IGlzIGxvYWRlZCcpO1xuICAgICAgdmFyIHN0YXRzID0gZnJhZy5zdGF0cztcbiAgICAgIF90aGlzMy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICBfdGhpczMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICBmcmFnLmRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLnBheWxvYWQpO1xuICAgICAgc3RhdHMucGFyc2luZy5zdGFydCA9IHN0YXRzLmJ1ZmZlcmluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBzdGF0cy5wYXJzaW5nLmVuZCA9IHN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpOyAvLyBTaWxlbmNlIEZSQUdfQlVGRkVSRUQgZXZlbnQgaWYgZnJhZ0N1cnJlbnQgaXMgbnVsbFxuXG4gICAgICBpZiAoZGF0YS5mcmFnID09PSBmcmFnQ3VycmVudCkge1xuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJFdmVudHNcIl0uRlJBR19CVUZGRVJFRCwge1xuICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICBmcmFnOiBmcmFnQ3VycmVudCxcbiAgICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICAgIGlkOiBmcmFnLnR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzMy50aWNrKCk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgX3RoaXMzLndhcm4ocmVhc29uKTtcblxuICAgICAgX3RoaXMzLnJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWcpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5mcmFnQ29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiBmcmFnQ29udGV4dENoYW5nZWQoZnJhZykge1xuICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgcmV0dXJuICFmcmFnIHx8ICFmcmFnQ3VycmVudCB8fCBmcmFnLmxldmVsICE9PSBmcmFnQ3VycmVudC5sZXZlbCB8fCBmcmFnLnNuICE9PSBmcmFnQ3VycmVudC5zbiB8fCBmcmFnLnVybElkICE9PSBmcmFnQ3VycmVudC51cmxJZDtcbiAgfTtcblxuICBfcHJvdG8uZnJhZ0J1ZmZlcmVkQ29tcGxldGUgPSBmdW5jdGlvbiBmcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnLCBwYXJ0KSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgIHRoaXMubG9nKFwiQnVmZmVyZWQgXCIgKyBmcmFnLnR5cGUgKyBcIiBzbjogXCIgKyBmcmFnLnNuICsgKHBhcnQgPyAnIHBhcnQ6ICcgKyBwYXJ0LmluZGV4IDogJycpICsgXCIgb2YgXCIgKyAodGhpcy5sb2dQcmVmaXggPT09ICdbc3RyZWFtLWNvbnRyb2xsZXJdJyA/ICdsZXZlbCcgOiAndHJhY2snKSArIFwiIFwiICsgZnJhZy5sZXZlbCArIFwiIFwiICsgX3V0aWxzX3RpbWVfcmFuZ2VzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fW1wiZGVmYXVsdFwiXS50b1N0cmluZyhfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiQnVmZmVySGVscGVyXCJdLmdldEJ1ZmZlcmVkKG1lZGlhKSkpO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIHRoaXMudGljaygpO1xuICB9O1xuXG4gIF9wcm90by5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUgPSBmdW5jdGlvbiBfaGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZnJhZ0xvYWRlZEVuZERhdGEpIHtcbiAgICB2YXIgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcblxuICAgIGlmICghdHJhbnNtdXhlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcmFnID0gZnJhZ0xvYWRlZEVuZERhdGEuZnJhZyxcbiAgICAgICAgcGFydCA9IGZyYWdMb2FkZWRFbmREYXRhLnBhcnQsXG4gICAgICAgIHBhcnRzTG9hZGVkID0gZnJhZ0xvYWRlZEVuZERhdGEucGFydHNMb2FkZWQ7IC8vIElmIHdlIGRpZCBub3QgbG9hZCBwYXJ0cywgb3IgbG9hZGVkIGFsbCBwYXJ0cywgd2UgaGF2ZSBjb21wbGV0ZSAobm90IHBhcnRpYWwpIGZyYWdtZW50IGRhdGFcblxuICAgIHZhciBjb21wbGV0ZSA9ICFwYXJ0c0xvYWRlZCB8fCBwYXJ0c0xvYWRlZC5sZW5ndGggPT09IDAgfHwgcGFydHNMb2FkZWQuc29tZShmdW5jdGlvbiAoZnJhZ0xvYWRlZCkge1xuICAgICAgcmV0dXJuICFmcmFnTG9hZGVkO1xuICAgIH0pO1xuICAgIHZhciBjaHVua01ldGEgPSBuZXcgX3R5cGVzX3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIkNodW5rTWV0YWRhdGFcIl0oZnJhZy5sZXZlbCwgZnJhZy5zbiwgZnJhZy5zdGF0cy5jaHVua0NvdW50ICsgMSwgMCwgcGFydCA/IHBhcnQuaW5kZXggOiAtMSwgIWNvbXBsZXRlKTtcbiAgICB0cmFuc211eGVyLmZsdXNoKGNodW5rTWV0YSk7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICA7XG5cbiAgX3Byb3RvLl9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uIF9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhmcmFnKSB7fTtcblxuICBfcHJvdG8uX2RvRnJhZ0xvYWQgPSBmdW5jdGlvbiBfZG9GcmFnTG9hZChmcmFnLCBkZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBpZiAodGFyZ2V0QnVmZmVyVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICB0YXJnZXRCdWZmZXJUaW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubGV2ZWxzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZyYWcgbG9hZCBhYm9ydGVkLCBtaXNzaW5nIGxldmVscycpO1xuICAgIH1cblxuICAgIHRhcmdldEJ1ZmZlclRpbWUgPSBNYXRoLm1heChmcmFnLnN0YXJ0LCB0YXJnZXRCdWZmZXJUaW1lIHx8IDApO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmIGRldGFpbHMpIHtcbiAgICAgIHZhciBwYXJ0TGlzdCA9IGRldGFpbHMucGFydExpc3Q7XG5cbiAgICAgIGlmIChwYXJ0TGlzdCAmJiBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0YXJnZXRCdWZmZXJUaW1lID4gZnJhZy5lbmQgJiYgZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICAgICAgICBmcmFnID0gZGV0YWlscy5mcmFnbWVudEhpbnQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFydEluZGV4ID0gdGhpcy5nZXROZXh0UGFydChwYXJ0TGlzdCwgZnJhZywgdGFyZ2V0QnVmZmVyVGltZSk7XG5cbiAgICAgICAgaWYgKHBhcnRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0TGlzdFtwYXJ0SW5kZXhdO1xuICAgICAgICAgIHRoaXMubG9nKFwiTG9hZGluZyBwYXJ0IHNuOiBcIiArIGZyYWcuc24gKyBcIiBwOiBcIiArIHBhcnQuaW5kZXggKyBcIiBjYzogXCIgKyBmcmFnLmNjICsgXCIgb2YgcGxheWxpc3QgW1wiICsgZGV0YWlscy5zdGFydFNOICsgXCItXCIgKyBkZXRhaWxzLmVuZFNOICsgXCJdIHBhcnRzIFswLVwiICsgcGFydEluZGV4ICsgXCItXCIgKyAocGFydExpc3QubGVuZ3RoIC0gMSkgKyBcIl0gXCIgKyAodGhpcy5sb2dQcmVmaXggPT09ICdbc3RyZWFtLWNvbnRyb2xsZXJdJyA/ICdsZXZlbCcgOiAndHJhY2snKSArIFwiOiBcIiArIGZyYWcubGV2ZWwgKyBcIiwgdGFyZ2V0OiBcIiArIHBhcnNlRmxvYXQodGFyZ2V0QnVmZmVyVGltZS50b0ZpeGVkKDMpKSk7XG4gICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gcGFydC5zdGFydCArIHBhcnQuZHVyYXRpb247XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURJTkcsIHtcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICBwYXJ0OiBwYXJ0TGlzdFtwYXJ0SW5kZXhdLFxuICAgICAgICAgICAgdGFyZ2V0QnVmZmVyVGltZTogdGFyZ2V0QnVmZmVyVGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRvRnJhZ1BhcnRzTG9hZChmcmFnLCBwYXJ0TGlzdCwgcGFydEluZGV4LCBwcm9ncmVzc0NhbGxiYWNrKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczQuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWZyYWcudXJsIHx8IHRoaXMubG9hZGVkRW5kT2ZQYXJ0cyhwYXJ0TGlzdCwgdGFyZ2V0QnVmZmVyVGltZSkpIHtcbiAgICAgICAgICAvLyBGcmFnbWVudCBoaW50IGhhcyBubyBwYXJ0c1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxvZyhcIkxvYWRpbmcgZnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgY2M6IFwiICsgZnJhZy5jYyArIFwiIFwiICsgKGRldGFpbHMgPyAnb2YgWycgKyBkZXRhaWxzLnN0YXJ0U04gKyAnLScgKyBkZXRhaWxzLmVuZFNOICsgJ10gJyA6ICcnKSArICh0aGlzLmxvZ1ByZWZpeCA9PT0gJ1tzdHJlYW0tY29udHJvbGxlcl0nID8gJ2xldmVsJyA6ICd0cmFjaycpICsgXCI6IFwiICsgZnJhZy5sZXZlbCArIFwiLCB0YXJnZXQ6IFwiICsgcGFyc2VGbG9hdCh0YXJnZXRCdWZmZXJUaW1lLnRvRml4ZWQoMykpKTsgLy8gRG9uJ3QgdXBkYXRlIG5leHRMb2FkUG9zaXRpb24gZm9yIGZyYWdtZW50cyB3aGljaCBhcmUgbm90IGJ1ZmZlcmVkXG5cbiAgICBpZiAoT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShmcmFnLnNuKSAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURJTkcsIHtcbiAgICAgIGZyYWc6IGZyYWcsXG4gICAgICB0YXJnZXRCdWZmZXJUaW1lOiB0YXJnZXRCdWZmZXJUaW1lXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRMb2FkZXIubG9hZChmcmFnLCBwcm9ncmVzc0NhbGxiYWNrKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBfdGhpczQuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcik7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmRvRnJhZ1BhcnRzTG9hZCA9IGZ1bmN0aW9uIGRvRnJhZ1BhcnRzTG9hZChmcmFnLCBwYXJ0TGlzdCwgcGFydEluZGV4LCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHBhcnRzTG9hZGVkID0gW107XG5cbiAgICAgIHZhciBsb2FkUGFydEluZGV4ID0gZnVuY3Rpb24gbG9hZFBhcnRJbmRleChpbmRleCkge1xuICAgICAgICB2YXIgcGFydCA9IHBhcnRMaXN0W2luZGV4XTtcblxuICAgICAgICBfdGhpczUuZnJhZ21lbnRMb2FkZXIubG9hZFBhcnQoZnJhZywgcGFydCwgcHJvZ3Jlc3NDYWxsYmFjaykudGhlbihmdW5jdGlvbiAocGFydExvYWRlZERhdGEpIHtcbiAgICAgICAgICBwYXJ0c0xvYWRlZFtwYXJ0LmluZGV4XSA9IHBhcnRMb2FkZWREYXRhO1xuICAgICAgICAgIHZhciBsb2FkZWRQYXJ0ID0gcGFydExvYWRlZERhdGEucGFydDtcblxuICAgICAgICAgIF90aGlzNS5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJFdmVudHNcIl0uRlJBR19MT0FERUQsIHBhcnRMb2FkZWREYXRhKTtcblxuICAgICAgICAgIHZhciBuZXh0UGFydCA9IHBhcnRMaXN0W2luZGV4ICsgMV07XG5cbiAgICAgICAgICBpZiAobmV4dFBhcnQgJiYgbmV4dFBhcnQuZnJhZ21lbnQgPT09IGZyYWcpIHtcbiAgICAgICAgICAgIGxvYWRQYXJ0SW5kZXgoaW5kZXggKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoe1xuICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0OiBsb2FkZWRQYXJ0LFxuICAgICAgICAgICAgICBwYXJ0c0xvYWRlZDogcGFydHNMb2FkZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgIH07XG5cbiAgICAgIGxvYWRQYXJ0SW5kZXgocGFydEluZGV4KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlRnJhZ0xvYWRFcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUZyYWdMb2FkRXJyb3IoX3JlZikge1xuICAgIHZhciBkYXRhID0gX3JlZi5kYXRhO1xuXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5kZXRhaWxzID09PSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJFcnJvckRldGFpbHNcIl0uSU5URVJOQUxfQUJPUlRFRCkge1xuICAgICAgdGhpcy5oYW5kbGVGcmFnTG9hZEFib3J0ZWQoZGF0YS5mcmFnLCBkYXRhLnBhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkV2ZW50c1wiXS5FUlJPUiwgZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLl9oYW5kbGVUcmFuc211eGVyRmx1c2ggPSBmdW5jdGlvbiBfaGFuZGxlVHJhbnNtdXhlckZsdXNoKGNodW5rTWV0YSkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpO1xuXG4gICAgaWYgKCFjb250ZXh0IHx8IHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIGlmICghdGhpcy5mcmFnQ3VycmVudCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnLFxuICAgICAgICBwYXJ0ID0gY29udGV4dC5wYXJ0LFxuICAgICAgICBsZXZlbCA9IGNvbnRleHQubGV2ZWw7XG4gICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgZnJhZy5zdGF0cy5wYXJzaW5nLmVuZCA9IG5vdztcblxuICAgIGlmIChwYXJ0KSB7XG4gICAgICBwYXJ0LnN0YXRzLnBhcnNpbmcuZW5kID0gbm93O1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlTGV2ZWxUaW1pbmcoZnJhZywgcGFydCwgbGV2ZWwsIGNodW5rTWV0YS5wYXJ0aWFsKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0Q3VycmVudENvbnRleHQgPSBmdW5jdGlvbiBnZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpIHtcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgdmFyIGxldmVsSW5kZXggPSBjaHVua01ldGEubGV2ZWwsXG4gICAgICAgIHNuID0gY2h1bmtNZXRhLnNuLFxuICAgICAgICBwYXJ0SW5kZXggPSBjaHVua01ldGEucGFydDtcblxuICAgIGlmICghbGV2ZWxzIHx8ICFsZXZlbHNbbGV2ZWxJbmRleF0pIHtcbiAgICAgIHRoaXMud2FybihcIkxldmVscyBvYmplY3Qgd2FzIHVuc2V0IHdoaWxlIGJ1ZmZlcmluZyBmcmFnbWVudCBcIiArIHNuICsgXCIgb2YgbGV2ZWwgXCIgKyBsZXZlbEluZGV4ICsgXCIuIFRoZSBjdXJyZW50IGNodW5rIHdpbGwgbm90IGJlIGJ1ZmZlcmVkLlwiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBsZXZlbCA9IGxldmVsc1tsZXZlbEluZGV4XTtcbiAgICB2YXIgcGFydCA9IHBhcnRJbmRleCA+IC0xID8gT2JqZWN0KF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXCJnZXRQYXJ0V2l0aFwiXSkobGV2ZWwsIHNuLCBwYXJ0SW5kZXgpIDogbnVsbDtcbiAgICB2YXIgZnJhZyA9IHBhcnQgPyBwYXJ0LmZyYWdtZW50IDogT2JqZWN0KF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXCJnZXRGcmFnbWVudFdpdGhTTlwiXSkobGV2ZWwsIHNuLCB0aGlzLmZyYWdDdXJyZW50KTtcblxuICAgIGlmICghZnJhZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZyYWc6IGZyYWcsXG4gICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgbGV2ZWw6IGxldmVsXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uYnVmZmVyRnJhZ21lbnREYXRhID0gZnVuY3Rpb24gYnVmZmVyRnJhZ21lbnREYXRhKGRhdGEsIGZyYWcsIHBhcnQsIGNodW5rTWV0YSkge1xuICAgIGlmICghZGF0YSB8fCB0aGlzLnN0YXRlICE9PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRhdGExID0gZGF0YS5kYXRhMSxcbiAgICAgICAgZGF0YTIgPSBkYXRhLmRhdGEyO1xuICAgIHZhciBidWZmZXIgPSBkYXRhMTtcblxuICAgIGlmIChkYXRhMSAmJiBkYXRhMikge1xuICAgICAgLy8gQ29tYmluZSB0aGUgbW9vZiArIG1kYXQgc28gdGhhdCB3ZSBidWZmZXIgd2l0aCBhIHNpbmdsZSBhcHBlbmRcbiAgICAgIGJ1ZmZlciA9IE9iamVjdChfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJhcHBlbmRVaW50OEFycmF5XCJdKShkYXRhMSwgZGF0YTIpO1xuICAgIH1cblxuICAgIGlmICghYnVmZmVyIHx8ICFidWZmZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlZ21lbnQgPSB7XG4gICAgICB0eXBlOiBkYXRhLnR5cGUsXG4gICAgICBmcmFnOiBmcmFnLFxuICAgICAgcGFydDogcGFydCxcbiAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhLFxuICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICBkYXRhOiBidWZmZXJcbiAgICB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9BUFBFTkRJTkcsIHNlZ21lbnQpO1xuXG4gICAgaWYgKGRhdGEuZHJvcHBlZCAmJiBkYXRhLmluZGVwZW5kZW50ICYmICFwYXJ0KSB7XG4gICAgICAvLyBDbGVhciBidWZmZXIgc28gdGhhdCB3ZSByZWxvYWQgcHJldmlvdXMgc2VnbWVudHMgc2VxdWVudGlhbGx5IGlmIHJlcXVpcmVkXG4gICAgICB0aGlzLmZsdXNoQnVmZmVyR2FwKGZyYWcpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZmx1c2hCdWZmZXJHYXAgPSBmdW5jdGlvbiBmbHVzaEJ1ZmZlckdhcChmcmFnKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcblxuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIGN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgY2xlYXIgdGhlIGJhY2sgYnVmZmVyIHNvIHRoYXQgd2UgY2FuIGJhY2t0cmFjayBhcyBtdWNoIGFzIG5lZWRlZFxuXG5cbiAgICBpZiAoIV91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJCdWZmZXJIZWxwZXJcIl0uaXNCdWZmZXJlZChtZWRpYSwgbWVkaWEuY3VycmVudFRpbWUpKSB7XG4gICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBmcmFnLnN0YXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFJlbW92ZSBiYWNrLWJ1ZmZlciB3aXRob3V0IGludGVycnVwdGluZyBwbGF5YmFjayB0byBhbGxvdyBiYWNrIHRyYWNraW5nXG5cblxuICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIHZhciBidWZmZXJJbmZvID0gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkJ1ZmZlckhlbHBlclwiXS5idWZmZXJJbmZvKG1lZGlhLCBjdXJyZW50VGltZSwgMCk7XG4gICAgdmFyIGZyYWdEdXJhdGlvbiA9IGZyYWcuZHVyYXRpb247XG4gICAgdmFyIHNlZ21lbnRGcmFjdGlvbiA9IE1hdGgubWluKHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UgKiAyLCBmcmFnRHVyYXRpb24gKiAwLjI1KTtcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChNYXRoLm1pbihmcmFnLnN0YXJ0IC0gc2VnbWVudEZyYWN0aW9uLCBidWZmZXJJbmZvLmVuZCAtIHNlZ21lbnRGcmFjdGlvbiksIGN1cnJlbnRUaW1lICsgc2VnbWVudEZyYWN0aW9uKTtcblxuICAgIGlmIChmcmFnLnN0YXJ0IC0gc3RhcnQgPiBzZWdtZW50RnJhY3Rpb24pIHtcbiAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKHN0YXJ0LCBmcmFnLnN0YXJ0KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldEZ3ZEJ1ZmZlckluZm8gPSBmdW5jdGlvbiBnZXRGd2RCdWZmZXJJbmZvKGJ1ZmZlcmFibGUsIHR5cGUpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgdmFyIHBvcyA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG5cbiAgICBpZiAoIU9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkocG9zKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlckluZm8gPSBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiQnVmZmVySGVscGVyXCJdLmJ1ZmZlckluZm8oYnVmZmVyYWJsZSwgcG9zLCBjb25maWcubWF4QnVmZmVySG9sZSk7IC8vIFdvcmthcm91bmQgZmxhdyBpbiBnZXR0aW5nIGZvcndhcmQgYnVmZmVyIHdoZW4gbWF4QnVmZmVySG9sZSBpcyBzbWFsbGVyIHRoYW4gZ2FwIGF0IGN1cnJlbnQgcG9zXG5cbiAgICBpZiAoYnVmZmVySW5mby5sZW4gPT09IDAgJiYgYnVmZmVySW5mby5uZXh0U3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGJ1ZmZlcmVkRnJhZ0F0UG9zID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QnVmZmVyZWRGcmFnKHBvcywgdHlwZSk7XG5cbiAgICAgIGlmIChidWZmZXJlZEZyYWdBdFBvcyAmJiBidWZmZXJJbmZvLm5leHRTdGFydCA8IGJ1ZmZlcmVkRnJhZ0F0UG9zLmVuZCkge1xuICAgICAgICByZXR1cm4gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkJ1ZmZlckhlbHBlclwiXS5idWZmZXJJbmZvKGJ1ZmZlcmFibGUsIHBvcywgTWF0aC5tYXgoYnVmZmVySW5mby5uZXh0U3RhcnQsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlckluZm87XG4gIH07XG5cbiAgX3Byb3RvLmdldE1heEJ1ZmZlckxlbmd0aCA9IGZ1bmN0aW9uIGdldE1heEJ1ZmZlckxlbmd0aChsZXZlbEJpdHJhdGUpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgdmFyIG1heEJ1ZkxlbjtcblxuICAgIGlmIChsZXZlbEJpdHJhdGUpIHtcbiAgICAgIG1heEJ1ZkxlbiA9IE1hdGgubWF4KDggKiBjb25maWcubWF4QnVmZmVyU2l6ZSAvIGxldmVsQml0cmF0ZSwgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heEJ1ZkxlbiA9IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgubWluKG1heEJ1ZkxlbiwgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCk7XG4gIH07XG5cbiAgX3Byb3RvLnJlZHVjZU1heEJ1ZmZlckxlbmd0aCA9IGZ1bmN0aW9uIHJlZHVjZU1heEJ1ZmZlckxlbmd0aCh0aHJlc2hvbGQpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgdmFyIG1pbkxlbmd0aCA9IHRocmVzaG9sZCB8fCBjb25maWcubWF4QnVmZmVyTGVuZ3RoO1xuXG4gICAgaWYgKGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggPj0gbWluTGVuZ3RoKSB7XG4gICAgICAvLyByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggYXMgaXQgbWlnaHQgYmUgdG9vIGhpZ2guIHdlIGRvIHRoaXMgdG8gYXZvaWQgbG9vcCBmbHVzaGluZyAuLi5cbiAgICAgIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggLz0gMjtcbiAgICAgIHRoaXMud2FybihcIlJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCB0byBcIiArIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggKyBcInNcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmdldE5leHRGcmFnbWVudCA9IGZ1bmN0aW9uIGdldE5leHRGcmFnbWVudChwb3MsIGxldmVsRGV0YWlscykge1xuICAgIHZhciBfZnJhZywgX2ZyYWcyO1xuXG4gICAgdmFyIGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHM7XG4gICAgdmFyIGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuXG4gICAgaWYgKCFmcmFnTGVuKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIGZpbmQgZnJhZ21lbnQgaW5kZXgsIGNvbnRpZ3VvdXMgd2l0aCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG5cblxuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICB2YXIgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgdmFyIGZyYWc7XG5cbiAgICBpZiAobGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgIHZhciBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSA9IGNvbmZpZy5pbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTtcblxuICAgICAgaWYgKGZyYWdMZW4gPCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSkge1xuICAgICAgICB0aGlzLndhcm4oXCJOb3QgZW5vdWdoIGZyYWdtZW50cyB0byBzdGFydCBwbGF5YmFjayAoaGF2ZTogXCIgKyBmcmFnTGVuICsgXCIsIG5lZWQ6IFwiICsgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUgKyBcIilcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSAvLyBUaGUgcmVhbCBmcmFnbWVudCBzdGFydCB0aW1lcyBmb3IgYSBsaXZlIHN0cmVhbSBhcmUgb25seSBrbm93biBhZnRlciB0aGUgUFRTIHJhbmdlIGZvciB0aGF0IGxldmVsIGlzIGtub3duLlxuICAgICAgLy8gSW4gb3JkZXIgdG8gZGlzY292ZXIgdGhlIHJhbmdlLCB3ZSBsb2FkIHRoZSBiZXN0IG1hdGNoaW5nIGZyYWdtZW50IGZvciB0aGF0IGxldmVsIGFuZCBkZW11eCBpdC5cbiAgICAgIC8vIERvIG5vdCBsb2FkIHVzaW5nIGxpdmUgbG9naWMgaWYgdGhlIHN0YXJ0aW5nIGZyYWcgaXMgcmVxdWVzdGVkIC0gd2Ugd2FudCB0byB1c2UgZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKCkgc28gdGhhdFxuICAgICAgLy8gd2UgZ2V0IHRoZSBmcmFnbWVudCBtYXRjaGluZyB0aGF0IHN0YXJ0IHRpbWVcblxuXG4gICAgICBpZiAoIWxldmVsRGV0YWlscy5QVFNLbm93biAmJiAhdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgdGhpcy5zdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICBmcmFnID0gdGhpcy5nZXRJbml0aWFsTGl2ZUZyYWdtZW50KGxldmVsRGV0YWlscywgZnJhZ21lbnRzKTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gZnJhZyA/IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb24gfHwgZnJhZy5zdGFydCA6IHBvcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvcyA8PSBzdGFydCkge1xuICAgICAgLy8gVm9EIHBsYXlsaXN0OiBpZiBsb2FkUG9zaXRpb24gYmVmb3JlIHN0YXJ0IG9mIHBsYXlsaXN0LCBsb2FkIGZpcnN0IGZyYWdtZW50XG4gICAgICBmcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgIH0gLy8gSWYgd2UgaGF2ZW4ndCBydW4gaW50byBhbnkgc3BlY2lhbCBjYXNlcyBhbHJlYWR5LCBqdXN0IGxvYWQgdGhlIGZyYWdtZW50IG1vc3QgY2xvc2VseSBtYXRjaGluZyB0aGUgcmVxdWVzdGVkIHBvc2l0aW9uXG5cblxuICAgIGlmICghZnJhZykge1xuICAgICAgdmFyIGVuZCA9IGNvbmZpZy5sb3dMYXRlbmN5TW9kZSA/IGxldmVsRGV0YWlscy5wYXJ0RW5kIDogbGV2ZWxEZXRhaWxzLmZyYWdtZW50RW5kO1xuICAgICAgZnJhZyA9IHRoaXMuZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKHBvcywgZW5kLCBsZXZlbERldGFpbHMpO1xuICAgIH0gLy8gSWYgYW4gaW5pdFNlZ21lbnQgaXMgcHJlc2VudCwgaXQgbXVzdCBiZSBidWZmZXJlZCBmaXJzdFxuXG5cbiAgICBpZiAoKF9mcmFnID0gZnJhZykgIT09IG51bGwgJiYgX2ZyYWcgIT09IHZvaWQgMCAmJiBfZnJhZy5pbml0U2VnbWVudCAmJiAhKChfZnJhZzIgPSBmcmFnKSAhPT0gbnVsbCAmJiBfZnJhZzIgIT09IHZvaWQgMCAmJiBfZnJhZzIuaW5pdFNlZ21lbnQuZGF0YSkgJiYgIXRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgIGZyYWcgPSBmcmFnLmluaXRTZWdtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmcmFnO1xuICB9O1xuXG4gIF9wcm90by5nZXROZXh0UGFydCA9IGZ1bmN0aW9uIGdldE5leHRQYXJ0KHBhcnRMaXN0LCBmcmFnLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgdmFyIG5leHRQYXJ0ID0gLTE7XG4gICAgdmFyIGNvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICB2YXIgaW5kZXBlbmRlbnRBdHRyT21pdHRlZCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydExpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0ID0gcGFydExpc3RbaV07XG4gICAgICBpbmRlcGVuZGVudEF0dHJPbWl0dGVkID0gaW5kZXBlbmRlbnRBdHRyT21pdHRlZCAmJiAhcGFydC5pbmRlcGVuZGVudDtcblxuICAgICAgaWYgKG5leHRQYXJ0ID4gLTEgJiYgdGFyZ2V0QnVmZmVyVGltZSA8IHBhcnQuc3RhcnQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBsb2FkZWQgPSBwYXJ0LmxvYWRlZDtcblxuICAgICAgaWYgKCFsb2FkZWQgJiYgKGNvbnRpZ3VvdXMgfHwgcGFydC5pbmRlcGVuZGVudCB8fCBpbmRlcGVuZGVudEF0dHJPbWl0dGVkKSAmJiBwYXJ0LmZyYWdtZW50ID09PSBmcmFnKSB7XG4gICAgICAgIG5leHRQYXJ0ID0gaTtcbiAgICAgIH1cblxuICAgICAgY29udGlndW91cyA9IGxvYWRlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFBhcnQ7XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRlZEVuZE9mUGFydHMgPSBmdW5jdGlvbiBsb2FkZWRFbmRPZlBhcnRzKHBhcnRMaXN0LCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgdmFyIGxhc3RQYXJ0ID0gcGFydExpc3RbcGFydExpc3QubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGxhc3RQYXJ0ICYmIHRhcmdldEJ1ZmZlclRpbWUgPiBsYXN0UGFydC5zdGFydCAmJiBsYXN0UGFydC5sb2FkZWQ7XG4gIH1cbiAgLypcbiAgIFRoaXMgbWV0aG9kIGlzIHVzZWQgZmluZCB0aGUgYmVzdCBtYXRjaGluZyBmaXJzdCBmcmFnbWVudCBmb3IgYSBsaXZlIHBsYXlsaXN0LiBUaGlzIGZyYWdtZW50IGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZVxuICAgXCJzbGlkaW5nXCIgb2YgdGhlIHBsYXlsaXN0LCB3aGljaCBpcyBpdHMgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHBsYXliYWNrLiBBZnRlciBzbGlkaW5nIHdlIGNhbiBjb21wdXRlIHRoZSByZWFsXG4gICBzdGFydCBhbmQgZW5kIHRpbWVzIGZvciBlYWNoIGZyYWdtZW50IGluIHRoZSBwbGF5bGlzdCAoYWZ0ZXIgd2hpY2ggdGhpcyBtZXRob2Qgd2lsbCBub3QgbmVlZCB0byBiZSBjYWxsZWQpLlxuICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldEluaXRpYWxMaXZlRnJhZ21lbnQgPSBmdW5jdGlvbiBnZXRJbml0aWFsTGl2ZUZyYWdtZW50KGxldmVsRGV0YWlscywgZnJhZ21lbnRzKSB7XG4gICAgdmFyIGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgIHZhciBmcmFnID0gbnVsbDtcblxuICAgIGlmIChmcmFnUHJldmlvdXMpIHtcbiAgICAgIGlmIChsZXZlbERldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgIC8vIFByZWZlciB1c2luZyBQRFQsIGJlY2F1c2UgaXQgY2FuIGJlIGFjY3VyYXRlIGVub3VnaCB0byBjaG9vc2UgdGhlIGNvcnJlY3QgZnJhZ21lbnQgd2l0aG91dCBrbm93aW5nIHRoZSBsZXZlbCBzbGlkaW5nXG4gICAgICAgIHRoaXMubG9nKFwiTGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIFBEVDogXCIgKyBmcmFnUHJldmlvdXMucHJvZ3JhbURhdGVUaW1lKTtcbiAgICAgICAgZnJhZyA9IE9iamVjdChfZnJhZ21lbnRfZmluZGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcImZpbmRGcmFnbWVudEJ5UERUXCJdKShmcmFnbWVudHMsIGZyYWdQcmV2aW91cy5lbmRQcm9ncmFtRGF0ZVRpbWUsIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgLy8gU04gZG9lcyBub3QgbmVlZCB0byBiZSBhY2N1cmF0ZSBiZXR3ZWVuIHJlbmRpdGlvbnMsIGJ1dCBkZXBlbmRpbmcgb24gdGhlIHBhY2thZ2luZyBpdCBtYXkgYmUgc28uXG4gICAgICAgIHZhciB0YXJnZXRTTiA9IGZyYWdQcmV2aW91cy5zbiArIDE7XG5cbiAgICAgICAgaWYgKHRhcmdldFNOID49IGxldmVsRGV0YWlscy5zdGFydFNOICYmIHRhcmdldFNOIDw9IGxldmVsRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgIHZhciBmcmFnTmV4dCA9IGZyYWdtZW50c1t0YXJnZXRTTiAtIGxldmVsRGV0YWlscy5zdGFydFNOXTsgLy8gRW5zdXJlIHRoYXQgd2UncmUgc3RheWluZyB3aXRoaW4gdGhlIGNvbnRpbnVpdHkgcmFuZ2UsIHNpbmNlIFBUUyByZXNldHMgdXBvbiBhIG5ldyByYW5nZVxuXG4gICAgICAgICAgaWYgKGZyYWdQcmV2aW91cy5jYyA9PT0gZnJhZ05leHQuY2MpIHtcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnTmV4dDtcbiAgICAgICAgICAgIHRoaXMubG9nKFwiTGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBuZXh0IFNOOiBcIiArIGZyYWcuc24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJdCdzIGltcG9ydGFudCB0byBzdGF5IHdpdGhpbiB0aGUgY29udGludWl0eSByYW5nZSBpZiBhdmFpbGFibGU7IG90aGVyd2lzZSB0aGUgZnJhZ21lbnRzIGluIHRoZSBwbGF5bGlzdFxuICAgICAgICAvLyB3aWxsIGhhdmUgdGhlIHdyb25nIHN0YXJ0IHRpbWVzXG5cblxuICAgICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgICBmcmFnID0gT2JqZWN0KF9mcmFnbWVudF9maW5kZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1wiZmluZEZyYWdXaXRoQ0NcIl0pKGZyYWdtZW50cywgZnJhZ1ByZXZpb3VzLmNjKTtcblxuICAgICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcIkxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggc2FtZSBDQzogXCIgKyBmcmFnLnNuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmluZCBhIG5ldyBzdGFydCBmcmFnbWVudCB3aGVuIGZyYWdQcmV2aW91cyBpcyBudWxsXG4gICAgICB2YXIgbGl2ZVN0YXJ0ID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbjtcblxuICAgICAgaWYgKGxpdmVTdGFydCAhPT0gbnVsbCkge1xuICAgICAgICBmcmFnID0gdGhpcy5nZXRGcmFnbWVudEF0UG9zaXRpb24obGl2ZVN0YXJ0LCB0aGlzLmJpdHJhdGVUZXN0ID8gbGV2ZWxEZXRhaWxzLmZyYWdtZW50RW5kIDogbGV2ZWxEZXRhaWxzLmVkZ2UsIGxldmVsRGV0YWlscyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cbiAgLypcbiAgVGhpcyBtZXRob2QgZmluZHMgdGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnQgZ2l2ZW4gdGhlIHByb3ZpZGVkIHBvc2l0aW9uLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRGcmFnbWVudEF0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRGcmFnbWVudEF0UG9zaXRpb24oYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlscykge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXM7XG4gICAgdmFyIGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHMsXG4gICAgICAgIGVuZFNOID0gbGV2ZWxEZXRhaWxzLmVuZFNOO1xuICAgIHZhciBmcmFnbWVudEhpbnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRIaW50O1xuICAgIHZhciB0b2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICB2YXIgbG9hZGluZ1BhcnRzID0gISEoY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmIGxldmVsRGV0YWlscy5wYXJ0TGlzdCAmJiBmcmFnbWVudEhpbnQpO1xuXG4gICAgaWYgKGxvYWRpbmdQYXJ0cyAmJiBmcmFnbWVudEhpbnQgJiYgIXRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgIC8vIEluY2x1ZGUgaW5jb21wbGV0ZSBmcmFnbWVudCB3aXRoIHBhcnRzIGF0IGVuZFxuICAgICAgZnJhZ21lbnRzID0gZnJhZ21lbnRzLmNvbmNhdChmcmFnbWVudEhpbnQpO1xuICAgICAgZW5kU04gPSBmcmFnbWVudEhpbnQuc247XG4gICAgfVxuXG4gICAgdmFyIGZyYWc7XG5cbiAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XG4gICAgICB2YXIgbG9va3VwVG9sZXJhbmNlID0gYnVmZmVyRW5kID4gZW5kIC0gdG9sZXJhbmNlID8gMCA6IHRvbGVyYW5jZTsgLy8gUmVtb3ZlIHRoZSB0b2xlcmFuY2UgaWYgaXQgd291bGQgcHV0IHRoZSBidWZmZXJFbmQgcGFzdCB0aGUgYWN0dWFsIGVuZCBvZiBzdHJlYW1cbiAgICAgIC8vIFVzZXMgYnVmZmVyIGFuZCBzZXF1ZW5jZSBudW1iZXIgdG8gY2FsY3VsYXRlIHN3aXRjaCBzZWdtZW50IChyZXF1aXJlZCBpZiB1c2luZyBFWFQtWC1ESVNDT05USU5VSVRZLVNFUVVFTkNFKVxuXG4gICAgICBmcmFnID0gT2JqZWN0KF9mcmFnbWVudF9maW5kZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1wiZmluZEZyYWdtZW50QnlQVFNcIl0pKGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBidWZmZXJFbmQsIGxvb2t1cFRvbGVyYW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlYWNoIGVuZCBvZiBwbGF5bGlzdFxuICAgICAgZnJhZyA9IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHZhciBjdXJTTklkeCA9IGZyYWcuc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcbiAgICAgIHZhciBzYW1lTGV2ZWwgPSBmcmFnUHJldmlvdXMgJiYgZnJhZy5sZXZlbCA9PT0gZnJhZ1ByZXZpb3VzLmxldmVsO1xuICAgICAgdmFyIG5leHRGcmFnID0gZnJhZ21lbnRzW2N1clNOSWR4ICsgMV07XG5cbiAgICAgIGlmIChmcmFnUHJldmlvdXMgJiYgZnJhZy5zbiA9PT0gZnJhZ1ByZXZpb3VzLnNuICYmICFsb2FkaW5nUGFydHMpIHtcbiAgICAgICAgLy8gRm9yY2UgdGhlIG5leHQgZnJhZ21lbnQgdG8gbG9hZCBpZiB0aGUgcHJldmlvdXMgb25lIHdhcyBhbHJlYWR5IHNlbGVjdGVkLiBUaGlzIGNhbiBvY2Nhc2lvbmFsbHkgaGFwcGVuIHdpdGhcbiAgICAgICAgLy8gbm9uLXVuaWZvcm0gZnJhZ21lbnQgZHVyYXRpb25zXG4gICAgICAgIGlmIChzYW1lTGV2ZWwpIHtcbiAgICAgICAgICBpZiAoZnJhZy5zbiA8IGVuZFNOICYmIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKG5leHRGcmFnKSAhPT0gX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkZyYWdtZW50U3RhdGVcIl0uT0spIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFwiU04gXCIgKyBmcmFnLnNuICsgXCIganVzdCBsb2FkZWQsIGxvYWQgbmV4dCBvbmU6IFwiICsgbmV4dEZyYWcuc24pO1xuICAgICAgICAgICAgZnJhZyA9IG5leHRGcmFnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnJhZztcbiAgfTtcblxuICBfcHJvdG8uc3luY2hyb25pemVUb0xpdmVFZGdlID0gZnVuY3Rpb24gc3luY2hyb25pemVUb0xpdmVFZGdlKGxldmVsRGV0YWlscykge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsaXZlU3luY1Bvc2l0aW9uID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbjtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB2YXIgc3RhcnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIHZhciBlbmQgPSBsZXZlbERldGFpbHMuZWRnZTtcbiAgICB2YXIgd2l0aGluU2xpZGluZ1dpbmRvdyA9IGN1cnJlbnRUaW1lID49IHN0YXJ0IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UgJiYgY3VycmVudFRpbWUgPD0gZW5kOyAvLyBDb250aW51ZSBpZiB3ZSBjYW4gc2VlayBmb3J3YXJkIHRvIHN5bmMgcG9zaXRpb24gb3IgaWYgY3VycmVudCB0aW1lIGlzIG91dHNpZGUgb2Ygc2xpZGluZyB3aW5kb3dcblxuICAgIGlmIChsaXZlU3luY1Bvc2l0aW9uICE9PSBudWxsICYmIG1lZGlhLmR1cmF0aW9uID4gbGl2ZVN5bmNQb3NpdGlvbiAmJiAoY3VycmVudFRpbWUgPCBsaXZlU3luY1Bvc2l0aW9uIHx8ICF3aXRoaW5TbGlkaW5nV2luZG93KSkge1xuICAgICAgLy8gQ29udGludWUgaWYgYnVmZmVyIGlzIHN0YXJ2aW5nIG9yIGlmIGN1cnJlbnQgdGltZSBpcyBiZWhpbmQgbWF4IGxhdGVuY3lcbiAgICAgIHZhciBtYXhMYXRlbmN5ID0gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDogY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcblxuICAgICAgaWYgKCF3aXRoaW5TbGlkaW5nV2luZG93ICYmIG1lZGlhLnJlYWR5U3RhdGUgPCA0IHx8IGN1cnJlbnRUaW1lIDwgZW5kIC0gbWF4TGF0ZW5jeSkge1xuICAgICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICB9IC8vIE9ubHkgc2VlayBpZiByZWFkeSBhbmQgdGhlcmUgaXMgbm90IGEgc2lnbmlmaWNhbnQgZm9yd2FyZCBidWZmZXIgYXZhaWxhYmxlIGZvciBwbGF5YmFja1xuXG5cbiAgICAgICAgaWYgKG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICB0aGlzLndhcm4oXCJQbGF5YmFjazogXCIgKyBjdXJyZW50VGltZS50b0ZpeGVkKDMpICsgXCIgaXMgbG9jYXRlZCB0b28gZmFyIGZyb20gdGhlIGVuZCBvZiBsaXZlIHNsaWRpbmcgcGxheWxpc3Q6IFwiICsgZW5kICsgXCIsIHJlc2V0IGN1cnJlbnRUaW1lIHRvIDogXCIgKyBsaXZlU3luY1Bvc2l0aW9uLnRvRml4ZWQoMykpO1xuICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYWxpZ25QbGF5bGlzdHMgPSBmdW5jdGlvbiBhbGlnblBsYXlsaXN0cyhkZXRhaWxzLCBwcmV2aW91c0RldGFpbHMpIHtcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICAgIGxldmVsTGFzdExvYWRlZCA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkLFxuICAgICAgICBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICB2YXIgbGFzdExldmVsID0gbGV2ZWxMYXN0TG9hZGVkICE9PSBudWxsID8gbGV2ZWxzW2xldmVsTGFzdExvYWRlZF0gOiBudWxsOyAvLyBGSVhNRTogSWYgbm90IGZvciBgc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllc2AgcmVxdWlyaW5nIGZyYWdQcmV2aW91cy5jYyxcbiAgICAvLyAgdGhpcyBjb3VsZCBhbGwgZ28gaW4gbGV2ZWwtaGVscGVyIG1lcmdlRGV0YWlscygpXG5cbiAgICB2YXIgbGVuZ3RoID0gZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoO1xuXG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHRoaXMud2FybihcIk5vIGZyYWdtZW50cyBpbiBsaXZlIHBsYXlsaXN0XCIpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIHNsaWRpbmdTdGFydCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIHZhciBmaXJzdExldmVsTG9hZCA9ICFwcmV2aW91c0RldGFpbHM7XG5cbiAgICB2YXIgYWxpZ25lZCA9IGRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiYgT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShzbGlkaW5nU3RhcnQpO1xuXG4gICAgaWYgKGZpcnN0TGV2ZWxMb2FkIHx8ICFhbGlnbmVkICYmICFzbGlkaW5nU3RhcnQpIHtcbiAgICAgIE9iamVjdChfdXRpbHNfZGlzY29udGludWl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJhbGlnblN0cmVhbVwiXSkoZnJhZ1ByZXZpb3VzLCBsYXN0TGV2ZWwsIGRldGFpbHMpO1xuICAgICAgdmFyIGFsaWduZWRTbGlkaW5nU3RhcnQgPSBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgIHRoaXMubG9nKFwiTGl2ZSBwbGF5bGlzdCBzbGlkaW5nOiBcIiArIGFsaWduZWRTbGlkaW5nU3RhcnQudG9GaXhlZCgyKSArIFwiIHN0YXJ0LXNuOiBcIiArIChwcmV2aW91c0RldGFpbHMgPyBwcmV2aW91c0RldGFpbHMuc3RhcnRTTiA6ICduYScpICsgXCItPlwiICsgZGV0YWlscy5zdGFydFNOICsgXCIgcHJldi1zbjogXCIgKyAoZnJhZ1ByZXZpb3VzID8gZnJhZ1ByZXZpb3VzLnNuIDogJ25hJykgKyBcIiBmcmFnbWVudHM6IFwiICsgbGVuZ3RoKTtcbiAgICAgIHJldHVybiBhbGlnbmVkU2xpZGluZ1N0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiBzbGlkaW5nU3RhcnQ7XG4gIH07XG5cbiAgX3Byb3RvLndhaXRGb3JDZG5UdW5lSW4gPSBmdW5jdGlvbiB3YWl0Rm9yQ2RuVHVuZUluKGRldGFpbHMpIHtcbiAgICAvLyBXYWl0IGZvciBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pbiB0byBnZXQgYW4gdXBkYXRlZCBwbGF5bGlzdFxuICAgIHZhciBhZHZhbmNlUGFydExpbWl0ID0gMztcbiAgICByZXR1cm4gZGV0YWlscy5saXZlICYmIGRldGFpbHMuY2FuQmxvY2tSZWxvYWQgJiYgZGV0YWlscy5wYXJ0VGFyZ2V0ICYmIGRldGFpbHMudHVuZUluR29hbCA+IE1hdGgubWF4KGRldGFpbHMucGFydEhvbGRCYWNrLCBkZXRhaWxzLnBhcnRUYXJnZXQgKiBhZHZhbmNlUGFydExpbWl0KTtcbiAgfTtcblxuICBfcHJvdG8uc2V0U3RhcnRQb3NpdGlvbiA9IGZ1bmN0aW9uIHNldFN0YXJ0UG9zaXRpb24oZGV0YWlscywgc2xpZGluZykge1xuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb24gaWYgc2V0IHRvIC0xLiB1c2UgaXQgc3RyYWlnaHQgYXdheSBpZiB2YWx1ZSBpcyBkZWZpbmVkXG4gICAgdmFyIHN0YXJ0UG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG5cbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA8IHNsaWRpbmcpIHtcbiAgICAgIHN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA9PT0gLTEgfHwgdGhpcy5sYXN0Q3VycmVudFRpbWUgPT09IC0xKSB7XG4gICAgICAvLyBmaXJzdCwgY2hlY2sgaWYgc3RhcnQgdGltZSBvZmZzZXQgaGFzIGJlZW4gc2V0IGluIHBsYXlsaXN0LCBpZiB5ZXMsIHVzZSB0aGlzIHZhbHVlXG4gICAgICB2YXIgc3RhcnRUaW1lT2Zmc2V0ID0gZGV0YWlscy5zdGFydFRpbWVPZmZzZXQ7XG5cbiAgICAgIGlmIChPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IHNsaWRpbmcgKyBzdGFydFRpbWVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKHN0YXJ0VGltZU9mZnNldCA8IDApIHtcbiAgICAgICAgICBzdGFydFBvc2l0aW9uICs9IGRldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSBNYXRoLm1pbihNYXRoLm1heChzbGlkaW5nLCBzdGFydFBvc2l0aW9uKSwgc2xpZGluZyArIGRldGFpbHMudG90YWxkdXJhdGlvbik7XG4gICAgICAgIHRoaXMubG9nKFwiU3RhcnQgdGltZSBvZmZzZXQgXCIgKyBzdGFydFRpbWVPZmZzZXQgKyBcIiBmb3VuZCBpbiBwbGF5bGlzdCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gdG8gXCIgKyBzdGFydFBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAoZGV0YWlscy5saXZlKSB7XG4gICAgICAgIC8vIExlYXZlIHRoaXMuc3RhcnRQb3NpdGlvbiBhdCAtMSwgc28gdGhhdCB3ZSBjYW4gdXNlIGBnZXRJbml0aWFsTGl2ZUZyYWdtZW50YCBsb2dpYyB3aGVuIHN0YXJ0UG9zaXRpb24gaGFzXG4gICAgICAgIC8vIG5vdCBiZWVuIHNwZWNpZmllZCB2aWEgdGhlIGNvbmZpZyBvciBhbiBhcyBhbiBhcmd1bWVudCB0byBzdGFydExvYWQgKCMzNzM2KS5cbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb24gfHwgc2xpZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb24gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgfVxuXG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TG9hZFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0TG9hZFBvc2l0aW9uKCkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7IC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cblxuICAgIHZhciBwb3MgPSAwO1xuXG4gICAgaWYgKHRoaXMubG9hZGVkbWV0YWRhdGEgJiYgbWVkaWEpIHtcbiAgICAgIHBvcyA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0TG9hZFBvc2l0aW9uKSB7XG4gICAgICBwb3MgPSB0aGlzLm5leHRMb2FkUG9zaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcztcbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlRnJhZ0xvYWRBYm9ydGVkID0gZnVuY3Rpb24gaGFuZGxlRnJhZ0xvYWRBYm9ydGVkKGZyYWcsIHBhcnQpIHtcbiAgICBpZiAodGhpcy50cmFuc211eGVyICYmIGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcgJiYgZnJhZy5zdGF0cy5hYm9ydGVkKSB7XG4gICAgICB0aGlzLndhcm4oXCJGcmFnbWVudCBcIiArIGZyYWcuc24gKyAocGFydCA/ICcgcGFydCcgKyBwYXJ0LmluZGV4IDogJycpICsgXCIgb2YgbGV2ZWwgXCIgKyBmcmFnLmxldmVsICsgXCIgd2FzIGFib3J0ZWRcIik7XG4gICAgICB0aGlzLnJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWcpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVzZXRGcmFnbWVudExvYWRpbmcgPSBmdW5jdGlvbiByZXNldEZyYWdtZW50TG9hZGluZyhmcmFnKSB7XG4gICAgaWYgKCF0aGlzLmZyYWdDdXJyZW50IHx8ICF0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkZyYWdtZW50T3JLZXlMb2FkRXJyb3IgPSBmdW5jdGlvbiBvbkZyYWdtZW50T3JLZXlMb2FkRXJyb3IoZmlsdGVyVHlwZSwgZGF0YSkge1xuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7IC8vIEhhbmRsZSBmcmFnIGVycm9yIHJlbGF0ZWQgdG8gY2FsbGVyJ3MgZmlsdGVyVHlwZVxuXG4gICAgaWYgKCFmcmFnIHx8IGZyYWcudHlwZSAhPT0gZmlsdGVyVHlwZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgY29uc29sZS5hc3NlcnQoZnJhZ0N1cnJlbnQgJiYgZnJhZy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiYgZnJhZy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiYgZnJhZy51cmxJZCA9PT0gZnJhZ0N1cnJlbnQudXJsSWQsICdGcmFnIGxvYWQgZXJyb3IgbXVzdCBtYXRjaCBjdXJyZW50IGZyYWcgdG8gcmV0cnknKTtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7IC8vIGtlZXAgcmV0cnlpbmcgdW50aWwgdGhlIGxpbWl0IHdpbGwgYmUgcmVhY2hlZFxuXG4gICAgaWYgKHRoaXMuZnJhZ0xvYWRFcnJvciArIDEgPD0gY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnkpIHtcbiAgICAgIGlmICh0aGlzLnJlc2V0TGl2ZVN0YXJ0V2hlbk5vdExvYWRlZChmcmFnLmxldmVsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dFxuXG5cbiAgICAgIHZhciBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsIHRoaXMuZnJhZ0xvYWRFcnJvcikgKiBjb25maWcuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LCBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQpO1xuICAgICAgdGhpcy53YXJuKFwiRnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgb2YgXCIgKyBmaWx0ZXJUeXBlICsgXCIgXCIgKyBmcmFnLmxldmVsICsgXCIgZmFpbGVkIHRvIGxvYWQsIHJldHJ5aW5nIGluIFwiICsgZGVsYXkgKyBcIm1zXCIpO1xuICAgICAgdGhpcy5yZXRyeURhdGUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XG4gICAgICB0aGlzLmZyYWdMb2FkRXJyb3IrKztcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTtcbiAgICB9IGVsc2UgaWYgKGRhdGEubGV2ZWxSZXRyeSkge1xuICAgICAgaWYgKGZpbHRlclR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5BVURJTykge1xuICAgICAgICAvLyBSZXNldCBjdXJyZW50IGZyYWdtZW50IHNpbmNlIGF1ZGlvIHRyYWNrIGF1ZGlvIGlzIGVzc2VudGlhbCBhbmQgbWF5IG5vdCBoYXZlIGEgZmFpbC1vdmVyIHRyYWNrXG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgfSAvLyBGcmFnbWVudCBlcnJvcnMgdGhhdCByZXN1bHQgaW4gYSBsZXZlbCBzd2l0Y2ggb3IgcmVkdW5kYW50IGZhaWwtb3ZlclxuICAgICAgLy8gc2hvdWxkIHJlc2V0IHRoZSBzdHJlYW0gY29udHJvbGxlciBzdGF0ZSB0byBpZGxlXG5cblxuICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJsb2dnZXJcIl0uZXJyb3IoZGF0YS5kZXRhaWxzICsgXCIgcmVhY2hlcyBtYXggcmV0cnksIHJlZGlzcGF0Y2ggYXMgZmF0YWwgLi4uXCIpOyAvLyBzd2l0Y2ggZXJyb3IgdG8gZmF0YWxcblxuICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICB0aGlzLmhscy5zdG9wTG9hZCgpO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYWZ0ZXJCdWZmZXJGbHVzaGVkID0gZnVuY3Rpb24gYWZ0ZXJCdWZmZXJGbHVzaGVkKG1lZGlhLCBidWZmZXJUeXBlLCBwbGF5bGlzdFR5cGUpIHtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBBZnRlciBzdWNjZXNzZnVsIGJ1ZmZlciBmbHVzaGluZywgZmlsdGVyIGZsdXNoZWQgZnJhZ21lbnRzIGZyb20gYnVmZmVyZWRGcmFncyB1c2UgbWVkaWFCdWZmZXJlZCBpbnN0ZWFkIG9mIG1lZGlhXG4gICAgLy8gKHNvIHRoYXQgd2Ugd2lsbCBjaGVjayBhZ2FpbnN0IHZpZGVvLmJ1ZmZlcmVkIHJhbmdlcyBpbiBjYXNlIG9mIGFsdCBhdWRpbyB0cmFjaylcblxuXG4gICAgdmFyIGJ1ZmZlcmVkVGltZVJhbmdlcyA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJCdWZmZXJIZWxwZXJcIl0uZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMoYnVmZmVyVHlwZSwgYnVmZmVyZWRUaW1lUmFuZ2VzLCBwbGF5bGlzdFR5cGUpO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZXNldExvYWRpbmdTdGF0ZSA9IGZ1bmN0aW9uIHJlc2V0TG9hZGluZ1N0YXRlKCkge1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXRMaXZlU3RhcnRXaGVuTm90TG9hZGVkID0gZnVuY3Rpb24gcmVzZXRMaXZlU3RhcnRXaGVuTm90TG9hZGVkKGxldmVsKSB7XG4gICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9uIGZpcnN0IGZyYWdcbiAgICAvLyBpbiB0aGF0IGNhc2UsIHJlc2V0IHN0YXJ0RnJhZ1JlcXVlc3RlZCBmbGFnXG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgdmFyIGRldGFpbHMgPSB0aGlzLmxldmVscyA/IHRoaXMubGV2ZWxzW2xldmVsXS5kZXRhaWxzIDogbnVsbDtcblxuICAgICAgaWYgKGRldGFpbHMgIT09IG51bGwgJiYgZGV0YWlscyAhPT0gdm9pZCAwICYmIGRldGFpbHMubGl2ZSkge1xuICAgICAgICAvLyBXZSBjYW4ndCBhZmZvcmQgdG8gcmV0cnkgYWZ0ZXIgYSBkZWxheSBpbiBhIGxpdmUgc2NlbmFyaW8uIFVwZGF0ZSB0aGUgc3RhcnQgcG9zaXRpb24gYW5kIHJldHVybiB0byBJRExFLlxuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKGRldGFpbHMsIDApO1xuICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by51cGRhdGVMZXZlbFRpbWluZyA9IGZ1bmN0aW9uIHVwZGF0ZUxldmVsVGltaW5nKGZyYWcsIHBhcnQsIGxldmVsLCBwYXJ0aWFsKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICB2YXIgZGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgY29uc29sZS5hc3NlcnQoISFkZXRhaWxzLCAnbGV2ZWwuZGV0YWlscyBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICB2YXIgcGFyc2VkID0gT2JqZWN0LmtleXMoZnJhZy5lbGVtZW50YXJ5U3RyZWFtcykucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtc1t0eXBlXTtcblxuICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgdmFyIHBhcnNlZER1cmF0aW9uID0gaW5mby5lbmRQVFMgLSBpbmZvLnN0YXJ0UFRTO1xuXG4gICAgICAgIGlmIChwYXJzZWREdXJhdGlvbiA8PSAwKSB7XG4gICAgICAgICAgLy8gRGVzdHJveSB0aGUgdHJhbnNtdXhlciBhZnRlciBpdCdzIG5leHQgdGltZSBvZmZzZXQgZmFpbGVkIHRvIGFkdmFuY2UgYmVjYXVzZSBkdXJhdGlvbiB3YXMgPD0gMC5cbiAgICAgICAgICAvLyBUaGUgbmV3IHRyYW5zbXV4ZXIgd2lsbCBiZSBjb25maWd1cmVkIHdpdGggYSB0aW1lIG9mZnNldCBtYXRjaGluZyB0aGUgbmV4dCBmcmFnbWVudCBzdGFydCxcbiAgICAgICAgICAvLyBwcmV2ZW50aW5nIHRoZSB0aW1lbGluZSBmcm9tIHNoaWZ0aW5nLlxuICAgICAgICAgIF90aGlzNi53YXJuKFwiQ291bGQgbm90IHBhcnNlIGZyYWdtZW50IFwiICsgZnJhZy5zbiArIFwiIFwiICsgdHlwZSArIFwiIGR1cmF0aW9uIHJlbGlhYmx5IChcIiArIHBhcnNlZER1cmF0aW9uICsgXCIpXCIpO1xuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcmlmdCA9IHBhcnRpYWwgPyAwIDogT2JqZWN0KF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXCJ1cGRhdGVGcmFnUFRTRFRTXCJdKShkZXRhaWxzLCBmcmFnLCBpbmZvLnN0YXJ0UFRTLCBpbmZvLmVuZFBUUywgaW5mby5zdGFydERUUywgaW5mby5lbmREVFMpO1xuXG4gICAgICAgIF90aGlzNi5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJFdmVudHNcIl0uTEVWRUxfUFRTX1VQREFURUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgICBkcmlmdDogZHJpZnQsXG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIHN0YXJ0OiBpbmZvLnN0YXJ0UFRTLFxuICAgICAgICAgIGVuZDogaW5mby5lbmRQVFNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIHRoaXMud2FybihcIkZvdW5kIG5vIG1lZGlhIGluIGZyYWdtZW50IFwiICsgZnJhZy5zbiArIFwiIG9mIGxldmVsIFwiICsgbGV2ZWwuaWQgKyBcIiByZXNldHRpbmcgdHJhbnNtdXhlciB0byBmYWxsYmFjayB0byBwbGF5bGlzdCB0aW1pbmdcIik7XG4gICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJFdmVudHNcIl0uRlJBR19QQVJTRUQsIHtcbiAgICAgIGZyYWc6IGZyYWcsXG4gICAgICBwYXJ0OiBwYXJ0XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0VHJhbnNtdXhlciA9IGZ1bmN0aW9uIHJlc2V0VHJhbnNtdXhlcigpIHtcbiAgICBpZiAodGhpcy50cmFuc211eGVyKSB7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKEJhc2VTdHJlYW1Db250cm9sbGVyLCBbe1xuICAgIGtleTogXCJzdGF0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV4dFN0YXRlKSB7XG4gICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXG4gICAgICBpZiAocHJldmlvdXNTdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICB0aGlzLmxvZyhwcmV2aW91c1N0YXRlICsgXCItPlwiICsgbmV4dFN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZVN0cmVhbUNvbnRyb2xsZXI7XG59KF90YXNrX2xvb3BfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0pO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9idWZmZXItY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBCdWZmZXJDb250cm9sbGVyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYnVmZmVyLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21lZGlhc291cmNlX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyICovIFwiLi9zcmMvdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvYWRlci9mcmFnbWVudCAqLyBcIi4vc3JjL2xvYWRlci9mcmFnbWVudC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYnVmZmVyX29wZXJhdGlvbl9xdWV1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9idWZmZXItb3BlcmF0aW9uLXF1ZXVlICovIFwiLi9zcmMvY29udHJvbGxlci9idWZmZXItb3BlcmF0aW9uLXF1ZXVlLnRzXCIpO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIE1lZGlhU291cmNlID0gT2JqZWN0KF91dGlsc19tZWRpYXNvdXJjZV9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImdldE1lZGlhU291cmNlXCJdKSgpO1xudmFyIFZJREVPX0NPREVDX1BST0ZJTEVfUkVQQUNFID0gLyhbaGFddmMuKSg/OlxcLlteLixdKykrLztcblxudmFyIEJ1ZmZlckNvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBUaGUgbGV2ZWwgZGV0YWlscyB1c2VkIHRvIGRldGVybWluZSBkdXJhdGlvbiwgdGFyZ2V0LWR1cmF0aW9uIGFuZCBsaXZlXG4gIC8vIGNhY2hlIHRoZSBzZWxmIGdlbmVyYXRlZCBvYmplY3QgdXJsIHRvIGRldGVjdCBoaWphY2sgb2YgdmlkZW8gdGFnXG4gIC8vIEEgcXVldWUgb2YgYnVmZmVyIG9wZXJhdGlvbnMgd2hpY2ggcmVxdWlyZSB0aGUgU291cmNlQnVmZmVyIHRvIG5vdCBiZSB1cGRhdGluZyB1cG9uIGV4ZWN1dGlvblxuICAvLyBSZWZlcmVuY2VzIHRvIGV2ZW50IGxpc3RlbmVycyBmb3IgZWFjaCBTb3VyY2VCdWZmZXIsIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVmZXJlbmNlZCBmb3IgZXZlbnQgcmVtb3ZhbFxuICAvLyBUaGUgbnVtYmVyIG9mIEJVRkZFUl9DT0RFQyBldmVudHMgcmVjZWl2ZWQgYmVmb3JlIGFueSBzb3VyY2VCdWZmZXJzIGFyZSBjcmVhdGVkXG4gIC8vIFRoZSB0b3RhbCBudW1iZXIgb2YgQlVGRkVSX0NPREVDIGV2ZW50cyByZWNlaXZlZFxuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgYXR0YWNoZWQgbWVkaWEgZWxlbWVudFxuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgYWN0aXZlIG1lZGlhIHNvdXJjZVxuICAvLyBjb3VudGVyc1xuICBmdW5jdGlvbiBCdWZmZXJDb250cm9sbGVyKF9obHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLl9vYmplY3RVcmwgPSBudWxsO1xuICAgIHRoaXMub3BlcmF0aW9uUXVldWUgPSB2b2lkIDA7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gMDtcbiAgICB0aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhU291cmNlID0gbnVsbDtcbiAgICB0aGlzLmFwcGVuZEVycm9yID0gMDtcbiAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgIHRoaXMuc291cmNlQnVmZmVyID0gdm9pZCAwO1xuXG4gICAgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaGxzID0gX3RoaXMuaGxzLFxuICAgICAgICAgIG1lZGlhID0gX3RoaXMubWVkaWEsXG4gICAgICAgICAgbWVkaWFTb3VyY2UgPSBfdGhpcy5tZWRpYVNvdXJjZTtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coJ1tidWZmZXItY29udHJvbGxlcl06IE1lZGlhIHNvdXJjZSBvcGVuZWQnKTtcblxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIF90aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCk7XG5cbiAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSEVELCB7XG4gICAgICAgICAgbWVkaWE6IG1lZGlhXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFTb3VyY2UpIHtcbiAgICAgICAgLy8gb25jZSByZWNlaXZlZCwgZG9uJ3QgbGlzdGVuIGFueW1vcmUgdG8gc291cmNlb3BlbiBldmVudFxuICAgICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgX3RoaXMuX29uTWVkaWFTb3VyY2VPcGVuKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgfTtcblxuICAgIHRoaXMuX29uTWVkaWFTb3VyY2VDbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coJ1tidWZmZXItY29udHJvbGxlcl06IE1lZGlhIHNvdXJjZSBjbG9zZWQnKTtcbiAgICB9O1xuXG4gICAgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZygnW2J1ZmZlci1jb250cm9sbGVyXTogTWVkaWEgc291cmNlIGVuZGVkJyk7XG4gICAgfTtcblxuICAgIHRoaXMuaGxzID0gX2hscztcblxuICAgIHRoaXMuX2luaXRTb3VyY2VCdWZmZXIoKTtcblxuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBCdWZmZXJDb250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaGFzU291cmNlVHlwZXMgPSBmdW5jdGlvbiBoYXNTb3VyY2VUeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aCA+IDAgfHwgT2JqZWN0LmtleXModGhpcy5wZW5kaW5nVHJhY2tzKS5sZW5ndGggPiAwO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9BUFBFTkRJTkcsIHRoaXMub25CdWZmZXJBcHBlbmRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRU9TLCB0aGlzLm9uQnVmZmVyRW9zLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19QQVJTRUQsIHRoaXMub25GcmFnUGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfQ0hBTkdFRCwgdGhpcy5vbkZyYWdDaGFuZ2VkLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQVBQRU5ESU5HLCB0aGlzLm9uQnVmZmVyQXBwZW5kaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRU9TLCB0aGlzLm9uQnVmZmVyRW9zLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19QQVJTRUQsIHRoaXMub25GcmFnUGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0NIQU5HRUQsIHRoaXMub25GcmFnQ2hhbmdlZCwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLl9pbml0U291cmNlQnVmZmVyID0gZnVuY3Rpb24gX2luaXRTb3VyY2VCdWZmZXIoKSB7XG4gICAgdGhpcy5zb3VyY2VCdWZmZXIgPSB7fTtcbiAgICB0aGlzLm9wZXJhdGlvblF1ZXVlID0gbmV3IF9idWZmZXJfb3BlcmF0aW9uX3F1ZXVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJkZWZhdWx0XCJdKHRoaXMuc291cmNlQnVmZmVyKTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHtcbiAgICAgIGF1ZGlvOiBbXSxcbiAgICAgIHZpZGVvOiBbXSxcbiAgICAgIGF1ZGlvdmlkZW86IFtdXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8ub25NYW5pZmVzdFBhcnNlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGFsdCBhdWRpbyAyIEJVRkZFUl9DT0RFQ1MgZXZlbnRzIHdpbGwgYmUgdHJpZ2dlcmVkLCBvbmUgcGVyIHN0cmVhbSBjb250cm9sbGVyXG4gICAgLy8gc291cmNlYnVmZmVycyB3aWxsIGJlIGNyZWF0ZWQgYWxsIGF0IG9uY2Ugd2hlbiB0aGUgZXhwZWN0ZWQgbmIgb2YgdHJhY2tzIHdpbGwgYmUgcmVhY2hlZFxuICAgIC8vIGluIGNhc2UgYWx0IGF1ZGlvIGlzIG5vdCB1c2VkLCBvbmx5IG9uZSBCVUZGRVJfQ09ERUMgZXZlbnQgd2lsbCBiZSBmaXJlZCBmcm9tIG1haW4gc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAvLyBpdCB3aWxsIGNvbnRhaW4gdGhlIGV4cGVjdGVkIG5iIG9mIHNvdXJjZSBidWZmZXJzLCBubyBuZWVkIHRvIGNvbXB1dGUgaXRcbiAgICB2YXIgY29kZWNFdmVudHMgPSAyO1xuXG4gICAgaWYgKGRhdGEuYXVkaW8gJiYgIWRhdGEudmlkZW8gfHwgIWRhdGEuYWx0QXVkaW8pIHtcbiAgICAgIGNvZGVjRXZlbnRzID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSB0aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gY29kZWNFdmVudHM7XG4gICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCArIFwiIGJ1ZmZlckNvZGVjIGV2ZW50KHMpIGV4cGVjdGVkXCIpO1xuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhQXR0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuXG4gICAgaWYgKG1lZGlhICYmIE1lZGlhU291cmNlKSB7XG4gICAgICB2YXIgbXMgPSB0aGlzLm1lZGlhU291cmNlID0gbmV3IE1lZGlhU291cmNlKCk7IC8vIE1lZGlhU291cmNlIGxpc3RlbmVycyBhcmUgYXJyb3cgZnVuY3Rpb25zIHdpdGggYSBsZXhpY2FsIHNjb3BlLCBhbmQgZG8gbm90IG5lZWQgdG8gYmUgYm91bmRcblxuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlKTsgLy8gbGluayB2aWRlbyBhbmQgbWVkaWEgU291cmNlXG5cbiAgICAgIG1lZGlhLnNyYyA9IHNlbGYuVVJMLmNyZWF0ZU9iamVjdFVSTChtcyk7IC8vIGNhY2hlIHRoZSBsb2NhbGx5IGdlbmVyYXRlZCBvYmplY3QgdXJsXG5cbiAgICAgIHRoaXMuX29iamVjdFVybCA9IG1lZGlhLnNyYztcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZSxcbiAgICAgICAgX29iamVjdFVybCA9IHRoaXMuX29iamVjdFVybDtcblxuICAgIGlmIChtZWRpYVNvdXJjZSkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZygnW2J1ZmZlci1jb250cm9sbGVyXTogbWVkaWEgc291cmNlIGRldGFjaGluZycpO1xuXG4gICAgICBpZiAobWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gZW5kT2ZTdHJlYW0gY291bGQgdHJpZ2dlciBleGNlcHRpb24gaWYgYW55IHNvdXJjZWJ1ZmZlciBpcyBpbiB1cGRhdGluZyBzdGF0ZVxuICAgICAgICAgIC8vIHdlIGRvbid0IHJlYWxseSBjYXJlIGFib3V0IGNoZWNraW5nIHNvdXJjZWJ1ZmZlciBzdGF0ZSBoZXJlLFxuICAgICAgICAgIC8vIGFzIHdlIGFyZSBhbnl3YXkgZGV0YWNoaW5nIHRoZSBNZWRpYVNvdXJjZVxuICAgICAgICAgIC8vIGxldCdzIGp1c3QgYXZvaWQgdGhpcyBleGNlcHRpb24gdG8gcHJvcGFnYXRlXG4gICAgICAgICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLndhcm4oXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBvbk1lZGlhRGV0YWNoaW5nOiBcIiArIGVyci5tZXNzYWdlICsgXCIgd2hpbGUgY2FsbGluZyBlbmRPZlN0cmVhbVwiKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBDbGVhbiB1cCB0aGUgU291cmNlQnVmZmVycyBieSBpbnZva2luZyBvbkJ1ZmZlclJlc2V0XG5cblxuICAgICAgdGhpcy5vbkJ1ZmZlclJlc2V0KCk7XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pO1xuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLl9vbk1lZGlhU291cmNlRW5kZWQpO1xuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UpOyAvLyBEZXRhY2ggcHJvcGVybHkgdGhlIE1lZGlhU291cmNlIGZyb20gdGhlIEhUTUxNZWRpYUVsZW1lbnQgYXNcbiAgICAgIC8vIHN1Z2dlc3RlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vdzNjL21lZGlhLXNvdXJjZS9pc3N1ZXMvNTMuXG5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoX29iamVjdFVybCkge1xuICAgICAgICAgIHNlbGYuVVJMLnJldm9rZU9iamVjdFVSTChfb2JqZWN0VXJsKTtcbiAgICAgICAgfSAvLyBjbGVhbiB1cCB2aWRlbyB0YWcgc3JjIG9ubHkgaWYgaXQncyBvdXIgb3duIHVybC4gc29tZSBleHRlcm5hbCBsaWJyYXJpZXMgbWlnaHRcbiAgICAgICAgLy8gaGlqYWNrIHRoZSB2aWRlbyB0YWcgYW5kIGNoYW5nZSBpdHMgJ3NyYycgd2l0aG91dCBkZXN0cm95aW5nIHRoZSBIbHMgaW5zdGFuY2UgZmlyc3RcblxuXG4gICAgICAgIGlmIChtZWRpYS5zcmMgPT09IF9vYmplY3RVcmwpIHtcbiAgICAgICAgICBtZWRpYS5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgIG1lZGlhLmxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybignW2J1ZmZlci1jb250cm9sbGVyXTogbWVkaWEuc3JjIHdhcyBjaGFuZ2VkIGJ5IGEgdGhpcmQgcGFydHkgLSBza2lwIGNsZWFudXAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLm1lZGlhU291cmNlID0gbnVsbDtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy5fb2JqZWN0VXJsID0gbnVsbDtcbiAgICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IHRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWw7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICAgIHRoaXMudHJhY2tzID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNIRUQsIHVuZGVmaW5lZCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uQnVmZmVyUmVzZXQgPSBmdW5jdGlvbiBvbkJ1ZmZlclJlc2V0KCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHZhciBzYiA9IF90aGlzMi5zb3VyY2VCdWZmZXJbdHlwZV07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzYikge1xuICAgICAgICAgIF90aGlzMi5yZW1vdmVCdWZmZXJMaXN0ZW5lcnModHlwZSk7XG5cbiAgICAgICAgICBpZiAoX3RoaXMyLm1lZGlhU291cmNlKSB7XG4gICAgICAgICAgICBfdGhpczIubWVkaWFTb3VyY2UucmVtb3ZlU291cmNlQnVmZmVyKHNiKTtcbiAgICAgICAgICB9IC8vIFN5bmNocm9ub3VzbHkgcmVtb3ZlIHRoZSBTQiBmcm9tIHRoZSBtYXAgYmVmb3JlIHRoZSBuZXh0IGNhbGwgaW4gb3JkZXIgdG8gcHJldmVudCBhbiBhc3luYyBmdW5jdGlvbiBmcm9tXG4gICAgICAgICAgLy8gYWNjZXNzaW5nIGl0XG5cblxuICAgICAgICAgIF90aGlzMi5zb3VyY2VCdWZmZXJbdHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybihcIltidWZmZXItY29udHJvbGxlcl06IEZhaWxlZCB0byByZXNldCB0aGUgXCIgKyB0eXBlICsgXCIgYnVmZmVyXCIsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9pbml0U291cmNlQnVmZmVyKCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uQnVmZmVyQ29kZWNzID0gZnVuY3Rpb24gb25CdWZmZXJDb2RlY3MoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBzb3VyY2VCdWZmZXJDb3VudCA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5sZW5ndGg7XG4gICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICBpZiAoc291cmNlQnVmZmVyQ291bnQpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgU291cmNlQnVmZmVyIGNvZGVjIG5lZWRzIHRvIGNoYW5nZVxuICAgICAgICB2YXIgdHJhY2sgPSBfdGhpczMudHJhY2tzW3RyYWNrTmFtZV07XG5cbiAgICAgICAgaWYgKHRyYWNrICYmIHR5cGVvZiB0cmFjay5idWZmZXIuY2hhbmdlVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBfZGF0YSR0cmFja05hbWUgPSBkYXRhW3RyYWNrTmFtZV0sXG4gICAgICAgICAgICAgIGlkID0gX2RhdGEkdHJhY2tOYW1lLmlkLFxuICAgICAgICAgICAgICBjb2RlYyA9IF9kYXRhJHRyYWNrTmFtZS5jb2RlYyxcbiAgICAgICAgICAgICAgbGV2ZWxDb2RlYyA9IF9kYXRhJHRyYWNrTmFtZS5sZXZlbENvZGVjLFxuICAgICAgICAgICAgICBjb250YWluZXIgPSBfZGF0YSR0cmFja05hbWUuY29udGFpbmVyLFxuICAgICAgICAgICAgICBtZXRhZGF0YSA9IF9kYXRhJHRyYWNrTmFtZS5tZXRhZGF0YTtcbiAgICAgICAgICB2YXIgY3VycmVudENvZGVjID0gKHRyYWNrLmxldmVsQ29kZWMgfHwgdHJhY2suY29kZWMpLnJlcGxhY2UoVklERU9fQ09ERUNfUFJPRklMRV9SRVBBQ0UsICckMScpO1xuICAgICAgICAgIHZhciBuZXh0Q29kZWMgPSAobGV2ZWxDb2RlYyB8fCBjb2RlYykucmVwbGFjZShWSURFT19DT0RFQ19QUk9GSUxFX1JFUEFDRSwgJyQxJyk7XG5cbiAgICAgICAgICBpZiAoY3VycmVudENvZGVjICE9PSBuZXh0Q29kZWMpIHtcbiAgICAgICAgICAgIHZhciBtaW1lVHlwZSA9IGNvbnRhaW5lciArIFwiO2NvZGVjcz1cIiArIChsZXZlbENvZGVjIHx8IGNvZGVjKTtcblxuICAgICAgICAgICAgX3RoaXMzLmFwcGVuZENoYW5nZVR5cGUodHJhY2tOYW1lLCBtaW1lVHlwZSk7XG5cbiAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBzd2l0Y2hpbmcgY29kZWMgXCIgKyBjdXJyZW50Q29kZWMgKyBcIiB0byBcIiArIG5leHRDb2RlYyk7XG4gICAgICAgICAgICBfdGhpczMudHJhY2tzW3RyYWNrTmFtZV0gPSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcjogdHJhY2suYnVmZmVyLFxuICAgICAgICAgICAgICBjb2RlYzogY29kZWMsXG4gICAgICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgICAgICBsZXZlbENvZGVjOiBsZXZlbENvZGVjLFxuICAgICAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGEsXG4gICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHNvdXJjZSBidWZmZXIocykgbm90IGNyZWF0ZWQgeWV0LCBhcHBlbmRlZCBidWZmZXIgdHJhY2tzIGluIHRoaXMucGVuZGluZ1RyYWNrc1xuICAgICAgICBfdGhpczMucGVuZGluZ1RyYWNrc1t0cmFja05hbWVdID0gZGF0YVt0cmFja05hbWVdO1xuICAgICAgfVxuICAgIH0pOyAvLyBpZiBzb3VyY2VidWZmZXJzIGFscmVhZHkgY3JlYXRlZCwgZG8gbm90aGluZyAuLi5cblxuICAgIGlmIChzb3VyY2VCdWZmZXJDb3VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IE1hdGgubWF4KHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCAtIDEsIDApO1xuXG4gICAgaWYgKHRoaXMubWVkaWFTb3VyY2UgJiYgdGhpcy5tZWRpYVNvdXJjZS5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5hcHBlbmRDaGFuZ2VUeXBlID0gZnVuY3Rpb24gYXBwZW5kQ2hhbmdlVHlwZSh0eXBlLCBtaW1lVHlwZSkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgdmFyIG9wZXJhdGlvblF1ZXVlID0gdGhpcy5vcGVyYXRpb25RdWV1ZTtcbiAgICB2YXIgb3BlcmF0aW9uID0ge1xuICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAgICAgICAgdmFyIHNiID0gX3RoaXM0LnNvdXJjZUJ1ZmZlclt0eXBlXTtcblxuICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKFwiW2J1ZmZlci1jb250cm9sbGVyXTogY2hhbmdpbmcgXCIgKyB0eXBlICsgXCIgc291cmNlQnVmZmVyIHR5cGUgdG8gXCIgKyBtaW1lVHlwZSk7XG4gICAgICAgICAgc2IuY2hhbmdlVHlwZShtaW1lVHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgfSxcbiAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7fSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7fSxcbiAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZSkge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybihcIltidWZmZXItY29udHJvbGxlcl06IEZhaWxlZCB0byBjaGFuZ2UgXCIgKyB0eXBlICsgXCIgU291cmNlQnVmZmVyIHR5cGVcIiwgZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmQob3BlcmF0aW9uLCB0eXBlKTtcbiAgfTtcblxuICBfcHJvdG8ub25CdWZmZXJBcHBlbmRpbmcgPSBmdW5jdGlvbiBvbkJ1ZmZlckFwcGVuZGluZyhldmVudCwgZXZlbnREYXRhKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICB2YXIgaGxzID0gdGhpcy5obHMsXG4gICAgICAgIG9wZXJhdGlvblF1ZXVlID0gdGhpcy5vcGVyYXRpb25RdWV1ZSxcbiAgICAgICAgdHJhY2tzID0gdGhpcy50cmFja3M7XG4gICAgdmFyIGRhdGEgPSBldmVudERhdGEuZGF0YSxcbiAgICAgICAgdHlwZSA9IGV2ZW50RGF0YS50eXBlLFxuICAgICAgICBmcmFnID0gZXZlbnREYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBldmVudERhdGEucGFydCxcbiAgICAgICAgY2h1bmtNZXRhID0gZXZlbnREYXRhLmNodW5rTWV0YTtcbiAgICB2YXIgY2h1bmtTdGF0cyA9IGNodW5rTWV0YS5idWZmZXJpbmdbdHlwZV07XG4gICAgdmFyIGJ1ZmZlckFwcGVuZGluZ1N0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjaHVua1N0YXRzLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgdmFyIGZyYWdCdWZmZXJpbmcgPSBmcmFnLnN0YXRzLmJ1ZmZlcmluZztcbiAgICB2YXIgcGFydEJ1ZmZlcmluZyA9IHBhcnQgPyBwYXJ0LnN0YXRzLmJ1ZmZlcmluZyA6IG51bGw7XG5cbiAgICBpZiAoZnJhZ0J1ZmZlcmluZy5zdGFydCA9PT0gMCkge1xuICAgICAgZnJhZ0J1ZmZlcmluZy5zdGFydCA9IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0O1xuICAgIH1cblxuICAgIGlmIChwYXJ0QnVmZmVyaW5nICYmIHBhcnRCdWZmZXJpbmcuc3RhcnQgPT09IDApIHtcbiAgICAgIHBhcnRCdWZmZXJpbmcuc3RhcnQgPSBidWZmZXJBcHBlbmRpbmdTdGFydDtcbiAgICB9IC8vIFRPRE86IE9ubHkgdXBkYXRlIHRpbWVzdGFtcE9mZnNldCB3aGVuIGF1ZGlvL21wZWcgZnJhZ21lbnQgb3IgcGFydCBpcyBub3QgY29udGlndW91cyB3aXRoIHByZXZpb3VzbHkgYXBwZW5kZWRcbiAgICAvLyBBZGp1c3RpbmcgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgIChkZXNpcmVkIHBvaW50IGluIHRoZSB0aW1lbGluZSB3aGVyZSB0aGUgbmV4dCBmcmFtZXMgc2hvdWxkIGJlIGFwcGVuZGVkKVxuICAgIC8vIGluIENocm9tZSBicm93c2VyIHdoZW4gd2UgZGV0ZWN0IE1QRUcgYXVkaW8gY29udGFpbmVyIGFuZCB0aW1lIGRlbHRhIGJldHdlZW4gbGV2ZWwgUFRTIGFuZCBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGBcbiAgICAvLyBpcyBncmVhdGVyIHRoYW4gMTAwbXMgKHRoaXMgaXMgZW5vdWdoIHRvIGhhbmRsZSBzZWVrIGZvciBWT0Qgb3IgbGV2ZWwgY2hhbmdlIGZvciBMSVZFIHZpZGVvcykuXG4gICAgLy8gTW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8zMzIjaXNzdWVjb21tZW50LTI1Nzk4NjQ4NlxuXG5cbiAgICB2YXIgYXVkaW9UcmFjayA9IHRyYWNrcy5hdWRpbztcbiAgICB2YXIgY2hlY2tUaW1lc3RhbXBPZmZzZXQgPSB0eXBlID09PSAnYXVkaW8nICYmIGNodW5rTWV0YS5pZCA9PT0gMSAmJiAoYXVkaW9UcmFjayA9PT0gbnVsbCB8fCBhdWRpb1RyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdWRpb1RyYWNrLmNvbnRhaW5lcikgPT09ICdhdWRpby9tcGVnJztcbiAgICB2YXIgb3BlcmF0aW9uID0ge1xuICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAgICAgICAgY2h1bmtTdGF0cy5leGVjdXRlU3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAgIGlmIChjaGVja1RpbWVzdGFtcE9mZnNldCkge1xuICAgICAgICAgIHZhciBzYiA9IF90aGlzNS5zb3VyY2VCdWZmZXJbdHlwZV07XG5cbiAgICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGZyYWcuc3RhcnQgLSBzYi50aW1lc3RhbXBPZmZzZXQ7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMC4xKSB7XG4gICAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBVcGRhdGluZyBhdWRpbyBTb3VyY2VCdWZmZXIgdGltZXN0YW1wT2Zmc2V0IHRvIFwiICsgZnJhZy5zdGFydCArIFwiIChkZWx0YTogXCIgKyBkZWx0YSArIFwiKSBzbjogXCIgKyBmcmFnLnNuICsgXCIpXCIpO1xuICAgICAgICAgICAgICBzYi50aW1lc3RhbXBPZmZzZXQgPSBmcmFnLnN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzNS5hcHBlbmRFeGVjdXRvcihkYXRhLCB0eXBlKTtcbiAgICAgIH0sXG4gICAgICBvblN0YXJ0OiBmdW5jdGlvbiBvblN0YXJ0KCkgey8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogJHt0eXBlfSBTb3VyY2VCdWZmZXIgdXBkYXRlc3RhcnRgKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06ICR7dHlwZX0gU291cmNlQnVmZmVyIHVwZGF0ZWVuZGApO1xuICAgICAgICB2YXIgZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgY2h1bmtTdGF0cy5leGVjdXRlRW5kID0gY2h1bmtTdGF0cy5lbmQgPSBlbmQ7XG5cbiAgICAgICAgaWYgKGZyYWdCdWZmZXJpbmcuZmlyc3QgPT09IDApIHtcbiAgICAgICAgICBmcmFnQnVmZmVyaW5nLmZpcnN0ID0gZW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRCdWZmZXJpbmcgJiYgcGFydEJ1ZmZlcmluZy5maXJzdCA9PT0gMCkge1xuICAgICAgICAgIHBhcnRCdWZmZXJpbmcuZmlyc3QgPSBlbmQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc291cmNlQnVmZmVyID0gX3RoaXM1LnNvdXJjZUJ1ZmZlcjtcbiAgICAgICAgdmFyIHRpbWVSYW5nZXMgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBfdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgICB0aW1lUmFuZ2VzW190eXBlXSA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJCdWZmZXJIZWxwZXJcIl0uZ2V0QnVmZmVyZWQoc291cmNlQnVmZmVyW190eXBlXSk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczUuYXBwZW5kRXJyb3IgPSAwO1xuXG4gICAgICAgIF90aGlzNS5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQlVGRkVSX0FQUEVOREVELCB7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGEsXG4gICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgICAgdGltZVJhbmdlczogdGltZVJhbmdlc1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgICAgICAvLyBpbiBjYXNlIGFueSBlcnJvciBvY2N1cmVkIHdoaWxlIGFwcGVuZGluZywgcHV0IGJhY2sgc2VnbWVudCBpbiBzZWdtZW50cyB0YWJsZVxuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0uZXJyb3IoXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBFcnJvciBlbmNvdW50ZXJlZCB3aGlsZSB0cnlpbmcgdG8gYXBwZW5kIHRvIHRoZSBcIiArIHR5cGUgKyBcIiBTb3VyY2VCdWZmZXJcIiwgZXJyKTtcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkVycm9yVHlwZXNcIl0uTUVESUFfRVJST1IsXG4gICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXJyb3JEZXRhaWxzXCJdLkJVRkZFUl9BUFBFTkRfRVJST1IsXG4gICAgICAgICAgZXJyOiBlcnIsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGVyci5jb2RlID09PSBET01FeGNlcHRpb24uUVVPVEFfRVhDRUVERURfRVJSKSB7XG4gICAgICAgICAgLy8gUXVvdGFFeGNlZWRlZEVycm9yOiBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI3F1b3RhZXhjZWVkZWRlcnJvclxuICAgICAgICAgIC8vIGxldCdzIHN0b3AgYXBwZW5kaW5nIGFueSBzZWdtZW50cywgYW5kIHJlcG9ydCBCVUZGRVJfRlVMTF9FUlJPUiBlcnJvclxuICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFcnJvckRldGFpbHNcIl0uQlVGRkVSX0ZVTExfRVJST1I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXM1LmFwcGVuZEVycm9yKys7XG4gICAgICAgICAgZXZlbnQuZGV0YWlscyA9IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkVycm9yRGV0YWlsc1wiXS5CVUZGRVJfQVBQRU5EX0VSUk9SO1xuICAgICAgICAgIC8qIHdpdGggVUhEIGNvbnRlbnQsIHdlIGNvdWxkIGdldCBsb29wIG9mIHF1b3RhIGV4Y2VlZGVkIGVycm9yIHVudGlsXG4gICAgICAgICAgICBicm93c2VyIGlzIGFibGUgdG8gZXZpY3Qgc29tZSBkYXRhIGZyb20gc291cmNlYnVmZmVyLiBSZXRyeWluZyBjYW4gaGVscCByZWNvdmVyLlxuICAgICAgICAgICovXG5cbiAgICAgICAgICBpZiAoX3RoaXM1LmFwcGVuZEVycm9yID4gaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5KSB7XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0uZXJyb3IoXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBGYWlsZWQgXCIgKyBobHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnkgKyBcIiB0aW1lcyB0byBhcHBlbmQgc2VnbWVudCBpbiBzb3VyY2VCdWZmZXJcIik7XG4gICAgICAgICAgICBldmVudC5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCBldmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmQob3BlcmF0aW9uLCB0eXBlKTtcbiAgfTtcblxuICBfcHJvdG8ub25CdWZmZXJGbHVzaGluZyA9IGZ1bmN0aW9uIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIHZhciBvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWU7XG5cbiAgICB2YXIgZmx1c2hPcGVyYXRpb24gPSBmdW5jdGlvbiBmbHVzaE9wZXJhdGlvbih0eXBlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleGVjdXRlOiBfdGhpczYucmVtb3ZlRXhlY3V0b3IuYmluZChfdGhpczYsIHR5cGUsIGRhdGEuc3RhcnRPZmZzZXQsIGRhdGEuZW5kT2Zmc2V0KSxcbiAgICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHsvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IFN0YXJ0ZWQgZmx1c2hpbmcgJHtkYXRhLnN0YXJ0T2Zmc2V0fSAtPiAke2RhdGEuZW5kT2Zmc2V0fSBmb3IgJHt0eXBlfSBTb3VyY2UgQnVmZmVyYCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBGaW5pc2hlZCBmbHVzaGluZyAke2RhdGEuc3RhcnRPZmZzZXR9IC0+ICR7ZGF0YS5lbmRPZmZzZXR9IGZvciAke3R5cGV9IFNvdXJjZSBCdWZmZXJgKTtcbiAgICAgICAgICBfdGhpczYuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSEVELCB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZSkge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKFwiW2J1ZmZlci1jb250cm9sbGVyXTogRmFpbGVkIHRvIHJlbW92ZSBmcm9tIFwiICsgdHlwZSArIFwiIFNvdXJjZUJ1ZmZlclwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgaWYgKGRhdGEudHlwZSkge1xuICAgICAgb3BlcmF0aW9uUXVldWUuYXBwZW5kKGZsdXNoT3BlcmF0aW9uKGRhdGEudHlwZSksIGRhdGEudHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZChmbHVzaE9wZXJhdGlvbih0eXBlKSwgdHlwZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ1BhcnNlZCA9IGZ1bmN0aW9uIG9uRnJhZ1BhcnNlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBkYXRhLnBhcnQ7XG4gICAgdmFyIGJ1ZmZlcnNBcHBlbmRlZFRvID0gW107XG4gICAgdmFyIGVsZW1lbnRhcnlTdHJlYW1zID0gcGFydCA/IHBhcnQuZWxlbWVudGFyeVN0cmVhbXMgOiBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuXG4gICAgaWYgKGVsZW1lbnRhcnlTdHJlYW1zW19sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJT1ZJREVPXSkge1xuICAgICAgYnVmZmVyc0FwcGVuZGVkVG8ucHVzaCgnYXVkaW92aWRlbycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWxlbWVudGFyeVN0cmVhbXNbX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiRWxlbWVudGFyeVN0cmVhbVR5cGVzXCJdLkFVRElPXSkge1xuICAgICAgICBidWZmZXJzQXBwZW5kZWRUby5wdXNoKCdhdWRpbycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudGFyeVN0cmVhbXNbX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiRWxlbWVudGFyeVN0cmVhbVR5cGVzXCJdLlZJREVPXSkge1xuICAgICAgICBidWZmZXJzQXBwZW5kZWRUby5wdXNoKCd2aWRlbycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvblVuYmxvY2tlZCA9IGZ1bmN0aW9uIG9uVW5ibG9ja2VkKCkge1xuICAgICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBmcmFnLnN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBub3c7XG5cbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHBhcnQuc3RhdHMuYnVmZmVyaW5nLmVuZCA9IG5vdztcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuXG4gICAgICBfdGhpczcuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfQlVGRkVSRUQsIHtcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICBpZDogZnJhZy50eXBlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKGJ1ZmZlcnNBcHBlbmRlZFRvLmxlbmd0aCA9PT0gMCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLndhcm4oXCJGcmFnbWVudHMgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBFbGVtZW50YXJ5U3RyZWFtVHlwZSBzZXQuIHR5cGU6IFwiICsgZnJhZy50eXBlICsgXCIgbGV2ZWw6IFwiICsgZnJhZy5sZXZlbCArIFwiIHNuOiBcIiArIGZyYWcuc24pO1xuICAgIH1cblxuICAgIHRoaXMuYmxvY2tCdWZmZXJzKG9uVW5ibG9ja2VkLCBidWZmZXJzQXBwZW5kZWRUbyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ0NoYW5nZWQgPSBmdW5jdGlvbiBvbkZyYWdDaGFuZ2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5mbHVzaEJhY2tCdWZmZXIoKTtcbiAgfSAvLyBvbiBCVUZGRVJfRU9TIG1hcmsgbWF0Y2hpbmcgc291cmNlYnVmZmVyKHMpIGFzIGVuZGVkIGFuZCB0cmlnZ2VyIGNoZWNrRW9zKClcbiAgLy8gYW4gdW5kZWZpbmVkIGRhdGEudHlwZSB3aWxsIG1hcmsgYWxsIGJ1ZmZlcnMgYXMgRU9TLlxuICA7XG5cbiAgX3Byb3RvLm9uQnVmZmVyRW9zID0gZnVuY3Rpb24gb25CdWZmZXJFb3MoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgIHZhciBlbmRlZCA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdHlwZSkge1xuICAgICAgdmFyIHNiID0gX3RoaXM4LnNvdXJjZUJ1ZmZlclt0eXBlXTtcblxuICAgICAgaWYgKCFkYXRhLnR5cGUgfHwgZGF0YS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgIGlmIChzYiAmJiAhc2IuZW5kZWQpIHtcbiAgICAgICAgICBzYi5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IFwiICsgdHlwZSArIFwiIHNvdXJjZUJ1ZmZlciBub3cgRU9TXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2MgJiYgISEoIXNiIHx8IHNiLmVuZGVkKTtcbiAgICB9LCB0cnVlKTtcblxuICAgIGlmIChlbmRlZCkge1xuICAgICAgdGhpcy5ibG9ja0J1ZmZlcnMoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWVkaWFTb3VyY2UgPSBfdGhpczgubWVkaWFTb3VyY2U7XG5cbiAgICAgICAgaWYgKCFtZWRpYVNvdXJjZSB8fCBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQWxsb3cgdGhpcyB0byB0aHJvdyBhbmQgYmUgY2F1Z2h0IGJ5IHRoZSBlbnF1ZXVlaW5nIGZ1bmN0aW9uXG5cblxuICAgICAgICBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkxldmVsVXBkYXRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxVcGRhdGVkKGV2ZW50LCBfcmVmKSB7XG4gICAgdmFyIGRldGFpbHMgPSBfcmVmLmRldGFpbHM7XG5cbiAgICBpZiAoIWRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG5cbiAgICBpZiAodGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aCkge1xuICAgICAgdGhpcy5ibG9ja0J1ZmZlcnModGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZmx1c2hCYWNrQnVmZmVyID0gZnVuY3Rpb24gZmx1c2hCYWNrQnVmZmVyKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgZGV0YWlscyA9IHRoaXMuZGV0YWlscyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcblxuICAgIGlmICghbWVkaWEgfHwgZGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VCdWZmZXJUeXBlcyA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKTtcblxuICAgIGlmICghc291cmNlQnVmZmVyVHlwZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBTdXBwb3J0IGZvciBkZXByZWNhdGVkIGxpdmVCYWNrQnVmZmVyTGVuZ3RoXG5cblxuICAgIHZhciBiYWNrQnVmZmVyTGVuZ3RoID0gZGV0YWlscy5saXZlICYmIGhscy5jb25maWcubGl2ZUJhY2tCdWZmZXJMZW5ndGggIT09IG51bGwgPyBobHMuY29uZmlnLmxpdmVCYWNrQnVmZmVyTGVuZ3RoIDogaGxzLmNvbmZpZy5iYWNrQnVmZmVyTGVuZ3RoO1xuXG4gICAgaWYgKCFPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGJhY2tCdWZmZXJMZW5ndGgpIHx8IGJhY2tCdWZmZXJMZW5ndGggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgdmFyIHRhcmdldER1cmF0aW9uID0gZGV0YWlscy5sZXZlbFRhcmdldER1cmF0aW9uO1xuICAgIHZhciBtYXhCYWNrQnVmZmVyTGVuZ3RoID0gTWF0aC5tYXgoYmFja0J1ZmZlckxlbmd0aCwgdGFyZ2V0RHVyYXRpb24pO1xuICAgIHZhciB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24gPSBNYXRoLmZsb29yKGN1cnJlbnRUaW1lIC8gdGFyZ2V0RHVyYXRpb24pICogdGFyZ2V0RHVyYXRpb24gLSBtYXhCYWNrQnVmZmVyTGVuZ3RoO1xuICAgIHNvdXJjZUJ1ZmZlclR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHZhciBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcblxuICAgICAgaWYgKHNiKSB7XG4gICAgICAgIHZhciBidWZmZXJlZCA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJCdWZmZXJIZWxwZXJcIl0uZ2V0QnVmZmVyZWQoc2IpOyAvLyB3aGVuIHRhcmdldCBidWZmZXIgc3RhcnQgZXhjZWVkcyBhY3R1YWwgYnVmZmVyIHN0YXJ0XG5cbiAgICAgICAgaWYgKGJ1ZmZlcmVkLmxlbmd0aCA+IDAgJiYgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uID4gYnVmZmVyZWQuc3RhcnQoMCkpIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQkFDS19CVUZGRVJfUkVBQ0hFRCwge1xuICAgICAgICAgICAgYnVmZmVyRW5kOiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb25cbiAgICAgICAgICB9KTsgLy8gU3VwcG9ydCBmb3IgZGVwcmVjYXRlZCBldmVudDpcblxuICAgICAgICAgIGlmIChkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5MSVZFX0JBQ0tfQlVGRkVSX1JFQUNIRUQsIHtcbiAgICAgICAgICAgICAgYnVmZmVyRW5kOiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiAwLFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24sXG4gICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiB0byBjdXJyZW50IGxldmVsIGR1cmF0aW9uIG9yIG92ZXJyaWRlIHRvIEluZmluaXR5IGlmIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyXG4gICAqICdsaXZlRHVyYXRpb25JbmZpbml0eWAgaXMgc2V0IHRvIGB0cnVlYFxuICAgKiBNb3JlIGRldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8zNTVcbiAgICovXG4gIDtcblxuICBfcHJvdG8udXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24gPSBmdW5jdGlvbiB1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZGV0YWlscyB8fCAhdGhpcy5tZWRpYSB8fCAhdGhpcy5tZWRpYVNvdXJjZSB8fCB0aGlzLm1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkZXRhaWxzID0gdGhpcy5kZXRhaWxzLFxuICAgICAgICBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgdmFyIGxldmVsRHVyYXRpb24gPSBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydCArIGRldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICB2YXIgbWVkaWFEdXJhdGlvbiA9IG1lZGlhLmR1cmF0aW9uO1xuICAgIHZhciBtc0R1cmF0aW9uID0gT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShtZWRpYVNvdXJjZS5kdXJhdGlvbikgPyBtZWRpYVNvdXJjZS5kdXJhdGlvbiA6IDA7XG5cbiAgICBpZiAoZGV0YWlscy5saXZlICYmIGhscy5jb25maWcubGl2ZUR1cmF0aW9uSW5maW5pdHkpIHtcbiAgICAgIC8vIE92ZXJyaWRlIGR1cmF0aW9uIHRvIEluZmluaXR5XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBNZWRpYSBTb3VyY2UgZHVyYXRpb24gaXMgc2V0IHRvIEluZmluaXR5Jyk7XG4gICAgICBtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IEluZmluaXR5O1xuICAgICAgdGhpcy51cGRhdGVTZWVrYWJsZVJhbmdlKGRldGFpbHMpO1xuICAgIH0gZWxzZSBpZiAobGV2ZWxEdXJhdGlvbiA+IG1zRHVyYXRpb24gJiYgbGV2ZWxEdXJhdGlvbiA+IG1lZGlhRHVyYXRpb24gfHwgIU9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkobWVkaWFEdXJhdGlvbikpIHtcbiAgICAgIC8vIGxldmVsRHVyYXRpb24gd2FzIHRoZSBsYXN0IHZhbHVlIHdlIHNldC5cbiAgICAgIC8vIG5vdCB1c2luZyBtZWRpYVNvdXJjZS5kdXJhdGlvbiBhcyB0aGUgYnJvd3NlciBtYXkgdHdlYWsgdGhpcyB2YWx1ZVxuICAgICAgLy8gb25seSB1cGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIGlmIGl0cyB2YWx1ZSBpbmNyZWFzZSwgdGhpcyBpcyB0byBhdm9pZFxuICAgICAgLy8gZmx1c2hpbmcgYWxyZWFkeSBidWZmZXJlZCBwb3J0aW9uIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gcXVhbGl0eSBsZXZlbFxuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IFVwZGF0aW5nIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiB0byBcIiArIGxldmVsRHVyYXRpb24udG9GaXhlZCgzKSk7XG4gICAgICBtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IGxldmVsRHVyYXRpb247XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by51cGRhdGVTZWVrYWJsZVJhbmdlID0gZnVuY3Rpb24gdXBkYXRlU2Vla2FibGVSYW5nZShsZXZlbERldGFpbHMpIHtcbiAgICB2YXIgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIHZhciBmcmFnbWVudHMgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzO1xuICAgIHZhciBsZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiAmJiBsZXZlbERldGFpbHMubGl2ZSAmJiBtZWRpYVNvdXJjZSAhPT0gbnVsbCAmJiBtZWRpYVNvdXJjZSAhPT0gdm9pZCAwICYmIG1lZGlhU291cmNlLnNldExpdmVTZWVrYWJsZVJhbmdlKSB7XG4gICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heCgwLCBmcmFnbWVudHNbMF0uc3RhcnQpO1xuICAgICAgdmFyIGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBzdGFydCArIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uKTtcbiAgICAgIG1lZGlhU291cmNlLnNldExpdmVTZWVrYWJsZVJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY2hlY2tQZW5kaW5nVHJhY2tzID0gZnVuY3Rpb24gY2hlY2tQZW5kaW5nVHJhY2tzKCkge1xuICAgIHZhciBidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkLFxuICAgICAgICBvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWUsXG4gICAgICAgIHBlbmRpbmdUcmFja3MgPSB0aGlzLnBlbmRpbmdUcmFja3M7IC8vIENoZWNrIGlmIHdlJ3ZlIHJlY2VpdmVkIGFsbCBvZiB0aGUgZXhwZWN0ZWQgYnVmZmVyQ29kZWMgZXZlbnRzLiBXaGVuIG5vbmUgcmVtYWluLCBjcmVhdGUgYWxsIHRoZSBzb3VyY2VCdWZmZXJzIGF0IG9uY2UuXG4gICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgTVNFIHNwZWMgYWxsb3dzIGltcGxlbWVudGF0aW9ucyB0byB0aHJvdyBRdW90YUV4Y2VlZGVkRXJyb3JzIGlmIGNyZWF0aW5nIG5ldyBzb3VyY2VCdWZmZXJzIGFmdGVyXG4gICAgLy8gZGF0YSBoYXMgYmVlbiBhcHBlbmRlZCB0byBleGlzdGluZyBvbmVzLlxuICAgIC8vIDIgdHJhY2tzIGlzIHRoZSBtYXggKG9uZSBmb3IgYXVkaW8sIG9uZSBmb3IgdmlkZW8pLiBJZiB3ZSd2ZSByZWFjaCB0aGlzIG1heCBnbyBhaGVhZCBhbmQgY3JlYXRlIHRoZSBidWZmZXJzLlxuXG4gICAgdmFyIHBlbmRpbmdUcmFja3NDb3VudCA9IE9iamVjdC5rZXlzKHBlbmRpbmdUcmFja3MpLmxlbmd0aDtcblxuICAgIGlmIChwZW5kaW5nVHJhY2tzQ291bnQgJiYgIWJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgfHwgcGVuZGluZ1RyYWNrc0NvdW50ID09PSAyKSB7XG4gICAgICAvLyBvaywgbGV0J3MgY3JlYXRlIHRoZW0gbm93ICFcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlQnVmZmVycyhwZW5kaW5nVHJhY2tzKTtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9OyAvLyBhcHBlbmQgYW55IHBlbmRpbmcgc2VnbWVudHMgbm93ICFcblxuICAgICAgdmFyIGJ1ZmZlcnMgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCk7XG5cbiAgICAgIGlmIChidWZmZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkVycm9yVHlwZXNcIl0uTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXJyb3JEZXRhaWxzXCJdLkJVRkZFUl9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgIHJlYXNvbjogJ2NvdWxkIG5vdCBjcmVhdGUgc291cmNlIGJ1ZmZlciBmb3IgbWVkaWEgY29kZWMocyknXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBvcGVyYXRpb25RdWV1ZS5leGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY3JlYXRlU291cmNlQnVmZmVycyA9IGZ1bmN0aW9uIGNyZWF0ZVNvdXJjZUJ1ZmZlcnModHJhY2tzKSB7XG4gICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLFxuICAgICAgICBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG5cbiAgICBpZiAoIW1lZGlhU291cmNlKSB7XG4gICAgICB0aHJvdyBFcnJvcignY3JlYXRlU291cmNlQnVmZmVycyBjYWxsZWQgd2hlbiBtZWRpYVNvdXJjZSB3YXMgbnVsbCcpO1xuICAgIH1cblxuICAgIHZhciB0cmFja3NDcmVhdGVkID0gMDtcblxuICAgIGZvciAodmFyIHRyYWNrTmFtZSBpbiB0cmFja3MpIHtcbiAgICAgIGlmICghc291cmNlQnVmZmVyW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XG5cbiAgICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICAgIHRocm93IEVycm9yKFwic291cmNlIGJ1ZmZlciBleGlzdHMgZm9yIHRyYWNrIFwiICsgdHJhY2tOYW1lICsgXCIsIGhvd2V2ZXIgdHJhY2sgZG9lcyBub3RcIik7XG4gICAgICAgIH0gLy8gdXNlIGxldmVsQ29kZWMgYXMgZmlyc3QgcHJpb3JpdHlcblxuXG4gICAgICAgIHZhciBjb2RlYyA9IHRyYWNrLmxldmVsQ29kZWMgfHwgdHJhY2suY29kZWM7XG4gICAgICAgIHZhciBtaW1lVHlwZSA9IHRyYWNrLmNvbnRhaW5lciArIFwiO2NvZGVjcz1cIiArIGNvZGVjO1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKFwiW2J1ZmZlci1jb250cm9sbGVyXTogY3JlYXRpbmcgc291cmNlQnVmZmVyKFwiICsgbWltZVR5cGUgKyBcIilcIik7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgc2IgPSBzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSA9IG1lZGlhU291cmNlLmFkZFNvdXJjZUJ1ZmZlcihtaW1lVHlwZSk7XG4gICAgICAgICAgdmFyIHNiTmFtZSA9IHRyYWNrTmFtZTtcbiAgICAgICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHNiTmFtZSwgJ3VwZGF0ZXN0YXJ0JywgdGhpcy5fb25TQlVwZGF0ZVN0YXJ0KTtcbiAgICAgICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHNiTmFtZSwgJ3VwZGF0ZWVuZCcsIHRoaXMuX29uU0JVcGRhdGVFbmQpO1xuICAgICAgICAgIHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIoc2JOYW1lLCAnZXJyb3InLCB0aGlzLl9vblNCVXBkYXRlRXJyb3IpO1xuICAgICAgICAgIHRoaXMudHJhY2tzW3RyYWNrTmFtZV0gPSB7XG4gICAgICAgICAgICBidWZmZXI6IHNiLFxuICAgICAgICAgICAgY29kZWM6IGNvZGVjLFxuICAgICAgICAgICAgY29udGFpbmVyOiB0cmFjay5jb250YWluZXIsXG4gICAgICAgICAgICBsZXZlbENvZGVjOiB0cmFjay5sZXZlbENvZGVjLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRyYWNrLm1ldGFkYXRhLFxuICAgICAgICAgICAgaWQ6IHRyYWNrLmlkXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0cmFja3NDcmVhdGVkKys7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcihcIltidWZmZXItY29udHJvbGxlcl06IGVycm9yIHdoaWxlIHRyeWluZyB0byBhZGQgc291cmNlQnVmZmVyOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXJyb3JUeXBlc1wiXS5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkVycm9yRGV0YWlsc1wiXS5CVUZGRVJfQUREX0NPREVDX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRyYWNrc0NyZWF0ZWQpIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9DUkVBVEVELCB7XG4gICAgICAgIHRyYWNrczogdGhpcy50cmFja3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBLZWVwIGFzIGFycm93IGZ1bmN0aW9ucyBzbyB0aGF0IHdlIGNhbiBkaXJlY3RseSByZWZlcmVuY2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IGFzIGV2ZW50IGxpc3RlbmVyc1xuICA7XG5cbiAgX3Byb3RvLl9vblNCVXBkYXRlU3RhcnQgPSBmdW5jdGlvbiBfb25TQlVwZGF0ZVN0YXJ0KHR5cGUpIHtcbiAgICB2YXIgb3BlcmF0aW9uUXVldWUgPSB0aGlzLm9wZXJhdGlvblF1ZXVlO1xuICAgIHZhciBvcGVyYXRpb24gPSBvcGVyYXRpb25RdWV1ZS5jdXJyZW50KHR5cGUpO1xuICAgIG9wZXJhdGlvbi5vblN0YXJ0KCk7XG4gIH07XG5cbiAgX3Byb3RvLl9vblNCVXBkYXRlRW5kID0gZnVuY3Rpb24gX29uU0JVcGRhdGVFbmQodHlwZSkge1xuICAgIHZhciBvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWU7XG4gICAgdmFyIG9wZXJhdGlvbiA9IG9wZXJhdGlvblF1ZXVlLmN1cnJlbnQodHlwZSk7XG4gICAgb3BlcmF0aW9uLm9uQ29tcGxldGUoKTtcbiAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICB9O1xuXG4gIF9wcm90by5fb25TQlVwZGF0ZUVycm9yID0gZnVuY3Rpb24gX29uU0JVcGRhdGVFcnJvcih0eXBlLCBldmVudCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcihcIltidWZmZXItY29udHJvbGxlcl06IFwiICsgdHlwZSArIFwiIFNvdXJjZUJ1ZmZlciBlcnJvclwiLCBldmVudCk7IC8vIGFjY29yZGluZyB0byBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3NvdXJjZWJ1ZmZlci1hcHBlbmQtZXJyb3JcbiAgICAvLyBTb3VyY2VCdWZmZXIgZXJyb3JzIGFyZSBub3QgbmVjZXNzYXJpbHkgZmF0YWw7IGlmIHNvLCB0aGUgSFRNTE1lZGlhRWxlbWVudCB3aWxsIGZpcmUgYW4gZXJyb3IgZXZlbnRcblxuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFcnJvclR5cGVzXCJdLk1FRElBX0VSUk9SLFxuICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXJyb3JEZXRhaWxzXCJdLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsXG4gICAgICBmYXRhbDogZmFsc2VcbiAgICB9KTsgLy8gdXBkYXRlZW5kIGlzIGFsd2F5cyBmaXJlZCBhZnRlciBlcnJvciwgc28gd2UnbGwgYWxsb3cgdGhhdCB0byBzaGlmdCB0aGUgY3VycmVudCBvcGVyYXRpb24gb2ZmIG9mIHRoZSBxdWV1ZVxuXG4gICAgdmFyIG9wZXJhdGlvbiA9IHRoaXMub3BlcmF0aW9uUXVldWUuY3VycmVudCh0eXBlKTtcblxuICAgIGlmIChvcGVyYXRpb24pIHtcbiAgICAgIG9wZXJhdGlvbi5vbkVycm9yKGV2ZW50KTtcbiAgICB9XG4gIH0gLy8gVGhpcyBtZXRob2QgbXVzdCByZXN1bHQgaW4gYW4gdXBkYXRlZW5kIGV2ZW50OyBpZiByZW1vdmUgaXMgbm90IGNhbGxlZCwgX29uU0JVcGRhdGVFbmQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHlcbiAgO1xuXG4gIF9wcm90by5yZW1vdmVFeGVjdXRvciA9IGZ1bmN0aW9uIHJlbW92ZUV4ZWN1dG9yKHR5cGUsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2UsXG4gICAgICAgIG9wZXJhdGlvblF1ZXVlID0gdGhpcy5vcGVyYXRpb25RdWV1ZSxcbiAgICAgICAgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgdmFyIHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuXG4gICAgaWYgKCFtZWRpYSB8fCAhbWVkaWFTb3VyY2UgfHwgIXNiKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybihcIltidWZmZXItY29udHJvbGxlcl06IEF0dGVtcHRpbmcgdG8gcmVtb3ZlIGZyb20gdGhlIFwiICsgdHlwZSArIFwiIFNvdXJjZUJ1ZmZlciwgYnV0IGl0IGRvZXMgbm90IGV4aXN0XCIpO1xuICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWVkaWFEdXJhdGlvbiA9IE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkobWVkaWEuZHVyYXRpb24pID8gbWVkaWEuZHVyYXRpb24gOiBJbmZpbml0eTtcbiAgICB2YXIgbXNEdXJhdGlvbiA9IE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkobWVkaWFTb3VyY2UuZHVyYXRpb24pID8gbWVkaWFTb3VyY2UuZHVyYXRpb24gOiBJbmZpbml0eTtcbiAgICB2YXIgcmVtb3ZlU3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydE9mZnNldCk7XG4gICAgdmFyIHJlbW92ZUVuZCA9IE1hdGgubWluKGVuZE9mZnNldCwgbWVkaWFEdXJhdGlvbiwgbXNEdXJhdGlvbik7XG5cbiAgICBpZiAocmVtb3ZlRW5kID4gcmVtb3ZlU3RhcnQpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBSZW1vdmluZyBbXCIgKyByZW1vdmVTdGFydCArIFwiLFwiICsgcmVtb3ZlRW5kICsgXCJdIGZyb20gdGhlIFwiICsgdHlwZSArIFwiIFNvdXJjZUJ1ZmZlclwiKTtcbiAgICAgIGNvbnNvbGUuYXNzZXJ0KCFzYi51cGRhdGluZywgdHlwZSArIFwiIHNvdXJjZUJ1ZmZlciBtdXN0IG5vdCBiZSB1cGRhdGluZ1wiKTtcbiAgICAgIHNiLnJlbW92ZShyZW1vdmVTdGFydCwgcmVtb3ZlRW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3ljbGUgdGhlIHF1ZXVlXG4gICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgIH1cbiAgfSAvLyBUaGlzIG1ldGhvZCBtdXN0IHJlc3VsdCBpbiBhbiB1cGRhdGVlbmQgZXZlbnQ7IGlmIGFwcGVuZCBpcyBub3QgY2FsbGVkLCBfb25TQlVwZGF0ZUVuZCBtdXN0IGJlIGNhbGxlZCBtYW51YWxseVxuICA7XG5cbiAgX3Byb3RvLmFwcGVuZEV4ZWN1dG9yID0gZnVuY3Rpb24gYXBwZW5kRXhlY3V0b3IoZGF0YSwgdHlwZSkge1xuICAgIHZhciBvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWUsXG4gICAgICAgIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgIHZhciBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcblxuICAgIGlmICghc2IpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKFwiW2J1ZmZlci1jb250cm9sbGVyXTogQXR0ZW1wdGluZyB0byBhcHBlbmQgdG8gdGhlIFwiICsgdHlwZSArIFwiIFNvdXJjZUJ1ZmZlciwgYnV0IGl0IGRvZXMgbm90IGV4aXN0XCIpO1xuICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzYi5lbmRlZCA9IGZhbHNlO1xuICAgIGNvbnNvbGUuYXNzZXJ0KCFzYi51cGRhdGluZywgdHlwZSArIFwiIHNvdXJjZUJ1ZmZlciBtdXN0IG5vdCBiZSB1cGRhdGluZ1wiKTtcbiAgICBzYi5hcHBlbmRCdWZmZXIoZGF0YSk7XG4gIH0gLy8gRW5xdWV1ZXMgYW4gb3BlcmF0aW9uIHRvIGVhY2ggU291cmNlQnVmZmVyIHF1ZXVlIHdoaWNoLCB1cG9uIGV4ZWN1dGlvbiwgcmVzb2x2ZXMgYSBwcm9taXNlLiBXaGVuIGFsbCBwcm9taXNlc1xuICAvLyByZXNvbHZlLCB0aGUgb25VbmJsb2NrZWQgZnVuY3Rpb24gaXMgZXhlY3V0ZWQuIEZ1bmN0aW9ucyBjYWxsaW5nIHRoaXMgbWV0aG9kIGRvIG5vdCBuZWVkIHRvIHVuYmxvY2sgdGhlIHF1ZXVlXG4gIC8vIHVwb24gY29tcGxldGlvbiwgc2luY2Ugd2UgYWxyZWFkeSBkbyBpdCBoZXJlXG4gIDtcblxuICBfcHJvdG8uYmxvY2tCdWZmZXJzID0gZnVuY3Rpb24gYmxvY2tCdWZmZXJzKG9uVW5ibG9ja2VkLCBidWZmZXJzKSB7XG4gICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICBpZiAoYnVmZmVycyA9PT0gdm9pZCAwKSB7XG4gICAgICBidWZmZXJzID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpO1xuICAgIH1cblxuICAgIGlmICghYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coJ1tidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nIG9wZXJhdGlvbiByZXF1ZXN0ZWQsIGJ1dCBubyBTb3VyY2VCdWZmZXJzIGV4aXN0Jyk7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKG9uVW5ibG9ja2VkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3BlcmF0aW9uUXVldWUgPSB0aGlzLm9wZXJhdGlvblF1ZXVlOyAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nICR7YnVmZmVyc30gU291cmNlQnVmZmVyYCk7XG5cbiAgICB2YXIgYmxvY2tpbmdPcGVyYXRpb25zID0gYnVmZmVycy5tYXAoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiBvcGVyYXRpb25RdWV1ZS5hcHBlbmRCbG9ja2VyKHR5cGUpO1xuICAgIH0pO1xuICAgIFByb21pc2UuYWxsKGJsb2NraW5nT3BlcmF0aW9ucykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nIG9wZXJhdGlvbiByZXNvbHZlZDsgdW5ibG9ja2luZyAke2J1ZmZlcnN9IFNvdXJjZUJ1ZmZlcmApO1xuICAgICAgb25VbmJsb2NrZWQoKTtcbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgc2IgPSBfdGhpczkuc291cmNlQnVmZmVyW3R5cGVdOyAvLyBPbmx5IGN5Y2xlIHRoZSBxdWV1ZSBpZiB0aGUgU0IgaXMgbm90IHVwZGF0aW5nLiBUaGVyZSdzIGEgYnVnIGluIENocm9tZSB3aGljaCBzZXRzIHRoZSBTQiB1cGRhdGluZyBmbGFnIHRvXG4gICAgICAgIC8vIHRydWUgd2hlbiBjaGFuZ2luZyB0aGUgTWVkaWFTb3VyY2UgZHVyYXRpb24gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk1OTM1OSZjYW49MiZxPW1lZGlhc291cmNlJTIwZHVyYXRpb24pXG4gICAgICAgIC8vIFdoaWxlIHRoaXMgaXMgYSB3b3JrYXJvdW5kLCBpdCdzIHByb2JhYmx5IHVzZWZ1bCB0byBoYXZlIGFyb3VuZFxuXG4gICAgICAgIGlmICghc2IgfHwgIXNiLnVwZGF0aW5nKSB7XG4gICAgICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldFNvdXJjZUJ1ZmZlclR5cGVzID0gZnVuY3Rpb24gZ2V0U291cmNlQnVmZmVyVHlwZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVyKTtcbiAgfTtcblxuICBfcHJvdG8uYWRkQnVmZmVyTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRCdWZmZXJMaXN0ZW5lcih0eXBlLCBldmVudCwgZm4pIHtcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG5cbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lciA9IGZuLmJpbmQodGhpcywgdHlwZSk7XG4gICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaCh7XG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgICB9KTtcbiAgICBidWZmZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICB9O1xuXG4gIF9wcm90by5yZW1vdmVCdWZmZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVCdWZmZXJMaXN0ZW5lcnModHlwZSkge1xuICAgIHZhciBidWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcblxuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgYnVmZmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobC5ldmVudCwgbC5saXN0ZW5lcik7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckNvbnRyb2xsZXI7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2J1ZmZlci1vcGVyYXRpb24tcXVldWUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYnVmZmVyLW9wZXJhdGlvbi1xdWV1ZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQnVmZmVyT3BlcmF0aW9uUXVldWU7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcblxuXG52YXIgQnVmZmVyT3BlcmF0aW9uUXVldWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJPcGVyYXRpb25RdWV1ZShzb3VyY2VCdWZmZXJSZWZlcmVuY2UpIHtcbiAgICB0aGlzLmJ1ZmZlcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5xdWV1ZXMgPSB7XG4gICAgICB2aWRlbzogW10sXG4gICAgICBhdWRpbzogW10sXG4gICAgICBhdWRpb3ZpZGVvOiBbXVxuICAgIH07XG4gICAgdGhpcy5idWZmZXJzID0gc291cmNlQnVmZmVyUmVmZXJlbmNlO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEJ1ZmZlck9wZXJhdGlvblF1ZXVlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSkge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWVzW3R5cGVdO1xuICAgIHF1ZXVlLnB1c2gob3BlcmF0aW9uKTtcblxuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgdGhpcy5idWZmZXJzW3R5cGVdKSB7XG4gICAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaW5zZXJ0QWJvcnQgPSBmdW5jdGlvbiBpbnNlcnRBYm9ydChvcGVyYXRpb24sIHR5cGUpIHtcbiAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlc1t0eXBlXTtcbiAgICBxdWV1ZS51bnNoaWZ0KG9wZXJhdGlvbik7XG4gICAgdGhpcy5leGVjdXRlTmV4dCh0eXBlKTtcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kQmxvY2tlciA9IGZ1bmN0aW9uIGFwcGVuZEJsb2NrZXIodHlwZSkge1xuICAgIHZhciBleGVjdXRlO1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGV4ZWN1dGUgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIHZhciBvcGVyYXRpb24gPSB7XG4gICAgICBleGVjdXRlOiBleGVjdXRlLFxuICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHt9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHt9LFxuICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcigpIHt9XG4gICAgfTtcbiAgICB0aGlzLmFwcGVuZChvcGVyYXRpb24sIHR5cGUpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIF9wcm90by5leGVjdXRlTmV4dCA9IGZ1bmN0aW9uIGV4ZWN1dGVOZXh0KHR5cGUpIHtcbiAgICB2YXIgYnVmZmVycyA9IHRoaXMuYnVmZmVycyxcbiAgICAgICAgcXVldWVzID0gdGhpcy5xdWV1ZXM7XG4gICAgdmFyIHNiID0gYnVmZmVyc1t0eXBlXTtcbiAgICB2YXIgcXVldWUgPSBxdWV1ZXNbdHlwZV07XG5cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICB2YXIgb3BlcmF0aW9uID0gcXVldWVbMF07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIE9wZXJhdGlvbnMgYXJlIGV4cGVjdGVkIHRvIHJlc3VsdCBpbiBhbiAndXBkYXRlZW5kJyBldmVudCBiZWluZyBmaXJlZC4gSWYgbm90LCB0aGUgcXVldWUgd2lsbCBsb2NrLiBPcGVyYXRpb25zXG4gICAgICAgIC8vIHdoaWNoIGRvIG5vdCBlbmQgd2l0aCB0aGlzIGV2ZW50IG11c3QgY2FsbCBfb25TQlVwZGF0ZUVuZCBtYW51YWxseVxuICAgICAgICBvcGVyYXRpb24uZXhlY3V0ZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJsb2dnZXJcIl0ud2FybignW2J1ZmZlci1vcGVyYXRpb24tcXVldWVdOiBVbmhhbmRsZWQgZXhjZXB0aW9uIGV4ZWN1dGluZyB0aGUgY3VycmVudCBvcGVyYXRpb24nKTtcbiAgICAgICAgb3BlcmF0aW9uLm9uRXJyb3IoZSk7IC8vIE9ubHkgc2hpZnQgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIG9mZiwgb3RoZXJ3aXNlIHRoZSB1cGRhdGVlbmQgaGFuZGxlciB3aWxsIGRvIHRoaXMgZm9yIHVzXG5cbiAgICAgICAgaWYgKCFzYiB8fCAhc2IudXBkYXRpbmcpIHtcbiAgICAgICAgICBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgIHRoaXMuZXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNoaWZ0QW5kRXhlY3V0ZU5leHQgPSBmdW5jdGlvbiBzaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpIHtcbiAgICB0aGlzLnF1ZXVlc1t0eXBlXS5zaGlmdCgpO1xuICAgIHRoaXMuZXhlY3V0ZU5leHQodHlwZSk7XG4gIH07XG5cbiAgX3Byb3RvLmN1cnJlbnQgPSBmdW5jdGlvbiBjdXJyZW50KHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZXNbdHlwZV1bMF07XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlck9wZXJhdGlvblF1ZXVlO1xufSgpO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9jYXAtbGV2ZWwtY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvY2FwLWxldmVsLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLypcbiAqIGNhcCBzdHJlYW0gbGV2ZWwgdG8gbWVkaWEgc2l6ZSBkaW1lbnNpb24gY29udHJvbGxlclxuICovXG5cblxudmFyIENhcExldmVsQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENhcExldmVsQ29udHJvbGxlcihobHMpIHtcbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5maXJzdExldmVsID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gdm9pZCAwO1xuICAgIHRoaXMudGltZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdGhpcy5maXJzdExldmVsID0gLTE7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDYXBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXRTdHJlYW1Db250cm9sbGVyID0gZnVuY3Rpb24gc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKSB7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gc3RyZWFtQ29udHJvbGxlcjtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXIoKTtcblxuICAgIGlmICh0aGlzLmhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUpIHtcbiAgICAgIHRoaXMuc3RvcENhcHBpbmcoKTtcbiAgICB9XG5cbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsOyAvLyBAdHMtaWdub3JlXG5cbiAgICB0aGlzLmhscyA9IHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRlBTX0RST1BfTEVWRUxfQ0FQUElORywgdGhpcy5vbkZwc0Ryb3BMZXZlbENhcHBpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnVucmVnaXN0ZXJMaXN0ZW5lciA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcigpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRlBTX0RST1BfTEVWRUxfQ0FQUElORywgdGhpcy5vbkZwc0Ryb3BMZXZlbENhcHBpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5vbkZwc0Ryb3BMZXZlbENhcHBpbmcgPSBmdW5jdGlvbiBvbkZwc0Ryb3BMZXZlbENhcHBpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBEb24ndCBhZGQgYSByZXN0cmljdGVkIGxldmVsIG1vcmUgdGhhbiBvbmNlXG4gICAgaWYgKENhcExldmVsQ29udHJvbGxlci5pc0xldmVsQWxsb3dlZChkYXRhLmRyb3BwZWRMZXZlbCwgdGhpcy5yZXN0cmljdGVkTGV2ZWxzKSkge1xuICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLnB1c2goZGF0YS5kcm9wcGVkTGV2ZWwpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYUF0dGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ub25NYW5pZmVzdFBhcnNlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgdGhpcy5maXJzdExldmVsID0gZGF0YS5maXJzdExldmVsO1xuXG4gICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgZGF0YS52aWRlbykge1xuICAgICAgLy8gU3RhcnQgY2FwcGluZyBpbW1lZGlhdGVseSBpZiB0aGUgbWFuaWZlc3QgaGFzIHNpZ25hbGVkIHZpZGVvIGNvZGVjc1xuICAgICAgdGhpcy5zdGFydENhcHBpbmcoKTtcbiAgICB9XG4gIH0gLy8gT25seSBhY3RpdmF0ZSBjYXBwaW5nIHdoZW4gcGxheWluZyBhIHZpZGVvIHN0cmVhbTsgb3RoZXJ3aXNlLCBtdWx0aS1iaXRyYXRlIGF1ZGlvLW9ubHkgc3RyZWFtcyB3aWxsIGJlIHJlc3RyaWN0ZWRcbiAgLy8gdG8gdGhlIGZpcnN0IGxldmVsXG4gIDtcblxuICBfcHJvdG8ub25CdWZmZXJDb2RlY3MgPSBmdW5jdGlvbiBvbkJ1ZmZlckNvZGVjcyhldmVudCwgZGF0YSkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcblxuICAgIGlmIChobHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplICYmIGRhdGEudmlkZW8pIHtcbiAgICAgIC8vIElmIHRoZSBtYW5pZmVzdCBkaWQgbm90IHNpZ25hbCBhIHZpZGVvIGNvZGVjIGNhcHBpbmcgaGFzIGJlZW4gZGVmZXJyZWQgdW50aWwgd2UncmUgY2VydGFpbiB2aWRlbyBpcyBwcmVzZW50XG4gICAgICB0aGlzLnN0YXJ0Q2FwcGluZygpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdGhpcy5zdG9wQ2FwcGluZygpO1xuICB9O1xuXG4gIF9wcm90by5kZXRlY3RQbGF5ZXJTaXplID0gZnVuY3Rpb24gZGV0ZWN0UGxheWVyU2l6ZSgpIHtcbiAgICBpZiAodGhpcy5tZWRpYSAmJiB0aGlzLm1lZGlhSGVpZ2h0ID4gMCAmJiB0aGlzLm1lZGlhV2lkdGggPiAwKSB7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuXG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIGhscy5hdXRvTGV2ZWxDYXBwaW5nID0gdGhpcy5nZXRNYXhMZXZlbChsZXZlbHMubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgaWYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID4gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nICYmIHRoaXMuc3RyZWFtQ29udHJvbGxlcikge1xuICAgICAgICAgIC8vIGlmIGF1dG8gbGV2ZWwgY2FwcGluZyBoYXMgYSBoaWdoZXIgdmFsdWUgZm9yIHRoZSBwcmV2aW91cyBvbmUsIGZsdXNoIHRoZSBidWZmZXIgdXNpbmcgbmV4dExldmVsU3dpdGNoXG4gICAgICAgICAgLy8gdXN1YWxseSBoYXBwZW4gd2hlbiB0aGUgdXNlciBnbyB0byB0aGUgZnVsbHNjcmVlbiBtb2RlLlxuICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IGhscy5hdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKlxuICAgKiByZXR1cm5zIGxldmVsIHNob3VsZCBiZSB0aGUgb25lIHdpdGggdGhlIGRpbWVuc2lvbnMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHRoZSBtZWRpYSAocGxheWVyKSBkaW1lbnNpb25zIChzbyB0aGUgdmlkZW8gd2lsbCBiZSBkb3duc2NhbGVkKVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRNYXhMZXZlbCA9IGZ1bmN0aW9uIGdldE1heExldmVsKGNhcExldmVsSW5kZXgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcblxuICAgIGlmICghbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHZhciB2YWxpZExldmVscyA9IGxldmVscy5maWx0ZXIoZnVuY3Rpb24gKGxldmVsLCBpbmRleCkge1xuICAgICAgcmV0dXJuIENhcExldmVsQ29udHJvbGxlci5pc0xldmVsQWxsb3dlZChpbmRleCwgX3RoaXMucmVzdHJpY3RlZExldmVscykgJiYgaW5kZXggPD0gY2FwTGV2ZWxJbmRleDtcbiAgICB9KTtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgIHJldHVybiBDYXBMZXZlbENvbnRyb2xsZXIuZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZSh2YWxpZExldmVscywgdGhpcy5tZWRpYVdpZHRoLCB0aGlzLm1lZGlhSGVpZ2h0KTtcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRDYXBwaW5nID0gZnVuY3Rpb24gc3RhcnRDYXBwaW5nKCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAvLyBEb24ndCByZXNldCBjYXBwaW5nIGlmIHN0YXJ0ZWQgdHdpY2U7IHRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgbWFuaWZlc3Qgc2lnbmFscyBhIHZpZGVvIGNvZGVjXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHRoaXMuaGxzLmZpcnN0TGV2ZWwgPSB0aGlzLmdldE1heExldmVsKHRoaXMuZmlyc3RMZXZlbCk7XG4gICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgIHRoaXMudGltZXIgPSBzZWxmLnNldEludGVydmFsKHRoaXMuZGV0ZWN0UGxheWVyU2l6ZS5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICB0aGlzLmRldGVjdFBsYXllclNpemUoKTtcbiAgfTtcblxuICBfcHJvdG8uc3RvcENhcHBpbmcgPSBmdW5jdGlvbiBzdG9wQ2FwcGluZygpIHtcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSAtMTtcbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldERpbWVuc2lvbnMgPSBmdW5jdGlvbiBnZXREaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmNsaWVudFJlY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudFJlY3Q7XG4gICAgfVxuXG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICB2YXIgYm91bmRzUmVjdCA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcblxuICAgIGlmIChtZWRpYSkge1xuICAgICAgdmFyIGNsaWVudFJlY3QgPSBtZWRpYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGJvdW5kc1JlY3Qud2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICAgICAgYm91bmRzUmVjdC5oZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcblxuICAgICAgaWYgKCFib3VuZHNSZWN0LndpZHRoICYmICFib3VuZHNSZWN0LmhlaWdodCkge1xuICAgICAgICAvLyBXaGVuIHRoZSBtZWRpYSBlbGVtZW50IGhhcyBubyB3aWR0aCBvciBoZWlnaHQgKGVxdWl2YWxlbnQgdG8gbm90IGJlaW5nIGluIHRoZSBET00pLFxuICAgICAgICAvLyB0aGVuIHVzZSBpdHMgd2lkdGggYW5kIGhlaWdodCBhdHRyaWJ1dGVzIChtZWRpYS53aWR0aCwgbWVkaWEuaGVpZ2h0KVxuICAgICAgICBib3VuZHNSZWN0LndpZHRoID0gY2xpZW50UmVjdC5yaWdodCAtIGNsaWVudFJlY3QubGVmdCB8fCBtZWRpYS53aWR0aCB8fCAwO1xuICAgICAgICBib3VuZHNSZWN0LmhlaWdodCA9IGNsaWVudFJlY3QuYm90dG9tIC0gY2xpZW50UmVjdC50b3AgfHwgbWVkaWEuaGVpZ2h0IHx8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jbGllbnRSZWN0ID0gYm91bmRzUmVjdDtcbiAgICByZXR1cm4gYm91bmRzUmVjdDtcbiAgfTtcblxuICBDYXBMZXZlbENvbnRyb2xsZXIuaXNMZXZlbEFsbG93ZWQgPSBmdW5jdGlvbiBpc0xldmVsQWxsb3dlZChsZXZlbCwgcmVzdHJpY3RlZExldmVscykge1xuICAgIGlmIChyZXN0cmljdGVkTGV2ZWxzID09PSB2b2lkIDApIHtcbiAgICAgIHJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdHJpY3RlZExldmVscy5pbmRleE9mKGxldmVsKSA9PT0gLTE7XG4gIH07XG5cbiAgQ2FwTGV2ZWxDb250cm9sbGVyLmdldE1heExldmVsQnlNZWRpYVNpemUgPSBmdW5jdGlvbiBnZXRNYXhMZXZlbEJ5TWVkaWFTaXplKGxldmVscywgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghbGV2ZWxzIHx8ICFsZXZlbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAvLyBMZXZlbHMgY2FuIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucyBidXQgZGlmZmVyaW5nIGJhbmR3aWR0aHMgLSBzaW5jZSBsZXZlbHMgYXJlIG9yZGVyZWQsIHdlIGNhbiBsb29rIHRvIHRoZSBuZXh0XG4gICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2UndmUgY2hvc2VuIHRoZSBncmVhdGVzdCBiYW5kd2lkdGggZm9yIHRoZSBtZWRpYSdzIGRpbWVuc2lvbnNcblxuXG4gICAgdmFyIGF0R3JlYXRlc3RCYW5kd2lkdGggPSBmdW5jdGlvbiBhdEdyZWF0ZXN0QmFuZHdpZHRoKGN1ckxldmVsLCBuZXh0TGV2ZWwpIHtcbiAgICAgIGlmICghbmV4dExldmVsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3VyTGV2ZWwud2lkdGggIT09IG5leHRMZXZlbC53aWR0aCB8fCBjdXJMZXZlbC5oZWlnaHQgIT09IG5leHRMZXZlbC5oZWlnaHQ7XG4gICAgfTsgLy8gSWYgd2UgcnVuIHRocm91Z2ggdGhlIGxvb3Agd2l0aG91dCBicmVha2luZywgdGhlIG1lZGlhJ3MgZGltZW5zaW9ucyBhcmUgZ3JlYXRlciB0aGFuIGV2ZXJ5IGxldmVsLCBzbyBkZWZhdWx0IHRvXG4gICAgLy8gdGhlIG1heCBsZXZlbFxuXG5cbiAgICB2YXIgbWF4TGV2ZWxJbmRleCA9IGxldmVscy5sZW5ndGggLSAxO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tpXTtcblxuICAgICAgaWYgKChsZXZlbC53aWR0aCA+PSB3aWR0aCB8fCBsZXZlbC5oZWlnaHQgPj0gaGVpZ2h0KSAmJiBhdEdyZWF0ZXN0QmFuZHdpZHRoKGxldmVsLCBsZXZlbHNbaSArIDFdKSkge1xuICAgICAgICBtYXhMZXZlbEluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heExldmVsSW5kZXg7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKENhcExldmVsQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwibWVkaWFXaWR0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGltZW5zaW9ucygpLndpZHRoICogdGhpcy5jb250ZW50U2NhbGVGYWN0b3I7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1lZGlhSGVpZ2h0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXREaW1lbnNpb25zKCkuaGVpZ2h0ICogdGhpcy5jb250ZW50U2NhbGVGYWN0b3I7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRlbnRTY2FsZUZhY3RvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSAxO1xuXG4gICAgICBpZiAoIXRoaXMuaGxzLmNvbmZpZy5pZ25vcmVEZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGl4ZWxSYXRpbyA9IHNlbGYuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8qIG5vLW9wICovXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBpeGVsUmF0aW87XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhcExldmVsQ29udHJvbGxlcjtcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDYXBMZXZlbENvbnRyb2xsZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2NtY2QtY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2NtY2QtY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDTUNEQ29udHJvbGxlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19jbWNkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9jbWNkICovIFwiLi9zcmMvdHlwZXMvY21jZC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYnVmZmVyLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpOyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHJldHVybiBmdW5jdGlvbiAoKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cblxuXG5cblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGRlYWwgd2l0aCBDb21tb24gTWVkaWEgQ2xpZW50IERhdGEgKENNQ0QpXG4gKiBAc2VlIGh0dHBzOi8vY2RuLmN0YS50ZWNoL2N0YS9tZWRpYS9tZWRpYS9yZXNvdXJjZXMvc3RhbmRhcmRzL3BkZnMvY3RhLTUwMDQtZmluYWwucGRmXG4gKi9cblxudmFyIENNQ0RDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgZnVuY3Rpb24gQ01DRENvbnRyb2xsZXIoaGxzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSB2b2lkIDA7XG4gICAgdGhpcy5zaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5jaWQgPSB2b2lkIDA7XG4gICAgdGhpcy51c2VIZWFkZXJzID0gZmFsc2U7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnZlZCA9IGZhbHNlO1xuICAgIHRoaXMuYnVmZmVyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmF1ZGlvQnVmZmVyID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9CdWZmZXIgPSB2b2lkIDA7XG5cbiAgICB0aGlzLm9uV2FpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICBfdGhpcy5zdGFydmVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuYnVmZmVyaW5nID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdGhpcy5vblBsYXlpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIF90aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuYnVmZmVyaW5nID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuYXBwbHlQbGF5bGlzdERhdGEgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgX3RoaXMuYXBwbHkoY29udGV4dCwge1xuICAgICAgICAgIG90OiBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiQ01DRE9iamVjdFR5cGVcIl0uTUFOSUZFU1QsXG4gICAgICAgICAgc3U6ICFfdGhpcy5pbml0aWFsaXplZFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS53YXJuKCdDb3VsZCBub3QgZ2VuZXJhdGUgbWFuaWZlc3QgQ01DRCBkYXRhLicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5hcHBseUZyYWdtZW50RGF0YSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSBjb250ZXh0LmZyYWc7XG4gICAgICAgIHZhciBsZXZlbCA9IF90aGlzLmhscy5sZXZlbHNbZnJhZ21lbnQubGV2ZWxdO1xuXG4gICAgICAgIHZhciBvdCA9IF90aGlzLmdldE9iamVjdFR5cGUoZnJhZ21lbnQpO1xuXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgIGQ6IGZyYWdtZW50LmR1cmF0aW9uICogMTAwMCxcbiAgICAgICAgICBvdDogb3RcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3QgPT09IF90eXBlc19jbWNkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJDTUNET2JqZWN0VHlwZVwiXS5WSURFTyB8fCBvdCA9PT0gX3R5cGVzX2NtY2RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkNNQ0RPYmplY3RUeXBlXCJdLkFVRElPIHx8IG90ID09IF90eXBlc19jbWNkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJDTUNET2JqZWN0VHlwZVwiXS5NVVhFRCkge1xuICAgICAgICAgIGRhdGEuYnIgPSBsZXZlbC5iaXRyYXRlIC8gMTAwMDtcbiAgICAgICAgICBkYXRhLnRiID0gX3RoaXMuZ2V0VG9wQmFuZHdpZHRoKG90KSAvIDEwMDA7XG4gICAgICAgICAgZGF0YS5ibCA9IF90aGlzLmdldEJ1ZmZlckxlbmd0aChvdCk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5hcHBseShjb250ZXh0LCBkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS53YXJuKCdDb3VsZCBub3QgZ2VuZXJhdGUgc2VnbWVudCBDTUNEIGRhdGEuJywgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHZhciBjbWNkID0gY29uZmlnLmNtY2Q7XG5cbiAgICBpZiAoY21jZCAhPSBudWxsKSB7XG4gICAgICBjb25maWcucExvYWRlciA9IHRoaXMuY3JlYXRlUGxheWxpc3RMb2FkZXIoKTtcbiAgICAgIGNvbmZpZy5mTG9hZGVyID0gdGhpcy5jcmVhdGVGcmFnbWVudExvYWRlcigpO1xuICAgICAgdGhpcy5zaWQgPSBjbWNkLnNlc3Npb25JZCB8fCBDTUNEQ29udHJvbGxlci51dWlkKCk7XG4gICAgICB0aGlzLmNpZCA9IGNtY2QuY29udGVudElkO1xuICAgICAgdGhpcy51c2VIZWFkZXJzID0gY21jZC51c2VIZWFkZXJzID09PSB0cnVlO1xuICAgICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDTUNEQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgdGhpcy5vbk1lZGlhRGV0YWNoZWQoKTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7IC8vIEB0cy1pZ25vcmVcblxuICAgIHRoaXMuaGxzID0gdGhpcy5jb25maWcgPSB0aGlzLmF1ZGlvQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMubWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignd2FpdGluZycsIHRoaXMub25XYWl0aW5nKTtcbiAgICB0aGlzLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCB0aGlzLm9uUGxheWluZyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFEZXRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hlZCgpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dhaXRpbmcnLCB0aGlzLm9uV2FpdGluZyk7XG4gICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgdGhpcy5vblBsYXlpbmcpOyAvLyBAdHMtaWdub3JlXG5cbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ub25CdWZmZXJDcmVhdGVkID0gZnVuY3Rpb24gb25CdWZmZXJDcmVhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJHRyYWNrcyRhdWRpbywgX2RhdGEkdHJhY2tzJHZpZGVvO1xuXG4gICAgdGhpcy5hdWRpb0J1ZmZlciA9IChfZGF0YSR0cmFja3MkYXVkaW8gPSBkYXRhLnRyYWNrcy5hdWRpbykgPT09IG51bGwgfHwgX2RhdGEkdHJhY2tzJGF1ZGlvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGF0YSR0cmFja3MkYXVkaW8uYnVmZmVyO1xuICAgIHRoaXMudmlkZW9CdWZmZXIgPSAoX2RhdGEkdHJhY2tzJHZpZGVvID0gZGF0YS50cmFja3MudmlkZW8pID09PSBudWxsIHx8IF9kYXRhJHRyYWNrcyR2aWRlbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RhdGEkdHJhY2tzJHZpZGVvLmJ1ZmZlcjtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGJhc2VsaW5lIENNQ0QgZGF0YVxuICAgKi9cbiAgX3Byb3RvLmNyZWF0ZURhdGEgPSBmdW5jdGlvbiBjcmVhdGVEYXRhKCkge1xuICAgIHZhciBfdGhpcyRtZWRpYTtcblxuICAgIHJldHVybiB7XG4gICAgICB2OiBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiQ01DRFZlcnNpb25cIl0sXG4gICAgICBzZjogX3R5cGVzX2NtY2RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkNNQ0RTdHJlYW1pbmdGb3JtYXRcIl0uSExTLFxuICAgICAgc2lkOiB0aGlzLnNpZCxcbiAgICAgIGNpZDogdGhpcy5jaWQsXG4gICAgICBwcjogKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgPT09IG51bGwgfHwgX3RoaXMkbWVkaWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhLnBsYXliYWNrUmF0ZSxcbiAgICAgIG10cDogdGhpcy5obHMuYmFuZHdpZHRoRXN0aW1hdGUgLyAxMDAwXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQXBwbHkgQ01DRCBkYXRhIHRvIGEgcmVxdWVzdC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYXBwbHkgPSBmdW5jdGlvbiBhcHBseShjb250ZXh0LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgZGF0YSA9IHt9O1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGJhc2VsaW5lIGRhdGFcbiAgICBfZXh0ZW5kcyhkYXRhLCB0aGlzLmNyZWF0ZURhdGEoKSk7XG5cbiAgICB2YXIgaXNWaWRlbyA9IGRhdGEub3QgPT09IF90eXBlc19jbWNkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJDTUNET2JqZWN0VHlwZVwiXS5JTklUIHx8IGRhdGEub3QgPT09IF90eXBlc19jbWNkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJDTUNET2JqZWN0VHlwZVwiXS5WSURFTyB8fCBkYXRhLm90ID09PSBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiQ01DRE9iamVjdFR5cGVcIl0uTVVYRUQ7XG5cbiAgICBpZiAodGhpcy5zdGFydmVkICYmIGlzVmlkZW8pIHtcbiAgICAgIGRhdGEuYnMgPSB0cnVlO1xuICAgICAgZGF0YS5zdSA9IHRydWU7XG4gICAgICB0aGlzLnN0YXJ2ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5zdSA9PSBudWxsKSB7XG4gICAgICBkYXRhLnN1ID0gdGhpcy5idWZmZXJpbmc7XG4gICAgfSAvLyBUT0RPOiBJbXBsZW1lbnQgcnRwLCBucnIsIG5vciwgZGxcblxuXG4gICAgaWYgKHRoaXMudXNlSGVhZGVycykge1xuICAgICAgdmFyIGhlYWRlcnMgPSBDTUNEQ29udHJvbGxlci50b0hlYWRlcnMoZGF0YSk7XG5cbiAgICAgIGlmICghT2JqZWN0LmtleXMoaGVhZGVycykubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb250ZXh0LmhlYWRlcnMpIHtcbiAgICAgICAgY29udGV4dC5oZWFkZXJzID0ge307XG4gICAgICB9XG5cbiAgICAgIF9leHRlbmRzKGNvbnRleHQuaGVhZGVycywgaGVhZGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBxdWVyeSA9IENNQ0RDb250cm9sbGVyLnRvUXVlcnkoZGF0YSk7XG5cbiAgICAgIGlmICghcXVlcnkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnVybCA9IENNQ0RDb250cm9sbGVyLmFwcGVuZFF1ZXJ5VG9VcmkoY29udGV4dC51cmwsIHF1ZXJ5KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFwcGx5IENNQ0QgZGF0YSB0byBhIG1hbmlmZXN0IHJlcXVlc3QuXG4gICAqL1xuICA7XG5cbiAgLyoqXG4gICAqIFRoZSBDTUNEIG9iamVjdCB0eXBlLlxuICAgKi9cbiAgX3Byb3RvLmdldE9iamVjdFR5cGUgPSBmdW5jdGlvbiBnZXRPYmplY3RUeXBlKGZyYWdtZW50KSB7XG4gICAgdmFyIHR5cGUgPSBmcmFnbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09ICdzdWJ0aXRsZScpIHtcbiAgICAgIHJldHVybiBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiQ01DRE9iamVjdFR5cGVcIl0uVElNRURfVEVYVDtcbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHJldHVybiBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiQ01DRE9iamVjdFR5cGVcIl0uSU5JVDtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgcmV0dXJuIF90eXBlc19jbWNkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJDTUNET2JqZWN0VHlwZVwiXS5BVURJTztcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICBpZiAoIXRoaXMuaGxzLmF1ZGlvVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gX3R5cGVzX2NtY2RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkNNQ0RPYmplY3RUeXBlXCJdLk1VWEVEO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3R5cGVzX2NtY2RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkNNQ0RPYmplY3RUeXBlXCJdLlZJREVPO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgaGlnaGVzdCBiaXRyYXRlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRUb3BCYW5kd2lkdGggPSBmdW5jdGlvbiBnZXRUb3BCYW5kd2lkdGgodHlwZSkge1xuICAgIHZhciBiaXRyYXRlID0gMDtcbiAgICB2YXIgbGV2ZWxzO1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcblxuICAgIGlmICh0eXBlID09PSBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiQ01DRE9iamVjdFR5cGVcIl0uQVVESU8pIHtcbiAgICAgIGxldmVscyA9IGhscy5hdWRpb1RyYWNrcztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1heCA9IGhscy5tYXhBdXRvTGV2ZWw7XG4gICAgICB2YXIgbGVuID0gbWF4ID4gLTEgPyBtYXggKyAxIDogaGxzLmxldmVscy5sZW5ndGg7XG4gICAgICBsZXZlbHMgPSBobHMubGV2ZWxzLnNsaWNlKDAsIGxlbik7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShsZXZlbHMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIGxldmVsID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIGlmIChsZXZlbC5iaXRyYXRlID4gYml0cmF0ZSkge1xuICAgICAgICBiaXRyYXRlID0gbGV2ZWwuYml0cmF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYml0cmF0ZSA+IDAgPyBiaXRyYXRlIDogTmFOO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGJ1ZmZlciBsZW5ndGggZm9yIGEgbWVkaWEgdHlwZSBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0QnVmZmVyTGVuZ3RoID0gZnVuY3Rpb24gZ2V0QnVmZmVyTGVuZ3RoKHR5cGUpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLmhscy5tZWRpYTtcbiAgICB2YXIgYnVmZmVyID0gdHlwZSA9PT0gX3R5cGVzX2NtY2RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkNNQ0RPYmplY3RUeXBlXCJdLkFVRElPID8gdGhpcy5hdWRpb0J1ZmZlciA6IHRoaXMudmlkZW9CdWZmZXI7XG5cbiAgICBpZiAoIWJ1ZmZlciB8fCAhbWVkaWEpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiQnVmZmVySGVscGVyXCJdLmJ1ZmZlckluZm8oYnVmZmVyLCBtZWRpYS5jdXJyZW50VGltZSwgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZSk7XG4gICAgcmV0dXJuIGluZm8ubGVuICogMTAwMDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgcGxheWxpc3QgbG9hZGVyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNyZWF0ZVBsYXlsaXN0TG9hZGVyID0gZnVuY3Rpb24gY3JlYXRlUGxheWxpc3RMb2FkZXIoKSB7XG4gICAgdmFyIHBMb2FkZXIgPSB0aGlzLmNvbmZpZy5wTG9hZGVyO1xuICAgIHZhciBhcHBseSA9IHRoaXMuYXBwbHlQbGF5bGlzdERhdGE7XG4gICAgdmFyIEN0b3IgPSBwTG9hZGVyIHx8IHRoaXMuY29uZmlnLmxvYWRlcjtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENtY2RQbGF5bGlzdExvYWRlcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IEN0b3IoY29uZmlnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9wcm90bzIgPSBDbWNkUGxheWxpc3RMb2FkZXIucHJvdG90eXBlO1xuXG4gICAgICBfcHJvdG8yLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8yLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmFib3J0KCk7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8yLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGFwcGx5KGNvbnRleHQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKTtcbiAgICAgIH07XG5cbiAgICAgIF9jcmVhdGVDbGFzcyhDbWNkUGxheWxpc3RMb2FkZXIsIFt7XG4gICAgICAgIGtleTogXCJzdGF0c1wiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIuc3RhdHM7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImNvbnRleHRcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLmNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIENtY2RQbGF5bGlzdExvYWRlcjtcbiAgICB9KCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHBsYXlsaXN0IGxvYWRlclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jcmVhdGVGcmFnbWVudExvYWRlciA9IGZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50TG9hZGVyKCkge1xuICAgIHZhciBmTG9hZGVyID0gdGhpcy5jb25maWcuZkxvYWRlcjtcbiAgICB2YXIgYXBwbHkgPSB0aGlzLmFwcGx5RnJhZ21lbnREYXRhO1xuICAgIHZhciBDdG9yID0gZkxvYWRlciB8fCB0aGlzLmNvbmZpZy5sb2FkZXI7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDbWNkRnJhZ21lbnRMb2FkZXIoY29uZmlnKSB7XG4gICAgICAgIHRoaXMubG9hZGVyID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBDdG9yKGNvbmZpZyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcHJvdG8zID0gQ21jZEZyYWdtZW50TG9hZGVyLnByb3RvdHlwZTtcblxuICAgICAgX3Byb3RvMy5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvMy5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICB0aGlzLmxvYWRlci5hYm9ydCgpO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvMy5sb2FkID0gZnVuY3Rpb24gbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgICAgICBhcHBseShjb250ZXh0KTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcyk7XG4gICAgICB9O1xuXG4gICAgICBfY3JlYXRlQ2xhc3MoQ21jZEZyYWdtZW50TG9hZGVyLCBbe1xuICAgICAgICBrZXk6IFwic3RhdHNcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLnN0YXRzO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJjb250ZXh0XCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5jb250ZXh0O1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBDbWNkRnJhZ21lbnRMb2FkZXI7XG4gICAgfSgpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHJhbmRvbSB2NCBVVUlcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIDtcblxuICBDTUNEQ29udHJvbGxlci51dWlkID0gZnVuY3Rpb24gdXVpZCgpIHtcbiAgICB2YXIgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYigpKTtcbiAgICB2YXIgdXVpZCA9IHVybC50b1N0cmluZygpO1xuICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICByZXR1cm4gdXVpZC5zbGljZSh1dWlkLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplIGEgQ01DRCBkYXRhIG9iamVjdCBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzIGRlZmluZWQgaW4gdGhlXG4gICAqIHNlY3Rpb24gMy4yIG9mXG4gICAqIFtDVEEtNTAwNF0oaHR0cHM6Ly9jZG4uY3RhLnRlY2gvY3RhL21lZGlhL21lZGlhL3Jlc291cmNlcy9zdGFuZGFyZHMvcGRmcy9jdGEtNTAwNC1maW5hbC5wZGYpLlxuICAgKi9cbiAgO1xuXG4gIENNQ0RDb250cm9sbGVyLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZShkYXRhKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgIHZhciBpc1ZhbGlkID0gZnVuY3Rpb24gaXNWYWxpZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuICFOdW1iZXIuaXNOYU4odmFsdWUpICYmIHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09ICcnICYmIHZhbHVlICE9PSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIHRvUm91bmRlZCA9IGZ1bmN0aW9uIHRvUm91bmRlZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xuICAgIH07XG5cbiAgICB2YXIgdG9IdW5kcmVkID0gZnVuY3Rpb24gdG9IdW5kcmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9Sb3VuZGVkKHZhbHVlIC8gMTAwKSAqIDEwMDtcbiAgICB9O1xuXG4gICAgdmFyIHRvVXJsU2FmZSA9IGZ1bmN0aW9uIHRvVXJsU2FmZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIHZhciBmb3JtYXR0ZXJzID0ge1xuICAgICAgYnI6IHRvUm91bmRlZCxcbiAgICAgIGQ6IHRvUm91bmRlZCxcbiAgICAgIGJsOiB0b0h1bmRyZWQsXG4gICAgICBkbDogdG9IdW5kcmVkLFxuICAgICAgbXRwOiB0b0h1bmRyZWQsXG4gICAgICBub3I6IHRvVXJsU2FmZSxcbiAgICAgIHJ0cDogdG9IdW5kcmVkLFxuICAgICAgdGI6IHRvUm91bmRlZFxuICAgIH07XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhIHx8IHt9KS5zb3J0KCk7XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShrZXlzKSwgX3N0ZXAyOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIoKSkuZG9uZTspIHtcbiAgICAgIHZhciBrZXkgPSBfc3RlcDIudmFsdWU7XG4gICAgICB2YXIgdmFsdWUgPSBkYXRhW2tleV07IC8vIGlnbm9yZSBpbnZhbGlkIHZhbHVlc1xuXG4gICAgICBpZiAoIWlzVmFsaWQodmFsdWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBWZXJzaW9uIHNob3VsZCBvbmx5IGJlIHJlcG9ydGVkIGlmIG5vdCBlcXVhbCB0byAxLlxuXG5cbiAgICAgIGlmIChrZXkgPT09ICd2JyAmJiB2YWx1ZSA9PT0gMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gUGxheWJhY2sgcmF0ZSBzaG91bGQgb25seSBiZSBzZW50IGlmIG5vdCBlcXVhbCB0byAxLlxuXG5cbiAgICAgIGlmIChrZXkgPT0gJ3ByJyAmJiB2YWx1ZSA9PT0gMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gQ2VydGFpbiB2YWx1ZXMgcmVxdWlyZSBzcGVjaWFsIGZvcm1hdHRpbmdcblxuXG4gICAgICB2YXIgZm9ybWF0dGVyID0gZm9ybWF0dGVyc1trZXldO1xuXG4gICAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhbHVlID0gZm9ybWF0dGVyKHZhbHVlKTtcbiAgICAgIH0gLy8gU2VyaWFsaXplIHRoZSBrZXkvdmFsdWUgcGFpclxuXG5cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcblxuICAgICAgaWYgKGtleSA9PT0gJ290JyB8fCBrZXkgPT09ICdzZicgfHwga2V5ID09PSAnc3QnKSB7XG4gICAgICAgIHJlc3VsdCA9IGtleSArIFwiPVwiICsgdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJlc3VsdCA9IGtleSArIFwiPVwiICsgdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBrZXkgKyBcIj1cIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHMuam9pbignLCcpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgQ01DRCBkYXRhIG9iamVjdCB0byByZXF1ZXN0IGhlYWRlcnMgYWNjb3JkaW5nIHRvIHRoZSBydWxlc1xuICAgKiBkZWZpbmVkIGluIHRoZSBzZWN0aW9uIDIuMSBhbmQgMy4yIG9mXG4gICAqIFtDVEEtNTAwNF0oaHR0cHM6Ly9jZG4uY3RhLnRlY2gvY3RhL21lZGlhL21lZGlhL3Jlc291cmNlcy9zdGFuZGFyZHMvcGRmcy9jdGEtNTAwNC1maW5hbC5wZGYpLlxuICAgKi9cbiAgO1xuXG4gIENNQ0RDb250cm9sbGVyLnRvSGVhZGVycyA9IGZ1bmN0aW9uIHRvSGVhZGVycyhkYXRhKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgIHZhciBoZWFkZXJOYW1lcyA9IFsnT2JqZWN0JywgJ1JlcXVlc3QnLCAnU2Vzc2lvbicsICdTdGF0dXMnXTtcbiAgICB2YXIgaGVhZGVyR3JvdXBzID0gW3t9LCB7fSwge30sIHt9XTtcbiAgICB2YXIgaGVhZGVyTWFwID0ge1xuICAgICAgYnI6IDAsXG4gICAgICBkOiAwLFxuICAgICAgb3Q6IDAsXG4gICAgICB0YjogMCxcbiAgICAgIGJsOiAxLFxuICAgICAgZGw6IDEsXG4gICAgICBtdHA6IDEsXG4gICAgICBub3I6IDEsXG4gICAgICBucnI6IDEsXG4gICAgICBzdTogMSxcbiAgICAgIGNpZDogMixcbiAgICAgIHByOiAyLFxuICAgICAgc2Y6IDIsXG4gICAgICBzaWQ6IDIsXG4gICAgICBzdDogMixcbiAgICAgIHY6IDIsXG4gICAgICBiczogMyxcbiAgICAgIHJ0cDogM1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaSA9IDAsIF9rZXlzID0ga2V5czsgX2kgPCBfa2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBrZXkgPSBfa2V5c1tfaV07XG4gICAgICAvLyBVbm1hcHBlZCBmaWVsZHMgYXJlIG1hcHBlZCB0byB0aGUgUmVxdWVzdCBoZWFkZXJcbiAgICAgIHZhciBpbmRleCA9IGhlYWRlck1hcFtrZXldICE9IG51bGwgPyBoZWFkZXJNYXBba2V5XSA6IDE7XG4gICAgICBoZWFkZXJHcm91cHNbaW5kZXhdW2tleV0gPSBkYXRhW2tleV07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkZXJHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IENNQ0RDb250cm9sbGVyLnNlcmlhbGl6ZShoZWFkZXJHcm91cHNbaV0pO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgaGVhZGVyc1tcIkNNQ0QtXCIgKyBoZWFkZXJOYW1lc1tpXV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVycztcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBhIENNQ0QgZGF0YSBvYmplY3QgdG8gcXVlcnkgYXJncyBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzXG4gICAqIGRlZmluZWQgaW4gdGhlIHNlY3Rpb24gMi4yIGFuZCAzLjIgb2ZcbiAgICogW0NUQS01MDA0XShodHRwczovL2Nkbi5jdGEudGVjaC9jdGEvbWVkaWEvbWVkaWEvcmVzb3VyY2VzL3N0YW5kYXJkcy9wZGZzL2N0YS01MDA0LWZpbmFsLnBkZikuXG4gICAqL1xuICA7XG5cbiAgQ01DRENvbnRyb2xsZXIudG9RdWVyeSA9IGZ1bmN0aW9uIHRvUXVlcnkoZGF0YSkge1xuICAgIHJldHVybiBcIkNNQ0Q9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoQ01DRENvbnRyb2xsZXIuc2VyaWFsaXplKGRhdGEpKTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kIHF1ZXJ5IGFyZ3MgdG8gYSB1cmkuXG4gICAqL1xuICA7XG5cbiAgQ01DRENvbnRyb2xsZXIuYXBwZW5kUXVlcnlUb1VyaSA9IGZ1bmN0aW9uIGFwcGVuZFF1ZXJ5VG9VcmkodXJpLCBxdWVyeSkge1xuICAgIGlmICghcXVlcnkpIHtcbiAgICAgIHJldHVybiB1cmk7XG4gICAgfVxuXG4gICAgdmFyIHNlcGFyYXRvciA9IHVyaS5pbmNsdWRlcygnPycpID8gJyYnIDogJz8nO1xuICAgIHJldHVybiBcIlwiICsgdXJpICsgc2VwYXJhdG9yICsgcXVlcnk7XG4gIH07XG5cbiAgcmV0dXJuIENNQ0RDb250cm9sbGVyO1xufSgpO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9lbWUtY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvZW1lLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tZWRpYWtleXNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tZWRpYWtleXMtaGVscGVyICovIFwiLi9zcmMvdXRpbHMvbWVkaWFrZXlzLWhlbHBlci50c1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyoqXG4gKiBAYXV0aG9yIFN0ZXBoYW4gSGVzc2UgPGRpc3BhcmF0QGdtYWlsLmNvbT4gfCA8dGNoYWthYmFtQGdtYWlsLmNvbT5cbiAqXG4gKiBEUk0gc3VwcG9ydCBmb3IgSGxzLmpzXG4gKi9cblxuXG5cblxudmFyIE1BWF9MSUNFTlNFX1JFUVVFU1RfRkFJTFVSRVMgPSAzO1xuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXVkaW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCBhdWRpbyBjb2RlY3MgdG8gc3VwcG9ydFxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB2aWRlb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIHZpZGVvIGNvZGVjcyB0byBzdXBwb3J0XG4gKiBAcGFyYW0ge29iamVjdH0gZHJtU3lzdGVtT3B0aW9ucyBPcHRpb25hbCBwYXJhbWV0ZXJzL3JlcXVpcmVtZW50cyBmb3IgdGhlIGtleS1zeXN0ZW1cbiAqIEByZXR1cm5zIHtBcnJheTxNZWRpYVN5c3RlbUNvbmZpZ3VyYXRpb24+fSBBbiBhcnJheSBvZiBzdXBwb3J0ZWQgY29uZmlndXJhdGlvbnNcbiAqL1xuXG52YXIgY3JlYXRlV2lkZXZpbmVNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zID0gZnVuY3Rpb24gY3JlYXRlV2lkZXZpbmVNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcywgZHJtU3lzdGVtT3B0aW9ucykge1xuICAvKiBqc2hpbnQgaWdub3JlOmxpbmUgKi9cbiAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgLy8gaW5pdERhdGFUeXBlczogWydrZXlpZHMnLCAnbXA0J10sXG4gICAgLy8gbGFiZWw6IFwiXCIsXG4gICAgLy8gcGVyc2lzdGVudFN0YXRlOiBcIm5vdC1hbGxvd2VkXCIsIC8vIG9yIFwicmVxdWlyZWRcIiA/XG4gICAgLy8gZGlzdGluY3RpdmVJZGVudGlmaWVyOiBcIm5vdC1hbGxvd2VkXCIsIC8vIG9yIFwicmVxdWlyZWRcIiA/XG4gICAgLy8gc2Vzc2lvblR5cGVzOiBbJ3RlbXBvcmFyeSddLFxuICAgIGF1ZGlvQ2FwYWJpbGl0aWVzOiBbXSxcbiAgICAvLyB7IGNvbnRlbnRUeXBlOiAnYXVkaW8vbXA0OyBjb2RlY3M9XCJtcDRhLjQwLjJcIicgfVxuICAgIHZpZGVvQ2FwYWJpbGl0aWVzOiBbXSAvLyB7IGNvbnRlbnRUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJhdmMxLjQyRTAxRVwiJyB9XG5cbiAgfTtcbiAgYXVkaW9Db2RlY3MuZm9yRWFjaChmdW5jdGlvbiAoY29kZWMpIHtcbiAgICBiYXNlQ29uZmlnLmF1ZGlvQ2FwYWJpbGl0aWVzLnB1c2goe1xuICAgICAgY29udGVudFR5cGU6IFwiYXVkaW8vbXA0OyBjb2RlY3M9XFxcIlwiICsgY29kZWMgKyBcIlxcXCJcIixcbiAgICAgIHJvYnVzdG5lc3M6IGRybVN5c3RlbU9wdGlvbnMuYXVkaW9Sb2J1c3RuZXNzIHx8ICcnXG4gICAgfSk7XG4gIH0pO1xuICB2aWRlb0NvZGVjcy5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlYykge1xuICAgIGJhc2VDb25maWcudmlkZW9DYXBhYmlsaXRpZXMucHVzaCh7XG4gICAgICBjb250ZW50VHlwZTogXCJ2aWRlby9tcDQ7IGNvZGVjcz1cXFwiXCIgKyBjb2RlYyArIFwiXFxcIlwiLFxuICAgICAgcm9idXN0bmVzczogZHJtU3lzdGVtT3B0aW9ucy52aWRlb1JvYnVzdG5lc3MgfHwgJydcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBbYmFzZUNvbmZpZ107XG59O1xuLyoqXG4gKiBUaGUgaWRlYSBoZXJlIGlzIHRvIGhhbmRsZSBrZXktc3lzdGVtIChhbmQgdGhlaXIgcmVzcGVjdGl2ZSBwbGF0Zm9ybXMpIHNwZWNpZmljIGNvbmZpZ3VyYXRpb24gZGlmZmVyZW5jZXNcbiAqIGluIG9yZGVyIHRvIHdvcmsgd2l0aCB0aGUgbG9jYWwgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIG1ldGhvZC5cbiAqXG4gKiBXZSBjYW4gYWxzbyBydWxlLW91dCBwbGF0Zm9ybS1yZWxhdGVkIGtleS1zeXN0ZW0gc3VwcG9ydCBhdCB0aGlzIHBvaW50IGJ5IHRocm93aW5nIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlTeXN0ZW0gSWRlbnRpZmllciBmb3IgdGhlIGtleS1zeXN0ZW0sIHNlZSBgS2V5U3lzdGVtc2AgZW51bVxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhdWRpb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIGF1ZGlvIGNvZGVjcyB0byBzdXBwb3J0XG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHZpZGVvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgdmlkZW8gY29kZWNzIHRvIHN1cHBvcnRcbiAqIEB0aHJvd3Mgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBhIHVua25vd24ga2V5IHN5c3RlbSBpcyBwYXNzZWRcbiAqIEByZXR1cm5zIHtBcnJheTxNZWRpYVN5c3RlbUNvbmZpZ3VyYXRpb24+fSBBIG5vbi1lbXB0eSBBcnJheSBvZiBNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb24gb2JqZWN0c1xuICovXG5cblxudmFyIGdldFN1cHBvcnRlZE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMgPSBmdW5jdGlvbiBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCBkcm1TeXN0ZW1PcHRpb25zKSB7XG4gIHN3aXRjaCAoa2V5U3lzdGVtKSB7XG4gICAgY2FzZSBfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiS2V5U3lzdGVtc1wiXS5XSURFVklORTpcbiAgICAgIHJldHVybiBjcmVhdGVXaWRldmluZU1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCBkcm1TeXN0ZW1PcHRpb25zKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGtleS1zeXN0ZW06IFwiICsga2V5U3lzdGVtKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGRlYWwgd2l0aCBlbmNyeXB0ZWQgbWVkaWEgZXh0ZW5zaW9ucyAoRU1FKVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRW5jcnlwdGVkX01lZGlhX0V4dGVuc2lvbnNfQVBJXG4gKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEVNRUNvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdHNcbiAgICogQHBhcmFtIHtIbHN9IGhscyBPdXIgSGxzLmpzIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBFTUVDb250cm9sbGVyKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuX3dpZGV2aW5lTGljZW5zZVVybCA9IHZvaWQgMDtcbiAgICB0aGlzLl9saWNlbnNlWGhyU2V0dXAgPSB2b2lkIDA7XG4gICAgdGhpcy5fbGljZW5zZVJlc3BvbnNlQ2FsbGJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5fZW1lRW5hYmxlZCA9IHZvaWQgMDtcbiAgICB0aGlzLl9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgPSB2b2lkIDA7XG4gICAgdGhpcy5fZHJtU3lzdGVtT3B0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLl9jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5fbWVkaWFLZXlzTGlzdCA9IFtdO1xuICAgIHRoaXMuX21lZGlhID0gbnVsbDtcbiAgICB0aGlzLl9oYXNTZXRNZWRpYUtleXMgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XG4gICAgdGhpcy5tZWRpYUtleXNQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9vbk1lZGlhRW5jcnlwdGVkID0gdGhpcy5vbk1lZGlhRW5jcnlwdGVkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5fY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLl93aWRldmluZUxpY2Vuc2VVcmwgPSB0aGlzLl9jb25maWcud2lkZXZpbmVMaWNlbnNlVXJsO1xuICAgIHRoaXMuX2xpY2Vuc2VYaHJTZXR1cCA9IHRoaXMuX2NvbmZpZy5saWNlbnNlWGhyU2V0dXA7XG4gICAgdGhpcy5fbGljZW5zZVJlc3BvbnNlQ2FsbGJhY2sgPSB0aGlzLl9jb25maWcubGljZW5zZVJlc3BvbnNlQ2FsbGJhY2s7XG4gICAgdGhpcy5fZW1lRW5hYmxlZCA9IHRoaXMuX2NvbmZpZy5lbWVFbmFibGVkO1xuICAgIHRoaXMuX3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyA9IHRoaXMuX2NvbmZpZy5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jO1xuICAgIHRoaXMuX2RybVN5c3RlbU9wdGlvbnMgPSB0aGlzLl9jb25maWcuZHJtU3lzdGVtT3B0aW9ucztcblxuICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRU1FQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTsgLy8gQHRzLWlnbm9yZVxuXG5cbiAgICB0aGlzLmhscyA9IHRoaXMuX29uTWVkaWFFbmNyeXB0ZWQgPSBudWxsO1xuICAgIHRoaXMuX3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLl9yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNIRUQsIHRoaXMub25NZWRpYURldGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5fdW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlTeXN0ZW0gSWRlbnRpZmllciBmb3IgdGhlIGtleS1zeXN0ZW0sIHNlZSBgS2V5U3lzdGVtc2AgZW51bVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBMaWNlbnNlIHNlcnZlciBVUkwgZm9yIGtleS1zeXN0ZW0gKGlmIGFueSBjb25maWd1cmVkLCBvdGhlcndpc2UgY2F1c2VzIGVycm9yKVxuICAgKiBAdGhyb3dzIGlmIGEgdW5zdXBwb3J0ZWQga2V5c3lzdGVtIGlzIHBhc3NlZFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRMaWNlbnNlU2VydmVyVXJsID0gZnVuY3Rpb24gZ2V0TGljZW5zZVNlcnZlclVybChrZXlTeXN0ZW0pIHtcbiAgICBzd2l0Y2ggKGtleVN5c3RlbSkge1xuICAgICAgY2FzZSBfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiS2V5U3lzdGVtc1wiXS5XSURFVklORTpcbiAgICAgICAgaWYgKCF0aGlzLl93aWRldmluZUxpY2Vuc2VVcmwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl93aWRldmluZUxpY2Vuc2VVcmw7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwibm8gbGljZW5zZSBzZXJ2ZXIgVVJMIGNvbmZpZ3VyZWQgZm9yIGtleS1zeXN0ZW0gXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwiXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhY2Nlc3Mgb2JqZWN0IGFuZCBhZGRzIGl0IHRvIG91ciBsaXN0IHVwb24gc3VjY2Vzc1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5U3lzdGVtIFN5c3RlbSBJRCAoc2VlIGBLZXlTeXN0ZW1zYClcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhdWRpb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIGF1ZGlvIGNvZGVjcyB0byBzdXBwb3J0XG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdmlkZW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCB2aWRlbyBjb2RlY3MgdG8gc3VwcG9ydFxuICAgKiBAdGhyb3dzIFdoZW4gYSB1bnN1cHBvcnRlZCBLZXlTeXN0ZW0gaXMgcGFzc2VkXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLl9hdHRlbXB0S2V5U3lzdGVtQWNjZXNzID0gZnVuY3Rpb24gX2F0dGVtcHRLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gVGhpcyBjYW4gdGhyb3csIGJ1dCBpcyBjYXVnaHQgaW4gZXZlbnQgaGFuZGxlciBjYWxscGF0aFxuICAgIHZhciBtZWRpYUtleVN5c3RlbUNvbmZpZ3MgPSBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCB0aGlzLl9kcm1TeXN0ZW1PcHRpb25zKTtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKCdSZXF1ZXN0aW5nIGVuY3J5cHRlZCBtZWRpYSBrZXktc3lzdGVtIGFjY2VzcycpOyAvLyBleHBlY3RpbmcgaW50ZXJmYWNlIGxpa2Ugd2luZG93Lm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NcblxuICAgIHZhciBrZXlTeXN0ZW1BY2Nlc3NQcm9taXNlID0gdGhpcy5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtLCBtZWRpYUtleVN5c3RlbUNvbmZpZ3MpO1xuICAgIHRoaXMubWVkaWFLZXlzUHJvbWlzZSA9IGtleVN5c3RlbUFjY2Vzc1Byb21pc2UudGhlbihmdW5jdGlvbiAobWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICAgIHJldHVybiBfdGhpcy5fb25NZWRpYUtleVN5c3RlbUFjY2Vzc09idGFpbmVkKGtleVN5c3RlbSwgbWVkaWFLZXlTeXN0ZW1BY2Nlc3MpO1xuICAgIH0pO1xuICAgIGtleVN5c3RlbUFjY2Vzc1Byb21pc2UuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmVycm9yKFwiRmFpbGVkIHRvIG9idGFpbiBrZXktc3lzdGVtIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIiBhY2Nlc3M6XCIsIGVycik7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgb2J0YWluaW5nIGFjY2VzcyB0byBhIGtleS1zeXN0ZW1cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVN5c3RlbVxuICAgKiBAcGFyYW0ge01lZGlhS2V5U3lzdGVtQWNjZXNzfSBtZWRpYUtleVN5c3RlbUFjY2VzcyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFLZXlTeXN0ZW1BY2Nlc3NcbiAgICovXG4gIF9wcm90by5fb25NZWRpYUtleVN5c3RlbUFjY2Vzc09idGFpbmVkID0gZnVuY3Rpb24gX29uTWVkaWFLZXlTeXN0ZW1BY2Nlc3NPYnRhaW5lZChrZXlTeXN0ZW0sIG1lZGlhS2V5U3lzdGVtQWNjZXNzKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKFwiQWNjZXNzIGZvciBrZXktc3lzdGVtIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIiBvYnRhaW5lZFwiKTtcbiAgICB2YXIgbWVkaWFLZXlzTGlzdEl0ZW0gPSB7XG4gICAgICBtZWRpYUtleXNTZXNzaW9uSW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgbWVkaWFLZXlTeXN0ZW1BY2Nlc3M6IG1lZGlhS2V5U3lzdGVtQWNjZXNzLFxuICAgICAgbWVkaWFLZXlTeXN0ZW1Eb21haW46IGtleVN5c3RlbVxuICAgIH07XG5cbiAgICB0aGlzLl9tZWRpYUtleXNMaXN0LnB1c2gobWVkaWFLZXlzTGlzdEl0ZW0pO1xuXG4gICAgdmFyIG1lZGlhS2V5c1Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBtZWRpYUtleVN5c3RlbUFjY2Vzcy5jcmVhdGVNZWRpYUtleXMoKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChtZWRpYUtleXMpIHtcbiAgICAgIG1lZGlhS2V5c0xpc3RJdGVtLm1lZGlhS2V5cyA9IG1lZGlhS2V5cztcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coXCJNZWRpYS1rZXlzIGNyZWF0ZWQgZm9yIGtleS1zeXN0ZW0gXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwiXCIpO1xuXG4gICAgICBfdGhpczIuX29uTWVkaWFLZXlzQ3JlYXRlZCgpO1xuXG4gICAgICByZXR1cm4gbWVkaWFLZXlzO1xuICAgIH0pO1xuICAgIG1lZGlhS2V5c1Byb21pc2UuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIG1lZGlhLWtleXM6JywgZXJyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWVkaWFLZXlzUHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBrZXktY3JlYXRpb24gKHJlcHJlc2VudHMgYWNjZXNzIHRvIENETSkuIFdlIGFyZSBnb2luZyB0byBjcmVhdGUga2V5LXNlc3Npb25zIHVwb24gdGhpc1xuICAgKiBmb3IgYWxsIGV4aXN0aW5nIGtleXMgd2hlcmUgbm8gc2Vzc2lvbiBleGlzdHMgeWV0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5fb25NZWRpYUtleXNDcmVhdGVkID0gZnVuY3Rpb24gX29uTWVkaWFLZXlzQ3JlYXRlZCgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIC8vIGNoZWNrIGZvciBhbGwga2V5LWxpc3QgaXRlbXMgaWYgYSBzZXNzaW9uIGV4aXN0cywgb3RoZXJ3aXNlLCBjcmVhdGUgb25lXG4gICAgdGhpcy5fbWVkaWFLZXlzTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChtZWRpYUtleXNMaXN0SXRlbSkge1xuICAgICAgaWYgKCFtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uKSB7XG4gICAgICAgIC8vIG1lZGlhS2V5cyBpcyBkZWZpbml0ZWx5IGluaXRpYWxpemVkIGhlcmVcbiAgICAgICAgbWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbiA9IG1lZGlhS2V5c0xpc3RJdGVtLm1lZGlhS2V5cy5jcmVhdGVTZXNzaW9uKCk7XG5cbiAgICAgICAgX3RoaXMzLl9vbk5ld01lZGlhS2V5U2Vzc2lvbihtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSBrZXlTZXNzaW9uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLl9vbk5ld01lZGlhS2V5U2Vzc2lvbiA9IGZ1bmN0aW9uIF9vbk5ld01lZGlhS2V5U2Vzc2lvbihrZXlTZXNzaW9uKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKFwiTmV3IGtleS1zeXN0ZW0gc2Vzc2lvbiBcIiArIGtleVNlc3Npb24uc2Vzc2lvbklkKTtcbiAgICBrZXlTZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzNC5fb25LZXlTZXNzaW9uTWVzc2FnZShrZXlTZXNzaW9uLCBldmVudC5tZXNzYWdlKTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TWVkaWFLZXlTZXNzaW9ufSBrZXlTZXNzaW9uXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IG1lc3NhZ2VcbiAgICovXG4gIDtcblxuICBfcHJvdG8uX29uS2V5U2Vzc2lvbk1lc3NhZ2UgPSBmdW5jdGlvbiBfb25LZXlTZXNzaW9uTWVzc2FnZShrZXlTZXNzaW9uLCBtZXNzYWdlKSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZygnR290IEVNRSBtZXNzYWdlIGV2ZW50LCBjcmVhdGluZyBsaWNlbnNlIHJlcXVlc3QnKTtcblxuICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlKG1lc3NhZ2UsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKFwiUmVjZWl2ZWQgbGljZW5zZSBkYXRhIChsZW5ndGg6IFwiICsgKGRhdGEgPyBkYXRhLmJ5dGVMZW5ndGggOiBkYXRhKSArIFwiKSwgdXBkYXRpbmcga2V5LXNlc3Npb25cIik7XG4gICAgICBrZXlTZXNzaW9uLnVwZGF0ZShkYXRhKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKFwiVXBkYXRpbmcga2V5LXNlc3Npb24gZmFpbGVkOiBcIiArIGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIGUge01lZGlhRW5jcnlwdGVkRXZlbnR9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uTWVkaWFFbmNyeXB0ZWQgPSBmdW5jdGlvbiBvbk1lZGlhRW5jcnlwdGVkKGUpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coXCJNZWRpYSBpcyBlbmNyeXB0ZWQgdXNpbmcgXFxcIlwiICsgZS5pbml0RGF0YVR5cGUgKyBcIlxcXCIgaW5pdCBkYXRhIHR5cGVcIik7XG5cbiAgICBpZiAoIXRoaXMubWVkaWFLZXlzUHJvbWlzZSkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmVycm9yKCdGYXRhbDogTWVkaWEgaXMgZW5jcnlwdGVkIGJ1dCBubyBDRE0gYWNjZXNzIG9yIG5vIGtleXMgaGF2ZSBiZWVuIHJlcXVlc3RlZCcpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uS0VZX1NZU1RFTV9OT19LRVlTLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZpbmFsbHlTZXRLZXlBbmRTdGFydFNlc3Npb24gPSBmdW5jdGlvbiBmaW5hbGx5U2V0S2V5QW5kU3RhcnRTZXNzaW9uKG1lZGlhS2V5cykge1xuICAgICAgaWYgKCFfdGhpczUuX21lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXM1Ll9hdHRlbXB0U2V0TWVkaWFLZXlzKG1lZGlhS2V5cyk7XG5cbiAgICAgIF90aGlzNS5fZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oZS5pbml0RGF0YVR5cGUsIGUuaW5pdERhdGEpO1xuICAgIH07IC8vIENvdWxkIHVzZSBgUHJvbWlzZS5maW5hbGx5YCBidXQgc29tZSBQcm9taXNlIHBvbHlmaWxscyBhcmUgbWlzc2luZyBpdFxuXG5cbiAgICB0aGlzLm1lZGlhS2V5c1Byb21pc2UudGhlbihmaW5hbGx5U2V0S2V5QW5kU3RhcnRTZXNzaW9uKS5jYXRjaChmaW5hbGx5U2V0S2V5QW5kU3RhcnRTZXNzaW9uKTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIDtcblxuICBfcHJvdG8uX2F0dGVtcHRTZXRNZWRpYUtleXMgPSBmdW5jdGlvbiBfYXR0ZW1wdFNldE1lZGlhS2V5cyhtZWRpYUtleXMpIHtcbiAgICBpZiAoIXRoaXMuX21lZGlhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBzZXQgbWVkaWFLZXlzIHdpdGhvdXQgZmlyc3QgYXR0YWNoaW5nIGEgbWVkaWEgZWxlbWVudCcpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5faGFzU2V0TWVkaWFLZXlzKSB7XG4gICAgICAvLyBGSVhNRTogc2VlIGlmIHdlIGNhbi93YW50L25lZWQtdG8gcmVhbGx5IHRvIGRlYWwgd2l0aCBzZXZlcmFsIHBvdGVudGlhbCBrZXktc2Vzc2lvbnM/XG4gICAgICB2YXIga2V5c0xpc3RJdGVtID0gdGhpcy5fbWVkaWFLZXlzTGlzdFswXTtcblxuICAgICAgaWYgKCFrZXlzTGlzdEl0ZW0gfHwgIWtleXNMaXN0SXRlbS5tZWRpYUtleXMpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmVycm9yKCdGYXRhbDogTWVkaWEgaXMgZW5jcnlwdGVkIGJ1dCBubyBDRE0gYWNjZXNzIG9yIG5vIGtleXMgaGF2ZSBiZWVuIG9idGFpbmVkIHlldCcpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uS0VZX1NZU1RFTV9OT19LRVlTLFxuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coJ1NldHRpbmcga2V5cyBmb3IgZW5jcnlwdGVkIG1lZGlhJyk7XG5cbiAgICAgIHRoaXMuX21lZGlhLnNldE1lZGlhS2V5cyhrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzKTtcblxuICAgICAgdGhpcy5faGFzU2V0TWVkaWFLZXlzID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLl9nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbiA9IGZ1bmN0aW9uIF9nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbihpbml0RGF0YVR5cGUsIGluaXREYXRhKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAvLyBGSVhNRTogc2VlIGlmIHdlIGNhbi93YW50L25lZWQtdG8gcmVhbGx5IHRvIGRlYWwgd2l0aCBzZXZlcmFsIHBvdGVudGlhbCBrZXktc2Vzc2lvbnM/XG4gICAgdmFyIGtleXNMaXN0SXRlbSA9IHRoaXMuX21lZGlhS2V5c0xpc3RbMF07XG5cbiAgICBpZiAoIWtleXNMaXN0SXRlbSkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmVycm9yKCdGYXRhbDogTWVkaWEgaXMgZW5jcnlwdGVkIGJ1dCBub3QgYW55IGtleS1zeXN0ZW0gYWNjZXNzIGhhcyBiZWVuIG9idGFpbmVkIHlldCcpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uS0VZX1NZU1RFTV9OT19BQ0NFU1MsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5c0xpc3RJdGVtLm1lZGlhS2V5c1Nlc3Npb25Jbml0aWFsaXplZCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLndhcm4oJ0tleS1TZXNzaW9uIGFscmVhZHkgaW5pdGlhbGl6ZWQgYnV0IHJlcXVlc3RlZCBhZ2FpbicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXlTZXNzaW9uID0ga2V5c0xpc3RJdGVtLm1lZGlhS2V5c1Nlc3Npb247XG5cbiAgICBpZiAoIWtleVNlc3Npb24pIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcignRmF0YWw6IE1lZGlhIGlzIGVuY3J5cHRlZCBidXQgbm8ga2V5LXNlc3Npb24gZXhpc3RpbmcnKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9TWVNURU1fTk9fU0VTU0lPTixcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaW5pdERhdGEgaXMgbnVsbCBpZiB0aGUgbWVkaWEgaXMgbm90IENPUlMtc2FtZS1vcmlnaW5cblxuXG4gICAgaWYgKCFpbml0RGF0YSkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLndhcm4oJ0ZhdGFsOiBpbml0RGF0YSByZXF1aXJlZCBmb3IgZ2VuZXJhdGluZyBhIGtleSBzZXNzaW9uIGlzIG51bGwnKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9TWVNURU1fTk9fSU5JVF9EQVRBLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZyhcIkdlbmVyYXRpbmcga2V5LXNlc3Npb24gcmVxdWVzdCBmb3IgXFxcIlwiICsgaW5pdERhdGFUeXBlICsgXCJcXFwiIGluaXQgZGF0YSB0eXBlXCIpO1xuICAgIGtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIGtleVNlc3Npb24uZ2VuZXJhdGVSZXF1ZXN0KGluaXREYXRhVHlwZSwgaW5pdERhdGEpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmRlYnVnKCdLZXktc2Vzc2lvbiBnZW5lcmF0aW9uIHN1Y2NlZWRlZCcpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBrZXktc2Vzc2lvbiByZXF1ZXN0OicsIGVycik7XG5cbiAgICAgIF90aGlzNi5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uS0VZX1NZU1RFTV9OT19TRVNTSU9OLFxuICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIExpY2Vuc2Ugc2VydmVyIFVSTFxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBrZXlNZXNzYWdlIE1lc3NhZ2UgZGF0YSBpc3N1ZWQgYnkga2V5LXN5c3RlbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgd2hlbiBYSFIgaGFzIHN1Y2NlZWRlZFxuICAgKiBAcmV0dXJucyB7WE1MSHR0cFJlcXVlc3R9IFVuc2VudCAoYnV0IG9wZW5lZCBzdGF0ZSkgWEhSIG9iamVjdFxuICAgKiBAdGhyb3dzIGlmIFhNTEh0dHBSZXF1ZXN0IGNvbnN0cnVjdGlvbiBmYWlsZWRcbiAgICovXG4gIDtcblxuICBfcHJvdG8uX2NyZWF0ZUxpY2Vuc2VYaHIgPSBmdW5jdGlvbiBfY3JlYXRlTGljZW5zZVhocih1cmwsIGtleU1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLl9vbkxpY2Vuc2VSZXF1ZXN0UmVhZHlTdGFnZUNoYW5nZS5iaW5kKHRoaXMsIHhociwgdXJsLCBrZXlNZXNzYWdlLCBjYWxsYmFjayk7XG4gICAgdmFyIGxpY2Vuc2VYaHJTZXR1cCA9IHRoaXMuX2xpY2Vuc2VYaHJTZXR1cDtcblxuICAgIGlmIChsaWNlbnNlWGhyU2V0dXApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpY2Vuc2VYaHJTZXR1cC5jYWxsKHRoaXMuaGxzLCB4aHIsIHVybCk7XG4gICAgICAgIGxpY2Vuc2VYaHJTZXR1cCA9IHVuZGVmaW5lZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmVycm9yKGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBpZiBsaWNlbnNlWGhyU2V0dXAgZGlkIG5vdCB5ZXQgY2FsbCBvcGVuLCBsZXQncyBkbyBpdCBub3dcbiAgICAgIGlmICgheGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCB1cmwsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGljZW5zZVhoclNldHVwKSB7XG4gICAgICAgIGxpY2Vuc2VYaHJTZXR1cC5jYWxsKHRoaXMuaGxzLCB4aHIsIHVybCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSUUxMSB0aHJvd3MgYW4gZXhjZXB0aW9uIG9uIHhoci5vcGVuIGlmIGF0dGVtcHRpbmcgdG8gYWNjZXNzIGFuIEhUVFAgcmVzb3VyY2Ugb3ZlciBIVFRQU1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXNzdWUgc2V0dGluZyB1cCBLZXlTeXN0ZW0gbGljZW5zZSBYSFIgXCIgKyBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4geGhyO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0fSB4aHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBMaWNlbnNlIHNlcnZlciBVUkxcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0ga2V5TWVzc2FnZSBNZXNzYWdlIGRhdGEgaXNzdWVkIGJ5IGtleS1zeXN0ZW1cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIHdoZW4gWEhSIGhhcyBzdWNjZWVkZWRcbiAgICovXG4gIDtcblxuICBfcHJvdG8uX29uTGljZW5zZVJlcXVlc3RSZWFkeVN0YWdlQ2hhbmdlID0gZnVuY3Rpb24gX29uTGljZW5zZVJlcXVlc3RSZWFkeVN0YWdlQ2hhbmdlKHhociwgdXJsLCBrZXlNZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIHN3aXRjaCAoeGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKCdMaWNlbnNlIHJlcXVlc3Qgc3VjY2VlZGVkJyk7XG4gICAgICAgICAgdmFyIF9kYXRhID0geGhyLnJlc3BvbnNlO1xuICAgICAgICAgIHZhciBsaWNlbnNlUmVzcG9uc2VDYWxsYmFjayA9IHRoaXMuX2xpY2Vuc2VSZXNwb25zZUNhbGxiYWNrO1xuXG4gICAgICAgICAgaWYgKGxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBfZGF0YSA9IGxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrLmNhbGwodGhpcy5obHMsIHhociwgdXJsKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhbGxiYWNrKF9kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0uZXJyb3IoXCJMaWNlbnNlIFJlcXVlc3QgWEhSIGZhaWxlZCAoXCIgKyB1cmwgKyBcIikuIFN0YXR1czogXCIgKyB4aHIuc3RhdHVzICsgXCIgKFwiICsgeGhyLnN0YXR1c1RleHQgKyBcIilcIik7XG4gICAgICAgICAgdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQrKztcblxuICAgICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA+IE1BWF9MSUNFTlNFX1JFUVVFU1RfRkFJTFVSRVMpIHtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCxcbiAgICAgICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBhdHRlbXB0c0xlZnQgPSBNQVhfTElDRU5TRV9SRVFVRVNUX0ZBSUxVUkVTIC0gdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgKyAxO1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKFwiUmV0cnlpbmcgbGljZW5zZSByZXF1ZXN0LCBcIiArIGF0dGVtcHRzTGVmdCArIFwiIGF0dGVtcHRzIGxlZnRcIik7XG5cbiAgICAgICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZShrZXlNZXNzYWdlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TWVkaWFLZXlzTGlzdEl0ZW19IGtleXNMaXN0SXRlbVxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBrZXlNZXNzYWdlXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gQ2hhbGxlbmdlIGRhdGEgcG9zdGVkIHRvIGxpY2Vuc2Ugc2VydmVyXG4gICAqIEB0aHJvd3MgaWYgS2V5U3lzdGVtIGlzIHVuc3VwcG9ydGVkXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLl9nZW5lcmF0ZUxpY2Vuc2VSZXF1ZXN0Q2hhbGxlbmdlID0gZnVuY3Rpb24gX2dlbmVyYXRlTGljZW5zZVJlcXVlc3RDaGFsbGVuZ2Uoa2V5c0xpc3RJdGVtLCBrZXlNZXNzYWdlKSB7XG4gICAgc3dpdGNoIChrZXlzTGlzdEl0ZW0ubWVkaWFLZXlTeXN0ZW1Eb21haW4pIHtcbiAgICAgIC8vIGNhc2UgS2V5U3lzdGVtcy5QTEFZUkVBRFk6XG4gICAgICAvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnRFZGdlL0RlbW9zL2Jsb2IvbWFzdGVyL2VtZS9zY3JpcHRzL2RlbW8uanNcblxuICAgICAgLypcbiAgICAgIGlmICh0aGlzLmxpY2Vuc2VUeXBlICE9PSB0aGlzLkxJQ0VOU0VfVFlQRV9XSURFVklORSkge1xuICAgICAgICAvLyBGb3IgUGxheVJlYWR5IENETXMsIHdlIG5lZWQgdG8gZGlnIHRoZSBDaGFsbGVuZ2Ugb3V0IG9mIHRoZSBYTUwuXG4gICAgICAgIHZhciBrZXlNZXNzYWdlWG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShrZXlNZXNzYWdlKSksICdhcHBsaWNhdGlvbi94bWwnKTtcbiAgICAgICAgaWYgKGtleU1lc3NhZ2VYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0NoYWxsZW5nZScpWzBdKSB7XG4gICAgICAgICAgICBjaGFsbGVuZ2UgPSBhdG9iKGtleU1lc3NhZ2VYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0NoYWxsZW5nZScpWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93ICdDYW5ub3QgZmluZCA8Q2hhbGxlbmdlPiBpbiBrZXkgbWVzc2FnZSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlck5hbWVzID0ga2V5TWVzc2FnZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbmFtZScpO1xuICAgICAgICB2YXIgaGVhZGVyVmFsdWVzID0ga2V5TWVzc2FnZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmFsdWUnKTtcbiAgICAgICAgaWYgKGhlYWRlck5hbWVzLmxlbmd0aCAhPT0gaGVhZGVyVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgJ01pc21hdGNoZWQgaGVhZGVyIDxuYW1lPi88dmFsdWU+IHBhaXIgaW4ga2V5IG1lc3NhZ2UnO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlck5hbWVzW2ldLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlLCBoZWFkZXJWYWx1ZXNbaV0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgICovXG4gICAgICBjYXNlIF91dGlsc19tZWRpYWtleXNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJLZXlTeXN0ZW1zXCJdLldJREVWSU5FOlxuICAgICAgICAvLyBGb3IgV2lkZXZpbmUgQ0RNcywgdGhlIGNoYWxsZW5nZSBpcyB0aGUga2V5TWVzc2FnZS5cbiAgICAgICAgcmV0dXJuIGtleU1lc3NhZ2U7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQga2V5LXN5c3RlbTogXCIgKyBrZXlzTGlzdEl0ZW0ubWVkaWFLZXlTeXN0ZW1Eb21haW4pO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ga2V5TWVzc2FnZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIDtcblxuICBfcHJvdG8uX3JlcXVlc3RMaWNlbnNlID0gZnVuY3Rpb24gX3JlcXVlc3RMaWNlbnNlKGtleU1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZygnUmVxdWVzdGluZyBjb250ZW50IGxpY2Vuc2UgZm9yIGtleS1zeXN0ZW0nKTtcbiAgICB2YXIga2V5c0xpc3RJdGVtID0gdGhpcy5fbWVkaWFLZXlzTGlzdFswXTtcblxuICAgIGlmICgha2V5c0xpc3RJdGVtKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0uZXJyb3IoJ0ZhdGFsIGVycm9yOiBNZWRpYSBpcyBlbmNyeXB0ZWQgYnV0IG5vIGtleS1zeXN0ZW0gYWNjZXNzIGhhcyBiZWVuIG9idGFpbmVkIHlldCcpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uS0VZX1NZU1RFTV9OT19BQ0NFU1MsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIF91cmwgPSB0aGlzLmdldExpY2Vuc2VTZXJ2ZXJVcmwoa2V5c0xpc3RJdGVtLm1lZGlhS2V5U3lzdGVtRG9tYWluKTtcblxuICAgICAgdmFyIF94aHIgPSB0aGlzLl9jcmVhdGVMaWNlbnNlWGhyKF91cmwsIGtleU1lc3NhZ2UsIGNhbGxiYWNrKTtcblxuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZyhcIlNlbmRpbmcgbGljZW5zZSByZXF1ZXN0IHRvIFVSTDogXCIgKyBfdXJsKTtcblxuICAgICAgdmFyIGNoYWxsZW5nZSA9IHRoaXMuX2dlbmVyYXRlTGljZW5zZVJlcXVlc3RDaGFsbGVuZ2Uoa2V5c0xpc3RJdGVtLCBrZXlNZXNzYWdlKTtcblxuICAgICAgX3hoci5zZW5kKGNoYWxsZW5nZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmVycm9yKFwiRmFpbHVyZSByZXF1ZXN0aW5nIERSTSBsaWNlbnNlOiBcIiArIGUpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uS0VZX1NZU1RFTV9MSUNFTlNFX1JFUVVFU1RfRkFJTEVELFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhQXR0YWNoZWQgPSBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuX2VtZUVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWVkaWEgPSBkYXRhLm1lZGlhOyAvLyBrZWVwIHJlZmVyZW5jZSBvZiBtZWRpYVxuXG4gICAgdGhpcy5fbWVkaWEgPSBtZWRpYTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmNyeXB0ZWQnLCB0aGlzLl9vbk1lZGlhRW5jcnlwdGVkKTtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYURldGFjaGVkID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGVkKCkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMuX21lZGlhO1xuICAgIHZhciBtZWRpYUtleXNMaXN0ID0gdGhpcy5fbWVkaWFLZXlzTGlzdDtcblxuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmNyeXB0ZWQnLCB0aGlzLl9vbk1lZGlhRW5jcnlwdGVkKTtcbiAgICB0aGlzLl9tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5fbWVkaWFLZXlzTGlzdCA9IFtdOyAvLyBDbG9zZSBhbGwgc2Vzc2lvbnMgYW5kIHJlbW92ZSBtZWRpYSBrZXlzIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQuXG5cbiAgICBQcm9taXNlLmFsbChtZWRpYUtleXNMaXN0Lm1hcChmdW5jdGlvbiAobWVkaWFLZXlzTGlzdEl0ZW0pIHtcbiAgICAgIGlmIChtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiBtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uLmNsb3NlKCkuY2F0Y2goZnVuY3Rpb24gKCkgey8vIElnbm9yZSBlcnJvcnMgd2hlbiBjbG9zaW5nIHRoZSBzZXNzaW9ucy4gQ2xvc2luZyBhIHNlc3Npb24gdGhhdFxuICAgICAgICAgIC8vIGdlbmVyYXRlZCBubyBrZXkgcmVxdWVzdHMgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG1lZGlhLnNldE1lZGlhS2V5cyhudWxsKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7Ly8gSWdub3JlIGFueSBmYWlsdXJlcyB3aGlsZSByZW1vdmluZyBtZWRpYSBrZXlzIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQuXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWFuaWZlc3RQYXJzZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0UGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLl9lbWVFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF1ZGlvQ29kZWNzID0gZGF0YS5sZXZlbHMubWFwKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgcmV0dXJuIGxldmVsLmF1ZGlvQ29kZWM7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChhdWRpb0NvZGVjKSB7XG4gICAgICByZXR1cm4gISFhdWRpb0NvZGVjO1xuICAgIH0pO1xuICAgIHZhciB2aWRlb0NvZGVjcyA9IGRhdGEubGV2ZWxzLm1hcChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgIHJldHVybiBsZXZlbC52aWRlb0NvZGVjO1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAodmlkZW9Db2RlYykge1xuICAgICAgcmV0dXJuICEhdmlkZW9Db2RlYztcbiAgICB9KTtcblxuICAgIHRoaXMuX2F0dGVtcHRLZXlTeXN0ZW1BY2Nlc3MoX3V0aWxzX21lZGlha2V5c19oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIktleVN5c3RlbXNcIl0uV0lERVZJTkUsIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcyk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKEVNRUNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiBcInJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgZnVuY3Rpb24gY29uZmlndXJlZCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFTUVDb250cm9sbGVyO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKEVNRUNvbnRyb2xsZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9mcHMtY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcblxuXG5cbnZhciBGUFNDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gc3RyZWFtIGNvbnRyb2xsZXIgbXVzdCBiZSBwcm92aWRlZCBhcyBhIGRlcGVuZGVuY3khXG4gIGZ1bmN0aW9uIEZQU0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy50aW1lciA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUaW1lID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdERyb3BwZWRGcmFtZXMgPSAwO1xuICAgIHRoaXMubGFzdERlY29kZWRGcmFtZXMgPSAwO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRlBTQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNldFN0cmVhbUNvbnRyb2xsZXIgPSBmdW5jdGlvbiBzZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBzdHJlYW1Db250cm9sbGVyO1xuICB9O1xuXG4gIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnVucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcpO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB9XG5cbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYUF0dGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuXG4gICAgaWYgKGNvbmZpZy5jYXBMZXZlbE9uRlBTRHJvcCkge1xuICAgICAgdmFyIG1lZGlhID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIHNlbGYuSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xuICAgICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuXG4gICAgICBpZiAobWVkaWEgJiYgdHlwZW9mIG1lZGlhLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldEludGVydmFsKHRoaXMuY2hlY2tGUFNJbnRlcnZhbC5iaW5kKHRoaXMpLCBjb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2QpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY2hlY2tGUFMgPSBmdW5jdGlvbiBjaGVja0ZQUyh2aWRlbywgZGVjb2RlZEZyYW1lcywgZHJvcHBlZEZyYW1lcykge1xuICAgIHZhciBjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgaWYgKGRlY29kZWRGcmFtZXMpIHtcbiAgICAgIGlmICh0aGlzLmxhc3RUaW1lKSB7XG4gICAgICAgIHZhciBjdXJyZW50UGVyaW9kID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUaW1lO1xuICAgICAgICB2YXIgY3VycmVudERyb3BwZWQgPSBkcm9wcGVkRnJhbWVzIC0gdGhpcy5sYXN0RHJvcHBlZEZyYW1lcztcbiAgICAgICAgdmFyIGN1cnJlbnREZWNvZGVkID0gZGVjb2RlZEZyYW1lcyAtIHRoaXMubGFzdERlY29kZWRGcmFtZXM7XG4gICAgICAgIHZhciBkcm9wcGVkRlBTID0gMTAwMCAqIGN1cnJlbnREcm9wcGVkIC8gY3VycmVudFBlcmlvZDtcbiAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRlBTX0RST1AsIHtcbiAgICAgICAgICBjdXJyZW50RHJvcHBlZDogY3VycmVudERyb3BwZWQsXG4gICAgICAgICAgY3VycmVudERlY29kZWQ6IGN1cnJlbnREZWNvZGVkLFxuICAgICAgICAgIHRvdGFsRHJvcHBlZEZyYW1lczogZHJvcHBlZEZyYW1lc1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZHJvcHBlZEZQUyA+IDApIHtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdjaGVja0ZQUyA6IGRyb3BwZWRGUFMvZGVjb2RlZEZQUzonICsgZHJvcHBlZEZQUy8oMTAwMCAqIGN1cnJlbnREZWNvZGVkIC8gY3VycmVudFBlcmlvZCkpO1xuICAgICAgICAgIGlmIChjdXJyZW50RHJvcHBlZCA+IGhscy5jb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQgKiBjdXJyZW50RGVjb2RlZCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRMZXZlbCA9IGhscy5jdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJsb2dnZXJcIl0ud2FybignZHJvcCBGUFMgcmF0aW8gZ3JlYXRlciB0aGFuIG1heCBhbGxvd2VkIHZhbHVlIGZvciBjdXJyZW50TGV2ZWw6ICcgKyBjdXJyZW50TGV2ZWwpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudExldmVsID4gMCAmJiAoaGxzLmF1dG9MZXZlbENhcHBpbmcgPT09IC0xIHx8IGhscy5hdXRvTGV2ZWxDYXBwaW5nID49IGN1cnJlbnRMZXZlbCkpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gY3VycmVudExldmVsIC0gMTtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHtcbiAgICAgICAgICAgICAgICBsZXZlbDogY3VycmVudExldmVsLFxuICAgICAgICAgICAgICAgIGRyb3BwZWRMZXZlbDogaGxzLmN1cnJlbnRMZXZlbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaGxzLmF1dG9MZXZlbENhcHBpbmcgPSBjdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyA9IGRyb3BwZWRGcmFtZXM7XG4gICAgICB0aGlzLmxhc3REZWNvZGVkRnJhbWVzID0gZGVjb2RlZEZyYW1lcztcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNoZWNrRlBTSW50ZXJ2YWwgPSBmdW5jdGlvbiBjaGVja0ZQU0ludGVydmFsKCkge1xuICAgIHZhciB2aWRlbyA9IHRoaXMubWVkaWE7XG5cbiAgICBpZiAodmlkZW8pIHtcbiAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUpIHtcbiAgICAgICAgdmFyIHZpZGVvUGxheWJhY2tRdWFsaXR5ID0gdmlkZW8uZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkoKTtcbiAgICAgICAgdGhpcy5jaGVja0ZQUyh2aWRlbywgdmlkZW9QbGF5YmFja1F1YWxpdHkudG90YWxWaWRlb0ZyYW1lcywgdmlkZW9QbGF5YmFja1F1YWxpdHkuZHJvcHBlZFZpZGVvRnJhbWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhUTUxWaWRlb0VsZW1lbnQgZG9lc24ndCBpbmNsdWRlIHRoZSB3ZWJraXQgdHlwZXNcbiAgICAgICAgdGhpcy5jaGVja0ZQUyh2aWRlbywgdmlkZW8ud2Via2l0RGVjb2RlZEZyYW1lQ291bnQsIHZpZGVvLndlYmtpdERyb3BwZWRGcmFtZUNvdW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEZQU0NvbnRyb2xsZXI7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoRlBTQ29udHJvbGxlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtZmluZGVycy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC1maW5kZXJzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBmaW5kRnJhZ21lbnRCeVBEVCwgZmluZEZyYWdtZW50QnlQVFMsIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCwgcGR0V2l0aGluVG9sZXJhbmNlVGVzdCwgZmluZEZyYWdXaXRoQ0MgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZmluZEZyYWdtZW50QnlQRFRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmaW5kRnJhZ21lbnRCeVBEVDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZmluZEZyYWdtZW50QnlQVFNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmaW5kRnJhZ21lbnRCeVBUUzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcGR0V2l0aGluVG9sZXJhbmNlVGVzdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZmluZEZyYWdXaXRoQ0NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmaW5kRnJhZ1dpdGhDQzsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2JpbmFyeV9zZWFyY2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2JpbmFyeS1zZWFyY2ggKi8gXCIuL3NyYy91dGlscy9iaW5hcnktc2VhcmNoLnRzXCIpO1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIGZpcnN0IGZyYWdtZW50IHdob3NlIGVuZFBkdCB2YWx1ZSBleGNlZWRzIHRoZSBnaXZlbiBQRFQuXG4gKiBAcGFyYW0ge0FycmF5PEZyYWdtZW50Pn0gZnJhZ21lbnRzIC0gVGhlIGFycmF5IG9mIGNhbmRpZGF0ZSBmcmFnbWVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfG51bGx9IFtQRFRWYWx1ZSA9IG51bGxdIC0gVGhlIFBEVCB2YWx1ZSB3aGljaCBtdXN0IGJlIGV4Y2VlZGVkXG4gKiBAcGFyYW0ge251bWJlcn0gW21heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwXSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydC9lbmQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHsqfG51bGx9IGZyYWdtZW50IC0gVGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gZmluZEZyYWdtZW50QnlQRFQoZnJhZ21lbnRzLCBQRFRWYWx1ZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkge1xuICBpZiAoUERUVmFsdWUgPT09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkoZnJhZ21lbnRzKSB8fCAhZnJhZ21lbnRzLmxlbmd0aCB8fCAhT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShQRFRWYWx1ZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBpZiBsZXNzIHRoYW4gc3RhcnRcblxuXG4gIHZhciBzdGFydFBEVCA9IGZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7XG5cbiAgaWYgKFBEVFZhbHVlIDwgKHN0YXJ0UERUIHx8IDApKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZW5kUERUID0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXS5lbmRQcm9ncmFtRGF0ZVRpbWU7XG5cbiAgaWYgKFBEVFZhbHVlID49IChlbmRQRFQgfHwgMCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHx8IDA7XG5cbiAgZm9yICh2YXIgc2VnID0gMDsgc2VnIDwgZnJhZ21lbnRzLmxlbmd0aDsgKytzZWcpIHtcbiAgICB2YXIgZnJhZyA9IGZyYWdtZW50c1tzZWddO1xuXG4gICAgaWYgKHBkdFdpdGhpblRvbGVyYW5jZVRlc3QoUERUVmFsdWUsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWcpKSB7XG4gICAgICByZXR1cm4gZnJhZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogRmluZHMgYSBmcmFnbWVudCBiYXNlZCBvbiB0aGUgU04gb2YgdGhlIHByZXZpb3VzIGZyYWdtZW50OyBvciBiYXNlZCBvbiB0aGUgbmVlZHMgb2YgdGhlIGN1cnJlbnQgYnVmZmVyLlxuICogVGhpcyBtZXRob2QgY29tcGVuc2F0ZXMgZm9yIHNtYWxsIGJ1ZmZlciBnYXBzIGJ5IGFwcGx5aW5nIGEgdG9sZXJhbmNlIHRvIHRoZSBzdGFydCBvZiBhbnkgY2FuZGlkYXRlIGZyYWdtZW50LCB0aHVzXG4gKiBicmVha2luZyBhbnkgdHJhcHMgd2hpY2ggd291bGQgY2F1c2UgdGhlIHNhbWUgZnJhZ21lbnQgdG8gYmUgY29udGludW91c2x5IHNlbGVjdGVkIHdpdGhpbiBhIHNtYWxsIHJhbmdlLlxuICogQHBhcmFtIHsqfSBmcmFnUHJldmlvdXMgLSBUaGUgbGFzdCBmcmFnIHN1Y2Nlc3NmdWxseSBhcHBlbmRlZFxuICogQHBhcmFtIHtBcnJheX0gZnJhZ21lbnRzIC0gVGhlIGFycmF5IG9mIGNhbmRpZGF0ZSBmcmFnbWVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYnVmZmVyRW5kID0gMF0gLSBUaGUgZW5kIG9mIHRoZSBjb250aWd1b3VzIGJ1ZmZlcmVkIHJhbmdlIHRoZSBwbGF5aGVhZCBpcyBjdXJyZW50bHkgd2l0aGluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydC9lbmQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHsqfSBmb3VuZEZyYWcgLSBUaGUgYmVzdCBtYXRjaGluZyBmcmFnbWVudFxuICovXG5cbmZ1bmN0aW9uIGZpbmRGcmFnbWVudEJ5UFRTKGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIHtcbiAgaWYgKGJ1ZmZlckVuZCA9PT0gdm9pZCAwKSB7XG4gICAgYnVmZmVyRW5kID0gMDtcbiAgfVxuXG4gIGlmIChtYXhGcmFnTG9va1VwVG9sZXJhbmNlID09PSB2b2lkIDApIHtcbiAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMDtcbiAgfVxuXG4gIHZhciBmcmFnTmV4dCA9IG51bGw7XG5cbiAgaWYgKGZyYWdQcmV2aW91cykge1xuICAgIGZyYWdOZXh0ID0gZnJhZ21lbnRzW2ZyYWdQcmV2aW91cy5zbiAtIGZyYWdtZW50c1swXS5zbiArIDFdIHx8IG51bGw7XG4gIH0gZWxzZSBpZiAoYnVmZmVyRW5kID09PSAwICYmIGZyYWdtZW50c1swXS5zdGFydCA9PT0gMCkge1xuICAgIGZyYWdOZXh0ID0gZnJhZ21lbnRzWzBdO1xuICB9IC8vIFByZWZlciB0aGUgbmV4dCBmcmFnbWVudCBpZiBpdCdzIHdpdGhpbiB0b2xlcmFuY2VcblxuXG4gIGlmIChmcmFnTmV4dCAmJiBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnTmV4dCkgPT09IDApIHtcbiAgICByZXR1cm4gZnJhZ05leHQ7XG4gIH0gLy8gV2UgbWlnaHQgYmUgc2Vla2luZyBwYXN0IHRoZSB0b2xlcmFuY2Ugc28gZmluZCB0aGUgYmVzdCBtYXRjaFxuXG5cbiAgdmFyIGZvdW5kRnJhZ21lbnQgPSBfdXRpbHNfYmluYXJ5X3NlYXJjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5zZWFyY2goZnJhZ21lbnRzLCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QuYmluZChudWxsLCBidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpKTtcblxuICBpZiAoZm91bmRGcmFnbWVudCkge1xuICAgIHJldHVybiBmb3VuZEZyYWdtZW50O1xuICB9IC8vIElmIG5vIG1hdGNoIHdhcyBmb3VuZCByZXR1cm4gdGhlIG5leHQgZnJhZ21lbnQgYWZ0ZXIgZnJhZ1ByZXZpb3VzLCBvciBudWxsXG5cblxuICByZXR1cm4gZnJhZ05leHQ7XG59XG4vKipcbiAqIFRoZSB0ZXN0IGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGZpbmRGcmFnbWVudEJ5U24ncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gKiBAcGFyYW0geyp9IGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gKiBAcGFyYW0ge251bWJlcn0gW2J1ZmZlckVuZCA9IDBdIC0gVGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5IHdpdGhpblxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gMCBpZiBpdCBtYXRjaGVzLCAxIGlmIHRvbyBsb3csIC0xIGlmIHRvbyBoaWdoXG4gKi9cblxuZnVuY3Rpb24gZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlKSB7XG4gIGlmIChidWZmZXJFbmQgPT09IHZvaWQgMCkge1xuICAgIGJ1ZmZlckVuZCA9IDA7XG4gIH1cblxuICBpZiAobWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9PT0gdm9pZCAwKSB7XG4gICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDA7XG4gIH1cblxuICAvLyBvZmZzZXQgc2hvdWxkIGJlIHdpdGhpbiBmcmFnbWVudCBib3VuZGFyeSAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlXG4gIC8vIHRoaXMgaXMgdG8gY29wZSB3aXRoIHNpdHVhdGlvbnMgbGlrZVxuICAvLyBidWZmZXJFbmQgPSA5Ljk5MVxuICAvLyBmcmFnW8OYXSA6IFswLDEwXVxuICAvLyBmcmFnWzFdIDogWzEwLDIwXVxuICAvLyBidWZmZXJFbmQgaXMgd2l0aGluIGZyYWdbMF0gcmFuZ2UgLi4uIGFsdGhvdWdoIHdoYXQgd2UgYXJlIGV4cGVjdGluZyBpcyB0byByZXR1cm4gZnJhZ1sxXSBoZXJlXG4gIC8vICAgICAgICAgICAgICBmcmFnIHN0YXJ0ICAgICAgICAgICAgICAgZnJhZyBzdGFydCtkdXJhdGlvblxuICAvLyAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgLy8gICAgICAgICAgICAgIDwtLS0+ICAgICAgICAgICAgICAgICAgICAgICAgIDwtLS0+XG4gIC8vICAuLi4tLS0tLS0tLT48LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+PC0tLS0tLS0tLS4uLi5cbiAgLy8gcHJldmlvdXMgZnJhZyAgICAgICAgIG1hdGNoaW5nIGZyYWdtZW50ICAgICAgICAgbmV4dCBmcmFnXG4gIC8vICByZXR1cm4gLTEgICAgICAgICAgICAgcmV0dXJuIDAgICAgICAgICAgICAgICAgIHJldHVybiAxXG4gIC8vIGxvZ2dlci5sb2coYGxldmVsL3NuL3N0YXJ0L2VuZC9idWZFbmQ6JHtsZXZlbH0vJHtjYW5kaWRhdGUuc259LyR7Y2FuZGlkYXRlLnN0YXJ0fS8keyhjYW5kaWRhdGUuc3RhcnQrY2FuZGlkYXRlLmR1cmF0aW9uKX0vJHtidWZmZXJFbmR9YCk7XG4gIC8vIFNldCB0aGUgbG9va3VwIHRvbGVyYW5jZSB0byBiZSBzbWFsbCBlbm91Z2ggdG8gZGV0ZWN0IHRoZSBjdXJyZW50IHNlZ21lbnQgLSBlbnN1cmVzIHdlIGRvbid0IHNraXAgb3ZlciB2ZXJ5IHNtYWxsIHNlZ21lbnRzXG4gIHZhciBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMCkpO1xuXG4gIGlmIChjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPD0gYnVmZmVyRW5kKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoY2FuZGlkYXRlLnN0YXJ0IC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gYnVmZmVyRW5kICYmIGNhbmRpZGF0ZS5zdGFydCkge1xuICAgIC8vIGlmIG1heEZyYWdMb29rVXBUb2xlcmFuY2Ugd2lsbCBoYXZlIG5lZ2F0aXZlIHZhbHVlIHRoZW4gZG9uJ3QgcmV0dXJuIC0xIGZvciBmaXJzdCBlbGVtZW50XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG4vKipcbiAqIFRoZSB0ZXN0IGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGZpbmRGcmFnbWVudEJ5UGR0J3MgQmluYXJ5U2VhcmNoIHRvIGxvb2sgZm9yIHRoZSBiZXN0IG1hdGNoIHRvIHRoZSBjdXJyZW50IGJ1ZmZlciBjb25kaXRpb25zLlxuICogVGhpcyBmdW5jdGlvbiB0ZXN0cyB0aGUgY2FuZGlkYXRlJ3MgcHJvZ3JhbSBkYXRlIHRpbWUgdmFsdWVzLCBhcyByZXByZXNlbnRlZCBpbiBVbml4IHRpbWVcbiAqIEBwYXJhbSB7Kn0gY2FuZGlkYXRlIC0gVGhlIGZyYWdtZW50IHRvIHRlc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGR0QnVmZmVyRW5kID0gMF0gLSBUaGUgVW5peCB0aW1lIHJlcHJlc2VudGluZyB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlcmVkIHJhbmdlXG4gKiBAcGFyYW0ge251bWJlcn0gW21heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwXSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgY29udGlndW91cywgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cblxuZnVuY3Rpb24gcGR0V2l0aGluVG9sZXJhbmNlVGVzdChwZHRCdWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZSkge1xuICB2YXIgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uICsgKGNhbmRpZGF0ZS5kZWx0YVBUUyA/IGNhbmRpZGF0ZS5kZWx0YVBUUyA6IDApKSAqIDEwMDA7IC8vIGVuZFByb2dyYW1EYXRlVGltZSBjYW4gYmUgbnVsbCwgZGVmYXVsdCB0byB6ZXJvXG5cbiAgdmFyIGVuZFByb2dyYW1EYXRlVGltZSA9IGNhbmRpZGF0ZS5lbmRQcm9ncmFtRGF0ZVRpbWUgfHwgMDtcbiAgcmV0dXJuIGVuZFByb2dyYW1EYXRlVGltZSAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IHBkdEJ1ZmZlckVuZDtcbn1cbmZ1bmN0aW9uIGZpbmRGcmFnV2l0aENDKGZyYWdtZW50cywgY2MpIHtcbiAgcmV0dXJuIF91dGlsc19iaW5hcnlfc2VhcmNoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLnNlYXJjaChmcmFnbWVudHMsIGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcbiAgICBpZiAoY2FuZGlkYXRlLmNjIDwgY2MpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoY2FuZGlkYXRlLmNjID4gY2MpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LXRyYWNrZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IEZyYWdtZW50U3RhdGUsIEZyYWdtZW50VHJhY2tlciAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJGcmFnbWVudFN0YXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRnJhZ21lbnRTdGF0ZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiRnJhZ21lbnRUcmFja2VyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRnJhZ21lbnRUcmFja2VyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvbG9hZGVyICovIFwiLi9zcmMvdHlwZXMvbG9hZGVyLnRzXCIpO1xuXG5cbnZhciBGcmFnbWVudFN0YXRlO1xuXG4oZnVuY3Rpb24gKEZyYWdtZW50U3RhdGUpIHtcbiAgRnJhZ21lbnRTdGF0ZVtcIk5PVF9MT0FERURcIl0gPSBcIk5PVF9MT0FERURcIjtcbiAgRnJhZ21lbnRTdGF0ZVtcIkFQUEVORElOR1wiXSA9IFwiQVBQRU5ESU5HXCI7XG4gIEZyYWdtZW50U3RhdGVbXCJQQVJUSUFMXCJdID0gXCJQQVJUSUFMXCI7XG4gIEZyYWdtZW50U3RhdGVbXCJPS1wiXSA9IFwiT0tcIjtcbn0pKEZyYWdtZW50U3RhdGUgfHwgKEZyYWdtZW50U3RhdGUgPSB7fSkpO1xuXG52YXIgRnJhZ21lbnRUcmFja2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRnJhZ21lbnRUcmFja2VyKGhscykge1xuICAgIHRoaXMuYWN0aXZlRnJhZ21lbnQgPSBudWxsO1xuICAgIHRoaXMuYWN0aXZlUGFydHMgPSBudWxsO1xuICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnRpbWVSYW5nZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYnVmZmVyUGFkZGluZyA9IDAuMjtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcblxuICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRnJhZ21lbnRUcmFja2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX3JlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkJVRkZFUl9BUFBFTkRFRCwgdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uX3VucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQlVGRkVSX0FQUEVOREVELCB0aGlzLm9uQnVmZmVyQXBwZW5kZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTsgLy8gQHRzLWlnbm9yZVxuXG5cbiAgICB0aGlzLmZyYWdtZW50cyA9IHRoaXMudGltZVJhbmdlcyA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIEZyYWdtZW50IHdpdGggYW4gYXBwZW5kZWQgcmFuZ2UgdGhhdCBtYXRjaGVzIHRoZSBwb3NpdGlvbiBhbmQgbGV2ZWxUeXBlLlxuICAgKiBJZiBub3QgZm91bmQgYW55IEZyYWdtZW50LCByZXR1cm4gbnVsbFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRBcHBlbmRlZEZyYWcgPSBmdW5jdGlvbiBnZXRBcHBlbmRlZEZyYWcocG9zaXRpb24sIGxldmVsVHlwZSkge1xuICAgIGlmIChsZXZlbFR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLk1BSU4pIHtcbiAgICAgIHZhciBhY3RpdmVGcmFnbWVudCA9IHRoaXMuYWN0aXZlRnJhZ21lbnQsXG4gICAgICAgICAgYWN0aXZlUGFydHMgPSB0aGlzLmFjdGl2ZVBhcnRzO1xuXG4gICAgICBpZiAoIWFjdGl2ZUZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aXZlUGFydHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFjdGl2ZVBhcnRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIHZhciBhY3RpdmVQYXJ0ID0gYWN0aXZlUGFydHNbaV07XG4gICAgICAgICAgdmFyIGFwcGVuZGVkUFRTID0gYWN0aXZlUGFydCA/IGFjdGl2ZVBhcnQuZW5kIDogYWN0aXZlRnJhZ21lbnQuYXBwZW5kZWRQVFM7XG5cbiAgICAgICAgICBpZiAoYWN0aXZlUGFydC5zdGFydCA8PSBwb3NpdGlvbiAmJiBhcHBlbmRlZFBUUyAhPT0gdW5kZWZpbmVkICYmIHBvc2l0aW9uIDw9IGFwcGVuZGVkUFRTKSB7XG4gICAgICAgICAgICAvLyA5IGlzIGEgbWFnaWMgbnVtYmVyLiByZW1vdmUgcGFydHMgZnJvbSBsb29rdXAgYWZ0ZXIgYSBtYXRjaCBidXQga2VlcCBzb21lIHNob3J0IHNlZWtzIGJhY2suXG4gICAgICAgICAgICBpZiAoaSA+IDkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hY3RpdmVQYXJ0cyA9IGFjdGl2ZVBhcnRzLnNsaWNlKGkgLSA5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZVBhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFjdGl2ZUZyYWdtZW50LnN0YXJ0IDw9IHBvc2l0aW9uICYmIGFjdGl2ZUZyYWdtZW50LmFwcGVuZGVkUFRTICE9PSB1bmRlZmluZWQgJiYgcG9zaXRpb24gPD0gYWN0aXZlRnJhZ21lbnQuYXBwZW5kZWRQVFMpIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZUZyYWdtZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgbGV2ZWxUeXBlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgYnVmZmVyZWQgRnJhZ21lbnQgdGhhdCBtYXRjaGVzIHRoZSBwb3NpdGlvbiBhbmQgbGV2ZWxUeXBlLlxuICAgKiBBIGJ1ZmZlcmVkIEZyYWdtZW50IGlzIG9uZSB3aG9zZSBsb2FkaW5nLCBwYXJzaW5nIGFuZCBhcHBlbmRpbmcgaXMgZG9uZSAoY29tcGxldGVkIG9yIFwicGFydGlhbFwiIG1lYW5pbmcgYWJvcnRlZCkuXG4gICAqIElmIG5vdCBmb3VuZCBhbnkgRnJhZ21lbnQsIHJldHVybiBudWxsXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldEJ1ZmZlcmVkRnJhZyA9IGZ1bmN0aW9uIGdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgbGV2ZWxUeXBlKSB7XG4gICAgdmFyIGZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnRzKTtcblxuICAgIGZvciAodmFyIGkgPSBrZXlzLmxlbmd0aDsgaS0tOykge1xuICAgICAgdmFyIGZyYWdtZW50RW50aXR5ID0gZnJhZ21lbnRzW2tleXNbaV1dO1xuXG4gICAgICBpZiAoKGZyYWdtZW50RW50aXR5ID09PSBudWxsIHx8IGZyYWdtZW50RW50aXR5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmcmFnbWVudEVudGl0eS5ib2R5LnR5cGUpID09PSBsZXZlbFR5cGUgJiYgZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQpIHtcbiAgICAgICAgdmFyIGZyYWcgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuXG4gICAgICAgIGlmIChmcmFnLnN0YXJ0IDw9IHBvc2l0aW9uICYmIHBvc2l0aW9uIDw9IGZyYWcuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUGFydGlhbCBmcmFnbWVudHMgZWZmZWN0ZWQgYnkgY29kZWQgZnJhbWUgZXZpY3Rpb24gd2lsbCBiZSByZW1vdmVkXG4gICAqIFRoZSBicm93c2VyIHdpbGwgdW5sb2FkIHBhcnRzIG9mIHRoZSBidWZmZXIgdG8gZnJlZSB1cCBtZW1vcnkgZm9yIG5ldyBidWZmZXIgZGF0YVxuICAgKiBGcmFnbWVudHMgd2lsbCBuZWVkIHRvIGJlIHJlbG9hZGVkIHdoZW4gdGhlIGJ1ZmZlciBpcyBmcmVlZCB1cCwgcmVtb3ZpbmcgcGFydGlhbCBmcmFnbWVudHMgd2lsbCBhbGxvdyB0aGVtIHRvIHJlbG9hZChzaW5jZSB0aGVyZSBtaWdodCBiZSBwYXJ0cyB0aGF0IGFyZSBzdGlsbCBwbGF5YWJsZSlcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyA9IGZ1bmN0aW9uIGRldGVjdEV2aWN0ZWRGcmFnbWVudHMoZWxlbWVudGFyeVN0cmVhbSwgdGltZVJhbmdlLCBwbGF5bGlzdFR5cGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gQ2hlY2sgaWYgYW55IGZsYWdnZWQgZnJhZ21lbnRzIGhhdmUgYmVlbiB1bmxvYWRlZFxuICAgIE9iamVjdC5rZXlzKHRoaXMuZnJhZ21lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBmcmFnbWVudEVudGl0eSA9IF90aGlzLmZyYWdtZW50c1trZXldO1xuXG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICBpZiAoZnJhZ21lbnRFbnRpdHkuYm9keS50eXBlID09PSBwbGF5bGlzdFR5cGUpIHtcbiAgICAgICAgICBfdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGVzRGF0YSA9IGZyYWdtZW50RW50aXR5LnJhbmdlW2VsZW1lbnRhcnlTdHJlYW1dO1xuXG4gICAgICBpZiAoIWVzRGF0YSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGVzRGF0YS50aW1lLnNvbWUoZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgdmFyIGlzTm90QnVmZmVyZWQgPSAhX3RoaXMuaXNUaW1lQnVmZmVyZWQodGltZS5zdGFydFBUUywgdGltZS5lbmRQVFMsIHRpbWVSYW5nZSk7XG5cbiAgICAgICAgaWYgKGlzTm90QnVmZmVyZWQpIHtcbiAgICAgICAgICAvLyBVbnJlZ2lzdGVyIHBhcnRpYWwgZnJhZ21lbnQgYXMgaXQgbmVlZHMgdG8gbG9hZCBhZ2FpbiB0byBiZSByZXVzZWRcbiAgICAgICAgICBfdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc05vdEJ1ZmZlcmVkO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZnJhZ21lbnQgcGFzc2VkIGluIGlzIGxvYWRlZCBpbiB0aGUgYnVmZmVyIHByb3Blcmx5XG4gICAqIFBhcnRpYWxseSBsb2FkZWQgZnJhZ21lbnRzIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyBhIHBhcnRpYWwgZnJhZ21lbnRcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGV0ZWN0UGFydGlhbEZyYWdtZW50cyA9IGZ1bmN0aW9uIGRldGVjdFBhcnRpYWxGcmFnbWVudHMoZGF0YSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHRpbWVSYW5nZXMgPSB0aGlzLnRpbWVSYW5nZXM7XG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBkYXRhLnBhcnQ7XG5cbiAgICBpZiAoIXRpbWVSYW5nZXMgfHwgZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZyk7XG4gICAgdmFyIGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG5cbiAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXModGltZVJhbmdlcykuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudGFyeVN0cmVhbSkge1xuICAgICAgdmFyIHN0cmVhbUluZm8gPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zW2VsZW1lbnRhcnlTdHJlYW1dO1xuXG4gICAgICBpZiAoIXN0cmVhbUluZm8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZVJhbmdlID0gdGltZVJhbmdlc1tlbGVtZW50YXJ5U3RyZWFtXTtcbiAgICAgIHZhciBwYXJ0aWFsID0gcGFydCAhPT0gbnVsbCB8fCBzdHJlYW1JbmZvLnBhcnRpYWwgPT09IHRydWU7XG4gICAgICBmcmFnbWVudEVudGl0eS5yYW5nZVtlbGVtZW50YXJ5U3RyZWFtXSA9IF90aGlzMi5nZXRCdWZmZXJlZFRpbWVzKGZyYWcsIHBhcnQsIHBhcnRpYWwsIHRpbWVSYW5nZSk7XG4gICAgfSk7XG4gICAgZnJhZ21lbnRFbnRpdHkubG9hZGVkID0gbnVsbDtcblxuICAgIGlmIChPYmplY3Qua2V5cyhmcmFnbWVudEVudGl0eS5yYW5nZSkubGVuZ3RoKSB7XG4gICAgICBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSBmcmFnbWVudCBpZiBub3RoaW5nIHdhcyBhcHBlbmRlZFxuICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmZyYWdCdWZmZXJlZCA9IGZ1bmN0aW9uIGZyYWdCdWZmZXJlZChmcmFnKSB7XG4gICAgdmFyIGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnKTtcbiAgICB2YXIgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcblxuICAgIGlmIChmcmFnbWVudEVudGl0eSkge1xuICAgICAgZnJhZ21lbnRFbnRpdHkubG9hZGVkID0gbnVsbDtcbiAgICAgIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldEJ1ZmZlcmVkVGltZXMgPSBmdW5jdGlvbiBnZXRCdWZmZXJlZFRpbWVzKGZyYWdtZW50LCBwYXJ0LCBwYXJ0aWFsLCB0aW1lUmFuZ2UpIHtcbiAgICB2YXIgYnVmZmVyZWQgPSB7XG4gICAgICB0aW1lOiBbXSxcbiAgICAgIHBhcnRpYWw6IHBhcnRpYWxcbiAgICB9O1xuICAgIHZhciBzdGFydFBUUyA9IHBhcnQgPyBwYXJ0LnN0YXJ0IDogZnJhZ21lbnQuc3RhcnQ7XG4gICAgdmFyIGVuZFBUUyA9IHBhcnQgPyBwYXJ0LmVuZCA6IGZyYWdtZW50LmVuZDtcbiAgICB2YXIgbWluRW5kUFRTID0gZnJhZ21lbnQubWluRW5kUFRTIHx8IGVuZFBUUztcbiAgICB2YXIgbWF4U3RhcnRQVFMgPSBmcmFnbWVudC5tYXhTdGFydFBUUyB8fCBzdGFydFBUUztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gdGltZVJhbmdlLnN0YXJ0KGkpIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgdmFyIGVuZFRpbWUgPSB0aW1lUmFuZ2UuZW5kKGkpICsgdGhpcy5idWZmZXJQYWRkaW5nO1xuXG4gICAgICBpZiAobWF4U3RhcnRQVFMgPj0gc3RhcnRUaW1lICYmIG1pbkVuZFBUUyA8PSBlbmRUaW1lKSB7XG4gICAgICAgIC8vIEZyYWdtZW50IGlzIGVudGlyZWx5IGNvbnRhaW5lZCBpbiBidWZmZXJcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgb3RoZXIgdGltZVJhbmdlIHRpbWVzIHNpbmNlIGl0J3MgY29tcGxldGVseSBwbGF5YWJsZVxuICAgICAgICBidWZmZXJlZC50aW1lLnB1c2goe1xuICAgICAgICAgIHN0YXJ0UFRTOiBNYXRoLm1heChzdGFydFBUUywgdGltZVJhbmdlLnN0YXJ0KGkpKSxcbiAgICAgICAgICBlbmRQVFM6IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSlcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChzdGFydFBUUyA8IGVuZFRpbWUgJiYgZW5kUFRTID4gc3RhcnRUaW1lKSB7XG4gICAgICAgIGJ1ZmZlcmVkLnBhcnRpYWwgPSB0cnVlOyAvLyBDaGVjayBmb3IgaW50ZXJzZWN0aW9uIHdpdGggYnVmZmVyXG4gICAgICAgIC8vIEdldCBwbGF5YWJsZSBzZWN0aW9ucyBvZiB0aGUgZnJhZ21lbnRcblxuICAgICAgICBidWZmZXJlZC50aW1lLnB1c2goe1xuICAgICAgICAgIHN0YXJ0UFRTOiBNYXRoLm1heChzdGFydFBUUywgdGltZVJhbmdlLnN0YXJ0KGkpKSxcbiAgICAgICAgICBlbmRQVFM6IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGVuZFBUUyA8PSBzdGFydFRpbWUpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWZmZXJlZDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcGFydGlhbCBmcmFnbWVudCBmb3IgYSBjZXJ0YWluIHRpbWVcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0UGFydGlhbEZyYWdtZW50ID0gZnVuY3Rpb24gZ2V0UGFydGlhbEZyYWdtZW50KHRpbWUpIHtcbiAgICB2YXIgYmVzdEZyYWdtZW50ID0gbnVsbDtcbiAgICB2YXIgdGltZVBhZGRpbmc7XG4gICAgdmFyIHN0YXJ0VGltZTtcbiAgICB2YXIgZW5kVGltZTtcbiAgICB2YXIgYmVzdE92ZXJsYXAgPSAwO1xuICAgIHZhciBidWZmZXJQYWRkaW5nID0gdGhpcy5idWZmZXJQYWRkaW5nLFxuICAgICAgICBmcmFnbWVudHMgPSB0aGlzLmZyYWdtZW50cztcbiAgICBPYmplY3Qua2V5cyhmcmFnbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGZyYWdtZW50RW50aXR5ID0gZnJhZ21lbnRzW2tleV07XG5cbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICBzdGFydFRpbWUgPSBmcmFnbWVudEVudGl0eS5ib2R5LnN0YXJ0IC0gYnVmZmVyUGFkZGluZztcbiAgICAgICAgZW5kVGltZSA9IGZyYWdtZW50RW50aXR5LmJvZHkuZW5kICsgYnVmZmVyUGFkZGluZztcblxuICAgICAgICBpZiAodGltZSA+PSBzdGFydFRpbWUgJiYgdGltZSA8PSBlbmRUaW1lKSB7XG4gICAgICAgICAgLy8gVXNlIHRoZSBmcmFnbWVudCB0aGF0IGhhcyB0aGUgbW9zdCBwYWRkaW5nIGZyb20gc3RhcnQgYW5kIGVuZCB0aW1lXG4gICAgICAgICAgdGltZVBhZGRpbmcgPSBNYXRoLm1pbih0aW1lIC0gc3RhcnRUaW1lLCBlbmRUaW1lIC0gdGltZSk7XG5cbiAgICAgICAgICBpZiAoYmVzdE92ZXJsYXAgPD0gdGltZVBhZGRpbmcpIHtcbiAgICAgICAgICAgIGJlc3RGcmFnbWVudCA9IGZyYWdtZW50RW50aXR5LmJvZHk7XG4gICAgICAgICAgICBiZXN0T3ZlcmxhcCA9IHRpbWVQYWRkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBiZXN0RnJhZ21lbnQ7XG4gIH07XG5cbiAgX3Byb3RvLmdldFN0YXRlID0gZnVuY3Rpb24gZ2V0U3RhdGUoZnJhZ21lbnQpIHtcbiAgICB2YXIgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICB2YXIgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcblxuICAgIGlmIChmcmFnbWVudEVudGl0eSkge1xuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5BUFBFTkRJTkc7XG4gICAgICB9IGVsc2UgaWYgKGlzUGFydGlhbChmcmFnbWVudEVudGl0eSkpIHtcbiAgICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuUEFSVElBTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBGcmFnbWVudFN0YXRlLk9LO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQ7XG4gIH07XG5cbiAgX3Byb3RvLmlzVGltZUJ1ZmZlcmVkID0gZnVuY3Rpb24gaXNUaW1lQnVmZmVyZWQoc3RhcnRQVFMsIGVuZFBUUywgdGltZVJhbmdlKSB7XG4gICAgdmFyIHN0YXJ0VGltZTtcbiAgICB2YXIgZW5kVGltZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGFydFRpbWUgPSB0aW1lUmFuZ2Uuc3RhcnQoaSkgLSB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcblxuICAgICAgaWYgKHN0YXJ0UFRTID49IHN0YXJ0VGltZSAmJiBlbmRQVFMgPD0gZW5kVGltZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFBUUyA8PSBzdGFydFRpbWUpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ0xvYWRlZCA9IGZ1bmN0aW9uIG9uRnJhZ0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZGF0YS5wYXJ0OyAvLyBkb24ndCB0cmFjayBpbml0c2VnbWVudCAoZm9yIHdoaWNoIHNuIGlzIG5vdCBhIG51bWJlcilcbiAgICAvLyBkb24ndCB0cmFjayBmcmFncyB1c2VkIGZvciBiaXRyYXRlVGVzdCwgdGhleSdyZSBpcnJlbGV2YW50LlxuICAgIC8vIGRvbid0IHRyYWNrIHBhcnRzIGZvciBtZW1vcnkgZWZmaWNpZW5jeVxuXG4gICAgaWYgKGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcgfHwgZnJhZy5iaXRyYXRlVGVzdCB8fCBwYXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnKTtcbiAgICB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XSA9IHtcbiAgICAgIGJvZHk6IGZyYWcsXG4gICAgICBsb2FkZWQ6IGRhdGEsXG4gICAgICBidWZmZXJlZDogZmFsc2UsXG4gICAgICByYW5nZTogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLm9uQnVmZmVyQXBwZW5kZWQgPSBmdW5jdGlvbiBvbkJ1ZmZlckFwcGVuZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgcGFydCA9IGRhdGEucGFydCxcbiAgICAgICAgdGltZVJhbmdlcyA9IGRhdGEudGltZVJhbmdlcztcblxuICAgIGlmIChmcmFnLnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLk1BSU4pIHtcbiAgICAgIHRoaXMuYWN0aXZlRnJhZ21lbnQgPSBmcmFnO1xuXG4gICAgICBpZiAocGFydCkge1xuICAgICAgICB2YXIgYWN0aXZlUGFydHMgPSB0aGlzLmFjdGl2ZVBhcnRzO1xuXG4gICAgICAgIGlmICghYWN0aXZlUGFydHMpIHtcbiAgICAgICAgICB0aGlzLmFjdGl2ZVBhcnRzID0gYWN0aXZlUGFydHMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFjdGl2ZVBhcnRzLnB1c2gocGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFjdGl2ZVBhcnRzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IC8vIFN0b3JlIHRoZSBsYXRlc3QgdGltZVJhbmdlcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlclxuXG5cbiAgICB0aGlzLnRpbWVSYW5nZXMgPSB0aW1lUmFuZ2VzO1xuICAgIE9iamVjdC5rZXlzKHRpbWVSYW5nZXMpLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnRhcnlTdHJlYW0pIHtcbiAgICAgIHZhciB0aW1lUmFuZ2UgPSB0aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dO1xuXG4gICAgICBfdGhpczMuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhlbGVtZW50YXJ5U3RyZWFtLCB0aW1lUmFuZ2UpO1xuXG4gICAgICBpZiAoIXBhcnQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lUmFuZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmcmFnLmFwcGVuZGVkUFRTID0gTWF0aC5tYXgodGltZVJhbmdlLmVuZChpKSwgZnJhZy5hcHBlbmRlZFBUUyB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5vbkZyYWdCdWZmZXJlZCA9IGZ1bmN0aW9uIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5kZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKGRhdGEpO1xuICB9O1xuXG4gIF9wcm90by5oYXNGcmFnbWVudCA9IGZ1bmN0aW9uIGhhc0ZyYWdtZW50KGZyYWdtZW50KSB7XG4gICAgdmFyIGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgcmV0dXJuICEhdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZUZyYWdtZW50c0luUmFuZ2UgPSBmdW5jdGlvbiByZW1vdmVGcmFnbWVudHNJblJhbmdlKHN0YXJ0LCBlbmQsIHBsYXlsaXN0VHlwZSkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgT2JqZWN0LmtleXModGhpcy5mcmFnbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGZyYWdtZW50RW50aXR5ID0gX3RoaXM0LmZyYWdtZW50c1trZXldO1xuXG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkKSB7XG4gICAgICAgIHZhciBmcmFnID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcblxuICAgICAgICBpZiAoZnJhZy50eXBlID09PSBwbGF5bGlzdFR5cGUgJiYgZnJhZy5zdGFydCA8IGVuZCAmJiBmcmFnLmVuZCA+IHN0YXJ0KSB7XG4gICAgICAgICAgX3RoaXM0LnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZUZyYWdtZW50ID0gZnVuY3Rpb24gcmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnQpIHtcbiAgICB2YXIgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICBmcmFnbWVudC5zdGF0cy5sb2FkZWQgPSAwO1xuICAgIGZyYWdtZW50LmNsZWFyRWxlbWVudGFyeVN0cmVhbUluZm8oKTtcbiAgICBkZWxldGUgdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZUFsbEZyYWdtZW50cyA9IGZ1bmN0aW9uIHJlbW92ZUFsbEZyYWdtZW50cygpIHtcbiAgICB0aGlzLmZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hY3RpdmVGcmFnbWVudCA9IG51bGw7XG4gICAgdGhpcy5hY3RpdmVQYXJ0cyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIEZyYWdtZW50VHJhY2tlcjtcbn0oKTtcblxuZnVuY3Rpb24gaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSB7XG4gIHZhciBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UsIF9mcmFnbWVudEVudGl0eSRyYW5nZTI7XG5cbiAgcmV0dXJuIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkICYmICgoKF9mcmFnbWVudEVudGl0eSRyYW5nZSA9IGZyYWdtZW50RW50aXR5LnJhbmdlLnZpZGVvKSA9PT0gbnVsbCB8fCBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mcmFnbWVudEVudGl0eSRyYW5nZS5wYXJ0aWFsKSB8fCAoKF9mcmFnbWVudEVudGl0eSRyYW5nZTIgPSBmcmFnbWVudEVudGl0eS5yYW5nZS5hdWRpbykgPT09IG51bGwgfHwgX2ZyYWdtZW50RW50aXR5JHJhbmdlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZyYWdtZW50RW50aXR5JHJhbmdlMi5wYXJ0aWFsKSk7XG59XG5cbmZ1bmN0aW9uIGdldEZyYWdtZW50S2V5KGZyYWdtZW50KSB7XG4gIHJldHVybiBmcmFnbWVudC50eXBlICsgXCJfXCIgKyBmcmFnbWVudC5sZXZlbCArIFwiX1wiICsgZnJhZ21lbnQudXJsSWQgKyBcIl9cIiArIGZyYWdtZW50LnNuO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2dhcC1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9nYXAtY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFNUQUxMX01JTklNVU1fRFVSQVRJT05fTVMsIE1BWF9TVEFSVF9HQVBfSlVNUCwgU0tJUF9CVUZGRVJfSE9MRV9TVEVQX1NFQ09ORFMsIFNLSVBfQlVGRkVSX1JBTkdFX1NUQVJULCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlNUQUxMX01JTklNVU1fRFVSQVRJT05fTVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTVEFMTF9NSU5JTVVNX0RVUkFUSU9OX01TOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJNQVhfU1RBUlRfR0FQX0pVTVBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBNQVhfU1RBUlRfR0FQX0pVTVA7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU0tJUF9CVUZGRVJfSE9MRV9TVEVQX1NFQ09ORFM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlNLSVBfQlVGRkVSX1JBTkdFX1NUQVJUXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU0tJUF9CVUZGRVJfUkFOR0VfU1RBUlQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBHYXBDb250cm9sbGVyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYnVmZmVyLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG5cblxuXG5cbnZhciBTVEFMTF9NSU5JTVVNX0RVUkFUSU9OX01TID0gMjUwO1xudmFyIE1BWF9TVEFSVF9HQVBfSlVNUCA9IDIuMDtcbnZhciBTS0lQX0JVRkZFUl9IT0xFX1NURVBfU0VDT05EUyA9IDAuMTtcbnZhciBTS0lQX0JVRkZFUl9SQU5HRV9TVEFSVCA9IDAuMDU7XG5cbnZhciBHYXBDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR2FwQ29udHJvbGxlcihjb25maWcsIG1lZGlhLCBmcmFnbWVudFRyYWNrZXIsIGhscykge1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gdm9pZCAwO1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XG4gICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICB0aGlzLm1vdmVkID0gZmFsc2U7XG4gICAgdGhpcy5zZWVraW5nID0gZmFsc2U7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEdhcENvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDsgLy8gQHRzLWlnbm9yZVxuXG4gICAgdGhpcy5obHMgPSB0aGlzLmZyYWdtZW50VHJhY2tlciA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcGxheWhlYWQgaXMgc3R1Y2sgd2l0aGluIGEgZ2FwLCBhbmQgaWYgc28sIGF0dGVtcHRzIHRvIGZyZWUgaXQuXG4gICAqIEEgZ2FwIGlzIGFuIHVuYnVmZmVyZWQgcmFuZ2UgYmV0d2VlbiB0d28gYnVmZmVyZWQgcmFuZ2VzIChvciB0aGUgc3RhcnQgYW5kIHRoZSBmaXJzdCBidWZmZXJlZCByYW5nZSkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0Q3VycmVudFRpbWUgUHJldmlvdXNseSByZWFkIHBsYXloZWFkIHBvc2l0aW9uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBvbGwgPSBmdW5jdGlvbiBwb2xsKGxhc3RDdXJyZW50VGltZSwgYWN0aXZlRnJhZykge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBzdGFsbGVkID0gdGhpcy5zdGFsbGVkO1xuXG4gICAgaWYgKG1lZGlhID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWUsXG4gICAgICAgIHNlZWtpbmcgPSBtZWRpYS5zZWVraW5nO1xuICAgIHZhciBzZWVrZWQgPSB0aGlzLnNlZWtpbmcgJiYgIXNlZWtpbmc7XG4gICAgdmFyIGJlZ2luU2VlayA9ICF0aGlzLnNlZWtpbmcgJiYgc2Vla2luZztcbiAgICB0aGlzLnNlZWtpbmcgPSBzZWVraW5nOyAvLyBUaGUgcGxheWhlYWQgaXMgbW92aW5nLCBuby1vcFxuXG4gICAgaWYgKGN1cnJlbnRUaW1lICE9PSBsYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoc3RhbGxlZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGUgcGxheWhlYWQgaXMgbm93IG1vdmluZywgYnV0IHdhcyBwcmV2aW91c2x5IHN0YWxsZWRcbiAgICAgICAgaWYgKHRoaXMuc3RhbGxSZXBvcnRlZCkge1xuICAgICAgICAgIHZhciBfc3RhbGxlZER1cmF0aW9uID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKSAtIHN0YWxsZWQ7XG5cbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ud2FybihcInBsYXliYWNrIG5vdCBzdHVjayBhbnltb3JlIEBcIiArIGN1cnJlbnRUaW1lICsgXCIsIGFmdGVyIFwiICsgTWF0aC5yb3VuZChfc3RhbGxlZER1cmF0aW9uKSArIFwibXNcIik7XG4gICAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDbGVhciBzdGFsbGVkIHN0YXRlIHdoZW4gYmVnaW5uaW5nIG9yIGZpbmlzaGluZyBzZWVraW5nIHNvIHRoYXQgd2UgZG9uJ3QgcmVwb3J0IHN0YWxscyBjb21pbmcgb3V0IG9mIGEgc2Vla1xuXG5cbiAgICBpZiAoYmVnaW5TZWVrIHx8IHNlZWtlZCkge1xuICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICB9IC8vIFRoZSBwbGF5aGVhZCBzaG91bGQgbm90IGJlIG1vdmluZ1xuXG5cbiAgICBpZiAobWVkaWEucGF1c2VkICYmICFzZWVraW5nIHx8IG1lZGlhLmVuZGVkIHx8IG1lZGlhLnBsYXliYWNrUmF0ZSA9PT0gMCB8fCAhX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkJ1ZmZlckhlbHBlclwiXS5nZXRCdWZmZXJlZChtZWRpYSkubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlckluZm8gPSBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiQnVmZmVySGVscGVyXCJdLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCAwKTtcbiAgICB2YXIgaXNCdWZmZXJlZCA9IGJ1ZmZlckluZm8ubGVuID4gMDtcbiAgICB2YXIgbmV4dFN0YXJ0ID0gYnVmZmVySW5mby5uZXh0U3RhcnQgfHwgMDsgLy8gVGhlcmUgaXMgbm8gcGxheWFibGUgYnVmZmVyIChzZWVrZWQsIHdhaXRpbmcgZm9yIGJ1ZmZlcilcblxuICAgIGlmICghaXNCdWZmZXJlZCAmJiAhbmV4dFN0YXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNlZWtpbmcpIHtcbiAgICAgIC8vIFdhaXRpbmcgZm9yIHNlZWtpbmcgaW4gYSBidWZmZXJlZCByYW5nZSB0byBjb21wbGV0ZVxuICAgICAgdmFyIGhhc0Vub3VnaEJ1ZmZlciA9IGJ1ZmZlckluZm8ubGVuID4gTUFYX1NUQVJUX0dBUF9KVU1QOyAvLyBOZXh0IGJ1ZmZlcmVkIHJhbmdlIGlzIHRvbyBmYXIgYWhlYWQgdG8ganVtcCB0byB3aGlsZSBzdGlsbCBzZWVraW5nXG5cbiAgICAgIHZhciBub0J1ZmZlckdhcCA9ICFuZXh0U3RhcnQgfHwgYWN0aXZlRnJhZyAmJiBhY3RpdmVGcmFnLnN0YXJ0IDw9IGN1cnJlbnRUaW1lIHx8IG5leHRTdGFydCAtIGN1cnJlbnRUaW1lID4gTUFYX1NUQVJUX0dBUF9KVU1QICYmICF0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRQYXJ0aWFsRnJhZ21lbnQoY3VycmVudFRpbWUpO1xuXG4gICAgICBpZiAoaGFzRW5vdWdoQnVmZmVyIHx8IG5vQnVmZmVyR2FwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gUmVzZXQgbW92ZWQgc3RhdGUgd2hlbiBzZWVraW5nIHRvIGEgcG9pbnQgaW4gb3IgYmVmb3JlIGEgZ2FwXG5cblxuICAgICAgdGhpcy5tb3ZlZCA9IGZhbHNlO1xuICAgIH0gLy8gU2tpcCBzdGFydCBnYXBzIGlmIHdlIGhhdmVuJ3QgcGxheWVkLCBidXQgdGhlIGxhc3QgcG9sbCBkZXRlY3RlZCB0aGUgc3RhcnQgb2YgYSBzdGFsbFxuICAgIC8vIFRoZSBhZGRpdGlvbiBwb2xsIGdpdmVzIHRoZSBicm93c2VyIGEgY2hhbmNlIHRvIGp1bXAgdGhlIGdhcCBmb3IgdXNcblxuXG4gICAgaWYgKCF0aGlzLm1vdmVkICYmIHRoaXMuc3RhbGxlZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9sZXZlbCRkZXRhaWxzO1xuXG4gICAgICAvLyBKdW1wIHN0YXJ0IGdhcHMgd2l0aGluIGp1bXAgdGhyZXNob2xkXG4gICAgICB2YXIgc3RhcnRKdW1wID0gTWF0aC5tYXgobmV4dFN0YXJ0LCBidWZmZXJJbmZvLnN0YXJ0IHx8IDApIC0gY3VycmVudFRpbWU7IC8vIFdoZW4gam9pbmluZyBhIGxpdmUgc3RyZWFtIHdpdGggYXVkaW8gdHJhY2tzLCBhY2NvdW50IGZvciBsaXZlIHBsYXlsaXN0IHdpbmRvdyBzbGlkaW5nIGJ5IGFsbG93aW5nXG4gICAgICAvLyBhIGxhcmdlciBqdW1wIG92ZXIgc3RhcnQgZ2FwcyBjYXVzZWQgYnkgdGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGJ1ZmZlcmluZyBhIHN0YXJ0IGZyYWdtZW50XG4gICAgICAvLyB0aGF0IGJlZ2lucyBvdmVyIDEgdGFyZ2V0IGR1cmF0aW9uIGFmdGVyIHRoZSB2aWRlbyBzdGFydCBwb3NpdGlvbi5cblxuICAgICAgdmFyIGxldmVsID0gdGhpcy5obHMubGV2ZWxzID8gdGhpcy5obHMubGV2ZWxzW3RoaXMuaGxzLmN1cnJlbnRMZXZlbF0gOiBudWxsO1xuICAgICAgdmFyIGlzTGl2ZSA9IGxldmVsID09PSBudWxsIHx8IGxldmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2xldmVsJGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzKSA9PT0gbnVsbCB8fCBfbGV2ZWwkZGV0YWlscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2xldmVsJGRldGFpbHMubGl2ZTtcbiAgICAgIHZhciBtYXhTdGFydEdhcEp1bXAgPSBpc0xpdmUgPyBsZXZlbC5kZXRhaWxzLnRhcmdldGR1cmF0aW9uICogMiA6IE1BWF9TVEFSVF9HQVBfSlVNUDtcblxuICAgICAgaWYgKHN0YXJ0SnVtcCA+IDAgJiYgc3RhcnRKdW1wIDw9IG1heFN0YXJ0R2FwSnVtcCkge1xuICAgICAgICB0aGlzLl90cnlTa2lwQnVmZmVySG9sZShudWxsKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSAvLyBTdGFydCB0cmFja2luZyBzdGFsbCB0aW1lXG5cblxuICAgIHZhciB0bm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcblxuICAgIGlmIChzdGFsbGVkID09PSBudWxsKSB7XG4gICAgICB0aGlzLnN0YWxsZWQgPSB0bm93O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdGFsbGVkRHVyYXRpb24gPSB0bm93IC0gc3RhbGxlZDtcblxuICAgIGlmICghc2Vla2luZyAmJiBzdGFsbGVkRHVyYXRpb24gPj0gU1RBTExfTUlOSU1VTV9EVVJBVElPTl9NUykge1xuICAgICAgLy8gUmVwb3J0IHN0YWxsaW5nIGFmdGVyIHRyeWluZyB0byBmaXhcbiAgICAgIHRoaXMuX3JlcG9ydFN0YWxsKGJ1ZmZlckluZm8pO1xuXG4gICAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBidWZmZXJlZFdpdGhIb2xlcyA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJCdWZmZXJIZWxwZXJcIl0uYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcblxuICAgIHRoaXMuX3RyeUZpeEJ1ZmZlclN0YWxsKGJ1ZmZlcmVkV2l0aEhvbGVzLCBzdGFsbGVkRHVyYXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlY3RzIGFuZCBhdHRlbXB0cyB0byBmaXgga25vd24gYnVmZmVyIHN0YWxsaW5nIGlzc3Vlcy5cbiAgICogQHBhcmFtIGJ1ZmZlckluZm8gLSBUaGUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBidWZmZXIuXG4gICAqIEBwYXJhbSBzdGFsbGVkRHVyYXRpb25NcyAtIFRoZSBhbW91bnQgb2YgdGltZSBIbHMuanMgaGFzIGJlZW4gc3RhbGxpbmcgZm9yLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5fdHJ5Rml4QnVmZmVyU3RhbGwgPSBmdW5jdGlvbiBfdHJ5Rml4QnVmZmVyU3RhbGwoYnVmZmVySW5mbywgc3RhbGxlZER1cmF0aW9uTXMpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIGZyYWdtZW50VHJhY2tlciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG5cbiAgICBpZiAobWVkaWEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB2YXIgcGFydGlhbCA9IGZyYWdtZW50VHJhY2tlci5nZXRQYXJ0aWFsRnJhZ21lbnQoY3VycmVudFRpbWUpO1xuXG4gICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgIC8vIFRyeSB0byBza2lwIG92ZXIgdGhlIGJ1ZmZlciBob2xlIGNhdXNlZCBieSBhIHBhcnRpYWwgZnJhZ21lbnRcbiAgICAgIC8vIFRoaXMgbWV0aG9kIGlzbid0IGxpbWl0ZWQgYnkgdGhlIHNpemUgb2YgdGhlIGdhcCBiZXR3ZWVuIGJ1ZmZlcmVkIHJhbmdlc1xuICAgICAgdmFyIHRhcmdldFRpbWUgPSB0aGlzLl90cnlTa2lwQnVmZmVySG9sZShwYXJ0aWFsKTsgLy8gd2UgcmV0dXJuIGhlcmUgaW4gdGhpcyBjYXNlLCBtZWFuaW5nXG4gICAgICAvLyB0aGUgYnJhbmNoIGJlbG93IG9ubHkgZXhlY3V0ZXMgd2hlbiB3ZSBkb24ndCBoYW5kbGUgYSBwYXJ0aWFsIGZyYWdtZW50XG5cblxuICAgICAgaWYgKHRhcmdldFRpbWUgfHwgIXRoaXMubWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gLy8gaWYgd2UgaGF2ZW4ndCBoYWQgdG8gc2tpcCBvdmVyIGEgYnVmZmVyIGhvbGUgb2YgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAgLy8gd2UgbWF5IGp1c3QgaGF2ZSB0byBcIm51ZGdlXCIgdGhlIHBsYXlsaXN0IGFzIHRoZSBicm93c2VyIGRlY29kaW5nL3JlbmRlcmluZyBlbmdpbmVcbiAgICAvLyBuZWVkcyB0byBjcm9zcyBzb21lIHNvcnQgb2YgdGhyZXNob2xkIGNvdmVyaW5nIGFsbCBzb3VyY2UtYnVmZmVycyBjb250ZW50XG4gICAgLy8gdG8gc3RhcnQgcGxheWluZyBwcm9wZXJseS5cblxuXG4gICAgaWYgKGJ1ZmZlckluZm8ubGVuID4gY29uZmlnLm1heEJ1ZmZlckhvbGUgJiYgc3RhbGxlZER1cmF0aW9uTXMgPiBjb25maWcuaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kICogMTAwMCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLndhcm4oJ1RyeWluZyB0byBudWRnZSBwbGF5aGVhZCBvdmVyIGJ1ZmZlci1ob2xlJyk7IC8vIFRyeSB0byBudWRnZSBjdXJyZW50VGltZSBvdmVyIGEgYnVmZmVyIGhvbGUgaWYgd2UndmUgYmVlbiBzdGFsbGluZyBmb3IgdGhlIGNvbmZpZ3VyZWQgYW1vdW50IG9mIHNlY29uZHNcbiAgICAgIC8vIFdlIG9ubHkgdHJ5IHRvIGp1bXAgdGhlIGhvbGUgaWYgaXQncyB1bmRlciB0aGUgY29uZmlndXJlZCBzaXplXG4gICAgICAvLyBSZXNldCBzdGFsbGVkIHNvIHRvIHJlYXJtIHdhdGNoZG9nIHRpbWVyXG5cbiAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG5cbiAgICAgIHRoaXMuX3RyeU51ZGdlQnVmZmVyKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhIEJVRkZFUl9TVEFMTEVEX0VSUk9SIGV2ZW50LCBidXQgb25seSBvbmNlIHBlciBzdGFsbCBwZXJpb2QuXG4gICAqIEBwYXJhbSBidWZmZXJMZW4gLSBUaGUgcGxheWhlYWQgZGlzdGFuY2UgZnJvbSB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlciBzZWdtZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5fcmVwb3J0U3RhbGwgPSBmdW5jdGlvbiBfcmVwb3J0U3RhbGwoYnVmZmVySW5mbykge1xuICAgIHZhciBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBzdGFsbFJlcG9ydGVkID0gdGhpcy5zdGFsbFJlcG9ydGVkO1xuXG4gICAgaWYgKCFzdGFsbFJlcG9ydGVkICYmIG1lZGlhKSB7XG4gICAgICAvLyBSZXBvcnQgc3RhbGxlZCBlcnJvciBvbmNlXG4gICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSB0cnVlO1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLndhcm4oXCJQbGF5YmFjayBzdGFsbGluZyBhdCBAXCIgKyBtZWRpYS5jdXJyZW50VGltZSArIFwiIGR1ZSB0byBsb3cgYnVmZmVyIChcIiArIEpTT04uc3RyaW5naWZ5KGJ1ZmZlckluZm8pICsgXCIpXCIpO1xuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5CVUZGRVJfU1RBTExFRF9FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBidWZmZXI6IGJ1ZmZlckluZm8ubGVuXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGZpeCBidWZmZXIgc3RhbGxzIGJ5IGp1bXBpbmcgb3ZlciBrbm93biBnYXBzIGNhdXNlZCBieSBwYXJ0aWFsIGZyYWdtZW50c1xuICAgKiBAcGFyYW0gcGFydGlhbCAtIFRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvdW5kIGF0IHRoZSBjdXJyZW50IHRpbWUgKHdoZXJlIHBsYXliYWNrIGlzIHN0YWxsaW5nKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIDtcblxuICBfcHJvdG8uX3RyeVNraXBCdWZmZXJIb2xlID0gZnVuY3Rpb24gX3RyeVNraXBCdWZmZXJIb2xlKHBhcnRpYWwpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG5cbiAgICBpZiAobWVkaWEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIHZhciBsYXN0RW5kVGltZSA9IDA7IC8vIENoZWNrIGlmIGN1cnJlbnRUaW1lIGlzIGJldHdlZW4gdW5idWZmZXJlZCByZWdpb25zIG9mIHBhcnRpYWwgZnJhZ21lbnRzXG5cbiAgICB2YXIgYnVmZmVyZWQgPSBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiQnVmZmVySGVscGVyXCJdLmdldEJ1ZmZlcmVkKG1lZGlhKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdGFydFRpbWUgPSBidWZmZXJlZC5zdGFydChpKTtcblxuICAgICAgaWYgKGN1cnJlbnRUaW1lICsgY29uZmlnLm1heEJ1ZmZlckhvbGUgPj0gbGFzdEVuZFRpbWUgJiYgY3VycmVudFRpbWUgPCBzdGFydFRpbWUpIHtcbiAgICAgICAgdmFyIHRhcmdldFRpbWUgPSBNYXRoLm1heChzdGFydFRpbWUgKyBTS0lQX0JVRkZFUl9SQU5HRV9TVEFSVCwgbWVkaWEuY3VycmVudFRpbWUgKyBTS0lQX0JVRkZFUl9IT0xFX1NURVBfU0VDT05EUyk7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS53YXJuKFwic2tpcHBpbmcgaG9sZSwgYWRqdXN0aW5nIGN1cnJlbnRUaW1lIGZyb20gXCIgKyBjdXJyZW50VGltZSArIFwiIHRvIFwiICsgdGFyZ2V0VGltZSk7XG4gICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHRhcmdldFRpbWU7XG5cbiAgICAgICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uTUVESUFfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uQlVGRkVSX1NFRUtfT1ZFUl9IT0xFLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgcmVhc29uOiBcImZyYWdtZW50IGxvYWRlZCB3aXRoIGJ1ZmZlciBob2xlcywgc2Vla2luZyBmcm9tIFwiICsgY3VycmVudFRpbWUgKyBcIiB0byBcIiArIHRhcmdldFRpbWUsXG4gICAgICAgICAgICBmcmFnOiBwYXJ0aWFsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0VGltZTtcbiAgICAgIH1cblxuICAgICAgbGFzdEVuZFRpbWUgPSBidWZmZXJlZC5lbmQoaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGZpeCBidWZmZXIgc3RhbGxzIGJ5IGFkdmFuY2luZyB0aGUgbWVkaWFFbGVtZW50J3MgY3VycmVudCB0aW1lIGJ5IGEgc21hbGwgYW1vdW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5fdHJ5TnVkZ2VCdWZmZXIgPSBmdW5jdGlvbiBfdHJ5TnVkZ2VCdWZmZXIoKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBudWRnZVJldHJ5ID0gdGhpcy5udWRnZVJldHJ5O1xuXG4gICAgaWYgKG1lZGlhID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgdGhpcy5udWRnZVJldHJ5Kys7XG5cbiAgICBpZiAobnVkZ2VSZXRyeSA8IGNvbmZpZy5udWRnZU1heFJldHJ5KSB7XG4gICAgICB2YXIgdGFyZ2V0VGltZSA9IGN1cnJlbnRUaW1lICsgKG51ZGdlUmV0cnkgKyAxKSAqIGNvbmZpZy5udWRnZU9mZnNldDsgLy8gcGxheWJhY2sgc3RhbGxlZCBpbiBidWZmZXJlZCBhcmVhIC4uLiBsZXQncyBudWRnZSBjdXJyZW50VGltZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpc1xuXG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ud2FybihcIk51ZGdpbmcgJ2N1cnJlbnRUaW1lJyBmcm9tIFwiICsgY3VycmVudFRpbWUgKyBcIiB0byBcIiArIHRhcmdldFRpbWUpO1xuICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSB0YXJnZXRUaW1lO1xuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5CVUZGRVJfTlVER0VfT05fU1RBTEwsXG4gICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS5lcnJvcihcIlBsYXloZWFkIHN0aWxsIG5vdCBtb3Zpbmcgd2hpbGUgZW5vdWdoIGRhdGEgYnVmZmVyZWQgQFwiICsgY3VycmVudFRpbWUgKyBcIiBhZnRlciBcIiArIGNvbmZpZy5udWRnZU1heFJldHJ5ICsgXCIgbnVkZ2VzXCIpO1xuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5CVUZGRVJfU1RBTExFRF9FUlJPUixcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gR2FwQ29udHJvbGxlcjtcbn0oKTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvaWQzLXRyYWNrLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2lkMy10cmFjay1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvdGV4dHRyYWNrLXV0aWxzICovIFwiLi9zcmMvdXRpbHMvdGV4dHRyYWNrLXV0aWxzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2lkMyAqLyBcIi4vc3JjL2RlbXV4L2lkMy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZGVyX2RhdGVfcmFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvYWRlci9kYXRlLXJhbmdlICovIFwiLi9zcmMvbG9hZGVyL2RhdGUtcmFuZ2UudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2RlbXV4ZXIgKi8gXCIuL3NyYy90eXBlcy9kZW11eGVyLnRzXCIpO1xuXG5cblxuXG5cblxudmFyIE1JTl9DVUVfRFVSQVRJT04gPSAwLjI1O1xuXG5mdW5jdGlvbiBnZXRDdWVDbGFzcygpIHtcbiAgLy8gQXR0ZW1wdCB0byByZWNyZWF0ZSBTYWZhcmkgZnVuY3Rpb25hbGl0eSBieSBjcmVhdGluZ1xuICAvLyBXZWJLaXREYXRhQ3VlIG9iamVjdHMgd2hlbiBhdmFpbGFibGUgYW5kIHN0b3JlIHRoZSBkZWNvZGVkXG4gIC8vIElEMyBkYXRhIGluIHRoZSB2YWx1ZSBwcm9wZXJ0eSBvZiB0aGUgY3VlXG4gIHJldHVybiBzZWxmLldlYktpdERhdGFDdWUgfHwgc2VsZi5WVFRDdWUgfHwgc2VsZi5UZXh0VHJhY2tDdWU7XG59XG5cbmZ1bmN0aW9uIGRhdGVSYW5nZURhdGVUb1RpbWVsaW5lU2Vjb25kcyhkYXRlLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIC8gMTAwMCAtIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gaGV4VG9BcnJheUJ1ZmZlcihzdHIpIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShzdHIucmVwbGFjZSgvXjB4LywgJycpLnJlcGxhY2UoLyhbXFxkYS1mQS1GXXsyfSkgPy9nLCAnMHgkMSAnKS5yZXBsYWNlKC8gKyQvLCAnJykuc3BsaXQoJyAnKSkuYnVmZmVyO1xufVxuXG52YXIgSUQzVHJhY2tDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSUQzVHJhY2tDb250cm9sbGVyKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuaWQzVHJhY2sgPSBudWxsO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0ge307XG4gICAgdGhpcy5obHMgPSBobHM7XG5cbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IElEM1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcblxuICAgIHRoaXMuaWQzVHJhY2sgPSBudWxsO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0ge307IC8vIEB0cy1pZ25vcmVcblxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8uX3JlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nTWV0YWRhdGEsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLl91bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nTWV0YWRhdGEsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgfSAvLyBBZGQgSUQzIG1ldGF0YWRhdGEgdGV4dCB0cmFjay5cbiAgO1xuXG4gIF9wcm90by5vbk1lZGlhQXR0YWNoZWQgPSBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgaWYgKCF0aGlzLmlkM1RyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgT2JqZWN0KF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImNsZWFyQ3VycmVudEN1ZXNcIl0pKHRoaXMuaWQzVHJhY2spO1xuICAgIHRoaXMuaWQzVHJhY2sgPSBudWxsO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0ge307XG4gIH07XG5cbiAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgfTtcblxuICBfcHJvdG8uY3JlYXRlVHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVUcmFjayhtZWRpYSkge1xuICAgIHZhciB0cmFjayA9IHRoaXMuZ2V0SUQzVHJhY2sobWVkaWEudGV4dFRyYWNrcyk7XG4gICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICAgIHJldHVybiB0cmFjaztcbiAgfTtcblxuICBfcHJvdG8uZ2V0SUQzVHJhY2sgPSBmdW5jdGlvbiBnZXRJRDNUcmFjayh0ZXh0VHJhY2tzKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGV4dFRyYWNrID0gdGV4dFRyYWNrc1tpXTtcblxuICAgICAgaWYgKHRleHRUcmFjay5raW5kID09PSAnbWV0YWRhdGEnICYmIHRleHRUcmFjay5sYWJlbCA9PT0gJ2lkMycpIHtcbiAgICAgICAgLy8gc2VuZCAnYWRkdHJhY2snIHdoZW4gcmV1c2luZyB0aGUgdGV4dFRyYWNrIGZvciBtZXRhZGF0YSxcbiAgICAgICAgLy8gc2FtZSBhcyB3aGF0IHdlIGRvIGZvciBjYXB0aW9uc1xuICAgICAgICBPYmplY3QoX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wic2VuZEFkZFRyYWNrRXZlbnRcIl0pKHRleHRUcmFjaywgdGhpcy5tZWRpYSk7XG4gICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubWVkaWEuYWRkVGV4dFRyYWNrKCdtZXRhZGF0YScsICdpZDMnKTtcbiAgfTtcblxuICBfcHJvdG8ub25GcmFnUGFyc2luZ01ldGFkYXRhID0gZnVuY3Rpb24gb25GcmFnUGFyc2luZ01ldGFkYXRhKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF90aGlzJGhscyRjb25maWcgPSB0aGlzLmhscy5jb25maWcsXG4gICAgICAgIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMgPSBfdGhpcyRobHMkY29uZmlnLmVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMsXG4gICAgICAgIGVuYWJsZUlEM01ldGFkYXRhQ3VlcyA9IF90aGlzJGhscyRjb25maWcuZW5hYmxlSUQzTWV0YWRhdGFDdWVzO1xuXG4gICAgaWYgKCFlbmFibGVFbXNnTWV0YWRhdGFDdWVzICYmICFlbmFibGVJRDNNZXRhZGF0YUN1ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZnJhZ21lbnQgPSBkYXRhLmZyYWcsXG4gICAgICAgIHNhbXBsZXMgPSBkYXRhLnNhbXBsZXMsXG4gICAgICAgIGRldGFpbHMgPSBkYXRhLmRldGFpbHM7IC8vIGNyZWF0ZSB0cmFjayBkeW5hbWljYWxseVxuXG4gICAgaWYgKCF0aGlzLmlkM1RyYWNrKSB7XG4gICAgICB0aGlzLmlkM1RyYWNrID0gdGhpcy5jcmVhdGVUcmFjayh0aGlzLm1lZGlhKTtcbiAgICB9IC8vIFZUVEN1ZSBlbmQgdGltZSBtdXN0IGJlIGZpbml0ZSwgc28gdXNlIHBsYXlsaXN0IGVkZ2Ugb3IgZnJhZ21lbnQgZW5kIHVudGlsIG5leHQgZnJhZ21lbnQgd2l0aCBzYW1lIGZyYW1lIHR5cGUgaXMgZm91bmRcblxuXG4gICAgdmFyIG1heEN1ZVRpbWUgPSBkZXRhaWxzLmVkZ2UgfHwgZnJhZ21lbnQuZW5kO1xuICAgIHZhciBDdWUgPSBnZXRDdWVDbGFzcygpO1xuICAgIHZhciB1cGRhdGVDdWVSYW5nZXMgPSBmYWxzZTtcbiAgICB2YXIgZnJhbWVUeXBlc0FkZGVkID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0eXBlID0gc2FtcGxlc1tpXS50eXBlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gX3R5cGVzX2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIk1ldGFkYXRhU2NoZW1hXCJdLmVtc2cgJiYgIWVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMgfHwgIWVuYWJsZUlEM01ldGFkYXRhQ3Vlcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZyYW1lcyA9IF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImdldElEM0ZyYW1lc1wiXShzYW1wbGVzW2ldLmRhdGEpO1xuXG4gICAgICBpZiAoZnJhbWVzKSB7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBzYW1wbGVzW2ldLnB0cztcbiAgICAgICAgdmFyIGVuZFRpbWUgPSBtYXhDdWVUaW1lO1xuICAgICAgICB2YXIgdGltZURpZmYgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuXG4gICAgICAgIGlmICh0aW1lRGlmZiA8PSAwKSB7XG4gICAgICAgICAgZW5kVGltZSA9IHN0YXJ0VGltZSArIE1JTl9DVUVfRFVSQVRJT047XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZyYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBmcmFtZSA9IGZyYW1lc1tqXTsgLy8gU2FmYXJpIGRvZXNuJ3QgcHV0IHRoZSB0aW1lc3RhbXAgZnJhbWUgaW4gdGhlIFRleHRUcmFja1xuXG4gICAgICAgICAgaWYgKCFfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJpc1RpbWVTdGFtcEZyYW1lXCJdKGZyYW1lKSkge1xuICAgICAgICAgICAgdmFyIGN1ZSA9IG5ldyBDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCAnJyk7XG4gICAgICAgICAgICBjdWUudmFsdWUgPSBmcmFtZTtcblxuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgY3VlLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmlkM1RyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgICAgICAgZnJhbWVUeXBlc0FkZGVkW2ZyYW1lLmtleV0gPSBudWxsO1xuICAgICAgICAgICAgdXBkYXRlQ3VlUmFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXBkYXRlQ3VlUmFuZ2VzKSB7XG4gICAgICB0aGlzLnVwZGF0ZUlkM0N1ZUVuZHMoZnJhbWVUeXBlc0FkZGVkKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZUlkM0N1ZUVuZHMgPSBmdW5jdGlvbiB1cGRhdGVJZDNDdWVFbmRzKGZyYW1lVHlwZXNBZGRlZCkge1xuICAgIHZhciBfdGhpcyRpZDNUcmFjaztcblxuICAgIC8vIFVwZGF0ZSBlbmRUaW1lIG9mIHByZXZpb3VzIGN1ZSB3aXRoIHNhbWUgSURSIGZyYW1lLnR5cGUgKEV4OiBUWFhYIGN1ZSBzcGFucyB0byBuZXh0IFRYWFgpXG4gICAgdmFyIGN1ZXMgPSAoX3RoaXMkaWQzVHJhY2sgPSB0aGlzLmlkM1RyYWNrKSA9PT0gbnVsbCB8fCBfdGhpcyRpZDNUcmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkaWQzVHJhY2suY3VlcztcblxuICAgIGlmIChjdWVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gY3Vlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgdmFyIF9jdWUkdmFsdWU7XG5cbiAgICAgICAgdmFyIGN1ZSA9IGN1ZXNbaV07XG4gICAgICAgIHZhciBmcmFtZVR5cGUgPSAoX2N1ZSR2YWx1ZSA9IGN1ZS52YWx1ZSkgPT09IG51bGwgfHwgX2N1ZSR2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2N1ZSR2YWx1ZS5rZXk7XG5cbiAgICAgICAgaWYgKGZyYW1lVHlwZSAmJiBmcmFtZVR5cGUgaW4gZnJhbWVUeXBlc0FkZGVkKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0VGltZSA9IGZyYW1lVHlwZXNBZGRlZFtmcmFtZVR5cGVdO1xuXG4gICAgICAgICAgaWYgKHN0YXJ0VGltZSAmJiBjdWUuZW5kVGltZSAhPT0gc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICBjdWUuZW5kVGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmcmFtZVR5cGVzQWRkZWRbZnJhbWVUeXBlXSA9IGN1ZS5zdGFydFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uQnVmZmVyRmx1c2hpbmcgPSBmdW5jdGlvbiBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCBfcmVmKSB7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gX3JlZi5zdGFydE9mZnNldCxcbiAgICAgICAgZW5kT2Zmc2V0ID0gX3JlZi5lbmRPZmZzZXQsXG4gICAgICAgIHR5cGUgPSBfcmVmLnR5cGU7XG4gICAgdmFyIGlkM1RyYWNrID0gdGhpcy5pZDNUcmFjayxcbiAgICAgICAgaGxzID0gdGhpcy5obHM7XG5cbiAgICBpZiAoIWhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfaGxzJGNvbmZpZyA9IGhscy5jb25maWcsXG4gICAgICAgIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMgPSBfaGxzJGNvbmZpZy5lbmFibGVFbXNnTWV0YWRhdGFDdWVzLFxuICAgICAgICBlbmFibGVJRDNNZXRhZGF0YUN1ZXMgPSBfaGxzJGNvbmZpZy5lbmFibGVJRDNNZXRhZGF0YUN1ZXM7XG5cbiAgICBpZiAoaWQzVHJhY2sgJiYgKGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMgfHwgZW5hYmxlSUQzTWV0YWRhdGFDdWVzKSkge1xuICAgICAgdmFyIHByZWRpY2F0ZTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24gcHJlZGljYXRlKGN1ZSkge1xuICAgICAgICAgIHJldHVybiBjdWUudHlwZSA9PT0gX3R5cGVzX2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIk1ldGFkYXRhU2NoZW1hXCJdLmF1ZGlvSWQzICYmIGVuYWJsZUlEM01ldGFkYXRhQ3VlcztcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbiBwcmVkaWNhdGUoY3VlKSB7XG4gICAgICAgICAgcmV0dXJuIGN1ZS50eXBlID09PSBfdHlwZXNfZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiTWV0YWRhdGFTY2hlbWFcIl0uZW1zZyAmJiBlbmFibGVFbXNnTWV0YWRhdGFDdWVzO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24gcHJlZGljYXRlKGN1ZSkge1xuICAgICAgICAgIHJldHVybiBjdWUudHlwZSA9PT0gX3R5cGVzX2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIk1ldGFkYXRhU2NoZW1hXCJdLmF1ZGlvSWQzICYmIGVuYWJsZUlEM01ldGFkYXRhQ3VlcyB8fCBjdWUudHlwZSA9PT0gX3R5cGVzX2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIk1ldGFkYXRhU2NoZW1hXCJdLmVtc2cgJiYgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcztcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0KF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcInJlbW92ZUN1ZXNJblJhbmdlXCJdKShpZDNUcmFjaywgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgcHJlZGljYXRlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uTGV2ZWxVcGRhdGVkID0gZnVuY3Rpb24gb25MZXZlbFVwZGF0ZWQoZXZlbnQsIF9yZWYyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBkZXRhaWxzID0gX3JlZjIuZGV0YWlscztcblxuICAgIGlmICghdGhpcy5tZWRpYSB8fCAhZGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgfHwgIXRoaXMuaGxzLmNvbmZpZy5lbmFibGVEYXRlUmFuZ2VNZXRhZGF0YUN1ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0gdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQsXG4gICAgICAgIGlkM1RyYWNrID0gdGhpcy5pZDNUcmFjaztcbiAgICB2YXIgZGF0ZVJhbmdlcyA9IGRldGFpbHMuZGF0ZVJhbmdlcztcbiAgICB2YXIgaWRzID0gT2JqZWN0LmtleXMoZGF0ZVJhbmdlcyk7IC8vIFJlbW92ZSBjdWVzIGZyb20gdHJhY2sgbm90IGZvdW5kIGluIGRldGFpbHMuZGF0ZVJhbmdlc1xuXG4gICAgaWYgKGlkM1RyYWNrKSB7XG4gICAgICB2YXIgaWRzVG9SZW1vdmUgPSBPYmplY3Qua2V5cyhkYXRlUmFuZ2VDdWVzQXBwZW5kZWQpLmZpbHRlcihmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuICFpZHMuaW5jbHVkZXMoaWQpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgdmFyIGlkID0gaWRzVG9SZW1vdmVbaV07XG4gICAgICAgIE9iamVjdC5rZXlzKGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF0uY3VlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgaWQzVHJhY2sucmVtb3ZlQ3VlKGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF0uY3Vlc1trZXldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSBkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IGlkc1RvUmVtb3ZlLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBfbG9vcChpKTtcbiAgICAgIH1cbiAgICB9IC8vIEV4aXQgaWYgdGhlIHBsYXlsaXN0IGRvZXMgbm90IGhhdmUgRGF0ZSBSYW5nZXMgb3IgZG9lcyBub3QgaGF2ZSBQcm9ncmFtIERhdGUgVGltZVxuXG5cbiAgICB2YXIgbGFzdEZyYWdtZW50ID0gZGV0YWlscy5mcmFnbWVudHNbZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMCB8fCAhT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShsYXN0RnJhZ21lbnQgPT09IG51bGwgfHwgbGFzdEZyYWdtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0RnJhZ21lbnQucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pZDNUcmFjaykge1xuICAgICAgdGhpcy5pZDNUcmFjayA9IHRoaXMuY3JlYXRlVHJhY2sodGhpcy5tZWRpYSk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGVUaW1lT2Zmc2V0ID0gbGFzdEZyYWdtZW50LnByb2dyYW1EYXRlVGltZSAvIDEwMDAgLSBsYXN0RnJhZ21lbnQuc3RhcnQ7XG4gICAgdmFyIG1heEN1ZVRpbWUgPSBkZXRhaWxzLmVkZ2UgfHwgbGFzdEZyYWdtZW50LmVuZDtcbiAgICB2YXIgQ3VlID0gZ2V0Q3VlQ2xhc3MoKTtcblxuICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoX2kpIHtcbiAgICAgIHZhciBpZCA9IGlkc1tfaV07XG4gICAgICB2YXIgZGF0ZVJhbmdlID0gZGF0ZVJhbmdlc1tpZF07XG4gICAgICB2YXIgYXBwZW5kZWREYXRlUmFuZ2VDdWVzID0gZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXTtcbiAgICAgIHZhciBjdWVzID0gKGFwcGVuZGVkRGF0ZVJhbmdlQ3VlcyA9PT0gbnVsbCB8fCBhcHBlbmRlZERhdGVSYW5nZUN1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcGVuZGVkRGF0ZVJhbmdlQ3Vlcy5jdWVzKSB8fCB7fTtcbiAgICAgIHZhciBkdXJhdGlvbktub3duID0gKGFwcGVuZGVkRGF0ZVJhbmdlQ3VlcyA9PT0gbnVsbCB8fCBhcHBlbmRlZERhdGVSYW5nZUN1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcGVuZGVkRGF0ZVJhbmdlQ3Vlcy5kdXJhdGlvbktub3duKSB8fCBmYWxzZTtcbiAgICAgIHZhciBzdGFydFRpbWUgPSBkYXRlUmFuZ2VEYXRlVG9UaW1lbGluZVNlY29uZHMoZGF0ZVJhbmdlLnN0YXJ0RGF0ZSwgZGF0ZVRpbWVPZmZzZXQpO1xuICAgICAgdmFyIGVuZFRpbWUgPSBtYXhDdWVUaW1lO1xuICAgICAgdmFyIGVuZERhdGUgPSBkYXRlUmFuZ2UuZW5kRGF0ZTtcblxuICAgICAgaWYgKGVuZERhdGUpIHtcbiAgICAgICAgZW5kVGltZSA9IGRhdGVSYW5nZURhdGVUb1RpbWVsaW5lU2Vjb25kcyhlbmREYXRlLCBkYXRlVGltZU9mZnNldCk7XG4gICAgICAgIGR1cmF0aW9uS25vd24gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkYXRlUmFuZ2UuZW5kT25OZXh0ICYmICFkdXJhdGlvbktub3duKSB7XG4gICAgICAgIHZhciBuZXh0RGF0ZVJhbmdlV2l0aFNhbWVDbGFzcyA9IGlkcy5yZWR1Y2UoZnVuY3Rpb24gKGZpbHRlck1hcEFycmF5LCBpZCkge1xuICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSBkYXRlUmFuZ2VzW2lkXTtcblxuICAgICAgICAgIGlmIChjYW5kaWRhdGUuY2xhc3MgPT09IGRhdGVSYW5nZS5jbGFzcyAmJiBjYW5kaWRhdGUuaWQgIT09IGlkICYmIGNhbmRpZGF0ZS5zdGFydERhdGUgPiBkYXRlUmFuZ2Uuc3RhcnREYXRlKSB7XG4gICAgICAgICAgICBmaWx0ZXJNYXBBcnJheS5wdXNoKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZpbHRlck1hcEFycmF5O1xuICAgICAgICB9LCBbXSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLnN0YXJ0RGF0ZS5nZXRUaW1lKCkgLSBiLnN0YXJ0RGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgIH0pWzBdO1xuXG4gICAgICAgIGlmIChuZXh0RGF0ZVJhbmdlV2l0aFNhbWVDbGFzcykge1xuICAgICAgICAgIGVuZFRpbWUgPSBkYXRlUmFuZ2VEYXRlVG9UaW1lbGluZVNlY29uZHMobmV4dERhdGVSYW5nZVdpdGhTYW1lQ2xhc3Muc3RhcnREYXRlLCBkYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgZHVyYXRpb25Lbm93biA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhkYXRlUmFuZ2UuYXR0cik7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIga2V5ID0gYXR0cmlidXRlc1tqXTtcblxuICAgICAgICBpZiAoa2V5ID09PSBfbG9hZGVyX2RhdGVfcmFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkRhdGVSYW5nZUF0dHJpYnV0ZVwiXS5JRCB8fCBrZXkgPT09IF9sb2FkZXJfZGF0ZV9yYW5nZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiRGF0ZVJhbmdlQXR0cmlidXRlXCJdLkNMQVNTIHx8IGtleSA9PT0gX2xvYWRlcl9kYXRlX3JhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJEYXRlUmFuZ2VBdHRyaWJ1dGVcIl0uU1RBUlRfREFURSB8fCBrZXkgPT09IF9sb2FkZXJfZGF0ZV9yYW5nZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiRGF0ZVJhbmdlQXR0cmlidXRlXCJdLkRVUkFUSU9OIHx8IGtleSA9PT0gX2xvYWRlcl9kYXRlX3JhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJEYXRlUmFuZ2VBdHRyaWJ1dGVcIl0uRU5EX0RBVEUgfHwga2V5ID09PSBfbG9hZGVyX2RhdGVfcmFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkRhdGVSYW5nZUF0dHJpYnV0ZVwiXS5FTkRfT05fTkVYVCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1ZSA9IGN1ZXNba2V5XTtcblxuICAgICAgICBpZiAoY3VlKSB7XG4gICAgICAgICAgaWYgKGR1cmF0aW9uS25vd24gJiYgIWFwcGVuZGVkRGF0ZVJhbmdlQ3Vlcy5kdXJhdGlvbktub3duKSB7XG4gICAgICAgICAgICBjdWUuZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkYXRhID0gZGF0ZVJhbmdlLmF0dHJba2V5XTtcbiAgICAgICAgICBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgJycpO1xuXG4gICAgICAgICAgaWYgKGtleSA9PT0gX2xvYWRlcl9kYXRlX3JhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJEYXRlUmFuZ2VBdHRyaWJ1dGVcIl0uU0NURTM1X09VVCB8fCBrZXkgPT09IF9sb2FkZXJfZGF0ZV9yYW5nZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiRGF0ZVJhbmdlQXR0cmlidXRlXCJdLlNDVEUzNV9JTikge1xuICAgICAgICAgICAgZGF0YSA9IGhleFRvQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VlLnZhbHVlID0ge1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjdWUudHlwZSA9IF90eXBlc19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJNZXRhZGF0YVNjaGVtYVwiXS5kYXRlUmFuZ2U7XG5cbiAgICAgICAgICBfdGhpcy5pZDNUcmFjay5hZGRDdWUoY3VlKTtcblxuICAgICAgICAgIGN1ZXNba2V5XSA9IGN1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdID0ge1xuICAgICAgICBjdWVzOiBjdWVzLFxuICAgICAgICBkYXRlUmFuZ2U6IGRhdGVSYW5nZSxcbiAgICAgICAgZHVyYXRpb25Lbm93bjogZHVyYXRpb25Lbm93blxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGlkcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIF9sb29wMihfaSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBJRDNUcmFja0NvbnRyb2xsZXI7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoSUQzVHJhY2tDb250cm9sbGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9sYXRlbmN5LWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9sYXRlbmN5LWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTGF0ZW5jeUNvbnRyb2xsZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cblxuXG5cbnZhciBMYXRlbmN5Q29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExhdGVuY3lDb250cm9sbGVyKGhscykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmxldmVsRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5zdGFsbENvdW50ID0gMDtcbiAgICB0aGlzLl9sYXRlbmN5ID0gbnVsbDtcblxuICAgIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMudGltZXVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IExhdGVuY3lDb250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5vbk1lZGlhRGV0YWNoaW5nKCk7XG4gICAgdGhpcy5sZXZlbERldGFpbHMgPSBudWxsOyAvLyBAdHMtaWdub3JlXG5cbiAgICB0aGlzLmhscyA9IHRoaXMudGltZXVwZGF0ZUhhbmRsZXIgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgdGhpcy5obHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnVucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkKTtcbiAgICB0aGlzLmhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nKTtcbiAgICB0aGlzLmhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcpO1xuICAgIHRoaXMuaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCk7XG4gICAgdGhpcy5obHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yKTtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5tZWRpYS5hZGRFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy50aW1ldXBkYXRlSGFuZGxlcik7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLnRpbWV1cGRhdGVIYW5kbGVyKTtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmxldmVsRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5fbGF0ZW5jeSA9IG51bGw7XG4gICAgdGhpcy5zdGFsbENvdW50ID0gMDtcbiAgfTtcblxuICBfcHJvdG8ub25MZXZlbFVwZGF0ZWQgPSBmdW5jdGlvbiBvbkxldmVsVXBkYXRlZChldmVudCwgX3JlZikge1xuICAgIHZhciBkZXRhaWxzID0gX3JlZi5kZXRhaWxzO1xuICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gZGV0YWlscztcblxuICAgIGlmIChkZXRhaWxzLmFkdmFuY2VkKSB7XG4gICAgICB0aGlzLnRpbWV1cGRhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIWRldGFpbHMubGl2ZSAmJiB0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLnRpbWV1cGRhdGVIYW5kbGVyKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuZGV0YWlscyAhPT0gX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXJyb3JEZXRhaWxzXCJdLkJVRkZFUl9TVEFMTEVEX0VSUk9SKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdGFsbENvdW50Kys7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLndhcm4oJ1twbGF5YmFjay1yYXRlLWNvbnRyb2xsZXJdOiBTdGFsbCBkZXRlY3RlZCwgYWRqdXN0aW5nIHRhcmdldCBsYXRlbmN5Jyk7XG4gIH07XG5cbiAgX3Byb3RvLnRpbWV1cGRhdGUgPSBmdW5jdGlvbiB0aW1ldXBkYXRlKCkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuXG4gICAgaWYgKCFtZWRpYSB8fCAhbGV2ZWxEZXRhaWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIHZhciBsYXRlbmN5ID0gdGhpcy5jb21wdXRlTGF0ZW5jeSgpO1xuXG4gICAgaWYgKGxhdGVuY3kgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXRlbmN5ID0gbGF0ZW5jeTsgLy8gQWRhcHQgcGxheWJhY2tSYXRlIHRvIG1lZXQgdGFyZ2V0IGxhdGVuY3kgaW4gbG93LWxhdGVuY3kgbW9kZVxuXG4gICAgdmFyIF90aGlzJGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBsb3dMYXRlbmN5TW9kZSA9IF90aGlzJGNvbmZpZy5sb3dMYXRlbmN5TW9kZSxcbiAgICAgICAgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGUgPSBfdGhpcyRjb25maWcubWF4TGl2ZVN5bmNQbGF5YmFja1JhdGU7XG5cbiAgICBpZiAoIWxvd0xhdGVuY3lNb2RlIHx8IG1heExpdmVTeW5jUGxheWJhY2tSYXRlID09PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldExhdGVuY3kgPSB0aGlzLnRhcmdldExhdGVuY3k7XG5cbiAgICBpZiAodGFyZ2V0TGF0ZW5jeSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkaXN0YW5jZUZyb21UYXJnZXQgPSBsYXRlbmN5IC0gdGFyZ2V0TGF0ZW5jeTsgLy8gT25seSBhZGp1c3QgcGxheWJhY2tSYXRlIHdoZW4gd2l0aGluIG9uZSB0YXJnZXQgZHVyYXRpb24gb2YgdGFyZ2V0TGF0ZW5jeVxuICAgIC8vIGFuZCBtb3JlIHRoYW4gb25lIHNlY29uZCBmcm9tIHVuZGVyLWJ1ZmZlcmluZy5cbiAgICAvLyBQbGF5YmFjayBmdXJ0aGVyIHRoYW4gb25lIHRhcmdldCBkdXJhdGlvbiBmcm9tIHRhcmdldCBjYW4gYmUgY29uc2lkZXJlZCBEVlIgcGxheWJhY2suXG5cbiAgICB2YXIgbGl2ZU1pbkxhdGVuY3lEdXJhdGlvbiA9IE1hdGgubWluKHRoaXMubWF4TGF0ZW5jeSwgdGFyZ2V0TGF0ZW5jeSArIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbik7XG4gICAgdmFyIGluTGl2ZVJhbmdlID0gZGlzdGFuY2VGcm9tVGFyZ2V0IDwgbGl2ZU1pbkxhdGVuY3lEdXJhdGlvbjtcblxuICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSAmJiBpbkxpdmVSYW5nZSAmJiBkaXN0YW5jZUZyb21UYXJnZXQgPiAwLjA1ICYmIHRoaXMuZm9yd2FyZEJ1ZmZlckxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBtYXggPSBNYXRoLm1pbigyLCBNYXRoLm1heCgxLjAsIG1heExpdmVTeW5jUGxheWJhY2tSYXRlKSk7XG4gICAgICB2YXIgcmF0ZSA9IE1hdGgucm91bmQoMiAvICgxICsgTWF0aC5leHAoLTAuNzUgKiBkaXN0YW5jZUZyb21UYXJnZXQgLSB0aGlzLmVkZ2VTdGFsbGVkKSkgKiAyMCkgLyAyMDtcbiAgICAgIG1lZGlhLnBsYXliYWNrUmF0ZSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgoMSwgcmF0ZSkpO1xuICAgIH0gZWxzZSBpZiAobWVkaWEucGxheWJhY2tSYXRlICE9PSAxICYmIG1lZGlhLnBsYXliYWNrUmF0ZSAhPT0gMCkge1xuICAgICAgbWVkaWEucGxheWJhY2tSYXRlID0gMTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmVzdGltYXRlTGl2ZUVkZ2UgPSBmdW5jdGlvbiBlc3RpbWF0ZUxpdmVFZGdlKCkge1xuICAgIHZhciBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcblxuICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBsZXZlbERldGFpbHMuZWRnZSArIGxldmVsRGV0YWlscy5hZ2U7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXB1dGVMYXRlbmN5ID0gZnVuY3Rpb24gY29tcHV0ZUxhdGVuY3koKSB7XG4gICAgdmFyIGxpdmVFZGdlID0gdGhpcy5lc3RpbWF0ZUxpdmVFZGdlKCk7XG5cbiAgICBpZiAobGl2ZUVkZ2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBsaXZlRWRnZSAtIHRoaXMuY3VycmVudFRpbWU7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKExhdGVuY3lDb250cm9sbGVyLCBbe1xuICAgIGtleTogXCJsYXRlbmN5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGF0ZW5jeSB8fCAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXhMYXRlbmN5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG5cbiAgICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxldmVsRGV0YWlscyA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24gOiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0YXJnZXRMYXRlbmN5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG5cbiAgICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBob2xkQmFjayA9IGxldmVsRGV0YWlscy5ob2xkQmFjayxcbiAgICAgICAgICBwYXJ0SG9sZEJhY2sgPSBsZXZlbERldGFpbHMucGFydEhvbGRCYWNrLFxuICAgICAgICAgIHRhcmdldGR1cmF0aW9uID0gbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgdmFyIF90aGlzJGNvbmZpZzIgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICBsaXZlU3luY0R1cmF0aW9uID0gX3RoaXMkY29uZmlnMi5saXZlU3luY0R1cmF0aW9uLFxuICAgICAgICAgIGxpdmVTeW5jRHVyYXRpb25Db3VudCA9IF90aGlzJGNvbmZpZzIubGl2ZVN5bmNEdXJhdGlvbkNvdW50LFxuICAgICAgICAgIGxvd0xhdGVuY3lNb2RlID0gX3RoaXMkY29uZmlnMi5sb3dMYXRlbmN5TW9kZTtcbiAgICAgIHZhciB1c2VyQ29uZmlnID0gdGhpcy5obHMudXNlckNvbmZpZztcbiAgICAgIHZhciB0YXJnZXRMYXRlbmN5ID0gbG93TGF0ZW5jeU1vZGUgPyBwYXJ0SG9sZEJhY2sgfHwgaG9sZEJhY2sgOiBob2xkQmFjaztcblxuICAgICAgaWYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCB0YXJnZXRMYXRlbmN5ID09PSAwKSB7XG4gICAgICAgIHRhcmdldExhdGVuY3kgPSBsaXZlU3luY0R1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBsaXZlU3luY0R1cmF0aW9uIDogbGl2ZVN5bmNEdXJhdGlvbkNvdW50ICogdGFyZ2V0ZHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXhMaXZlU3luY09uU3RhbGxJbmNyZWFzZSA9IHRhcmdldGR1cmF0aW9uO1xuICAgICAgdmFyIGxpdmVTeW5jT25TdGFsbEluY3JlYXNlID0gMS4wO1xuICAgICAgcmV0dXJuIHRhcmdldExhdGVuY3kgKyBNYXRoLm1pbih0aGlzLnN0YWxsQ291bnQgKiBsaXZlU3luY09uU3RhbGxJbmNyZWFzZSwgbWF4TGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsaXZlU3luY1Bvc2l0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbGl2ZUVkZ2UgPSB0aGlzLmVzdGltYXRlTGl2ZUVkZ2UoKTtcbiAgICAgIHZhciB0YXJnZXRMYXRlbmN5ID0gdGhpcy50YXJnZXRMYXRlbmN5O1xuICAgICAgdmFyIGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuXG4gICAgICBpZiAobGl2ZUVkZ2UgPT09IG51bGwgfHwgdGFyZ2V0TGF0ZW5jeSA9PT0gbnVsbCB8fCBsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlID0gbGV2ZWxEZXRhaWxzLmVkZ2U7XG4gICAgICB2YXIgc3luY1Bvc2l0aW9uID0gbGl2ZUVkZ2UgLSB0YXJnZXRMYXRlbmN5IC0gdGhpcy5lZGdlU3RhbGxlZDtcbiAgICAgIHZhciBtaW4gPSBlZGdlIC0gbGV2ZWxEZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgICB2YXIgbWF4ID0gZWRnZSAtICh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSAmJiBsZXZlbERldGFpbHMucGFydFRhcmdldCB8fCBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pO1xuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgc3luY1Bvc2l0aW9uKSwgbWF4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJpZnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcblxuICAgICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxldmVsRGV0YWlscy5kcmlmdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWRnZVN0YWxsZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcblxuICAgICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIG1heExldmVsVXBkYXRlQWdlID0gKHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmIGxldmVsRGV0YWlscy5wYXJ0VGFyZ2V0IHx8IGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikgKiAzO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGxldmVsRGV0YWlscy5hZ2UgLSBtYXhMZXZlbFVwZGF0ZUFnZSwgMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcndhcmRCdWZmZXJMZW5ndGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG5cbiAgICAgIGlmICghbWVkaWEgfHwgIWxldmVsRGV0YWlscykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ1ZmZlcmVkUmFuZ2VzID0gbWVkaWEuYnVmZmVyZWQubGVuZ3RoO1xuICAgICAgcmV0dXJuIChidWZmZXJlZFJhbmdlcyA/IG1lZGlhLmJ1ZmZlcmVkLmVuZChidWZmZXJlZFJhbmdlcyAtIDEpIDogbGV2ZWxEZXRhaWxzLmVkZ2UpIC0gdGhpcy5jdXJyZW50VGltZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGF0ZW5jeUNvbnRyb2xsZXI7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2xldmVsLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTGV2ZWxDb250cm9sbGVyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xldmVsICovIFwiLi9zcmMvdHlwZXMvbGV2ZWwudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY29kZWNzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9jb2RlY3MgKi8gXCIuL3NyYy91dGlscy9jb2RlY3MudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sZXZlbC1oZWxwZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2xldmVsLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFzZV9wbGF5bGlzdF9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Jhc2UtcGxheWxpc3QtY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYmFzZS1wbGF5bGlzdC1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xvYWRlciAqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiKTtcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG4vKlxuICogTGV2ZWwgQ29udHJvbGxlclxuICovXG5cblxuXG5cblxuXG5cbnZhciBjaHJvbWVPckZpcmVmb3ggPSAvY2hyb21lfGZpcmVmb3gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcblxudmFyIExldmVsQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VQbGF5bGlzdENvbnRyb2xsKSB7XG4gIF9pbmhlcml0c0xvb3NlKExldmVsQ29udHJvbGxlciwgX0Jhc2VQbGF5bGlzdENvbnRyb2xsKTtcblxuICBmdW5jdGlvbiBMZXZlbENvbnRyb2xsZXIoaGxzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQmFzZVBsYXlsaXN0Q29udHJvbGwuY2FsbCh0aGlzLCBobHMsICdbbGV2ZWwtY29udHJvbGxlcl0nKSB8fCB0aGlzO1xuICAgIF90aGlzLl9sZXZlbHMgPSBbXTtcbiAgICBfdGhpcy5fZmlyc3RMZXZlbCA9IC0xO1xuICAgIF90aGlzLl9zdGFydExldmVsID0gdm9pZCAwO1xuICAgIF90aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gLTE7XG4gICAgX3RoaXMubWFudWFsTGV2ZWxJbmRleCA9IC0xO1xuICAgIF90aGlzLm9uUGFyc2VkQ29tcGxldGUgPSB2b2lkIDA7XG5cbiAgICBfdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5fcmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfU1dJVENIRUQsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5fdW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cbiAgICB0aGlzLm1hbnVhbExldmVsSW5kZXggPSAtMTtcbiAgICB0aGlzLl9sZXZlbHMubGVuZ3RoID0gMDtcblxuICAgIF9CYXNlUGxheWxpc3RDb250cm9sbC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5zdGFydExvYWQgPSBmdW5jdGlvbiBzdGFydExvYWQoKSB7XG4gICAgdmFyIGxldmVscyA9IHRoaXMuX2xldmVsczsgLy8gY2xlYW4gdXAgbGl2ZSBsZXZlbCBkZXRhaWxzIHRvIGZvcmNlIHJlbG9hZCB0aGVtLCBhbmQgcmVzZXQgbG9hZCBlcnJvcnNcblxuICAgIGxldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICB9KTtcblxuICAgIF9CYXNlUGxheWxpc3RDb250cm9sbC5wcm90b3R5cGUuc3RhcnRMb2FkLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGxldmVscyA9IFtdO1xuICAgIHZhciBhdWRpb1RyYWNrcyA9IFtdO1xuICAgIHZhciBzdWJ0aXRsZVRyYWNrcyA9IFtdO1xuICAgIHZhciBiaXRyYXRlU3RhcnQ7XG4gICAgdmFyIGxldmVsU2V0ID0ge307XG4gICAgdmFyIGxldmVsRnJvbVNldDtcbiAgICB2YXIgcmVzb2x1dGlvbkZvdW5kID0gZmFsc2U7XG4gICAgdmFyIHZpZGVvQ29kZWNGb3VuZCA9IGZhbHNlO1xuICAgIHZhciBhdWRpb0NvZGVjRm91bmQgPSBmYWxzZTsgLy8gcmVncm91cCByZWR1bmRhbnQgbGV2ZWxzIHRvZ2V0aGVyXG5cbiAgICBkYXRhLmxldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbFBhcnNlZCkge1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBsZXZlbFBhcnNlZC5hdHRycztcbiAgICAgIHJlc29sdXRpb25Gb3VuZCA9IHJlc29sdXRpb25Gb3VuZCB8fCAhIShsZXZlbFBhcnNlZC53aWR0aCAmJiBsZXZlbFBhcnNlZC5oZWlnaHQpO1xuICAgICAgdmlkZW9Db2RlY0ZvdW5kID0gdmlkZW9Db2RlY0ZvdW5kIHx8ICEhbGV2ZWxQYXJzZWQudmlkZW9Db2RlYztcbiAgICAgIGF1ZGlvQ29kZWNGb3VuZCA9IGF1ZGlvQ29kZWNGb3VuZCB8fCAhIWxldmVsUGFyc2VkLmF1ZGlvQ29kZWM7IC8vIGVyYXNlIGF1ZGlvIGNvZGVjIGluZm8gaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG1wNGEuNDAuMzQuXG4gICAgICAvLyBkZW11eGVyIHdpbGwgYXV0b2RldGVjdCBjb2RlYyBhbmQgZmFsbGJhY2sgdG8gbXBlZy9hdWRpb1xuXG4gICAgICBpZiAoY2hyb21lT3JGaXJlZm94ICYmIGxldmVsUGFyc2VkLmF1ZGlvQ29kZWMgJiYgbGV2ZWxQYXJzZWQuYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjM0JykgIT09IC0xKSB7XG4gICAgICAgIGxldmVsUGFyc2VkLmF1ZGlvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZXZlbEtleSA9IGxldmVsUGFyc2VkLmJpdHJhdGUgKyBcIi1cIiArIGxldmVsUGFyc2VkLmF0dHJzLlJFU09MVVRJT04gKyBcIi1cIiArIGxldmVsUGFyc2VkLmF0dHJzLkNPREVDUztcbiAgICAgIGxldmVsRnJvbVNldCA9IGxldmVsU2V0W2xldmVsS2V5XTtcblxuICAgICAgaWYgKCFsZXZlbEZyb21TZXQpIHtcbiAgICAgICAgbGV2ZWxGcm9tU2V0ID0gbmV3IF90eXBlc19sZXZlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiTGV2ZWxcIl0obGV2ZWxQYXJzZWQpO1xuICAgICAgICBsZXZlbFNldFtsZXZlbEtleV0gPSBsZXZlbEZyb21TZXQ7XG4gICAgICAgIGxldmVscy5wdXNoKGxldmVsRnJvbVNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbEZyb21TZXQudXJsLnB1c2gobGV2ZWxQYXJzZWQudXJsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMuQVVESU8pIHtcbiAgICAgICAgICBPYmplY3QoX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiYWRkR3JvdXBJZFwiXSkobGV2ZWxGcm9tU2V0LCAnYXVkaW8nLCBhdHRyaWJ1dGVzLkFVRElPKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLlNVQlRJVExFUykge1xuICAgICAgICAgIE9iamVjdChfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJhZGRHcm91cElkXCJdKShsZXZlbEZyb21TZXQsICd0ZXh0JywgYXR0cmlidXRlcy5TVUJUSVRMRVMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7IC8vIHJlbW92ZSBhdWRpby1vbmx5IGxldmVsIGlmIHdlIGFsc28gaGF2ZSBsZXZlbHMgd2l0aCB2aWRlbyBjb2RlY3Mgb3IgUkVTT0xVVElPTiBzaWduYWxsZWRcblxuICAgIGlmICgocmVzb2x1dGlvbkZvdW5kIHx8IHZpZGVvQ29kZWNGb3VuZCkgJiYgYXVkaW9Db2RlY0ZvdW5kKSB7XG4gICAgICBsZXZlbHMgPSBsZXZlbHMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciB2aWRlb0NvZGVjID0gX3JlZi52aWRlb0NvZGVjLFxuICAgICAgICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG4gICAgICAgIHJldHVybiAhIXZpZGVvQ29kZWMgfHwgISEod2lkdGggJiYgaGVpZ2h0KTtcbiAgICAgIH0pO1xuICAgIH0gLy8gb25seSBrZWVwIGxldmVscyB3aXRoIHN1cHBvcnRlZCBhdWRpby92aWRlbyBjb2RlY3NcblxuXG4gICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgIHZhciBhdWRpb0NvZGVjID0gX3JlZjIuYXVkaW9Db2RlYyxcbiAgICAgICAgICB2aWRlb0NvZGVjID0gX3JlZjIudmlkZW9Db2RlYztcbiAgICAgIHJldHVybiAoIWF1ZGlvQ29kZWMgfHwgT2JqZWN0KF91dGlsc19jb2RlY3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImlzQ29kZWNTdXBwb3J0ZWRJbk1wNFwiXSkoYXVkaW9Db2RlYywgJ2F1ZGlvJykpICYmICghdmlkZW9Db2RlYyB8fCBPYmplY3QoX3V0aWxzX2NvZGVjc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiaXNDb2RlY1N1cHBvcnRlZEluTXA0XCJdKSh2aWRlb0NvZGVjLCAndmlkZW8nKSk7XG4gICAgfSk7XG5cbiAgICBpZiAoZGF0YS5hdWRpb1RyYWNrcykge1xuICAgICAgYXVkaW9UcmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzLmZpbHRlcihmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgcmV0dXJuICF0cmFjay5hdWRpb0NvZGVjIHx8IE9iamVjdChfdXRpbHNfY29kZWNzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJpc0NvZGVjU3VwcG9ydGVkSW5NcDRcIl0pKHRyYWNrLmF1ZGlvQ29kZWMsICdhdWRpbycpO1xuICAgICAgfSk7IC8vIEFzc2lnbiBpZHMgYWZ0ZXIgZmlsdGVyaW5nIGFzIGFycmF5IGluZGljZXMgYnkgZ3JvdXAtaWRcblxuICAgICAgT2JqZWN0KF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImFzc2lnblRyYWNrSWRzQnlHcm91cFwiXSkoYXVkaW9UcmFja3MpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLnN1YnRpdGxlcykge1xuICAgICAgc3VidGl0bGVUcmFja3MgPSBkYXRhLnN1YnRpdGxlcztcbiAgICAgIE9iamVjdChfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJhc3NpZ25UcmFja0lkc0J5R3JvdXBcIl0pKHN1YnRpdGxlVHJhY2tzKTtcbiAgICB9XG5cbiAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHN0YXJ0IGJpdHJhdGUgaXMgdGhlIGZpcnN0IGJpdHJhdGUgb2YgdGhlIG1hbmlmZXN0XG4gICAgICBiaXRyYXRlU3RhcnQgPSBsZXZlbHNbMF0uYml0cmF0ZTsgLy8gc29ydCBsZXZlbCBvbiBiaXRyYXRlXG5cbiAgICAgIGxldmVscy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLmJpdHJhdGUgLSBiLmJpdHJhdGU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2xldmVscyA9IGxldmVsczsgLy8gZmluZCBpbmRleCBvZiBmaXJzdCBsZXZlbCBpbiBzb3J0ZWQgbGV2ZWxzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsZXZlbHNbaV0uYml0cmF0ZSA9PT0gYml0cmF0ZVN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IGk7XG4gICAgICAgICAgdGhpcy5sb2coXCJtYW5pZmVzdCBsb2FkZWQsIFwiICsgbGV2ZWxzLmxlbmd0aCArIFwiIGxldmVsKHMpIGZvdW5kLCBmaXJzdCBiaXRyYXRlOiBcIiArIGJpdHJhdGVTdGFydCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQXVkaW8gaXMgb25seSBhbHRlcm5hdGUgaWYgbWFuaWZlc3QgaW5jbHVkZSBhIFVSSSBhbG9uZyB3aXRoIHRoZSBhdWRpbyBncm91cCB0YWcsXG4gICAgICAvLyBhbmQgdGhpcyBpcyBub3QgYW4gYXVkaW8tb25seSBzdHJlYW0gd2hlcmUgbGV2ZWxzIGNvbnRhaW4gYXVkaW8tb25seVxuXG5cbiAgICAgIHZhciBhdWRpb09ubHkgPSBhdWRpb0NvZGVjRm91bmQgJiYgIXZpZGVvQ29kZWNGb3VuZDtcbiAgICAgIHZhciBlZGF0YSA9IHtcbiAgICAgICAgbGV2ZWxzOiBsZXZlbHMsXG4gICAgICAgIGF1ZGlvVHJhY2tzOiBhdWRpb1RyYWNrcyxcbiAgICAgICAgc3VidGl0bGVUcmFja3M6IHN1YnRpdGxlVHJhY2tzLFxuICAgICAgICBmaXJzdExldmVsOiB0aGlzLl9maXJzdExldmVsLFxuICAgICAgICBzdGF0czogZGF0YS5zdGF0cyxcbiAgICAgICAgYXVkaW86IGF1ZGlvQ29kZWNGb3VuZCxcbiAgICAgICAgdmlkZW86IHZpZGVvQ29kZWNGb3VuZCxcbiAgICAgICAgYWx0QXVkaW86ICFhdWRpb09ubHkgJiYgYXVkaW9UcmFja3Muc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiAhIXQudXJsO1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX1BBUlNFRCwgZWRhdGEpOyAvLyBJbml0aWF0ZSBsb2FkaW5nIGFmdGVyIGFsbCBjb250cm9sbGVycyBoYXZlIHJlY2VpdmVkIE1BTklGRVNUX1BBUlNFRFxuXG4gICAgICBpZiAodGhpcy5obHMuY29uZmlnLmF1dG9TdGFydExvYWQgfHwgdGhpcy5obHMuZm9yY2VTdGFydExvYWQpIHtcbiAgICAgICAgdGhpcy5obHMuc3RhcnRMb2FkKHRoaXMuaGxzLmNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JUeXBlc1wiXS5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsXG4gICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICB1cmw6IGRhdGEudXJsLFxuICAgICAgICByZWFzb246ICdubyBsZXZlbCB3aXRoIGNvbXBhdGlibGUgY29kZWNzIGZvdW5kIGluIG1hbmlmZXN0J1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIF9CYXNlUGxheWxpc3RDb250cm9sbC5wcm90b3R5cGUub25FcnJvci5jYWxsKHRoaXMsIGV2ZW50LCBkYXRhKTtcblxuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBTd2l0Y2ggdG8gcmVkdW5kYW50IGxldmVsIHdoZW4gdHJhY2sgZmFpbHMgdG8gbG9hZFxuXG5cbiAgICB2YXIgY29udGV4dCA9IGRhdGEuY29udGV4dDtcbiAgICB2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbdGhpcy5jdXJyZW50TGV2ZWxJbmRleF07XG5cbiAgICBpZiAoY29udGV4dCAmJiAoY29udGV4dC50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLkFVRElPX1RSQUNLICYmIGxldmVsLmF1ZGlvR3JvdXBJZHMgJiYgY29udGV4dC5ncm91cElkID09PSBsZXZlbC5hdWRpb0dyb3VwSWRzW2xldmVsLnVybElkXSB8fCBjb250ZXh0LnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uU1VCVElUTEVfVFJBQ0sgJiYgbGV2ZWwudGV4dEdyb3VwSWRzICYmIGNvbnRleHQuZ3JvdXBJZCA9PT0gbGV2ZWwudGV4dEdyb3VwSWRzW2xldmVsLnVybElkXSkpIHtcbiAgICAgIHRoaXMucmVkdW5kYW50RmFpbG92ZXIodGhpcy5jdXJyZW50TGV2ZWxJbmRleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxldmVsRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgbGV2ZWxTd2l0Y2ggPSB0cnVlO1xuICAgIHZhciBsZXZlbEluZGV4OyAvLyB0cnkgdG8gcmVjb3ZlciBub3QgZmF0YWwgZXJyb3JzXG5cbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGlmIChkYXRhLmZyYWcpIHtcbiAgICAgICAgICB2YXIgX2xldmVsID0gdGhpcy5fbGV2ZWxzW2RhdGEuZnJhZy5sZXZlbF07IC8vIFNldCBsZXZlbEluZGV4IHdoZW4gd2UncmUgb3V0IG9mIGZyYWdtZW50IHJldHJpZXNcblxuICAgICAgICAgIGlmIChfbGV2ZWwpIHtcbiAgICAgICAgICAgIF9sZXZlbC5mcmFnbWVudEVycm9yKys7XG5cbiAgICAgICAgICAgIGlmIChfbGV2ZWwuZnJhZ21lbnRFcnJvciA+IHRoaXMuaGxzLmNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5KSB7XG4gICAgICAgICAgICAgIGxldmVsSW5kZXggPSBkYXRhLmZyYWcubGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldmVsSW5kZXggPSBkYXRhLmZyYWcubGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIC8vIERvIG5vdCBwZXJmb3JtIGxldmVsIHN3aXRjaCBpZiBhbiBlcnJvciBvY2N1cnJlZCB1c2luZyBkZWxpdmVyeSBkaXJlY3RpdmVzXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gcmVsb2FkIGxldmVsIHdpdGhvdXQgZGlyZWN0aXZlcyBmaXJzdFxuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0LmRlbGl2ZXJ5RGlyZWN0aXZlcykge1xuICAgICAgICAgICAgbGV2ZWxTd2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXZlbEluZGV4ID0gY29udGV4dC5sZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldmVsRXJyb3IgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uUkVNVVhfQUxMT0NfRVJST1I6XG4gICAgICAgIGxldmVsSW5kZXggPSBkYXRhLmxldmVsO1xuICAgICAgICBsZXZlbEVycm9yID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGxldmVsSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5yZWNvdmVyTGV2ZWwoZGF0YSwgbGV2ZWxJbmRleCwgbGV2ZWxFcnJvciwgbGV2ZWxTd2l0Y2gpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3dpdGNoIHRvIGEgcmVkdW5kYW50IHN0cmVhbSBpZiBhbnkgYXZhaWxhYmxlLlxuICAgKiBJZiByZWR1bmRhbnQgc3RyZWFtIGlzIG5vdCBhdmFpbGFibGUsIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBpZiBBQlIgbW9kZSBpcyBlbmFibGVkLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZWNvdmVyTGV2ZWwgPSBmdW5jdGlvbiByZWNvdmVyTGV2ZWwoZXJyb3JFdmVudCwgbGV2ZWxJbmRleCwgbGV2ZWxFcnJvciwgbGV2ZWxTd2l0Y2gpIHtcbiAgICB2YXIgZXJyb3JEZXRhaWxzID0gZXJyb3JFdmVudC5kZXRhaWxzO1xuICAgIHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbEluZGV4XTtcbiAgICBsZXZlbC5sb2FkRXJyb3IrKztcblxuICAgIGlmIChsZXZlbEVycm9yKSB7XG4gICAgICB2YXIgcmV0cnlpbmcgPSB0aGlzLnJldHJ5TG9hZGluZ09yRmFpbChlcnJvckV2ZW50KTtcblxuICAgICAgaWYgKHJldHJ5aW5nKSB7XG4gICAgICAgIC8vIGJvb2xlYW4gdXNlZCB0byBpbmZvcm0gc3RyZWFtIGNvbnRyb2xsZXIgbm90IHRvIHN3aXRjaCBiYWNrIHRvIElETEUgb24gbm9uIGZhdGFsIGVycm9yXG4gICAgICAgIGVycm9yRXZlbnQubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gLTE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGV2ZWxTd2l0Y2gpIHtcbiAgICAgIHZhciByZWR1bmRhbnRMZXZlbHMgPSBsZXZlbC51cmwubGVuZ3RoOyAvLyBUcnkgcmVkdW5kYW50IGZhaWwtb3ZlciB1bnRpbCBsZXZlbC5sb2FkRXJyb3IgcmVhY2hlcyByZWR1bmRhbnRMZXZlbHNcblxuICAgICAgaWYgKHJlZHVuZGFudExldmVscyA+IDEgJiYgbGV2ZWwubG9hZEVycm9yIDwgcmVkdW5kYW50TGV2ZWxzKSB7XG4gICAgICAgIGVycm9yRXZlbnQubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVkdW5kYW50RmFpbG92ZXIobGV2ZWxJbmRleCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgLy8gU2VhcmNoIGZvciBhdmFpbGFibGUgbGV2ZWwgaW4gYXV0byBsZXZlbCBzZWxlY3Rpb24gbW9kZSwgY3ljbGluZyBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0IGJpdHJhdGVcbiAgICAgICAgdmFyIG5leHRMZXZlbCA9IGxldmVsSW5kZXggPT09IDAgPyB0aGlzLl9sZXZlbHMubGVuZ3RoIC0gMSA6IGxldmVsSW5kZXggLSAxO1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRMZXZlbEluZGV4ICE9PSBuZXh0TGV2ZWwgJiYgdGhpcy5fbGV2ZWxzW25leHRMZXZlbF0ubG9hZEVycm9yID09PSAwKSB7XG4gICAgICAgICAgdGhpcy53YXJuKGVycm9yRGV0YWlscyArIFwiOiBzd2l0Y2ggdG8gXCIgKyBuZXh0TGV2ZWwpO1xuICAgICAgICAgIGVycm9yRXZlbnQubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5obHMubmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVkdW5kYW50RmFpbG92ZXIgPSBmdW5jdGlvbiByZWR1bmRhbnRGYWlsb3ZlcihsZXZlbEluZGV4KSB7XG4gICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIHZhciByZWR1bmRhbnRMZXZlbHMgPSBsZXZlbC51cmwubGVuZ3RoO1xuXG4gICAgaWYgKHJlZHVuZGFudExldmVscyA+IDEpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgdXJsIGlkIG9mIGFsbCBsZXZlbHMgc28gdGhhdCB3ZSBzdGF5IG9uIHRoZSBzYW1lIHNldCBvZiB2YXJpYW50cyB3aGVuIGxldmVsIHN3aXRjaGluZ1xuICAgICAgdmFyIG5ld1VybElkID0gKGxldmVsLnVybElkICsgMSkgJSByZWR1bmRhbnRMZXZlbHM7XG4gICAgICB0aGlzLndhcm4oXCJTd2l0Y2hpbmcgdG8gcmVkdW5kYW50IFVSTC1pZCBcIiArIG5ld1VybElkKTtcblxuICAgICAgdGhpcy5fbGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIGxldmVsLnVybElkID0gbmV3VXJsSWQ7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5sZXZlbCA9IGxldmVsSW5kZXg7XG4gICAgfVxuICB9IC8vIHJlc2V0IGVycm9ycyBvbiB0aGUgc3VjY2Vzc2Z1bCBsb2FkIG9mIGEgZnJhZ21lbnRcbiAgO1xuXG4gIF9wcm90by5vbkZyYWdMb2FkZWQgPSBmdW5jdGlvbiBvbkZyYWdMb2FkZWQoZXZlbnQsIF9yZWYzKSB7XG4gICAgdmFyIGZyYWcgPSBfcmVmMy5mcmFnO1xuXG4gICAgaWYgKGZyYWcgIT09IHVuZGVmaW5lZCAmJiBmcmFnLnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLk1BSU4pIHtcbiAgICAgIHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1tmcmFnLmxldmVsXTtcblxuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkxldmVsTG9hZGVkID0gZnVuY3Rpb24gb25MZXZlbExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfZGF0YSRkZWxpdmVyeURpcmVjdGkyO1xuXG4gICAgdmFyIGxldmVsID0gZGF0YS5sZXZlbCxcbiAgICAgICAgZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB2YXIgY3VyTGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxdO1xuXG4gICAgaWYgKCFjdXJMZXZlbCkge1xuICAgICAgdmFyIF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTtcblxuICAgICAgdGhpcy53YXJuKFwiSW52YWxpZCBsZXZlbCBpbmRleCBcIiArIGxldmVsKTtcblxuICAgICAgaWYgKChfZGF0YSRkZWxpdmVyeURpcmVjdGkgPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcykgIT09IG51bGwgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpICE9PSB2b2lkIDAgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpLnNraXApIHtcbiAgICAgICAgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG9ubHkgcHJvY2VzcyBsZXZlbCBsb2FkZWQgZXZlbnRzIG1hdGNoaW5nIHdpdGggZXhwZWN0ZWQgbGV2ZWxcblxuXG4gICAgaWYgKGxldmVsID09PSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4KSB7XG4gICAgICAvLyByZXNldCBsZXZlbCBsb2FkIGVycm9yIGNvdW50ZXIgb24gc3VjY2Vzc2Z1bCBsZXZlbCBsb2FkZWQgb25seSBpZiB0aGVyZSBpcyBubyBpc3N1ZXMgd2l0aCBmcmFnbWVudHNcbiAgICAgIGlmIChjdXJMZXZlbC5mcmFnbWVudEVycm9yID09PSAwKSB7XG4gICAgICAgIGN1ckxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICAgIHRoaXMucmV0cnlDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGxheWxpc3RMb2FkZWQobGV2ZWwsIGRhdGEsIGN1ckxldmVsLmRldGFpbHMpO1xuICAgIH0gZWxzZSBpZiAoKF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTIgPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcykgIT09IG51bGwgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpMiAhPT0gdm9pZCAwICYmIF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTIuc2tpcCkge1xuICAgICAgLy8gcmVjZWl2ZWQgYSBkZWx0YSBwbGF5bGlzdCB1cGRhdGUgdGhhdCBjYW5ub3QgYmUgbWVyZ2VkXG4gICAgICBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uQXVkaW9UcmFja1N3aXRjaGVkID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrU3dpdGNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgY3VycmVudExldmVsID0gdGhpcy5obHMubGV2ZWxzW3RoaXMuY3VycmVudExldmVsSW5kZXhdO1xuXG4gICAgaWYgKCFjdXJyZW50TGV2ZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudExldmVsLmF1ZGlvR3JvdXBJZHMpIHtcbiAgICAgIHZhciB1cmxJZCA9IC0xO1xuICAgICAgdmFyIGF1ZGlvR3JvdXBJZCA9IHRoaXMuaGxzLmF1ZGlvVHJhY2tzW2RhdGEuaWRdLmdyb3VwSWQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudExldmVsLmF1ZGlvR3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzW2ldID09PSBhdWRpb0dyb3VwSWQpIHtcbiAgICAgICAgICB1cmxJZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHVybElkICE9PSBjdXJyZW50TGV2ZWwudXJsSWQpIHtcbiAgICAgICAgY3VycmVudExldmVsLnVybElkID0gdXJsSWQ7XG4gICAgICAgIHRoaXMuc3RhcnRMb2FkKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5sb2FkUGxheWxpc3QgPSBmdW5jdGlvbiBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycykge1xuICAgIHZhciBsZXZlbCA9IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgdmFyIGN1cnJlbnRMZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbF07XG5cbiAgICBpZiAodGhpcy5jYW5Mb2FkICYmIGN1cnJlbnRMZXZlbCAmJiBjdXJyZW50TGV2ZWwudXJsLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBpZCA9IGN1cnJlbnRMZXZlbC51cmxJZDtcbiAgICAgIHZhciB1cmwgPSBjdXJyZW50TGV2ZWwudXJsW2lkXTtcblxuICAgICAgaWYgKGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cmwgPSBobHNVcmxQYXJhbWV0ZXJzLmFkZERpcmVjdGl2ZXModXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLndhcm4oXCJDb3VsZCBub3QgY29uc3RydWN0IG5ldyBVUkwgd2l0aCBITFMgRGVsaXZlcnkgRGlyZWN0aXZlczogXCIgKyBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2coXCJBdHRlbXB0IGxvYWRpbmcgbGV2ZWwgaW5kZXggXCIgKyBsZXZlbCArIChobHNVcmxQYXJhbWV0ZXJzID8gJyBhdCBzbiAnICsgaGxzVXJsUGFyYW1ldGVycy5tc24gKyAnIHBhcnQgJyArIGhsc1VybFBhcmFtZXRlcnMucGFydCA6ICcnKSArIFwiIHdpdGggVVJMLWlkIFwiICsgaWQgKyBcIiBcIiArIHVybCk7IC8vIGNvbnNvbGUubG9nKCdDdXJyZW50IGF1ZGlvIHRyYWNrIGdyb3VwIElEOicsIHRoaXMuaGxzLmF1ZGlvVHJhY2tzW3RoaXMuaGxzLmF1ZGlvVHJhY2tdLmdyb3VwSWQpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ05ldyB2aWRlbyBxdWFsaXR5IGxldmVsIGF1ZGlvIGdyb3VwIGlkOicsIGxldmVsT2JqZWN0LmF0dHJzLkFVRElPLCBsZXZlbCk7XG5cbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BRElORywge1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogaGxzVXJsUGFyYW1ldGVycyB8fCBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZUxldmVsID0gZnVuY3Rpb24gcmVtb3ZlTGV2ZWwobGV2ZWxJbmRleCwgdXJsSWQpIHtcbiAgICB2YXIgZmlsdGVyTGV2ZWxBbmRHcm91cEJ5SWRJbmRleCA9IGZ1bmN0aW9uIGZpbHRlckxldmVsQW5kR3JvdXBCeUlkSW5kZXgodXJsLCBpZCkge1xuICAgICAgcmV0dXJuIGlkICE9PSB1cmxJZDtcbiAgICB9O1xuXG4gICAgdmFyIGxldmVscyA9IHRoaXMuX2xldmVscy5maWx0ZXIoZnVuY3Rpb24gKGxldmVsLCBpbmRleCkge1xuICAgICAgaWYgKGluZGV4ICE9PSBsZXZlbEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobGV2ZWwudXJsLmxlbmd0aCA+IDEgJiYgdXJsSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXZlbC51cmwgPSBsZXZlbC51cmwuZmlsdGVyKGZpbHRlckxldmVsQW5kR3JvdXBCeUlkSW5kZXgpO1xuXG4gICAgICAgIGlmIChsZXZlbC5hdWRpb0dyb3VwSWRzKSB7XG4gICAgICAgICAgbGV2ZWwuYXVkaW9Hcm91cElkcyA9IGxldmVsLmF1ZGlvR3JvdXBJZHMuZmlsdGVyKGZpbHRlckxldmVsQW5kR3JvdXBCeUlkSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxldmVsLnRleHRHcm91cElkcykge1xuICAgICAgICAgIGxldmVsLnRleHRHcm91cElkcyA9IGxldmVsLnRleHRHcm91cElkcy5maWx0ZXIoZmlsdGVyTGV2ZWxBbmRHcm91cEJ5SWRJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXZlbC51cmxJZCA9IDA7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChsZXZlbCwgaW5kZXgpIHtcbiAgICAgIHZhciBkZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcblxuICAgICAgaWYgKGRldGFpbHMgIT09IG51bGwgJiYgZGV0YWlscyAhPT0gdm9pZCAwICYmIGRldGFpbHMuZnJhZ21lbnRzKSB7XG4gICAgICAgIGRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgICAgICAgZnJhZ21lbnQubGV2ZWwgPSBpbmRleDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsZXZlbDtcbiAgICB9KTtcblxuICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcbiAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5MRVZFTFNfVVBEQVRFRCwge1xuICAgICAgbGV2ZWxzOiBsZXZlbHNcbiAgICB9KTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoTGV2ZWxDb250cm9sbGVyLCBbe1xuICAgIGtleTogXCJsZXZlbHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLl9sZXZlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fbGV2ZWxzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgdmFyIF9sZXZlbHMkbmV3TGV2ZWw7XG5cbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG5cbiAgICAgIGlmIChsZXZlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY3VycmVudExldmVsSW5kZXggPT09IG5ld0xldmVsICYmIChfbGV2ZWxzJG5ld0xldmVsID0gbGV2ZWxzW25ld0xldmVsXSkgIT09IG51bGwgJiYgX2xldmVscyRuZXdMZXZlbCAhPT0gdm9pZCAwICYmIF9sZXZlbHMkbmV3TGV2ZWwuZGV0YWlscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuXG5cbiAgICAgIGlmIChuZXdMZXZlbCA8IDAgfHwgbmV3TGV2ZWwgPj0gbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICAvLyBpbnZhbGlkIGxldmVsIGlkIGdpdmVuLCB0cmlnZ2VyIGVycm9yXG4gICAgICAgIHZhciBmYXRhbCA9IG5ld0xldmVsIDwgMDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvclR5cGVzXCJdLk9USEVSX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5MRVZFTF9TV0lUQ0hfRVJST1IsXG4gICAgICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgICAgIGZhdGFsOiBmYXRhbCxcbiAgICAgICAgICByZWFzb246ICdpbnZhbGlkIGxldmVsIGlkeCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGZhdGFsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1pbihuZXdMZXZlbCwgbGV2ZWxzLmxlbmd0aCAtIDEpO1xuICAgICAgfSAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcblxuXG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIHZhciBsYXN0TGV2ZWxJbmRleCA9IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgICB2YXIgbGFzdExldmVsID0gbGV2ZWxzW2xhc3RMZXZlbEluZGV4XTtcbiAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tuZXdMZXZlbF07XG4gICAgICB0aGlzLmxvZyhcInN3aXRjaGluZyB0byBsZXZlbCBcIiArIG5ld0xldmVsICsgXCIgZnJvbSBcIiArIGxhc3RMZXZlbEluZGV4KTtcbiAgICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSBuZXdMZXZlbDtcblxuICAgICAgdmFyIGxldmVsU3dpdGNoaW5nRGF0YSA9IF9leHRlbmRzKHt9LCBsZXZlbCwge1xuICAgICAgICBsZXZlbDogbmV3TGV2ZWwsXG4gICAgICAgIG1heEJpdHJhdGU6IGxldmVsLm1heEJpdHJhdGUsXG4gICAgICAgIHVyaTogbGV2ZWwudXJpLFxuICAgICAgICB1cmxJZDogbGV2ZWwudXJsSWRcbiAgICAgIH0pOyAvLyBAdHMtaWdub3JlXG5cblxuICAgICAgZGVsZXRlIGxldmVsU3dpdGNoaW5nRGF0YS5fdXJsSWQ7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5MRVZFTF9TV0lUQ0hJTkcsIGxldmVsU3dpdGNoaW5nRGF0YSk7IC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBsZXZlbFxuXG4gICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcblxuICAgICAgaWYgKCFsZXZlbERldGFpbHMgfHwgbGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgLy8gbGV2ZWwgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgICB2YXIgaGxzVXJsUGFyYW1ldGVycyA9IHRoaXMuc3dpdGNoUGFyYW1zKGxldmVsLnVyaSwgbGFzdExldmVsID09PSBudWxsIHx8IGxhc3RMZXZlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdExldmVsLmRldGFpbHMpO1xuICAgICAgICB0aGlzLmxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFudWFsTGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hbnVhbExldmVsSW5kZXg7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gbmV3TGV2ZWw7XG5cbiAgICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3TGV2ZWwgIT09IC0xKSB7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlyc3RMZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydExldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAvLyBobHMuc3RhcnRMZXZlbCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgY29uZmlnLnN0YXJ0TGV2ZWxcbiAgICAgIC8vIGlmIG5vbmUgb2YgdGhlc2UgdmFsdWVzIGFyZSBkZWZpbmVkLCBmYWxsYmFjayBvbiB0aGlzLl9maXJzdExldmVsIChmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiB2YXJpYW50IG1hbmlmZXN0KVxuICAgICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgY29uZmlnU3RhcnRMZXZlbCA9IHRoaXMuaGxzLmNvbmZpZy5zdGFydExldmVsO1xuXG4gICAgICAgIGlmIChjb25maWdTdGFydExldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gY29uZmlnU3RhcnRMZXZlbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0TGV2ZWw7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZXh0TG9hZExldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXh0TGV2ZWwpIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBuZXh0TGV2ZWw7XG5cbiAgICAgIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExldmVsQ29udHJvbGxlcjtcbn0oX2Jhc2VfcGxheWxpc3RfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2xldmVsLWhlbHBlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2xldmVsLWhlbHBlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBhZGRHcm91cElkLCBhc3NpZ25UcmFja0lkc0J5R3JvdXAsIHVwZGF0ZVBUUywgdXBkYXRlRnJhZ1BUU0RUUywgbWVyZ2VEZXRhaWxzLCBtYXBQYXJ0SW50ZXJzZWN0aW9uLCBtYXBGcmFnbWVudEludGVyc2VjdGlvbiwgYWRqdXN0U2xpZGluZywgYWRkU2xpZGluZywgY29tcHV0ZVJlbG9hZEludGVydmFsLCBnZXRGcmFnbWVudFdpdGhTTiwgZ2V0UGFydFdpdGggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWRkR3JvdXBJZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFkZEdyb3VwSWQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFzc2lnblRyYWNrSWRzQnlHcm91cFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFzc2lnblRyYWNrSWRzQnlHcm91cDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidXBkYXRlUFRTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdXBkYXRlUFRTOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ1cGRhdGVGcmFnUFRTRFRTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdXBkYXRlRnJhZ1BUU0RUUzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibWVyZ2VEZXRhaWxzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVyZ2VEZXRhaWxzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJtYXBQYXJ0SW50ZXJzZWN0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWFwUGFydEludGVyc2VjdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibWFwRnJhZ21lbnRJbnRlcnNlY3Rpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtYXBGcmFnbWVudEludGVyc2VjdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWRqdXN0U2xpZGluZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFkanVzdFNsaWRpbmc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFkZFNsaWRpbmdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhZGRTbGlkaW5nOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjb21wdXRlUmVsb2FkSW50ZXJ2YWxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb21wdXRlUmVsb2FkSW50ZXJ2YWw7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldEZyYWdtZW50V2l0aFNOXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0RnJhZ21lbnRXaXRoU047IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldFBhcnRXaXRoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0UGFydFdpdGg7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZGVyX2RhdGVfcmFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvYWRlci9kYXRlLXJhbmdlICovIFwiLi9zcmMvbG9hZGVyL2RhdGUtcmFuZ2UudHNcIik7XG5cblxuXG5cblxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuLyoqXG4gKiBAbW9kdWxlIExldmVsSGVscGVyXG4gKiBQcm92aWRpbmcgbWV0aG9kcyBkZWFsaW5nIHdpdGggcGxheWxpc3Qgc2xpZGluZyBhbmQgZHJpZnRcbiAqICovXG5cblxuZnVuY3Rpb24gYWRkR3JvdXBJZChsZXZlbCwgdHlwZSwgaWQpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgaWYgKCFsZXZlbC5hdWRpb0dyb3VwSWRzKSB7XG4gICAgICAgIGxldmVsLmF1ZGlvR3JvdXBJZHMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgbGV2ZWwuYXVkaW9Hcm91cElkcy5wdXNoKGlkKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dCc6XG4gICAgICBpZiAoIWxldmVsLnRleHRHcm91cElkcykge1xuICAgICAgICBsZXZlbC50ZXh0R3JvdXBJZHMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgbGV2ZWwudGV4dEdyb3VwSWRzLnB1c2goaWQpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2lnblRyYWNrSWRzQnlHcm91cCh0cmFja3MpIHtcbiAgdmFyIGdyb3VwcyA9IHt9O1xuICB0cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICB2YXIgZ3JvdXBJZCA9IHRyYWNrLmdyb3VwSWQgfHwgJyc7XG4gICAgdHJhY2suaWQgPSBncm91cHNbZ3JvdXBJZF0gPSBncm91cHNbZ3JvdXBJZF0gfHwgMDtcbiAgICBncm91cHNbZ3JvdXBJZF0rKztcbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVQVFMoZnJhZ21lbnRzLCBmcm9tSWR4LCB0b0lkeCkge1xuICB2YXIgZnJhZ0Zyb20gPSBmcmFnbWVudHNbZnJvbUlkeF07XG4gIHZhciBmcmFnVG8gPSBmcmFnbWVudHNbdG9JZHhdO1xuICB1cGRhdGVGcm9tVG9QVFMoZnJhZ0Zyb20sIGZyYWdUbyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZyb21Ub1BUUyhmcmFnRnJvbSwgZnJhZ1RvKSB7XG4gIHZhciBmcmFnVG9QVFMgPSBmcmFnVG8uc3RhcnRQVFM7IC8vIGlmIHdlIGtub3cgc3RhcnRQVFNbdG9JZHhdXG5cbiAgaWYgKE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoZnJhZ1RvUFRTKSkge1xuICAgIC8vIHVwZGF0ZSBmcmFnbWVudCBkdXJhdGlvbi5cbiAgICAvLyBpdCBoZWxwcyB0byBmaXggZHJpZnRzIGJldHdlZW4gcGxheWxpc3QgcmVwb3J0ZWQgZHVyYXRpb24gYW5kIGZyYWdtZW50IHJlYWwgZHVyYXRpb25cbiAgICB2YXIgZHVyYXRpb24gPSAwO1xuICAgIHZhciBmcmFnO1xuXG4gICAgaWYgKGZyYWdUby5zbiA+IGZyYWdGcm9tLnNuKSB7XG4gICAgICBkdXJhdGlvbiA9IGZyYWdUb1BUUyAtIGZyYWdGcm9tLnN0YXJ0O1xuICAgICAgZnJhZyA9IGZyYWdGcm9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdXJhdGlvbiA9IGZyYWdGcm9tLnN0YXJ0IC0gZnJhZ1RvUFRTO1xuICAgICAgZnJhZyA9IGZyYWdUbztcbiAgICB9IC8vIFRPRE8/IERyaWZ0IGNhbiBnbyBlaXRoZXIgd2F5LCBvciB0aGUgcGxheWxpc3QgY291bGQgYmUgY29tcGxldGVseSBhY2N1cmF0ZVxuICAgIC8vIGNvbnNvbGUuYXNzZXJ0KGR1cmF0aW9uID4gMCxcbiAgICAvLyAgIGBkdXJhdGlvbiBvZiAke2R1cmF0aW9ufSBjb21wdXRlZCBmb3IgZnJhZyAke2ZyYWcuc259LCBsZXZlbCAke2ZyYWcubGV2ZWx9LCB0aGVyZSBzaG91bGQgYmUgc29tZSBkdXJhdGlvbiBkcmlmdCBiZXR3ZWVuIHBsYXlsaXN0IGFuZCBmcmFnbWVudCFgKTtcblxuXG4gICAgaWYgKGZyYWcuZHVyYXRpb24gIT09IGR1cmF0aW9uKSB7XG4gICAgICBmcmFnLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgfSAvLyB3ZSBkb250IGtub3cgc3RhcnRQVFNbdG9JZHhdXG5cbiAgfSBlbHNlIGlmIChmcmFnVG8uc24gPiBmcmFnRnJvbS5zbikge1xuICAgIHZhciBjb250aWd1b3VzID0gZnJhZ0Zyb20uY2MgPT09IGZyYWdUby5jYzsgLy8gVE9ETzogV2l0aCBwYXJ0LWxvYWRpbmcgZW5kL2R1cmF0aW9ucyB3ZSBuZWVkIHRvIGNvbmZpcm0gdGhlIHdob2xlIGZyYWdtZW50IGlzIGxvYWRlZCBiZWZvcmUgdXNpbmcgKG9yIHNldHRpbmcpIG1pbkVuZFBUU1xuXG4gICAgaWYgKGNvbnRpZ3VvdXMgJiYgZnJhZ0Zyb20ubWluRW5kUFRTKSB7XG4gICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCArIChmcmFnRnJvbS5taW5FbmRQVFMgLSBmcmFnRnJvbS5zdGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWdUby5zdGFydCA9IGZyYWdGcm9tLnN0YXJ0ICsgZnJhZ0Zyb20uZHVyYXRpb247XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZyYWdUby5zdGFydCA9IE1hdGgubWF4KGZyYWdGcm9tLnN0YXJ0IC0gZnJhZ1RvLmR1cmF0aW9uLCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVGcmFnUFRTRFRTKGRldGFpbHMsIGZyYWcsIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpIHtcbiAgdmFyIHBhcnNlZE1lZGlhRHVyYXRpb24gPSBlbmRQVFMgLSBzdGFydFBUUztcblxuICBpZiAocGFyc2VkTWVkaWFEdXJhdGlvbiA8PSAwKSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wibG9nZ2VyXCJdLndhcm4oJ0ZyYWdtZW50IHNob3VsZCBoYXZlIGEgcG9zaXRpdmUgZHVyYXRpb24nLCBmcmFnKTtcbiAgICBlbmRQVFMgPSBzdGFydFBUUyArIGZyYWcuZHVyYXRpb247XG4gICAgZW5kRFRTID0gc3RhcnREVFMgKyBmcmFnLmR1cmF0aW9uO1xuICB9XG5cbiAgdmFyIG1heFN0YXJ0UFRTID0gc3RhcnRQVFM7XG4gIHZhciBtaW5FbmRQVFMgPSBlbmRQVFM7XG4gIHZhciBmcmFnU3RhcnRQdHMgPSBmcmFnLnN0YXJ0UFRTO1xuICB2YXIgZnJhZ0VuZFB0cyA9IGZyYWcuZW5kUFRTO1xuXG4gIGlmIChPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGZyYWdTdGFydFB0cykpIHtcbiAgICAvLyBkZWx0YSBQVFMgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW9cbiAgICB2YXIgZGVsdGFQVFMgPSBNYXRoLmFicyhmcmFnU3RhcnRQdHMgLSBzdGFydFBUUyk7XG5cbiAgICBpZiAoIU9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoZnJhZy5kZWx0YVBUUykpIHtcbiAgICAgIGZyYWcuZGVsdGFQVFMgPSBkZWx0YVBUUztcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZy5kZWx0YVBUUyA9IE1hdGgubWF4KGRlbHRhUFRTLCBmcmFnLmRlbHRhUFRTKTtcbiAgICB9XG5cbiAgICBtYXhTdGFydFBUUyA9IE1hdGgubWF4KHN0YXJ0UFRTLCBmcmFnU3RhcnRQdHMpO1xuICAgIHN0YXJ0UFRTID0gTWF0aC5taW4oc3RhcnRQVFMsIGZyYWdTdGFydFB0cyk7XG4gICAgc3RhcnREVFMgPSBNYXRoLm1pbihzdGFydERUUywgZnJhZy5zdGFydERUUyk7XG4gICAgbWluRW5kUFRTID0gTWF0aC5taW4oZW5kUFRTLCBmcmFnRW5kUHRzKTtcbiAgICBlbmRQVFMgPSBNYXRoLm1heChlbmRQVFMsIGZyYWdFbmRQdHMpO1xuICAgIGVuZERUUyA9IE1hdGgubWF4KGVuZERUUywgZnJhZy5lbmREVFMpO1xuICB9XG5cbiAgZnJhZy5kdXJhdGlvbiA9IGVuZFBUUyAtIHN0YXJ0UFRTO1xuICB2YXIgZHJpZnQgPSBzdGFydFBUUyAtIGZyYWcuc3RhcnQ7XG4gIGZyYWcuYXBwZW5kZWRQVFMgPSBlbmRQVFM7XG4gIGZyYWcuc3RhcnQgPSBmcmFnLnN0YXJ0UFRTID0gc3RhcnRQVFM7XG4gIGZyYWcubWF4U3RhcnRQVFMgPSBtYXhTdGFydFBUUztcbiAgZnJhZy5zdGFydERUUyA9IHN0YXJ0RFRTO1xuICBmcmFnLmVuZFBUUyA9IGVuZFBUUztcbiAgZnJhZy5taW5FbmRQVFMgPSBtaW5FbmRQVFM7XG4gIGZyYWcuZW5kRFRTID0gZW5kRFRTO1xuICB2YXIgc24gPSBmcmFnLnNuOyAvLyAnaW5pdFNlZ21lbnQnXG4gIC8vIGV4aXQgaWYgc24gb3V0IG9mIHJhbmdlXG5cbiAgaWYgKCFkZXRhaWxzIHx8IHNuIDwgZGV0YWlscy5zdGFydFNOIHx8IHNuID4gZGV0YWlscy5lbmRTTikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIGk7XG4gIHZhciBmcmFnSWR4ID0gc24gLSBkZXRhaWxzLnN0YXJ0U047XG4gIHZhciBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50czsgLy8gdXBkYXRlIGZyYWcgcmVmZXJlbmNlIGluIGZyYWdtZW50cyBhcnJheVxuICAvLyByYXRpb25hbGUgaXMgdGhhdCBmcmFnbWVudHMgYXJyYXkgbWlnaHQgbm90IGNvbnRhaW4gdGhpcyBmcmFnIG9iamVjdC5cbiAgLy8gdGhpcyB3aWxsIGhhcHBlbiBpZiBwbGF5bGlzdCBoYXMgYmVlbiByZWZyZXNoZWQgYmV0d2VlbiBmcmFnIGxvYWRpbmcgYW5kIGNhbGwgdG8gdXBkYXRlRnJhZ1BUU0RUUygpXG4gIC8vIGlmIHdlIGRvbid0IHVwZGF0ZSBmcmFnLCB3ZSB3b24ndCBiZSBhYmxlIHRvIHByb3BhZ2F0ZSBQVFMgaW5mbyBvbiB0aGUgcGxheWxpc3RcbiAgLy8gcmVzdWx0aW5nIGluIGludmFsaWQgc2xpZGluZyBjb21wdXRhdGlvblxuXG4gIGZyYWdtZW50c1tmcmFnSWR4XSA9IGZyYWc7IC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0tMSB0byBmcmFnIDBcblxuICBmb3IgKGkgPSBmcmFnSWR4OyBpID4gMDsgaS0tKSB7XG4gICAgdXBkYXRlRnJvbVRvUFRTKGZyYWdtZW50c1tpXSwgZnJhZ21lbnRzW2kgLSAxXSk7XG4gIH0gLy8gYWRqdXN0IGZyYWdtZW50IFBUUy9kdXJhdGlvbiBmcm9tIHNlcW51bSB0byBsYXN0IGZyYWdcblxuXG4gIGZvciAoaSA9IGZyYWdJZHg7IGkgPCBmcmFnbWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdXBkYXRlRnJvbVRvUFRTKGZyYWdtZW50c1tpXSwgZnJhZ21lbnRzW2kgKyAxXSk7XG4gIH1cblxuICBpZiAoZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICB1cGRhdGVGcm9tVG9QVFMoZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXSwgZGV0YWlscy5mcmFnbWVudEhpbnQpO1xuICB9XG5cbiAgZGV0YWlscy5QVFNLbm93biA9IGRldGFpbHMuYWxpZ25lZFNsaWRpbmcgPSB0cnVlO1xuICByZXR1cm4gZHJpZnQ7XG59XG5mdW5jdGlvbiBtZXJnZURldGFpbHMob2xkRGV0YWlscywgbmV3RGV0YWlscykge1xuICAvLyBUcmFjayB0aGUgbGFzdCBpbml0U2VnbWVudCBwcm9jZXNzZWQuIEluaXRpYWxpemUgaXQgdG8gdGhlIGxhc3Qgb25lIG9uIHRoZSB0aW1lbGluZS5cbiAgdmFyIGN1cnJlbnRJbml0U2VnbWVudCA9IG51bGw7XG4gIHZhciBvbGRGcmFnbWVudHMgPSBvbGREZXRhaWxzLmZyYWdtZW50cztcblxuICBmb3IgKHZhciBpID0gb2xkRnJhZ21lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIG9sZEluaXQgPSBvbGRGcmFnbWVudHNbaV0uaW5pdFNlZ21lbnQ7XG5cbiAgICBpZiAob2xkSW5pdCkge1xuICAgICAgY3VycmVudEluaXRTZWdtZW50ID0gb2xkSW5pdDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvbGREZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgIC8vIHByZXZlbnQgUFRTIGFuZCBkdXJhdGlvbiBmcm9tIGJlaW5nIGFkanVzdGVkIG9uIHRoZSBuZXh0IGhpbnRcbiAgICBkZWxldGUgb2xkRGV0YWlscy5mcmFnbWVudEhpbnQuZW5kUFRTO1xuICB9IC8vIGNoZWNrIGlmIG9sZC9uZXcgcGxheWxpc3RzIGhhdmUgZnJhZ21lbnRzIGluIGNvbW1vblxuICAvLyBsb29wIHRocm91Z2ggb3ZlcmxhcHBpbmcgU04gYW5kIHVwZGF0ZSBzdGFydFBUUyAsIGNjLCBhbmQgZHVyYXRpb24gaWYgYW55IGZvdW5kXG5cblxuICB2YXIgY2NPZmZzZXQgPSAwO1xuICB2YXIgUFRTRnJhZztcbiAgbWFwRnJhZ21lbnRJbnRlcnNlY3Rpb24ob2xkRGV0YWlscywgbmV3RGV0YWlscywgZnVuY3Rpb24gKG9sZEZyYWcsIG5ld0ZyYWcpIHtcbiAgICBpZiAob2xkRnJhZy5yZWx1cmwpIHtcbiAgICAgIC8vIERvIG5vdCBjb21wYXJlIENDIGlmIHRoZSBvbGQgZnJhZ21lbnQgaGFzIG5vIHVybC4gVGhpcyBpcyBhIGxldmVsLmZyYWdtZW50SGludCB1c2VkIGJ5IExMLUhMUyBwYXJ0cy5cbiAgICAgIC8vIEl0IG1heWJlIGJlIG9mZiBieSAxIGlmIGl0IHdhcyBjcmVhdGVkIGJlZm9yZSBhbnkgcGFydHMgb3IgZGlzY29udGludWl0eSB0YWdzIHdlcmUgYXBwZW5kZWQgdG8gdGhlIGVuZFxuICAgICAgLy8gb2YgdGhlIHBsYXlsaXN0LlxuICAgICAgY2NPZmZzZXQgPSBvbGRGcmFnLmNjIC0gbmV3RnJhZy5jYztcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShvbGRGcmFnLnN0YXJ0UFRTKSAmJiBPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKG9sZEZyYWcuZW5kUFRTKSkge1xuICAgICAgbmV3RnJhZy5zdGFydCA9IG5ld0ZyYWcuc3RhcnRQVFMgPSBvbGRGcmFnLnN0YXJ0UFRTO1xuICAgICAgbmV3RnJhZy5zdGFydERUUyA9IG9sZEZyYWcuc3RhcnREVFM7XG4gICAgICBuZXdGcmFnLmFwcGVuZGVkUFRTID0gb2xkRnJhZy5hcHBlbmRlZFBUUztcbiAgICAgIG5ld0ZyYWcubWF4U3RhcnRQVFMgPSBvbGRGcmFnLm1heFN0YXJ0UFRTO1xuICAgICAgbmV3RnJhZy5lbmRQVFMgPSBvbGRGcmFnLmVuZFBUUztcbiAgICAgIG5ld0ZyYWcuZW5kRFRTID0gb2xkRnJhZy5lbmREVFM7XG4gICAgICBuZXdGcmFnLm1pbkVuZFBUUyA9IG9sZEZyYWcubWluRW5kUFRTO1xuICAgICAgbmV3RnJhZy5kdXJhdGlvbiA9IG9sZEZyYWcuZW5kUFRTIC0gb2xkRnJhZy5zdGFydFBUUztcblxuICAgICAgaWYgKG5ld0ZyYWcuZHVyYXRpb24pIHtcbiAgICAgICAgUFRTRnJhZyA9IG5ld0ZyYWc7XG4gICAgICB9IC8vIFBUUyBpcyBrbm93biB3aGVuIGFueSBzZWdtZW50IGhhcyBzdGFydFBUUyBhbmQgZW5kUFRTXG5cblxuICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IG5ld0RldGFpbHMuYWxpZ25lZFNsaWRpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIG5ld0ZyYWcuZWxlbWVudGFyeVN0cmVhbXMgPSBvbGRGcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgIG5ld0ZyYWcubG9hZGVyID0gb2xkRnJhZy5sb2FkZXI7XG4gICAgbmV3RnJhZy5zdGF0cyA9IG9sZEZyYWcuc3RhdHM7XG4gICAgbmV3RnJhZy51cmxJZCA9IG9sZEZyYWcudXJsSWQ7XG5cbiAgICBpZiAob2xkRnJhZy5pbml0U2VnbWVudCkge1xuICAgICAgbmV3RnJhZy5pbml0U2VnbWVudCA9IG9sZEZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgICBjdXJyZW50SW5pdFNlZ21lbnQgPSBvbGRGcmFnLmluaXRTZWdtZW50O1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGN1cnJlbnRJbml0U2VnbWVudCkge1xuICAgIHZhciBmcmFnbWVudHNUb0NoZWNrID0gbmV3RGV0YWlscy5mcmFnbWVudEhpbnQgPyBuZXdEZXRhaWxzLmZyYWdtZW50cy5jb25jYXQobmV3RGV0YWlscy5mcmFnbWVudEhpbnQpIDogbmV3RGV0YWlscy5mcmFnbWVudHM7XG4gICAgZnJhZ21lbnRzVG9DaGVjay5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICB2YXIgX2N1cnJlbnRJbml0U2VnbWVudDtcblxuICAgICAgaWYgKCFmcmFnLmluaXRTZWdtZW50IHx8IGZyYWcuaW5pdFNlZ21lbnQucmVsdXJsID09PSAoKF9jdXJyZW50SW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQpID09PSBudWxsIHx8IF9jdXJyZW50SW5pdFNlZ21lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jdXJyZW50SW5pdFNlZ21lbnQucmVsdXJsKSkge1xuICAgICAgICBmcmFnLmluaXRTZWdtZW50ID0gY3VycmVudEluaXRTZWdtZW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgbmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IG5ld0RldGFpbHMuZnJhZ21lbnRzLnNvbWUoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgIHJldHVybiAhZnJhZztcbiAgICB9KTtcblxuICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJsb2dnZXJcIl0ud2FybignW2xldmVsLWhlbHBlcl0gUHJldmlvdXMgcGxheWxpc3QgbWlzc2luZyBzZWdtZW50cyBza2lwcGVkIGluIGRlbHRhIHBsYXlsaXN0Jyk7XG5cbiAgICAgIGZvciAodmFyIF9pID0gbmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHM7IF9pLS07KSB7XG4gICAgICAgIG5ld0RldGFpbHMuZnJhZ21lbnRzLnNoaWZ0KCk7XG4gICAgICB9XG5cbiAgICAgIG5ld0RldGFpbHMuc3RhcnRTTiA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLnNuO1xuICAgICAgbmV3RGV0YWlscy5zdGFydENDID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uY2M7XG4gICAgfSBlbHNlIGlmIChuZXdEZXRhaWxzLmNhblNraXBEYXRlUmFuZ2VzKSB7XG4gICAgICBuZXdEZXRhaWxzLmRhdGVSYW5nZXMgPSBtZXJnZURhdGVSYW5nZXMob2xkRGV0YWlscy5kYXRlUmFuZ2VzLCBuZXdEZXRhaWxzLmRhdGVSYW5nZXMsIG5ld0RldGFpbHMucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld0ZyYWdtZW50cyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuXG4gIGlmIChjY09mZnNldCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImxvZ2dlclwiXS53YXJuKCdkaXNjb250aW51aXR5IHNsaWRpbmcgZnJvbSBwbGF5bGlzdCwgdGFrZSBkcmlmdCBpbnRvIGFjY291bnQnKTtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5ld0ZyYWdtZW50cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICBuZXdGcmFnbWVudHNbX2kyXS5jYyArPSBjY09mZnNldDtcbiAgICB9XG4gIH1cblxuICBpZiAobmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHMpIHtcbiAgICBuZXdEZXRhaWxzLnN0YXJ0Q0MgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5jYztcbiAgfSAvLyBNZXJnZSBwYXJ0c1xuXG5cbiAgbWFwUGFydEludGVyc2VjdGlvbihvbGREZXRhaWxzLnBhcnRMaXN0LCBuZXdEZXRhaWxzLnBhcnRMaXN0LCBmdW5jdGlvbiAob2xkUGFydCwgbmV3UGFydCkge1xuICAgIG5ld1BhcnQuZWxlbWVudGFyeVN0cmVhbXMgPSBvbGRQYXJ0LmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgIG5ld1BhcnQuc3RhdHMgPSBvbGRQYXJ0LnN0YXRzO1xuICB9KTsgLy8gaWYgYXQgbGVhc3Qgb25lIGZyYWdtZW50IGNvbnRhaW5zIFBUUyBpbmZvLCByZWNvbXB1dGUgUFRTIGluZm9ybWF0aW9uIGZvciBhbGwgZnJhZ21lbnRzXG5cbiAgaWYgKFBUU0ZyYWcpIHtcbiAgICB1cGRhdGVGcmFnUFRTRFRTKG5ld0RldGFpbHMsIFBUU0ZyYWcsIFBUU0ZyYWcuc3RhcnRQVFMsIFBUU0ZyYWcuZW5kUFRTLCBQVFNGcmFnLnN0YXJ0RFRTLCBQVFNGcmFnLmVuZERUUyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW5zdXJlIHRoYXQgZGVsdGEgaXMgd2l0aGluIG9sZEZyYWdtZW50cyByYW5nZVxuICAgIC8vIGFsc28gYWRqdXN0IHNsaWRpbmcgaW4gY2FzZSBkZWx0YSBpcyAwICh3ZSBjb3VsZCBoYXZlIG9sZD1bNTAtNjBdIGFuZCBuZXc9b2xkPVs1MC02MV0pXG4gICAgLy8gaW4gdGhhdCBjYXNlIHdlIGFsc28gbmVlZCB0byBhZGp1c3Qgc3RhcnQgb2Zmc2V0IG9mIGFsbCBmcmFnbWVudHNcbiAgICBhZGp1c3RTbGlkaW5nKG9sZERldGFpbHMsIG5ld0RldGFpbHMpO1xuICB9XG5cbiAgaWYgKG5ld0ZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb24gPSBuZXdEZXRhaWxzLmVkZ2UgLSBuZXdGcmFnbWVudHNbMF0uc3RhcnQ7XG4gIH1cblxuICBuZXdEZXRhaWxzLmRyaWZ0U3RhcnRUaW1lID0gb2xkRGV0YWlscy5kcmlmdFN0YXJ0VGltZTtcbiAgbmV3RGV0YWlscy5kcmlmdFN0YXJ0ID0gb2xkRGV0YWlscy5kcmlmdFN0YXJ0O1xuICB2YXIgYWR2YW5jZWREYXRlVGltZSA9IG5ld0RldGFpbHMuYWR2YW5jZWREYXRlVGltZTtcblxuICBpZiAobmV3RGV0YWlscy5hZHZhbmNlZCAmJiBhZHZhbmNlZERhdGVUaW1lKSB7XG4gICAgdmFyIGVkZ2UgPSBuZXdEZXRhaWxzLmVkZ2U7XG5cbiAgICBpZiAoIW5ld0RldGFpbHMuZHJpZnRTdGFydCkge1xuICAgICAgbmV3RGV0YWlscy5kcmlmdFN0YXJ0VGltZSA9IGFkdmFuY2VkRGF0ZVRpbWU7XG4gICAgICBuZXdEZXRhaWxzLmRyaWZ0U3RhcnQgPSBlZGdlO1xuICAgIH1cblxuICAgIG5ld0RldGFpbHMuZHJpZnRFbmRUaW1lID0gYWR2YW5jZWREYXRlVGltZTtcbiAgICBuZXdEZXRhaWxzLmRyaWZ0RW5kID0gZWRnZTtcbiAgfSBlbHNlIHtcbiAgICBuZXdEZXRhaWxzLmRyaWZ0RW5kVGltZSA9IG9sZERldGFpbHMuZHJpZnRFbmRUaW1lO1xuICAgIG5ld0RldGFpbHMuZHJpZnRFbmQgPSBvbGREZXRhaWxzLmRyaWZ0RW5kO1xuICAgIG5ld0RldGFpbHMuYWR2YW5jZWREYXRlVGltZSA9IG9sZERldGFpbHMuYWR2YW5jZWREYXRlVGltZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZURhdGVSYW5nZXMob2xkRGF0ZVJhbmdlcywgZGVsdGFEYXRlUmFuZ2VzLCByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzKSB7XG4gIHZhciBkYXRlUmFuZ2VzID0gX2V4dGVuZHMoe30sIG9sZERhdGVSYW5nZXMpO1xuXG4gIGlmIChyZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzKSB7XG4gICAgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgZGVsZXRlIGRhdGVSYW5nZXNbaWRdO1xuICAgIH0pO1xuICB9XG5cbiAgT2JqZWN0LmtleXMoZGVsdGFEYXRlUmFuZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBkYXRlUmFuZ2UgPSBuZXcgX2xvYWRlcl9kYXRlX3JhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJEYXRlUmFuZ2VcIl0oZGVsdGFEYXRlUmFuZ2VzW2lkXS5hdHRyLCBkYXRlUmFuZ2VzW2lkXSk7XG5cbiAgICBpZiAoZGF0ZVJhbmdlLmlzVmFsaWQpIHtcbiAgICAgIGRhdGVSYW5nZXNbaWRdID0gZGF0ZVJhbmdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJsb2dnZXJcIl0ud2FybihcIklnbm9yaW5nIGludmFsaWQgUGxheWxpc3QgRGVsdGEgVXBkYXRlIERBVEVSQU5HRSB0YWc6IFxcXCJcIiArIEpTT04uc3RyaW5naWZ5KGRlbHRhRGF0ZVJhbmdlc1tpZF0uYXR0cikgKyBcIlxcXCJcIik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGVSYW5nZXM7XG59XG5cbmZ1bmN0aW9uIG1hcFBhcnRJbnRlcnNlY3Rpb24ob2xkUGFydHMsIG5ld1BhcnRzLCBpbnRlcnNlY3Rpb25Gbikge1xuICBpZiAob2xkUGFydHMgJiYgbmV3UGFydHMpIHtcbiAgICB2YXIgZGVsdGEgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9sZFBhcnRzLmxlbmd0aDsgaSA8PSBsZW47IGkrKykge1xuICAgICAgdmFyIF9vbGRQYXJ0ID0gb2xkUGFydHNbaV07XG4gICAgICB2YXIgX25ld1BhcnQgPSBuZXdQYXJ0c1tpICsgZGVsdGFdO1xuXG4gICAgICBpZiAoX29sZFBhcnQgJiYgX25ld1BhcnQgJiYgX29sZFBhcnQuaW5kZXggPT09IF9uZXdQYXJ0LmluZGV4ICYmIF9vbGRQYXJ0LmZyYWdtZW50LnNuID09PSBfbmV3UGFydC5mcmFnbWVudC5zbikge1xuICAgICAgICBpbnRlcnNlY3Rpb25Gbihfb2xkUGFydCwgX25ld1BhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsdGEtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcEZyYWdtZW50SW50ZXJzZWN0aW9uKG9sZERldGFpbHMsIG5ld0RldGFpbHMsIGludGVyc2VjdGlvbkZuKSB7XG4gIHZhciBza2lwcGVkU2VnbWVudHMgPSBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cztcbiAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgob2xkRGV0YWlscy5zdGFydFNOLCBuZXdEZXRhaWxzLnN0YXJ0U04pIC0gbmV3RGV0YWlscy5zdGFydFNOO1xuICB2YXIgZW5kID0gKG9sZERldGFpbHMuZnJhZ21lbnRIaW50ID8gMSA6IDApICsgKHNraXBwZWRTZWdtZW50cyA/IG5ld0RldGFpbHMuZW5kU04gOiBNYXRoLm1pbihvbGREZXRhaWxzLmVuZFNOLCBuZXdEZXRhaWxzLmVuZFNOKSkgLSBuZXdEZXRhaWxzLnN0YXJ0U047XG4gIHZhciBkZWx0YSA9IG5ld0RldGFpbHMuc3RhcnRTTiAtIG9sZERldGFpbHMuc3RhcnRTTjtcbiAgdmFyIG5ld0ZyYWdzID0gbmV3RGV0YWlscy5mcmFnbWVudEhpbnQgPyBuZXdEZXRhaWxzLmZyYWdtZW50cy5jb25jYXQobmV3RGV0YWlscy5mcmFnbWVudEhpbnQpIDogbmV3RGV0YWlscy5mcmFnbWVudHM7XG4gIHZhciBvbGRGcmFncyA9IG9sZERldGFpbHMuZnJhZ21lbnRIaW50ID8gb2xkRGV0YWlscy5mcmFnbWVudHMuY29uY2F0KG9sZERldGFpbHMuZnJhZ21lbnRIaW50KSA6IG9sZERldGFpbHMuZnJhZ21lbnRzO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgIHZhciBfb2xkRnJhZyA9IG9sZEZyYWdzW2RlbHRhICsgaV07XG4gICAgdmFyIF9uZXdGcmFnID0gbmV3RnJhZ3NbaV07XG5cbiAgICBpZiAoc2tpcHBlZFNlZ21lbnRzICYmICFfbmV3RnJhZyAmJiBpIDwgc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgICAvLyBGaWxsIGluIHNraXBwZWQgc2VnbWVudHMgaW4gZGVsdGEgcGxheWxpc3RcbiAgICAgIF9uZXdGcmFnID0gbmV3RGV0YWlscy5mcmFnbWVudHNbaV0gPSBfb2xkRnJhZztcbiAgICB9XG5cbiAgICBpZiAoX29sZEZyYWcgJiYgX25ld0ZyYWcpIHtcbiAgICAgIGludGVyc2VjdGlvbkZuKF9vbGRGcmFnLCBfbmV3RnJhZyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGp1c3RTbGlkaW5nKG9sZERldGFpbHMsIG5ld0RldGFpbHMpIHtcbiAgdmFyIGRlbHRhID0gbmV3RGV0YWlscy5zdGFydFNOICsgbmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHMgLSBvbGREZXRhaWxzLnN0YXJ0U047XG4gIHZhciBvbGRGcmFnbWVudHMgPSBvbGREZXRhaWxzLmZyYWdtZW50cztcblxuICBpZiAoZGVsdGEgPCAwIHx8IGRlbHRhID49IG9sZEZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhZGRTbGlkaW5nKG5ld0RldGFpbHMsIG9sZEZyYWdtZW50c1tkZWx0YV0uc3RhcnQpO1xufVxuZnVuY3Rpb24gYWRkU2xpZGluZyhkZXRhaWxzLCBzdGFydCkge1xuICBpZiAoc3RhcnQpIHtcbiAgICB2YXIgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG5cbiAgICBmb3IgKHZhciBpID0gZGV0YWlscy5za2lwcGVkU2VnbWVudHM7IGkgPCBmcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyYWdtZW50c1tpXS5zdGFydCArPSBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICAgIGRldGFpbHMuZnJhZ21lbnRIaW50LnN0YXJ0ICs9IHN0YXJ0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZVJlbG9hZEludGVydmFsKG5ld0RldGFpbHMsIHN0YXRzKSB7XG4gIHZhciByZWxvYWRJbnRlcnZhbCA9IDEwMDAgKiBuZXdEZXRhaWxzLmxldmVsVGFyZ2V0RHVyYXRpb247XG4gIHZhciByZWxvYWRJbnRlcnZhbEFmdGVyTWlzcyA9IHJlbG9hZEludGVydmFsIC8gMjtcbiAgdmFyIHRpbWVTaW5jZUxhc3RNb2RpZmllZCA9IG5ld0RldGFpbHMuYWdlO1xuICB2YXIgdXNlTGFzdE1vZGlmaWVkID0gdGltZVNpbmNlTGFzdE1vZGlmaWVkID4gMCAmJiB0aW1lU2luY2VMYXN0TW9kaWZpZWQgPCByZWxvYWRJbnRlcnZhbCAqIDM7XG4gIHZhciByb3VuZFRyaXAgPSBzdGF0cy5sb2FkaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQ7XG4gIHZhciBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGU7XG4gIHZhciBhdmFpbGFiaWxpdHlEZWxheSA9IG5ld0RldGFpbHMuYXZhaWxhYmlsaXR5RGVsYXk7IC8vIGxldCBlc3RpbWF0ZSA9ICdhdmVyYWdlJztcblxuICBpZiAobmV3RGV0YWlscy51cGRhdGVkID09PSBmYWxzZSkge1xuICAgIGlmICh1c2VMYXN0TW9kaWZpZWQpIHtcbiAgICAgIC8vIGVzdGltYXRlID0gJ21pc3Mgcm91bmQgdHJpcCc7XG4gICAgICAvLyBXZSBzaG91bGQgaGF2ZSBoYWQgYSBoaXQgc28gdHJ5IGFnYWluIGluIHRoZSB0aW1lIGl0IHRha2VzIHRvIGdldCBhIHJlc3BvbnNlLFxuICAgICAgLy8gYnV0IG5vIGxlc3MgdGhhbiAxLzMgc2Vjb25kLlxuICAgICAgdmFyIG1pblJldHJ5ID0gMzMzICogbmV3RGV0YWlscy5taXNzZXM7XG4gICAgICBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgPSBNYXRoLm1heChNYXRoLm1pbihyZWxvYWRJbnRlcnZhbEFmdGVyTWlzcywgcm91bmRUcmlwICogMiksIG1pblJldHJ5KTtcbiAgICAgIG5ld0RldGFpbHMuYXZhaWxhYmlsaXR5RGVsYXkgPSAobmV3RGV0YWlscy5hdmFpbGFiaWxpdHlEZWxheSB8fCAwKSArIGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXN0aW1hdGUgPSAnbWlzcyBoYWxmIGF2ZXJhZ2UnO1xuICAgICAgLy8gZm9sbG93IEhMUyBTcGVjLCBJZiB0aGUgY2xpZW50IHJlbG9hZHMgYSBQbGF5bGlzdCBmaWxlIGFuZCBmaW5kcyB0aGF0IGl0IGhhcyBub3RcbiAgICAgIC8vIGNoYW5nZWQgdGhlbiBpdCBNVVNUIHdhaXQgZm9yIGEgcGVyaW9kIG9mIG9uZS1oYWxmIHRoZSB0YXJnZXRcbiAgICAgIC8vIGR1cmF0aW9uIGJlZm9yZSByZXRyeWluZy5cbiAgICAgIGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSA9IHJlbG9hZEludGVydmFsQWZ0ZXJNaXNzO1xuICAgIH1cbiAgfSBlbHNlIGlmICh1c2VMYXN0TW9kaWZpZWQpIHtcbiAgICAvLyBlc3RpbWF0ZSA9ICduZXh0IG1vZGlmaWVkIGRhdGUnO1xuICAgIC8vIEdldCB0aGUgY2xvc2VzdCB3ZSd2ZSBiZWVuIHRvIHRpbWVTaW5jZUxhc3RNb2RpZmllZCBvbiB1cGRhdGVcbiAgICBhdmFpbGFiaWxpdHlEZWxheSA9IE1hdGgubWluKGF2YWlsYWJpbGl0eURlbGF5IHx8IHJlbG9hZEludGVydmFsIC8gMiwgdGltZVNpbmNlTGFzdE1vZGlmaWVkKTtcbiAgICBuZXdEZXRhaWxzLmF2YWlsYWJpbGl0eURlbGF5ID0gYXZhaWxhYmlsaXR5RGVsYXk7XG4gICAgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlID0gYXZhaWxhYmlsaXR5RGVsYXkgKyByZWxvYWRJbnRlcnZhbCAtIHRpbWVTaW5jZUxhc3RNb2RpZmllZDtcbiAgfSBlbHNlIHtcbiAgICBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgPSByZWxvYWRJbnRlcnZhbCAtIHJvdW5kVHJpcDtcbiAgfSAvLyBjb25zb2xlLmxvZyhgW2NvbXB1dGVSZWxvYWRJbnRlcnZhbF0gbGl2ZSByZWxvYWQgJHtuZXdEZXRhaWxzLnVwZGF0ZWQgPyAnUkVGUkVTSEVEJyA6ICdNSVNTRUQnfWAsXG4gIC8vICAgJ1xcbiAgbWV0aG9kJywgZXN0aW1hdGUsXG4gIC8vICAgJ1xcbiAgZXN0aW1hdGVkIHRpbWUgdW50aWwgdXBkYXRlID0+JywgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlLFxuICAvLyAgICdcXG4gIGF2ZXJhZ2UgdGFyZ2V0IGR1cmF0aW9uJywgcmVsb2FkSW50ZXJ2YWwsXG4gIC8vICAgJ1xcbiAgdGltZSBzaW5jZSBtb2RpZmllZCcsIHRpbWVTaW5jZUxhc3RNb2RpZmllZCxcbiAgLy8gICAnXFxuICB0aW1lIHJvdW5kIHRyaXAnLCByb3VuZFRyaXAsXG4gIC8vICAgJ1xcbiAgYXZhaWxhYmlsaXR5IGRlbGF5JywgYXZhaWxhYmlsaXR5RGVsYXkpO1xuXG5cbiAgcmV0dXJuIE1hdGgucm91bmQoZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlKTtcbn1cbmZ1bmN0aW9uIGdldEZyYWdtZW50V2l0aFNOKGxldmVsLCBzbiwgZnJhZ0N1cnJlbnQpIHtcbiAgaWYgKCFsZXZlbCB8fCAhbGV2ZWwuZGV0YWlscykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gIHZhciBmcmFnbWVudCA9IGxldmVsRGV0YWlscy5mcmFnbWVudHNbc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTl07XG5cbiAgaWYgKGZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG5cbiAgZnJhZ21lbnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRIaW50O1xuXG4gIGlmIChmcmFnbWVudCAmJiBmcmFnbWVudC5zbiA9PT0gc24pIHtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cblxuICBpZiAoc24gPCBsZXZlbERldGFpbHMuc3RhcnRTTiAmJiBmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudC5zbiA9PT0gc24pIHtcbiAgICByZXR1cm4gZnJhZ0N1cnJlbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFBhcnRXaXRoKGxldmVsLCBzbiwgcGFydEluZGV4KSB7XG4gIGlmICghbGV2ZWwgfHwgIWxldmVsLmRldGFpbHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwYXJ0TGlzdCA9IGxldmVsLmRldGFpbHMucGFydExpc3Q7XG5cbiAgaWYgKHBhcnRMaXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IHBhcnRMaXN0Lmxlbmd0aDsgaS0tOykge1xuICAgICAgdmFyIHBhcnQgPSBwYXJ0TGlzdFtpXTtcblxuICAgICAgaWYgKHBhcnQuaW5kZXggPT09IHBhcnRJbmRleCAmJiBwYXJ0LmZyYWdtZW50LnNuID09PSBzbikge1xuICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9zdHJlYW0tY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTdHJlYW1Db250cm9sbGVyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLXN0cmVhbS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9iYXNlLXN0cmVhbS1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pc19zdXBwb3J0ZWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2lzLXN1cHBvcnRlZCAqLyBcIi4vc3JjL2lzLXN1cHBvcnRlZC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2J1ZmZlci1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZyYWdtZW50LXRyYWNrZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LXRyYWNrZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvbG9hZGVyICovIFwiLi9zcmMvdHlwZXMvbG9hZGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvYWRlci9mcmFnbWVudCAqLyBcIi4vc3JjL2xvYWRlci9mcmFnbWVudC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfdHJhbnNtdXhlcl9pbnRlcmZhY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L3RyYW5zbXV4ZXItaW50ZXJmYWNlICovIFwiLi9zcmMvZGVtdXgvdHJhbnNtdXhlci1pbnRlcmZhY2UudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL3RyYW5zbXV4ZXIgKi8gXCIuL3NyYy90eXBlcy90cmFuc211eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nYXBfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2FwLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2dhcC1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcblxuXG5cblxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgVElDS19JTlRFUlZBTCA9IDEwMDsgLy8gaG93IG9mdGVuIHRvIHRpY2sgaW4gbXNcblxudmFyIFN0cmVhbUNvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlU3RyZWFtQ29udHJvbGxlcikge1xuICBfaW5oZXJpdHNMb29zZShTdHJlYW1Db250cm9sbGVyLCBfQmFzZVN0cmVhbUNvbnRyb2xsZXIpO1xuXG4gIGZ1bmN0aW9uIFN0cmVhbUNvbnRyb2xsZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlU3RyZWFtQ29udHJvbGxlci5jYWxsKHRoaXMsIGhscywgZnJhZ21lbnRUcmFja2VyLCAnW3N0cmVhbS1jb250cm9sbGVyXScpIHx8IHRoaXM7XG4gICAgX3RoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcbiAgICBfdGhpcy5nYXBDb250cm9sbGVyID0gbnVsbDtcbiAgICBfdGhpcy5sZXZlbCA9IC0xO1xuICAgIF90aGlzLl9mb3JjZVN0YXJ0TG9hZCA9IGZhbHNlO1xuICAgIF90aGlzLmFsdEF1ZGlvID0gZmFsc2U7XG4gICAgX3RoaXMuYXVkaW9Pbmx5ID0gZmFsc2U7XG4gICAgX3RoaXMuZnJhZ1BsYXlpbmcgPSBudWxsO1xuICAgIF90aGlzLm9udnBsYXlpbmcgPSBudWxsO1xuICAgIF90aGlzLm9udnNlZWtlZCA9IG51bGw7XG4gICAgX3RoaXMuZnJhZ0xhc3RLYnBzID0gMDtcbiAgICBfdGhpcy5zdGFsbGVkID0gZmFsc2U7XG4gICAgX3RoaXMuY291bGRCYWNrdHJhY2sgPSBmYWxzZTtcbiAgICBfdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgX3RoaXMuYXVkaW9Db2RlY1N3aXRjaCA9IGZhbHNlO1xuICAgIF90aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcblxuICAgIF90aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5fcmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHRoaXMub25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5fdW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCwgdGhpcy5vbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfU1dJVENIRUQsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5vbkhhbmRsZXJEZXN0cm95aW5nID0gZnVuY3Rpb24gb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cbiAgICB0aGlzLm9uTWVkaWFEZXRhY2hpbmcoKTtcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAodGhpcy5sZXZlbHMpIHtcbiAgICAgIHZhciBsYXN0Q3VycmVudFRpbWUgPSB0aGlzLmxhc3RDdXJyZW50VGltZSxcbiAgICAgICAgICBobHMgPSB0aGlzLmhscztcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuXG4gICAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgICAgIC8vIGRldGVybWluZSBsb2FkIGxldmVsXG4gICAgICAgIHZhciBzdGFydExldmVsID0gaGxzLnN0YXJ0TGV2ZWw7XG5cbiAgICAgICAgaWYgKHN0YXJ0TGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgaWYgKGhscy5jb25maWcudGVzdEJhbmR3aWR0aCkge1xuICAgICAgICAgICAgLy8gLTEgOiBndWVzcyBzdGFydCBMZXZlbCBieSBkb2luZyBhIGJpdHJhdGUgdGVzdCBieSBsb2FkaW5nIGZpcnN0IGZyYWdtZW50IG9mIGxvd2VzdCBxdWFsaXR5IGxldmVsXG4gICAgICAgICAgICBzdGFydExldmVsID0gMDtcbiAgICAgICAgICAgIHRoaXMuYml0cmF0ZVRlc3QgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydExldmVsID0gaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHNldCBuZXcgbGV2ZWwgdG8gcGxheWxpc3QgbG9hZGVyIDogdGhpcyB3aWxsIHRyaWdnZXIgc3RhcnQgbGV2ZWwgbG9hZFxuICAgICAgICAvLyBobHMubmV4dExvYWRMZXZlbCByZW1haW5zIHVudGlsIGl0IGlzIHNldCB0byBhIG5ldyB2YWx1ZSBvciB1bnRpbCBhIG5ldyBmcmFnIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWRcblxuXG4gICAgICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IHN0YXJ0TGV2ZWw7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgIH0gLy8gaWYgc3RhcnRQb3NpdGlvbiB1bmRlZmluZWQgYnV0IGxhc3RDdXJyZW50VGltZSBzZXQsIHNldCBzdGFydFBvc2l0aW9uIHRvIGxhc3QgY3VycmVudFRpbWVcblxuXG4gICAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICB0aGlzLmxvZyhcIk92ZXJyaWRlIHN0YXJ0UG9zaXRpb24gd2l0aCBsYXN0Q3VycmVudFRpbWUgQFwiICsgbGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoMykpO1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gbGFzdEN1cnJlbnRUaW1lO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZm9yY2VTdGFydExvYWQgPSB0cnVlO1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5TVE9QUEVEO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc3RvcExvYWQgPSBmdW5jdGlvbiBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLl9mb3JjZVN0YXJ0TG9hZCA9IGZhbHNlO1xuXG4gICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5zdG9wTG9hZC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5kb1RpY2sgPSBmdW5jdGlvbiBkb1RpY2soKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFOlxuICAgICAgICB0aGlzLmRvVGlja0lkbGUoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfTEVWRUw6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2xldmVscyRsZXZlbDtcblxuICAgICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsO1xuICAgICAgICAgIHZhciBkZXRhaWxzID0gbGV2ZWxzID09PSBudWxsIHx8IGxldmVscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9sZXZlbHMkbGV2ZWwgPSBsZXZlbHNbbGV2ZWxdKSA9PT0gbnVsbCB8fCBfbGV2ZWxzJGxldmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGV2ZWxzJGxldmVsLmRldGFpbHM7XG5cbiAgICAgICAgICBpZiAoZGV0YWlscyAmJiAoIWRldGFpbHMubGl2ZSB8fCB0aGlzLmxldmVsTGFzdExvYWRlZCA9PT0gdGhpcy5sZXZlbCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndhaXRGb3JDZG5UdW5lSW4oZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uSURMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF90aGlzJG1lZGlhO1xuXG4gICAgICAgICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgdmFyIHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlOyAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuXG4gICAgICAgICAgaWYgKCFyZXRyeURhdGUgfHwgbm93ID49IHJldHJ5RGF0ZSB8fCAoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSAhPT0gbnVsbCAmJiBfdGhpcyRtZWRpYSAhPT0gdm9pZCAwICYmIF90aGlzJG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdyZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZScpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfSAvLyBjaGVjayBidWZmZXJcbiAgICAvLyBjaGVjay91cGRhdGUgY3VycmVudCBmcmFnbWVudFxuXG5cbiAgICB0aGlzLm9uVGlja0VuZCgpO1xuICB9O1xuXG4gIF9wcm90by5vblRpY2tFbmQgPSBmdW5jdGlvbiBvblRpY2tFbmQoKSB7XG4gICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vblRpY2tFbmQuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuY2hlY2tCdWZmZXIoKTtcbiAgICB0aGlzLmNoZWNrRnJhZ21lbnRDaGFuZ2VkKCk7XG4gIH07XG5cbiAgX3Byb3RvLmRvVGlja0lkbGUgPSBmdW5jdGlvbiBkb1RpY2tJZGxlKCkge1xuICAgIHZhciBfZnJhZyRkZWNyeXB0ZGF0YSwgX2ZyYWckZGVjcnlwdGRhdGEyO1xuXG4gICAgdmFyIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBsZXZlbExhc3RMb2FkZWQgPSB0aGlzLmxldmVsTGFzdExvYWRlZCxcbiAgICAgICAgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICB2YXIgY29uZmlnID0gaGxzLmNvbmZpZyxcbiAgICAgICAgbGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbDsgLy8gaWYgc3RhcnQgbGV2ZWwgbm90IHBhcnNlZCB5ZXQgT1JcbiAgICAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggbm90IGVuYWJsZWRcbiAgICAvLyBleGl0IGxvb3AsIGFzIHdlIGVpdGhlciBuZWVkIG1vcmUgaW5mbyAobGV2ZWwgbm90IHBhcnNlZCkgb3Igd2UgbmVlZCBtZWRpYSB0byBiZSBhdHRhY2hlZCB0byBsb2FkIG5ldyBmcmFnbWVudFxuXG4gICAgaWYgKGxldmVsTGFzdExvYWRlZCA9PT0gbnVsbCB8fCAhbWVkaWEgJiYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB0aGUgXCJtYWluXCIgbGV2ZWwgaXMgYXVkaW8tb25seSBidXQgd2UgYXJlIGxvYWRpbmcgYW4gYWx0ZXJuYXRlIHRyYWNrIGluIHRoZSBzYW1lIGdyb3VwLCBkbyBub3QgbG9hZCBhbnl0aGluZ1xuXG5cbiAgICBpZiAodGhpcy5hbHRBdWRpbyAmJiB0aGlzLmF1ZGlvT25seSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghbGV2ZWxzIHx8ICFsZXZlbHNbbGV2ZWxdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxldmVsSW5mbyA9IGxldmVsc1tsZXZlbF07IC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudFxuICAgIC8vIHNldCBuZXh0IGxvYWQgbGV2ZWwgOiB0aGlzIHdpbGwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWQgaWYgbmVlZGVkXG5cbiAgICB0aGlzLmxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgICB2YXIgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7IC8vIGlmIGxldmVsIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgbGV2ZWwgcmV0cmlldmFsXG4gICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCwgZW5zdXJlIHRoYXQgbmV3IHBsYXlsaXN0IGhhcyBiZWVuIHJlZnJlc2hlZCB0byBhdm9pZCBsb2FkaW5nL3RyeSB0byBsb2FkXG4gICAgLy8gYSB1c2VsZXNzIGFuZCBvdXRkYXRlZCBmcmFnbWVudCAodGhhdCBtaWdodCBldmVuIGludHJvZHVjZSBsb2FkIGVycm9yIGlmIGl0IGlzIGFscmVhZHkgb3V0IG9mIHRoZSBsaXZlIHBsYXlsaXN0KVxuXG4gICAgaWYgKCFsZXZlbERldGFpbHMgfHwgdGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfTEVWRUwgfHwgbGV2ZWxEZXRhaWxzLmxpdmUgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IGxldmVsKSB7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfTEVWRUw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlckluZm8gPSB0aGlzLmdldE1haW5Gd2RCdWZmZXJJbmZvKCk7XG5cbiAgICBpZiAoYnVmZmVySW5mbyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBidWZmZXJMZW4gPSBidWZmZXJJbmZvLmxlbjsgLy8gY29tcHV0ZSBtYXggQnVmZmVyIExlbmd0aCB0aGF0IHdlIGNvdWxkIGdldCBmcm9tIHRoaXMgbG9hZCBsZXZlbCwgYmFzZWQgb24gbGV2ZWwgYml0cmF0ZS4gZG9uJ3QgYnVmZmVyIG1vcmUgdGhhbiA2MCBNQiBhbmQgbW9yZSB0aGFuIDMwc1xuXG4gICAgdmFyIG1heEJ1ZkxlbiA9IHRoaXMuZ2V0TWF4QnVmZmVyTGVuZ3RoKGxldmVsSW5mby5tYXhCaXRyYXRlKTsgLy8gU3RheSBpZGxlIGlmIHdlIGFyZSBzdGlsbCB3aXRoIGJ1ZmZlciBtYXJnaW5zXG5cbiAgICBpZiAoYnVmZmVyTGVuID49IG1heEJ1Zkxlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpKSB7XG4gICAgICB2YXIgZGF0YSA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5hbHRBdWRpbykge1xuICAgICAgICBkYXRhLnR5cGUgPSAndmlkZW8nO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRU9TLCBkYXRhKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uRU5ERUQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgJiYgdGhpcy5iYWNrdHJhY2tGcmFnbWVudC5zdGFydCA+IGJ1ZmZlckluZm8uZW5kKSB7XG4gICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0QnVmZmVyVGltZSA9IHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPyB0aGlzLmJhY2t0cmFja0ZyYWdtZW50LnN0YXJ0IDogYnVmZmVySW5mby5lbmQ7XG4gICAgdmFyIGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudCh0YXJnZXRCdWZmZXJUaW1lLCBsZXZlbERldGFpbHMpOyAvLyBBdm9pZCBiYWNrdHJhY2tpbmcgYnkgbG9hZGluZyBhbiBlYXJsaWVyIHNlZ21lbnQgaW4gc3RyZWFtcyB3aXRoIHNlZ21lbnRzIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGggYSBrZXkgZnJhbWUgKGZsYWdnZWQgYnkgYGNvdWxkQmFja3RyYWNrYClcblxuICAgIGlmICh0aGlzLmNvdWxkQmFja3RyYWNrICYmICF0aGlzLmZyYWdQcmV2aW91cyAmJiBmcmFnICYmIGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcgJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZykgIT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJGcmFnbWVudFN0YXRlXCJdLk9LKSB7XG4gICAgICB2YXIgX3RoaXMkYmFja3RyYWNrRnJhZ21lO1xuXG4gICAgICB2YXIgYmFja3RyYWNrU24gPSAoKF90aGlzJGJhY2t0cmFja0ZyYWdtZSA9IHRoaXMuYmFja3RyYWNrRnJhZ21lbnQpICE9IG51bGwgPyBfdGhpcyRiYWNrdHJhY2tGcmFnbWUgOiBmcmFnKS5zbjtcbiAgICAgIHZhciBmcmFnSWR4ID0gYmFja3RyYWNrU24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcbiAgICAgIHZhciBiYWNrdHJhY2tGcmFnID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1tmcmFnSWR4IC0gMV07XG5cbiAgICAgIGlmIChiYWNrdHJhY2tGcmFnICYmIGZyYWcuY2MgPT09IGJhY2t0cmFja0ZyYWcuY2MpIHtcbiAgICAgICAgZnJhZyA9IGJhY2t0cmFja0ZyYWc7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGJhY2t0cmFja0ZyYWcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5iYWNrdHJhY2tGcmFnbWVudCAmJiBidWZmZXJJbmZvLmxlbikge1xuICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgfSAvLyBBdm9pZCBsb29wIGxvYWRpbmcgYnkgdXNpbmcgbmV4dExvYWRQb3NpdGlvbiBzZXQgZm9yIGJhY2t0cmFja2luZ1xuXG5cbiAgICBpZiAoZnJhZyAmJiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKSA9PT0gX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkZyYWdtZW50U3RhdGVcIl0uT0sgJiYgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID4gdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgICAgLy8gQ2xlYW51cCB0aGUgZnJhZ21lbnQgdHJhY2tlciBiZWZvcmUgdHJ5aW5nIHRvIGZpbmQgdGhlIG5leHQgdW5idWZmZXJlZCBmcmFnbWVudFxuICAgICAgdmFyIHR5cGUgPSB0aGlzLmF1ZGlvT25seSAmJiAhdGhpcy5hbHRBdWRpbyA/IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJTyA6IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5WSURFTztcbiAgICAgIHRoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKG1lZGlhLCB0eXBlLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5NQUlOKTtcbiAgICAgIGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudCh0aGlzLm5leHRMb2FkUG9zaXRpb24sIGxldmVsRGV0YWlscyk7XG4gICAgfVxuXG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGZyYWcuaW5pdFNlZ21lbnQgJiYgIWZyYWcuaW5pdFNlZ21lbnQuZGF0YSAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgZnJhZyA9IGZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgfSAvLyBXZSB3YW50IHRvIGxvYWQgdGhlIGtleSBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYW4gaWRlbnRpdHkga2V5LCBiZWNhdXNlIHdlIHdpbGwgZGVjcnlwdFxuICAgIC8vIHRoaXMgY29udGVudCB1c2luZyB0aGUga2V5IHdlIGZldGNoLiBPdGhlciBrZXlzIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgRFJNIENETSB2aWEgRU1FLlxuXG5cbiAgICBpZiAoKChfZnJhZyRkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGEpID09PSBudWxsIHx8IF9mcmFnJGRlY3J5cHRkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZnJhZyRkZWNyeXB0ZGF0YS5rZXlGb3JtYXQpID09PSAnaWRlbnRpdHknICYmICEoKF9mcmFnJGRlY3J5cHRkYXRhMiA9IGZyYWcuZGVjcnlwdGRhdGEpICE9PSBudWxsICYmIF9mcmFnJGRlY3J5cHRkYXRhMiAhPT0gdm9pZCAwICYmIF9mcmFnJGRlY3J5cHRkYXRhMi5rZXkpKSB7XG4gICAgICB0aGlzLmxvYWRLZXkoZnJhZywgbGV2ZWxEZXRhaWxzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWxEZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRGcmFnbWVudCA9IGZ1bmN0aW9uIGxvYWRGcmFnbWVudChmcmFnLCBsZXZlbERldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICB2YXIgX3RoaXMkbWVkaWEyO1xuXG4gICAgLy8gQ2hlY2sgaWYgZnJhZ21lbnQgaXMgbm90IGxvYWRlZFxuICAgIHZhciBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcblxuICAgIGlmIChmcmFnU3RhdGUgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJGcmFnbWVudFN0YXRlXCJdLk5PVF9MT0FERUQgfHwgZnJhZ1N0YXRlID09PSBfZnJhZ21lbnRfdHJhY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRnJhZ21lbnRTdGF0ZVwiXS5QQVJUSUFMKSB7XG4gICAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICB0aGlzLl9sb2FkSW5pdFNlZ21lbnQoZnJhZyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgZnJhZy5iaXRyYXRlVGVzdCA9IHRydWU7XG4gICAgICAgIHRoaXMubG9nKFwiRnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgb2YgbGV2ZWwgXCIgKyBmcmFnLmxldmVsICsgXCIgaXMgYmVpbmcgZG93bmxvYWRlZCB0byB0ZXN0IGJpdHJhdGUgYW5kIHdpbGwgbm90IGJlIGJ1ZmZlcmVkXCIpO1xuXG4gICAgICAgIHRoaXMuX2xvYWRCaXRyYXRlVGVzdEZyYWcoZnJhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG5cbiAgICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5sb2FkRnJhZ21lbnQuY2FsbCh0aGlzLCBmcmFnLCBsZXZlbERldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZnJhZ1N0YXRlID09PSBfZnJhZ21lbnRfdHJhY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRnJhZ21lbnRTdGF0ZVwiXS5BUFBFTkRJTkcpIHtcbiAgICAgIC8vIExvd2VyIHRoZSBidWZmZXIgc2l6ZSBhbmQgdHJ5IGFnYWluXG4gICAgICBpZiAodGhpcy5yZWR1Y2VNYXhCdWZmZXJMZW5ndGgoZnJhZy5kdXJhdGlvbikpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoKF90aGlzJG1lZGlhMiA9IHRoaXMubWVkaWEpID09PSBudWxsIHx8IF90aGlzJG1lZGlhMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbWVkaWEyLmJ1ZmZlcmVkLmxlbmd0aCkgPT09IDApIHtcbiAgICAgIC8vIFN0b3AgZ2FwIGZvciBiYWQgdHJhY2tlciAvIGJ1ZmZlciBmbHVzaCBiZWhhdmlvclxuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXRBcHBlbmRlZEZyYWcgPSBmdW5jdGlvbiBnZXRBcHBlbmRlZEZyYWcocG9zaXRpb24pIHtcbiAgICB2YXIgZnJhZ09yUGFydCA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEFwcGVuZGVkRnJhZyhwb3NpdGlvbiwgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uTUFJTik7XG5cbiAgICBpZiAoZnJhZ09yUGFydCAmJiAnZnJhZ21lbnQnIGluIGZyYWdPclBhcnQpIHtcbiAgICAgIHJldHVybiBmcmFnT3JQYXJ0LmZyYWdtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmcmFnT3JQYXJ0O1xuICB9O1xuXG4gIF9wcm90by5nZXRCdWZmZXJlZEZyYWcgPSBmdW5jdGlvbiBnZXRCdWZmZXJlZEZyYWcocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QnVmZmVyZWRGcmFnKHBvc2l0aW9uLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5NQUlOKTtcbiAgfTtcblxuICBfcHJvdG8uZm9sbG93aW5nQnVmZmVyZWRGcmFnID0gZnVuY3Rpb24gZm9sbG93aW5nQnVmZmVyZWRGcmFnKGZyYWcpIHtcbiAgICBpZiAoZnJhZykge1xuICAgICAgLy8gdHJ5IHRvIGdldCByYW5nZSBvZiBuZXh0IGZyYWdtZW50ICg1MDBtcyBhZnRlciB0aGlzIHJhbmdlKVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyZWRGcmFnKGZyYWcuZW5kICsgMC41KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKlxuICAgIG9uIGltbWVkaWF0ZSBsZXZlbCBzd2l0Y2ggOlxuICAgICAtIHBhdXNlIHBsYXliYWNrIGlmIHBsYXlpbmdcbiAgICAgLSBjYW5jZWwgYW55IHBlbmRpbmcgbG9hZCByZXF1ZXN0XG4gICAgIC0gYW5kIHRyaWdnZXIgYSBidWZmZXIgZmx1c2hcbiAgKi9cbiAgO1xuXG4gIF9wcm90by5pbW1lZGlhdGVMZXZlbFN3aXRjaCA9IGZ1bmN0aW9uIGltbWVkaWF0ZUxldmVsU3dpdGNoKCkge1xuICAgIHRoaXMuYWJvcnRDdXJyZW50RnJhZygpO1xuICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gIH1cbiAgLyoqXG4gICAqIHRyeSB0byBzd2l0Y2ggQVNBUCB3aXRob3V0IGJyZWFraW5nIHZpZGVvIHBsYXliYWNrOlxuICAgKiBpbiBvcmRlciB0byBlbnN1cmUgc21vb3RoIGJ1dCBxdWljayBsZXZlbCBzd2l0Y2hpbmcsXG4gICAqIHdlIG5lZWQgdG8gZmluZCB0aGUgbmV4dCBmbHVzaGFibGUgYnVmZmVyIHJhbmdlXG4gICAqIHdlIHNob3VsZCB0YWtlIGludG8gYWNjb3VudCBuZXcgc2VnbWVudCBmZXRjaCB0aW1lXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm5leHRMZXZlbFN3aXRjaCA9IGZ1bmN0aW9uIG5leHRMZXZlbFN3aXRjaCgpIHtcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTsgLy8gZW5zdXJlIHRoYXQgbWVkaWEgaXMgZGVmaW5lZCBhbmQgdGhhdCBtZXRhZGF0YSBhcmUgYXZhaWxhYmxlICh0byByZXRyaWV2ZSBjdXJyZW50VGltZSlcblxuICAgIGlmIChtZWRpYSAhPT0gbnVsbCAmJiBtZWRpYSAhPT0gdm9pZCAwICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgIHZhciBmZXRjaGRlbGF5O1xuICAgICAgdmFyIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcblxuICAgICAgaWYgKGZyYWdQbGF5aW5nQ3VycmVudCAmJiBmcmFnUGxheWluZ0N1cnJlbnQuc3RhcnQgPiAxKSB7XG4gICAgICAgIC8vIGZsdXNoIGJ1ZmZlciBwcmVjZWRpbmcgY3VycmVudCBmcmFnbWVudCAoZmx1c2ggdW50aWwgY3VycmVudCBmcmFnbWVudCBzdGFydCBvZmZzZXQpXG4gICAgICAgIC8vIG1pbnVzIDFzIHRvIGF2b2lkIHZpZGVvIGZyZWV6aW5nLCB0aGF0IGNvdWxkIGhhcHBlbiBpZiB3ZSBmbHVzaCBrZXlmcmFtZSBvZiBjdXJyZW50IHZpZGVvIC4uLlxuICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBmcmFnUGxheWluZ0N1cnJlbnQuc3RhcnQgLSAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtZWRpYS5wYXVzZWQgJiYgbGV2ZWxzKSB7XG4gICAgICAgIC8vIGFkZCBhIHNhZmV0eSBkZWxheSBvZiAxc1xuICAgICAgICB2YXIgbmV4dExldmVsSWQgPSB0aGlzLmhscy5uZXh0TG9hZExldmVsO1xuICAgICAgICB2YXIgbmV4dExldmVsID0gbGV2ZWxzW25leHRMZXZlbElkXTtcbiAgICAgICAgdmFyIGZyYWdMYXN0S2JwcyA9IHRoaXMuZnJhZ0xhc3RLYnBzO1xuXG4gICAgICAgIGlmIChmcmFnTGFzdEticHMgJiYgdGhpcy5mcmFnQ3VycmVudCkge1xuICAgICAgICAgIGZldGNoZGVsYXkgPSB0aGlzLmZyYWdDdXJyZW50LmR1cmF0aW9uICogbmV4dExldmVsLm1heEJpdHJhdGUgLyAoMTAwMCAqIGZyYWdMYXN0S2JwcykgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgIH0gLy8gdGhpcy5sb2coJ2ZldGNoZGVsYXk6JytmZXRjaGRlbGF5KTtcbiAgICAgIC8vIGZpbmQgYnVmZmVyIHJhbmdlIHRoYXQgd2lsbCBiZSByZWFjaGVkIG9uY2UgbmV3IGZyYWdtZW50IHdpbGwgYmUgZmV0Y2hlZFxuXG5cbiAgICAgIHZhciBidWZmZXJlZEZyYWcgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSArIGZldGNoZGVsYXkpO1xuXG4gICAgICBpZiAoYnVmZmVyZWRGcmFnKSB7XG4gICAgICAgIC8vIHdlIGNhbiBmbHVzaCBidWZmZXIgcmFuZ2UgZm9sbG93aW5nIHRoaXMgb25lIHdpdGhvdXQgc3RhbGxpbmcgcGxheWJhY2tcbiAgICAgICAgdmFyIG5leHRCdWZmZXJlZEZyYWcgPSB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhidWZmZXJlZEZyYWcpO1xuXG4gICAgICAgIGlmIChuZXh0QnVmZmVyZWRGcmFnKSB7XG4gICAgICAgICAgLy8gaWYgd2UgYXJlIGhlcmUsIHdlIGNhbiBhbHNvIGNhbmNlbCBhbnkgbG9hZGluZy9kZW11eGluZyBpbiBwcm9ncmVzcywgYXMgdGhleSBhcmUgdXNlbGVzc1xuICAgICAgICAgIHRoaXMuYWJvcnRDdXJyZW50RnJhZygpOyAvLyBzdGFydCBmbHVzaCBwb3NpdGlvbiBpcyBpbiBuZXh0IGJ1ZmZlcmVkIGZyYWcuIExlYXZlIHNvbWUgcGFkZGluZyBmb3Igbm9uLWluZGVwZW5kZW50IHNlZ21lbnRzIGFuZCBzbW9vdGhlciBwbGF5YmFjay5cblxuICAgICAgICAgIHZhciBtYXhTdGFydCA9IG5leHRCdWZmZXJlZEZyYWcubWF4U3RhcnRQVFMgPyBuZXh0QnVmZmVyZWRGcmFnLm1heFN0YXJ0UFRTIDogbmV4dEJ1ZmZlcmVkRnJhZy5zdGFydDtcbiAgICAgICAgICB2YXIgZnJhZ0R1cmF0aW9uID0gbmV4dEJ1ZmZlcmVkRnJhZy5kdXJhdGlvbjtcbiAgICAgICAgICB2YXIgc3RhcnRQdHMgPSBNYXRoLm1heChidWZmZXJlZEZyYWcuZW5kLCBtYXhTdGFydCArIE1hdGgubWluKE1hdGgubWF4KGZyYWdEdXJhdGlvbiAtIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWdEdXJhdGlvbiAqIDAuNSksIGZyYWdEdXJhdGlvbiAqIDAuNzUpKTtcbiAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcihzdGFydFB0cywgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYWJvcnRDdXJyZW50RnJhZyA9IGZ1bmN0aW9uIGFib3J0Q3VycmVudEZyYWcoKSB7XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcblxuICAgIGlmIChmcmFnQ3VycmVudCAhPT0gbnVsbCAmJiBmcmFnQ3VycmVudCAhPT0gdm9pZCAwICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5LRVlfTE9BRElORzpcbiAgICAgIGNhc2UgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLkZSQUdfTE9BRElORzpcbiAgICAgIGNhc2UgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgY2FzZSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uUEFSU0lORzpcbiAgICAgIGNhc2UgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLlBBUlNFRDpcbiAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICB9O1xuXG4gIF9wcm90by5mbHVzaE1haW5CdWZmZXIgPSBmdW5jdGlvbiBmbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuZmx1c2hNYWluQnVmZmVyLmNhbGwodGhpcywgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdGhpcy5hbHRBdWRpbyA/ICd2aWRlbycgOiBudWxsKTtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhQXR0YWNoZWQuY2FsbCh0aGlzLCBldmVudCwgZGF0YSk7XG5cbiAgICB2YXIgbWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMub252cGxheWluZyA9IHRoaXMub25NZWRpYVBsYXlpbmcuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9udnNlZWtlZCA9IHRoaXMub25NZWRpYVNlZWtlZC5iaW5kKHRoaXMpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCB0aGlzLm9udnBsYXlpbmcpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtlZCcsIHRoaXMub252c2Vla2VkKTtcbiAgICB0aGlzLmdhcENvbnRyb2xsZXIgPSBuZXcgX2dhcF9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1wiZGVmYXVsdFwiXSh0aGlzLmNvbmZpZywgbWVkaWEsIHRoaXMuZnJhZ21lbnRUcmFja2VyLCB0aGlzLmhscyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG5cbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCB0aGlzLm9udnBsYXlpbmcpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgICAgdGhpcy5vbnZwbGF5aW5nID0gdGhpcy5vbnZzZWVrZWQgPSBudWxsO1xuICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFnUGxheWluZyA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5nYXBDb250cm9sbGVyKSB7XG4gICAgICB0aGlzLmdhcENvbnRyb2xsZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5nYXBDb250cm9sbGVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFEZXRhY2hpbmcuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYVBsYXlpbmcgPSBmdW5jdGlvbiBvbk1lZGlhUGxheWluZygpIHtcbiAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIEZSQUdfQ0hBTkdFRCB0cmlnZ2VyaW5nXG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFTZWVrZWQgPSBmdW5jdGlvbiBvbk1lZGlhU2Vla2VkKCkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IG51bGw7XG5cbiAgICBpZiAoT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShjdXJyZW50VGltZSkpIHtcbiAgICAgIHRoaXMubG9nKFwiTWVkaWEgc2Vla2VkIHRvIFwiICsgY3VycmVudFRpbWUudG9GaXhlZCgzKSk7XG4gICAgfSAvLyB0aWNrIHRvIHNwZWVkIHVwIEZSQUdfQ0hBTkdFRCB0cmlnZ2VyaW5nXG5cblxuICAgIHRoaXMudGljaygpO1xuICB9O1xuXG4gIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIC8vIHJlc2V0IGJ1ZmZlciBvbiBtYW5pZmVzdCBsb2FkaW5nXG4gICAgdGhpcy5sb2coJ1RyaWdnZXIgQlVGRkVSX1JFU0VUJyk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uQlVGRkVSX1JFU0VULCB1bmRlZmluZWQpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIHRoaXMuY291bGRCYWNrdHJhY2sgPSB0aGlzLnN0YWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5mcmFnUGxheWluZyA9IG51bGw7XG4gICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWFuaWZlc3RQYXJzZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0UGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGFhYyA9IGZhbHNlO1xuICAgIHZhciBoZWFhYyA9IGZhbHNlO1xuICAgIHZhciBjb2RlYztcbiAgICBkYXRhLmxldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgLy8gZGV0ZWN0IGlmIHdlIGhhdmUgZGlmZmVyZW50IGtpbmQgb2YgYXVkaW8gY29kZWNzIHVzZWQgYW1vbmdzdCBwbGF5bGlzdHNcbiAgICAgIGNvZGVjID0gbGV2ZWwuYXVkaW9Db2RlYztcblxuICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgIGlmIChjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTEpIHtcbiAgICAgICAgICBhYWMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgIGhlYWFjID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3aXRjaCA9IGFhYyAmJiBoZWFhYyAmJiAhT2JqZWN0KF9pc19zdXBwb3J0ZWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImNoYW5nZVR5cGVTdXBwb3J0ZWRcIl0pKCk7XG5cbiAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XG4gICAgICB0aGlzLmxvZygnQm90aCBBQUMvSEUtQUFDIGF1ZGlvIGZvdW5kIGluIGxldmVsczsgZGVjbGFyaW5nIGxldmVsIGNvZGVjIGFzIEhFLUFBQycpO1xuICAgIH1cblxuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8ub25MZXZlbExvYWRpbmcgPSBmdW5jdGlvbiBvbkxldmVsTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuICAgIGlmICghbGV2ZWxzIHx8IHRoaXMuc3RhdGUgIT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxldmVsID0gbGV2ZWxzW2RhdGEubGV2ZWxdO1xuXG4gICAgaWYgKCFsZXZlbC5kZXRhaWxzIHx8IGxldmVsLmRldGFpbHMubGl2ZSAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gZGF0YS5sZXZlbCB8fCB0aGlzLndhaXRGb3JDZG5UdW5lSW4obGV2ZWwuZGV0YWlscykpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uV0FJVElOR19MRVZFTDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uTGV2ZWxMb2FkZWQgPSBmdW5jdGlvbiBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9jdXJMZXZlbCRkZXRhaWxzO1xuXG4gICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgIHZhciBuZXdMZXZlbElkID0gZGF0YS5sZXZlbDtcbiAgICB2YXIgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB2YXIgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb247XG5cbiAgICBpZiAoIWxldmVscykge1xuICAgICAgdGhpcy53YXJuKFwiTGV2ZWxzIHdlcmUgcmVzZXQgd2hpbGUgbG9hZGluZyBsZXZlbCBcIiArIG5ld0xldmVsSWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubG9nKFwiTGV2ZWwgXCIgKyBuZXdMZXZlbElkICsgXCIgbG9hZGVkIFtcIiArIG5ld0RldGFpbHMuc3RhcnRTTiArIFwiLFwiICsgbmV3RGV0YWlscy5lbmRTTiArIFwiXSwgY2MgW1wiICsgbmV3RGV0YWlscy5zdGFydENDICsgXCIsIFwiICsgbmV3RGV0YWlscy5lbmRDQyArIFwiXSBkdXJhdGlvbjpcIiArIGR1cmF0aW9uKTtcbiAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuXG4gICAgaWYgKGZyYWdDdXJyZW50ICYmICh0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uRlJBR19MT0FESU5HIHx8IHRoaXMuc3RhdGUgPT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWSkpIHtcbiAgICAgIGlmIChmcmFnQ3VycmVudC5sZXZlbCAhPT0gZGF0YS5sZXZlbCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGN1ckxldmVsID0gbGV2ZWxzW25ld0xldmVsSWRdO1xuICAgIHZhciBzbGlkaW5nID0gMDtcblxuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgfHwgKF9jdXJMZXZlbCRkZXRhaWxzID0gY3VyTGV2ZWwuZGV0YWlscykgIT09IG51bGwgJiYgX2N1ckxldmVsJGRldGFpbHMgIT09IHZvaWQgMCAmJiBfY3VyTGV2ZWwkZGV0YWlscy5saXZlKSB7XG4gICAgICBpZiAoIW5ld0RldGFpbHMuZnJhZ21lbnRzWzBdKSB7XG4gICAgICAgIG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNsaWRpbmcgPSB0aGlzLmFsaWduUGxheWxpc3RzKG5ld0RldGFpbHMsIGN1ckxldmVsLmRldGFpbHMpO1xuICAgIH0gLy8gb3ZlcnJpZGUgbGV2ZWwgaW5mb1xuXG5cbiAgICBjdXJMZXZlbC5kZXRhaWxzID0gbmV3RGV0YWlscztcbiAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IG5ld0xldmVsSWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uTEVWRUxfVVBEQVRFRCwge1xuICAgICAgZGV0YWlsczogbmV3RGV0YWlscyxcbiAgICAgIGxldmVsOiBuZXdMZXZlbElkXG4gICAgfSk7IC8vIG9ubHkgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIGxldmVsIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfTEVWRUwpIHtcbiAgICAgIGlmICh0aGlzLndhaXRGb3JDZG5UdW5lSW4obmV3RGV0YWlscykpIHtcbiAgICAgICAgLy8gV2FpdCBmb3IgTG93LUxhdGVuY3kgQ0ROIFR1bmUtaW5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKG5ld0RldGFpbHMsIHNsaWRpbmcpO1xuICAgIH0gZWxzZSBpZiAobmV3RGV0YWlscy5saXZlKSB7XG4gICAgICB0aGlzLnN5bmNocm9uaXplVG9MaXZlRWRnZShuZXdEZXRhaWxzKTtcbiAgICB9IC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcblxuXG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG5cbiAgX3Byb3RvLl9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uIF9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhkYXRhKSB7XG4gICAgdmFyIF9mcmFnJGluaXRTZWdtZW50O1xuXG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBkYXRhLnBhcnQsXG4gICAgICAgIHBheWxvYWQgPSBkYXRhLnBheWxvYWQ7XG4gICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihcIkxldmVscyB3ZXJlIHJlc2V0IHdoaWxlIGZyYWdtZW50IGxvYWQgd2FzIGluIHByb2dyZXNzLiBGcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiB3aWxsIG5vdCBiZSBidWZmZXJlZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudExldmVsID0gbGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgIHZhciBkZXRhaWxzID0gY3VycmVudExldmVsLmRldGFpbHM7XG5cbiAgICBpZiAoIWRldGFpbHMpIHtcbiAgICAgIHRoaXMud2FybihcIkRyb3BwaW5nIGZyYWdtZW50IFwiICsgZnJhZy5zbiArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIGFmdGVyIGxldmVsIGRldGFpbHMgd2VyZSByZXNldFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdmlkZW9Db2RlYyA9IGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjOyAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcblxuICAgIHZhciBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBkZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmU7XG4gICAgdmFyIGluaXRTZWdtZW50RGF0YSA9IChfZnJhZyRpbml0U2VnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQpID09PSBudWxsIHx8IF9mcmFnJGluaXRTZWdtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZnJhZyRpbml0U2VnbWVudC5kYXRhO1xuXG4gICAgdmFyIGF1ZGlvQ29kZWMgPSB0aGlzLl9nZXRBdWRpb0NvZGVjKGN1cnJlbnRMZXZlbCk7IC8vIHRyYW5zbXV4IHRoZSBNUEVHLVRTIGRhdGEgdG8gSVNPLUJNRkYgc2VnbWVudHNcbiAgICAvLyB0aGlzLmxvZyhgVHJhbnNtdXhpbmcgJHtmcmFnLnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSxsZXZlbCAke2ZyYWcubGV2ZWx9LCBjYyAke2ZyYWcuY2N9YCk7XG5cblxuICAgIHZhciB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyIHx8IG5ldyBfZGVtdXhfdHJhbnNtdXhlcl9pbnRlcmZhY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImRlZmF1bHRcIl0odGhpcy5obHMsIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLk1BSU4sIHRoaXMuX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUuYmluZCh0aGlzKSwgdGhpcy5faGFuZGxlVHJhbnNtdXhlckZsdXNoLmJpbmQodGhpcykpO1xuICAgIHZhciBwYXJ0SW5kZXggPSBwYXJ0ID8gcGFydC5pbmRleCA6IC0xO1xuICAgIHZhciBwYXJ0aWFsID0gcGFydEluZGV4ICE9PSAtMTtcbiAgICB2YXIgY2h1bmtNZXRhID0gbmV3IF90eXBlc190cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJDaHVua01ldGFkYXRhXCJdKGZyYWcubGV2ZWwsIGZyYWcuc24sIGZyYWcuc3RhdHMuY2h1bmtDb3VudCwgcGF5bG9hZC5ieXRlTGVuZ3RoLCBwYXJ0SW5kZXgsIHBhcnRpYWwpO1xuICAgIHZhciBpbml0UFRTID0gdGhpcy5pbml0UFRTW2ZyYWcuY2NdO1xuICAgIHRyYW5zbXV4ZXIucHVzaChwYXlsb2FkLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGZyYWcsIHBhcnQsIGRldGFpbHMudG90YWxkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEsIGluaXRQVFMpO1xuICB9O1xuXG4gIF9wcm90by5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcgPSBmdW5jdGlvbiBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgdmFyIGZyb21BbHRBdWRpbyA9IHRoaXMuYWx0QXVkaW87XG4gICAgdmFyIGFsdEF1ZGlvID0gISFkYXRhLnVybDtcbiAgICB2YXIgdHJhY2tJZCA9IGRhdGEuaWQ7IC8vIGlmIHdlIHN3aXRjaCBvbiBtYWluIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggbWVkaWEuYnVmZmVyZWRcbiAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiB3ZSBzd2l0Y2ggdG8gYWx0IGF1ZGlvOiBhdWRpbyBzdHJlYW0gY29udHJvbGxlciBpcyBoYW5kbGluZyBpdC5cbiAgICAvLyB3ZSB3aWxsIGp1c3QgaGF2ZSB0byBjaGFuZ2UgYnVmZmVyIHNjaGVkdWxpbmcgb24gYXVkaW9UcmFja1N3aXRjaGVkXG5cbiAgICBpZiAoIWFsdEF1ZGlvKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYUJ1ZmZlciAhPT0gdGhpcy5tZWRpYSkge1xuICAgICAgICB0aGlzLmxvZygnU3dpdGNoaW5nIG9uIG1haW4gYXVkaW8sIHVzZSBtZWRpYS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnKTtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7IC8vIHdlIG5lZWQgdG8gcmVmaWxsIGF1ZGlvIGJ1ZmZlciBmcm9tIG1haW46IGNhbmNlbCBhbnkgZnJhZyBsb2FkaW5nIHRvIHNwZWVkIHVwIGF1ZGlvIHN3aXRjaFxuXG4gICAgICAgIGlmIChmcmFnQ3VycmVudCAhPT0gbnVsbCAmJiBmcmFnQ3VycmVudCAhPT0gdm9pZCAwICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgdG8gbWFpbiBhdWRpbyB0cmFjaywgY2FuY2VsIG1haW4gZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9IC8vIGRlc3Ryb3kgdHJhbnNtdXhlciB0byBmb3JjZSBpbml0IHNlZ21lbnQgZ2VuZXJhdGlvbiAoZm9sbG93aW5nIGF1ZGlvIHN3aXRjaClcblxuXG4gICAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7IC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGxvYWQgbmV3IGZyYWdtZW50XG5cbiAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmF1ZGlvT25seSkge1xuICAgICAgICAvLyBSZXNldCBhdWRpbyB0cmFuc211eGVyIHNvIHdoZW4gc3dpdGNoaW5nIGJhY2sgdG8gbWFpbiBhdWRpbyB3ZSdyZSBub3Qgc3RpbGwgYXBwZW5kaW5nIHdoZXJlIHdlIGxlZnQgb2ZmXG4gICAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBobHMgPSB0aGlzLmhsczsgLy8gSWYgc3dpdGNoaW5nIGZyb20gYWx0IHRvIG1haW4gYXVkaW8sIGZsdXNoIGFsbCBhdWRpbyBhbmQgdHJpZ2dlciB0cmFjayBzd2l0Y2hlZFxuXG4gICAgICBpZiAoZnJvbUFsdEF1ZGlvKSB7XG4gICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICBzdGFydE9mZnNldDogMCxcbiAgICAgICAgICBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICB0eXBlOiAnYXVkaW8nXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfU1dJVENIRUQsIHtcbiAgICAgICAgaWQ6IHRyYWNrSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25BdWRpb1RyYWNrU3dpdGNoZWQgPSBmdW5jdGlvbiBvbkF1ZGlvVHJhY2tTd2l0Y2hlZChldmVudCwgZGF0YSkge1xuICAgIHZhciB0cmFja0lkID0gZGF0YS5pZDtcbiAgICB2YXIgYWx0QXVkaW8gPSAhIXRoaXMuaGxzLmF1ZGlvVHJhY2tzW3RyYWNrSWRdLnVybDtcblxuICAgIGlmIChhbHRBdWRpbykge1xuICAgICAgdmFyIHZpZGVvQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlcjsgLy8gaWYgd2Ugc3dpdGNoZWQgb24gYWx0ZXJuYXRlIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggdmlkZW8gc291cmNlYnVmZmVyIGJ1ZmZlcmVkXG5cbiAgICAgIGlmICh2aWRlb0J1ZmZlciAmJiB0aGlzLm1lZGlhQnVmZmVyICE9PSB2aWRlb0J1ZmZlcikge1xuICAgICAgICB0aGlzLmxvZygnU3dpdGNoaW5nIG9uIGFsdGVybmF0ZSBhdWRpbywgdXNlIHZpZGVvLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdmlkZW9CdWZmZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hbHRBdWRpbyA9IGFsdEF1ZGlvO1xuICAgIHRoaXMudGljaygpO1xuICB9O1xuXG4gIF9wcm90by5vbkJ1ZmZlckNyZWF0ZWQgPSBmdW5jdGlvbiBvbkJ1ZmZlckNyZWF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgdHJhY2tzID0gZGF0YS50cmFja3M7XG4gICAgdmFyIG1lZGlhVHJhY2s7XG4gICAgdmFyIG5hbWU7XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgdHlwZSBpbiB0cmFja3MpIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1t0eXBlXTtcblxuICAgICAgaWYgKHRyYWNrLmlkID09PSAnbWFpbicpIHtcbiAgICAgICAgbmFtZSA9IHR5cGU7XG4gICAgICAgIG1lZGlhVHJhY2sgPSB0cmFjazsgLy8ga2VlcCB2aWRlbyBzb3VyY2UgYnVmZmVyIHJlZmVyZW5jZVxuXG4gICAgICAgIGlmICh0eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgdmFyIHZpZGVvVHJhY2sgPSB0cmFja3NbdHlwZV07XG5cbiAgICAgICAgICBpZiAodmlkZW9UcmFjaykge1xuICAgICAgICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IHZpZGVvVHJhY2suYnVmZmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWx0ZXJuYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWx0ZXJuYXRlICYmIG1lZGlhVHJhY2spIHtcbiAgICAgIHRoaXMubG9nKFwiQWx0ZXJuYXRlIHRyYWNrIGZvdW5kLCB1c2UgXCIgKyBuYW1lICsgXCIuYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nXCIpO1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG1lZGlhVHJhY2suYnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ0J1ZmZlcmVkID0gZnVuY3Rpb24gb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgcGFydCA9IGRhdGEucGFydDtcblxuICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uTUFJTikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgLy8gSWYgYSBsZXZlbCBzd2l0Y2ggd2FzIHJlcXVlc3RlZCB3aGlsZSBhIGZyYWdtZW50IHdhcyBidWZmZXJpbmcsIGl0IHdpbGwgZW1pdCB0aGUgRlJBR19CVUZGRVJFRCBldmVudCB1cG9uIGNvbXBsZXRpb25cbiAgICAgIC8vIEF2b2lkIHNldHRpbmcgc3RhdGUgYmFjayB0byBJRExFLCBzaW5jZSB0aGF0IHdpbGwgaW50ZXJmZXJlIHdpdGggYSBsZXZlbCBzd2l0Y2hcbiAgICAgIHRoaXMud2FybihcIkZyYWdtZW50IFwiICsgZnJhZy5zbiArIChwYXJ0ID8gJyBwOiAnICsgcGFydC5pbmRleCA6ICcnKSArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIGZpbmlzaGVkIGJ1ZmZlcmluZywgYnV0IHdhcyBhYm9ydGVkLiBzdGF0ZTogXCIgKyB0aGlzLnN0YXRlKTtcblxuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5QQVJTRUQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgIHRoaXMuZnJhZ0xhc3RLYnBzID0gTWF0aC5yb3VuZCg4ICogc3RhdHMudG90YWwgLyAoc3RhdHMuYnVmZmVyaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuZmlyc3QpKTtcblxuICAgIGlmIChmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnLCBwYXJ0KTtcbiAgfTtcblxuICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wiRXJyb3JEZXRhaWxzXCJdLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcIkVycm9yRGV0YWlsc1wiXS5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICB0aGlzLm9uRnJhZ21lbnRPcktleUxvYWRFcnJvcihfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5NQUlOLCBkYXRhKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcIkVycm9yRGV0YWlsc1wiXS5MRVZFTF9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wiRXJyb3JEZXRhaWxzXCJdLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5FUlJPUikge1xuICAgICAgICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICAgICAgICAvLyBpZiBmYXRhbCBlcnJvciwgc3RvcCBwcm9jZXNzaW5nXG4gICAgICAgICAgICB0aGlzLndhcm4oXCJcIiArIGRhdGEuZGV0YWlscyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLkVSUk9SO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIG9mIG5vbiBmYXRhbCBlcnJvciB3aGlsZSBsb2FkaW5nIGxldmVsLCBpZiBsZXZlbCBjb250cm9sbGVyIGlzIG5vdCByZXRyeWluZyB0byBsb2FkIGxldmVsICwgc3dpdGNoIGJhY2sgdG8gSURMRVxuICAgICAgICAgICAgaWYgKCFkYXRhLmxldmVsUmV0cnkgJiYgdGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfTEVWRUwpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXCJFcnJvckRldGFpbHNcIl0uQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAgIC8vIGlmIGluIGFwcGVuZGluZyBzdGF0ZVxuICAgICAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdtYWluJyAmJiAodGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLlBBUlNJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLlBBUlNFRCkpIHtcbiAgICAgICAgICB2YXIgZmx1c2hCdWZmZXIgPSB0cnVlO1xuICAgICAgICAgIHZhciBidWZmZXJlZEluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8odGhpcy5tZWRpYSwgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uTUFJTik7IC8vIDAuNSA6IHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIGVuZFxuICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXG5cbiAgICAgICAgICBpZiAoYnVmZmVyZWRJbmZvICYmIGJ1ZmZlcmVkSW5mby5sZW4gPiAwLjUpIHtcbiAgICAgICAgICAgIGZsdXNoQnVmZmVyID0gIXRoaXMucmVkdWNlTWF4QnVmZmVyTGVuZ3RoKGJ1ZmZlcmVkSW5mby5sZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmbHVzaEJ1ZmZlcikge1xuICAgICAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsIGJ1dCBicm93c2VyIGlzIHN0aWxsIGNvbXBsYWluaW5nIGFib3V0IGJ1ZmZlciBmdWxsIGVycm9yXG4gICAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgb24gSUUvRWRnZSwgcmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvcHVsbC83MDhcbiAgICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSBmbHVzaCB0aGUgd2hvbGUgYnVmZmVyIHRvIHJlY292ZXJcbiAgICAgICAgICAgIHRoaXMud2FybignYnVmZmVyIGZ1bGwgZXJyb3IgYWxzbyBtZWRpYS5jdXJyZW50VGltZSBpcyBub3QgYnVmZmVyZWQsIGZsdXNoIG1haW4nKTsgLy8gZmx1c2ggbWFpbiBidWZmZXJcblxuICAgICAgICAgICAgdGhpcy5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gLy8gQ2hlY2tzIHRoZSBoZWFsdGggb2YgdGhlIGJ1ZmZlciBhbmQgYXR0ZW1wdHMgdG8gcmVzb2x2ZSBwbGF5YmFjayBzdGFsbHMuXG4gIDtcblxuICBfcHJvdG8uY2hlY2tCdWZmZXIgPSBmdW5jdGlvbiBjaGVja0J1ZmZlcigpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBnYXBDb250cm9sbGVyID0gdGhpcy5nYXBDb250cm9sbGVyO1xuXG4gICAgaWYgKCFtZWRpYSB8fCAhZ2FwQ29udHJvbGxlciB8fCAhbWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgLy8gRXhpdCBlYXJseSBpZiB3ZSBkb24ndCBoYXZlIG1lZGlhIG9yIGlmIHRoZSBtZWRpYSBoYXNuJ3QgYnVmZmVyZWQgYW55dGhpbmcgeWV0IChyZWFkeVN0YXRlIDApXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDaGVjayBjb21iaW5lZCBidWZmZXJcblxuXG4gICAgdmFyIGJ1ZmZlcmVkID0gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkJ1ZmZlckhlbHBlclwiXS5nZXRCdWZmZXJlZChtZWRpYSk7XG5cbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEgJiYgYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2Vla1RvU3RhcnRQb3MoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzb2x2ZSBnYXBzIHVzaW5nIHRoZSBtYWluIGJ1ZmZlciwgd2hvc2UgcmFuZ2VzIGFyZSB0aGUgaW50ZXJzZWN0aW9ucyBvZiB0aGUgQS9WIHNvdXJjZWJ1ZmZlcnNcbiAgICAgIHZhciBhY3RpdmVGcmFnID0gdGhpcy5zdGF0ZSAhPT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEUgPyB0aGlzLmZyYWdDdXJyZW50IDogbnVsbDtcbiAgICAgIGdhcENvbnRyb2xsZXIucG9sbCh0aGlzLmxhc3RDdXJyZW50VGltZSwgYWN0aXZlRnJhZyk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgfTtcblxuICBfcHJvdG8ub25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQgPSBmdW5jdGlvbiBvbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCgpIHtcbiAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7IC8vIGlmIGxvYWRlZG1ldGFkYXRhIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoYXQgd2UgYXJlIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBvbiBmaXJzdCBmcmFnXG4gICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuXG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIH1cblxuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9O1xuXG4gIF9wcm90by5vbkJ1ZmZlckZsdXNoZWQgPSBmdW5jdGlvbiBvbkJ1ZmZlckZsdXNoZWQoZXZlbnQsIF9yZWYpIHtcbiAgICB2YXIgdHlwZSA9IF9yZWYudHlwZTtcblxuICAgIGlmICh0eXBlICE9PSBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIl0uQVVESU8gfHwgdGhpcy5hdWRpb09ubHkgJiYgIXRoaXMuYWx0QXVkaW8pIHtcbiAgICAgIHZhciBtZWRpYSA9ICh0eXBlID09PSBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIl0uVklERU8gPyB0aGlzLnZpZGVvQnVmZmVyIDogdGhpcy5tZWRpYUJ1ZmZlcikgfHwgdGhpcy5tZWRpYTtcbiAgICAgIHRoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKG1lZGlhLCB0eXBlLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5NQUlOKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uTGV2ZWxzVXBkYXRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxzVXBkYXRlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gIH07XG5cbiAgX3Byb3RvLnN3YXBBdWRpb0NvZGVjID0gZnVuY3Rpb24gc3dhcEF1ZGlvQ29kZWMoKSB7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9ICF0aGlzLmF1ZGlvQ29kZWNTd2FwO1xuICB9XG4gIC8qKlxuICAgKiBTZWVrcyB0byB0aGUgc2V0IHN0YXJ0UG9zaXRpb24gaWYgbm90IGVxdWFsIHRvIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNlZWtUb1N0YXJ0UG9zID0gZnVuY3Rpb24gc2Vla1RvU3RhcnRQb3MoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjsgLy8gb25seSBhZGp1c3QgY3VycmVudFRpbWUgaWYgZGlmZmVyZW50IGZyb20gc3RhcnRQb3NpdGlvbiBvciBpZiBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZFxuICAgIC8vIGF0IHRoYXQgc3RhZ2UsIHRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBidWZmZXJlZCByYW5nZSwgYXMgd2UgcmVhY2ggdGhhdCBjb2RlIGFmdGVyIGZpcnN0IGZyYWdtZW50IGhhcyBiZWVuIGJ1ZmZlcmVkXG5cbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA+PSAwICYmIGN1cnJlbnRUaW1lIDwgc3RhcnRQb3NpdGlvbikge1xuICAgICAgaWYgKG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1tcImxvZ2dlclwiXS5sb2coXCJjb3VsZCBub3Qgc2VlayB0byBcIiArIHN0YXJ0UG9zaXRpb24gKyBcIiwgYWxyZWFkeSBzZWVraW5nIGF0IFwiICsgY3VycmVudFRpbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBidWZmZXJlZCA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJCdWZmZXJIZWxwZXJcIl0uZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgICAgdmFyIGJ1ZmZlclN0YXJ0ID0gYnVmZmVyZWQubGVuZ3RoID8gYnVmZmVyZWQuc3RhcnQoMCkgOiAwO1xuICAgICAgdmFyIGRlbHRhID0gYnVmZmVyU3RhcnQgLSBzdGFydFBvc2l0aW9uO1xuXG4gICAgICBpZiAoZGVsdGEgPiAwICYmIChkZWx0YSA8IHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUgfHwgZGVsdGEgPCB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKSkge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1wibG9nZ2VyXCJdLmxvZyhcImFkanVzdGluZyBzdGFydCBwb3NpdGlvbiBieSBcIiArIGRlbHRhICsgXCIgdG8gbWF0Y2ggYnVmZmVyIHN0YXJ0XCIpO1xuICAgICAgICBzdGFydFBvc2l0aW9uICs9IGRlbHRhO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZyhcInNlZWsgdG8gdGFyZ2V0IHN0YXJ0IHBvc2l0aW9uIFwiICsgc3RhcnRQb3NpdGlvbiArIFwiIGZyb20gY3VycmVudCB0aW1lIFwiICsgY3VycmVudFRpbWUpO1xuICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2dldEF1ZGlvQ29kZWMgPSBmdW5jdGlvbiBfZ2V0QXVkaW9Db2RlYyhjdXJyZW50TGV2ZWwpIHtcbiAgICB2YXIgYXVkaW9Db2RlYyA9IHRoaXMuY29uZmlnLmRlZmF1bHRBdWRpb0NvZGVjIHx8IGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjO1xuXG4gICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3YXAgJiYgYXVkaW9Db2RlYykge1xuICAgICAgdGhpcy5sb2coJ1N3YXBwaW5nIGF1ZGlvIGNvZGVjJyk7XG5cbiAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGF1ZGlvQ29kZWM7XG4gIH07XG5cbiAgX3Byb3RvLl9sb2FkQml0cmF0ZVRlc3RGcmFnID0gZnVuY3Rpb24gX2xvYWRCaXRyYXRlVGVzdEZyYWcoZnJhZykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdGhpcy5fZG9GcmFnTG9hZChmcmFnKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgaGxzID0gX3RoaXMyLmhscztcblxuICAgICAgaWYgKCFkYXRhIHx8IGhscy5uZXh0TG9hZExldmVsIHx8IF90aGlzMi5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpczIuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICBfdGhpczIuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uSURMRTtcbiAgICAgIF90aGlzMi5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIF90aGlzMi5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgICAgdmFyIHN0YXRzID0gZnJhZy5zdGF0czsgLy8gQml0cmF0ZSB0ZXN0cyBmcmFnbWVudHMgYXJlIG5laXRoZXIgcGFyc2VkIG5vciBidWZmZXJlZFxuXG4gICAgICBzdGF0cy5wYXJzaW5nLnN0YXJ0ID0gc3RhdHMucGFyc2luZy5lbmQgPSBzdGF0cy5idWZmZXJpbmcuc3RhcnQgPSBzdGF0cy5idWZmZXJpbmcuZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLl9oYW5kbGVUcmFuc211eENvbXBsZXRlID0gZnVuY3Rpb24gX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUodHJhbnNtdXhSZXN1bHQpIHtcbiAgICB2YXIgX2lkMyRzYW1wbGVzO1xuXG4gICAgdmFyIGlkID0gJ21haW4nO1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICB2YXIgcmVtdXhSZXN1bHQgPSB0cmFuc211eFJlc3VsdC5yZW11eFJlc3VsdCxcbiAgICAgICAgY2h1bmtNZXRhID0gdHJhbnNtdXhSZXN1bHQuY2h1bmtNZXRhO1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpO1xuXG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICB0aGlzLndhcm4oXCJUaGUgbG9hZGluZyBjb250ZXh0IGNoYW5nZWQgd2hpbGUgYnVmZmVyaW5nIGZyYWdtZW50IFwiICsgY2h1bmtNZXRhLnNuICsgXCIgb2YgbGV2ZWwgXCIgKyBjaHVua01ldGEubGV2ZWwgKyBcIi4gVGhpcyBjaHVuayB3aWxsIG5vdCBiZSBidWZmZXJlZC5cIik7XG4gICAgICB0aGlzLnJlc2V0TGl2ZVN0YXJ0V2hlbk5vdExvYWRlZChjaHVua01ldGEubGV2ZWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnLFxuICAgICAgICBwYXJ0ID0gY29udGV4dC5wYXJ0LFxuICAgICAgICBsZXZlbCA9IGNvbnRleHQubGV2ZWw7XG4gICAgdmFyIHZpZGVvID0gcmVtdXhSZXN1bHQudmlkZW8sXG4gICAgICAgIHRleHQgPSByZW11eFJlc3VsdC50ZXh0LFxuICAgICAgICBpZDMgPSByZW11eFJlc3VsdC5pZDMsXG4gICAgICAgIGluaXRTZWdtZW50ID0gcmVtdXhSZXN1bHQuaW5pdFNlZ21lbnQ7XG4gICAgdmFyIGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzOyAvLyBUaGUgYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIgaGFuZGxlcyBhdWRpbyBidWZmZXJpbmcgaWYgSGxzLmpzIGlzIHBsYXlpbmcgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG5cbiAgICB2YXIgYXVkaW8gPSB0aGlzLmFsdEF1ZGlvID8gdW5kZWZpbmVkIDogcmVtdXhSZXN1bHQuYXVkaW87IC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGZyYWdtZW50IGhhcyBiZWVuIGFib3J0ZWQuIFdlIGNoZWNrIHRoaXMgYnkgZmlyc3Qgc2VlaW5nIGlmIHdlJ3JlIHN0aWxsIHBsYXlpbmcgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgLy8gSWYgd2UgYXJlLCBzdWJzZXF1ZW50bHkgY2hlY2sgaWYgdGhlIGN1cnJlbnRseSBsb2FkaW5nIGZyYWdtZW50IChmcmFnQ3VycmVudCkgaGFzIGNoYW5nZWQuXG5cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLlBBUlNJTkc7XG5cbiAgICBpZiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgIGlmIChpbml0U2VnbWVudC50cmFja3MpIHtcbiAgICAgICAgdGhpcy5fYnVmZmVySW5pdFNlZ21lbnQobGV2ZWwsIGluaXRTZWdtZW50LnRyYWNrcywgZnJhZywgY2h1bmtNZXRhKTtcblxuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwge1xuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHRyYWNrczogaW5pdFNlZ21lbnQudHJhY2tzXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBUaGlzIHdvdWxkIGJlIG5pY2UgaWYgTnVtYmVyLmlzRmluaXRlIGFjdGVkIGFzIGEgdHlwZWd1YXJkLCBidXQgaXQgZG9lc24ndC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzEwMDM4XG5cblxuICAgICAgdmFyIGluaXRQVFMgPSBpbml0U2VnbWVudC5pbml0UFRTO1xuICAgICAgdmFyIHRpbWVzY2FsZSA9IGluaXRTZWdtZW50LnRpbWVzY2FsZTtcblxuICAgICAgaWYgKE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoaW5pdFBUUykpIHtcbiAgICAgICAgdGhpcy5pbml0UFRTW2ZyYWcuY2NdID0gaW5pdFBUUztcbiAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLklOSVRfUFRTX0ZPVU5ELCB7XG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgaW5pdFBUUzogaW5pdFBUUyxcbiAgICAgICAgICB0aW1lc2NhbGU6IHRpbWVzY2FsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IC8vIEF2b2lkIGJ1ZmZlcmluZyBpZiBiYWNrdHJhY2tpbmcgdGhpcyBmcmFnbWVudFxuXG5cbiAgICBpZiAodmlkZW8gJiYgcmVtdXhSZXN1bHQuaW5kZXBlbmRlbnQgIT09IGZhbHNlKSB7XG4gICAgICBpZiAoZGV0YWlscykge1xuICAgICAgICB2YXIgc3RhcnRQVFMgPSB2aWRlby5zdGFydFBUUyxcbiAgICAgICAgICAgIGVuZFBUUyA9IHZpZGVvLmVuZFBUUyxcbiAgICAgICAgICAgIHN0YXJ0RFRTID0gdmlkZW8uc3RhcnREVFMsXG4gICAgICAgICAgICBlbmREVFMgPSB2aWRlby5lbmREVFM7XG5cbiAgICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgICBwYXJ0LmVsZW1lbnRhcnlTdHJlYW1zW3ZpZGVvLnR5cGVdID0ge1xuICAgICAgICAgICAgc3RhcnRQVFM6IHN0YXJ0UFRTLFxuICAgICAgICAgICAgZW5kUFRTOiBlbmRQVFMsXG4gICAgICAgICAgICBzdGFydERUUzogc3RhcnREVFMsXG4gICAgICAgICAgICBlbmREVFM6IGVuZERUU1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZpZGVvLmZpcnN0S2V5RnJhbWUgJiYgdmlkZW8uaW5kZXBlbmRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY291bGRCYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2aWRlby5kcm9wcGVkICYmIHZpZGVvLmluZGVwZW5kZW50KSB7XG4gICAgICAgICAgICAvLyBCYWNrdHJhY2sgaWYgZHJvcHBlZCBmcmFtZXMgY3JlYXRlIGEgZ2FwIGFmdGVyIGN1cnJlbnRUaW1lXG4gICAgICAgICAgICB2YXIgYnVmZmVySW5mbyA9IHRoaXMuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXRCdWZmZXJUaW1lID0gKGJ1ZmZlckluZm8gPyBidWZmZXJJbmZvLmVuZCA6IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCkpICsgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZTtcbiAgICAgICAgICAgIHZhciBzdGFydFRpbWUgPSB2aWRlby5maXJzdEtleUZyYW1lUFRTID8gdmlkZW8uZmlyc3RLZXlGcmFtZVBUUyA6IHN0YXJ0UFRTO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0QnVmZmVyVGltZSA8IHN0YXJ0VGltZSAtIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5iYWNrdHJhY2soZnJhZyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gLy8gU2V0IHZpZGVvIHN0cmVhbSBzdGFydCB0byBmcmFnbWVudCBzdGFydCBzbyB0aGF0IHRydW5jYXRlZCBzYW1wbGVzIGRvIG5vdCBkaXN0b3J0IHRoZSB0aW1lbGluZSwgYW5kIG1hcmsgaXQgcGFydGlhbFxuXG5cbiAgICAgICAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odmlkZW8udHlwZSwgZnJhZy5zdGFydCwgZW5kUFRTLCBmcmFnLnN0YXJ0LCBlbmREVFMsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odmlkZW8udHlwZSwgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUyk7XG5cbiAgICAgICAgaWYgKHRoaXMuYmFja3RyYWNrRnJhZ21lbnQpIHtcbiAgICAgICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gZnJhZztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYnVmZmVyRnJhZ21lbnREYXRhKHZpZGVvLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVtdXhSZXN1bHQuaW5kZXBlbmRlbnQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmJhY2t0cmFjayhmcmFnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYXVkaW8pIHtcbiAgICAgIHZhciBfc3RhcnRQVFMgPSBhdWRpby5zdGFydFBUUyxcbiAgICAgICAgICBfZW5kUFRTID0gYXVkaW8uZW5kUFRTLFxuICAgICAgICAgIF9zdGFydERUUyA9IGF1ZGlvLnN0YXJ0RFRTLFxuICAgICAgICAgIF9lbmREVFMgPSBhdWRpby5lbmREVFM7XG5cbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiRWxlbWVudGFyeVN0cmVhbVR5cGVzXCJdLkFVRElPXSA9IHtcbiAgICAgICAgICBzdGFydFBUUzogX3N0YXJ0UFRTLFxuICAgICAgICAgIGVuZFBUUzogX2VuZFBUUyxcbiAgICAgICAgICBzdGFydERUUzogX3N0YXJ0RFRTLFxuICAgICAgICAgIGVuZERUUzogX2VuZERUU1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJTywgX3N0YXJ0UFRTLCBfZW5kUFRTLCBfc3RhcnREVFMsIF9lbmREVFMpO1xuICAgICAgdGhpcy5idWZmZXJGcmFnbWVudERhdGEoYXVkaW8sIGZyYWcsIHBhcnQsIGNodW5rTWV0YSk7XG4gICAgfVxuXG4gICAgaWYgKGRldGFpbHMgJiYgaWQzICE9PSBudWxsICYmIGlkMyAhPT0gdm9pZCAwICYmIChfaWQzJHNhbXBsZXMgPSBpZDMuc2FtcGxlcykgIT09IG51bGwgJiYgX2lkMyRzYW1wbGVzICE9PSB2b2lkIDAgJiYgX2lkMyRzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgdmFyIGVtaXR0ZWRJRDMgPSB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgc2FtcGxlczogaWQzLnNhbXBsZXNcbiAgICAgIH07XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uRlJBR19QQVJTSU5HX01FVEFEQVRBLCBlbWl0dGVkSUQzKTtcbiAgICB9XG5cbiAgICBpZiAoZGV0YWlscyAmJiB0ZXh0KSB7XG4gICAgICB2YXIgZW1pdHRlZFRleHQgPSB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgc2FtcGxlczogdGV4dC5zYW1wbGVzXG4gICAgICB9O1xuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZW1pdHRlZFRleHQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2J1ZmZlckluaXRTZWdtZW50ID0gZnVuY3Rpb24gX2J1ZmZlckluaXRTZWdtZW50KGN1cnJlbnRMZXZlbCwgdHJhY2tzLCBmcmFnLCBjaHVua01ldGEpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uUEFSU0lORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYXVkaW9Pbmx5ID0gISF0cmFja3MuYXVkaW8gJiYgIXRyYWNrcy52aWRlbzsgLy8gaWYgYXVkaW8gdHJhY2sgaXMgZXhwZWN0ZWQgdG8gY29tZSBmcm9tIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyLCBkaXNjYXJkIGFueSBjb21pbmcgZnJvbSBtYWluXG5cbiAgICBpZiAodGhpcy5hbHRBdWRpbyAmJiAhdGhpcy5hdWRpb09ubHkpIHtcbiAgICAgIGRlbGV0ZSB0cmFja3MuYXVkaW87XG4gICAgfSAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuXG5cbiAgICB2YXIgYXVkaW8gPSB0cmFja3MuYXVkaW8sXG4gICAgICAgIHZpZGVvID0gdHJhY2tzLnZpZGVvLFxuICAgICAgICBhdWRpb3ZpZGVvID0gdHJhY2tzLmF1ZGlvdmlkZW87XG5cbiAgICBpZiAoYXVkaW8pIHtcbiAgICAgIHZhciBhdWRpb0NvZGVjID0gY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgICAgaWYgKGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgICBpZiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJbiB0aGUgY2FzZSB0aGF0IEFBQyBhbmQgSEUtQUFDIGF1ZGlvIGNvZGVjcyBhcmUgc2lnbmFsbGVkIGluIG1hbmlmZXN0LFxuICAgICAgICAvLyBmb3JjZSBIRS1BQUMsIGFzIGl0IHNlZW1zIHRoYXQgbW9zdCBicm93c2VycyBwcmVmZXJzIGl0LlxuICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgbW9ubyBzdHJlYW0sIG9yIGluIEZpcmVmb3hcblxuXG4gICAgICAgIGlmIChhdWRpby5tZXRhZGF0YS5jaGFubmVsQ291bnQgIT09IDEgJiYgdWEuaW5kZXhPZignZmlyZWZveCcpID09PSAtMSkge1xuICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgfVxuICAgICAgfSAvLyBIRS1BQUMgaXMgYnJva2VuIG9uIEFuZHJvaWQsIGFsd2F5cyBzaWduYWwgYXVkaW8gY29kZWMgYXMgQUFDIGV2ZW4gaWYgdmFyaWFudCBtYW5pZmVzdCBzdGF0ZXMgb3RoZXJ3aXNlXG5cblxuICAgICAgaWYgKHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEgJiYgYXVkaW8uY29udGFpbmVyICE9PSAnYXVkaW8vbXBlZycpIHtcbiAgICAgICAgLy8gRXhjbHVkZSBtcGVnIGF1ZGlvXG4gICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgdGhpcy5sb2coXCJBbmRyb2lkOiBmb3JjZSBhdWRpbyBjb2RlYyB0byBcIiArIGF1ZGlvQ29kZWMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudExldmVsLmF1ZGlvQ29kZWMgJiYgY3VycmVudExldmVsLmF1ZGlvQ29kZWMgIT09IGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgdGhpcy5sb2coXCJTd2FwcGluZyBtYW5pZmVzdCBhdWRpbyBjb2RlYyBcXFwiXCIgKyBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYyArIFwiXFxcIiBmb3IgXFxcIlwiICsgYXVkaW9Db2RlYyArIFwiXFxcIlwiKTtcbiAgICAgIH1cblxuICAgICAgYXVkaW8ubGV2ZWxDb2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICBhdWRpby5pZCA9ICdtYWluJztcbiAgICAgIHRoaXMubG9nKFwiSW5pdCBhdWRpbyBidWZmZXIsIGNvbnRhaW5lcjpcIiArIGF1ZGlvLmNvbnRhaW5lciArIFwiLCBjb2RlY3Nbc2VsZWN0ZWQvbGV2ZWwvcGFyc2VkXT1bXCIgKyAoYXVkaW9Db2RlYyB8fCAnJykgKyBcIi9cIiArIChjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYyB8fCAnJykgKyBcIi9cIiArIGF1ZGlvLmNvZGVjICsgXCJdXCIpO1xuICAgIH1cblxuICAgIGlmICh2aWRlbykge1xuICAgICAgdmlkZW8ubGV2ZWxDb2RlYyA9IGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjO1xuICAgICAgdmlkZW8uaWQgPSAnbWFpbic7XG4gICAgICB0aGlzLmxvZyhcIkluaXQgdmlkZW8gYnVmZmVyLCBjb250YWluZXI6XCIgKyB2aWRlby5jb250YWluZXIgKyBcIiwgY29kZWNzW2xldmVsL3BhcnNlZF09W1wiICsgKGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjIHx8ICcnKSArIFwiL1wiICsgdmlkZW8uY29kZWMgKyBcIl1cIik7XG4gICAgfVxuXG4gICAgaWYgKGF1ZGlvdmlkZW8pIHtcbiAgICAgIHRoaXMubG9nKFwiSW5pdCBhdWRpb3ZpZGVvIGJ1ZmZlciwgY29udGFpbmVyOlwiICsgYXVkaW92aWRlby5jb250YWluZXIgKyBcIiwgY29kZWNzW2xldmVsL3BhcnNlZF09W1wiICsgKGN1cnJlbnRMZXZlbC5hdHRycy5DT0RFQ1MgfHwgJycpICsgXCIvXCIgKyBhdWRpb3ZpZGVvLmNvZGVjICsgXCJdXCIpO1xuICAgIH1cblxuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkJVRkZFUl9DT0RFQ1MsIHRyYWNrcyk7IC8vIGxvb3AgdGhyb3VnaCB0cmFja3MgdGhhdCBhcmUgZ29pbmcgdG8gYmUgcHJvdmlkZWQgdG8gYnVmZmVyQ29udHJvbGxlclxuXG4gICAgT2JqZWN0LmtleXModHJhY2tzKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja05hbWUpIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgdmFyIGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG5cbiAgICAgIGlmIChpbml0U2VnbWVudCAhPT0gbnVsbCAmJiBpbml0U2VnbWVudCAhPT0gdm9pZCAwICYmIGluaXRTZWdtZW50LmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgX3RoaXMzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQVBQRU5ESU5HLCB7XG4gICAgICAgICAgdHlwZTogdHJhY2tOYW1lLFxuICAgICAgICAgIGRhdGE6IGluaXRTZWdtZW50LFxuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICBjaHVua01ldGE6IGNodW5rTWV0YSxcbiAgICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTsgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuXG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldE1haW5Gd2RCdWZmZXJJbmZvID0gZnVuY3Rpb24gZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWEsIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLk1BSU4pO1xuICB9O1xuXG4gIF9wcm90by5iYWNrdHJhY2sgPSBmdW5jdGlvbiBiYWNrdHJhY2soZnJhZykge1xuICAgIHRoaXMuY291bGRCYWNrdHJhY2sgPSB0cnVlOyAvLyBDYXVzZXMgZmluZEZyYWdtZW50cyB0byBiYWNrdHJhY2sgdGhyb3VnaCBmcmFnbWVudHMgdG8gZmluZCB0aGUga2V5ZnJhbWVcblxuICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBmcmFnO1xuICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgdGhpcy5mbHVzaEJ1ZmZlckdhcChmcmFnKTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydDtcbiAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7XG4gIH07XG5cbiAgX3Byb3RvLmNoZWNrRnJhZ21lbnRDaGFuZ2VkID0gZnVuY3Rpb24gY2hlY2tGcmFnbWVudENoYW5nZWQoKSB7XG4gICAgdmFyIHZpZGVvID0gdGhpcy5tZWRpYTtcbiAgICB2YXIgZnJhZ1BsYXlpbmdDdXJyZW50ID0gbnVsbDtcblxuICAgIGlmICh2aWRlbyAmJiB2aWRlby5yZWFkeVN0YXRlID4gMSAmJiB2aWRlby5zZWVraW5nID09PSBmYWxzZSkge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG4gICAgICAvKiBpZiB2aWRlbyBlbGVtZW50IGlzIGluIHNlZWtlZCBzdGF0ZSwgY3VycmVudFRpbWUgY2FuIG9ubHkgaW5jcmVhc2UuXG4gICAgICAgIChhc3N1bWluZyB0aGF0IHBsYXliYWNrIHJhdGUgaXMgcG9zaXRpdmUgLi4uKVxuICAgICAgICBBcyBzb21ldGltZXMgY3VycmVudFRpbWUganVtcHMgYmFjayB0byB6ZXJvIGFmdGVyIGFcbiAgICAgICAgbWVkaWEgZGVjb2RlIGVycm9yLCBjaGVjayB0aGlzLCB0byBhdm9pZCBzZWVraW5nIGJhY2sgdG9cbiAgICAgICAgd3JvbmcgcG9zaXRpb24gYWZ0ZXIgYSBtZWRpYSBkZWNvZGUgZXJyb3JcbiAgICAgICovXG5cbiAgICAgIGlmIChfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiQnVmZmVySGVscGVyXCJdLmlzQnVmZmVyZWQodmlkZW8sIGN1cnJlbnRUaW1lKSkge1xuICAgICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEFwcGVuZGVkRnJhZyhjdXJyZW50VGltZSk7XG4gICAgICB9IGVsc2UgaWYgKF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJCdWZmZXJIZWxwZXJcIl0uaXNCdWZmZXJlZCh2aWRlbywgY3VycmVudFRpbWUgKyAwLjEpKSB7XG4gICAgICAgIC8qIGVuc3VyZSB0aGF0IEZSQUdfQ0hBTkdFRCBldmVudCBpcyB0cmlnZ2VyZWQgYXQgc3RhcnR1cCxcbiAgICAgICAgICB3aGVuIGZpcnN0IHZpZGVvIGZyYW1lIGlzIGRpc3BsYXllZCBhbmQgcGxheWJhY2sgaXMgcGF1c2VkLlxuICAgICAgICAgIGFkZCBhIHRvbGVyYW5jZSBvZiAxMDBtcywgaW4gY2FzZSBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCxcbiAgICAgICAgICBjaGVjayBpZiBjdXJyZW50IHBvcysxMDBtcyBpcyBidWZmZXJlZCBhbmQgdXNlIHRoYXQgYnVmZmVyIHJhbmdlXG4gICAgICAgICAgZm9yIEZSQUdfQ0hBTkdFRCBldmVudCByZXBvcnRpbmcgKi9cbiAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRBcHBlbmRlZEZyYWcoY3VycmVudFRpbWUgKyAwLjEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50KSB7XG4gICAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgICAgICB2YXIgZnJhZ1BsYXlpbmcgPSB0aGlzLmZyYWdQbGF5aW5nO1xuICAgICAgICB2YXIgZnJhZ0N1cnJlbnRMZXZlbCA9IGZyYWdQbGF5aW5nQ3VycmVudC5sZXZlbDtcblxuICAgICAgICBpZiAoIWZyYWdQbGF5aW5nIHx8IGZyYWdQbGF5aW5nQ3VycmVudC5zbiAhPT0gZnJhZ1BsYXlpbmcuc24gfHwgZnJhZ1BsYXlpbmcubGV2ZWwgIT09IGZyYWdDdXJyZW50TGV2ZWwgfHwgZnJhZ1BsYXlpbmdDdXJyZW50LnVybElkICE9PSBmcmFnUGxheWluZy51cmxJZCkge1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkZSQUdfQ0hBTkdFRCwge1xuICAgICAgICAgICAgZnJhZzogZnJhZ1BsYXlpbmdDdXJyZW50XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIWZyYWdQbGF5aW5nIHx8IGZyYWdQbGF5aW5nLmxldmVsICE9PSBmcmFnQ3VycmVudExldmVsKSB7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5MRVZFTF9TV0lUQ0hFRCwge1xuICAgICAgICAgICAgICBsZXZlbDogZnJhZ0N1cnJlbnRMZXZlbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5mcmFnUGxheWluZyA9IGZyYWdQbGF5aW5nQ3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU3RyZWFtQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwibmV4dExldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgZnJhZyA9IHRoaXMubmV4dEJ1ZmZlcmVkRnJhZztcblxuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgcmV0dXJuIGZyYWcubGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3VycmVudEZyYWdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnUGxheWluZyB8fCB0aGlzLmdldEFwcGVuZGVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjdXJyZW50UHJvZ3JhbURhdGVUaW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciBmcmFnID0gdGhpcy5jdXJyZW50RnJhZztcblxuICAgICAgICBpZiAoZnJhZyAmJiBPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGN1cnJlbnRUaW1lKSAmJiBPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGZyYWcucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgICAgIHZhciBlcG9jTXMgPSBmcmFnLnByb2dyYW1EYXRlVGltZSArIChjdXJyZW50VGltZSAtIGZyYWcuc3RhcnQpICogMTAwMDtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZXBvY01zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3VycmVudExldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgZnJhZyA9IHRoaXMuY3VycmVudEZyYWc7XG5cbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5leHRCdWZmZXJlZEZyYWdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBmcmFnID0gdGhpcy5jdXJyZW50RnJhZztcblxuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKGZyYWcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yY2VTdGFydExvYWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mb3JjZVN0YXJ0TG9hZDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RyZWFtQ29udHJvbGxlcjtcbn0oX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0pO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiU3VidGl0bGVTdHJlYW1Db250cm9sbGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU3VidGl0bGVTdHJlYW1Db250cm9sbGVyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2J1ZmZlci1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mcmFnbWVudF9maW5kZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZyYWdtZW50LWZpbmRlcnMgKi8gXCIuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LWZpbmRlcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2Rpc2NvbnRpbnVpdGllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZGlzY29udGludWl0aWVzICovIFwiLi9zcmMvdXRpbHMvZGlzY29udGludWl0aWVzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGV2ZWwtaGVscGVyICovIFwiLi9zcmMvY29udHJvbGxlci9sZXZlbC1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQtdHJhY2tlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLXN0cmVhbS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9iYXNlLXN0cmVhbS1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xvYWRlciAqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xldmVsICovIFwiLi9zcmMvdHlwZXMvbGV2ZWwudHNcIik7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgVElDS19JTlRFUlZBTCA9IDUwMDsgLy8gaG93IG9mdGVuIHRvIHRpY2sgaW4gbXNcblxudmFyIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VTdHJlYW1Db250cm9sbGVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciwgX0Jhc2VTdHJlYW1Db250cm9sbGVyKTtcblxuICBmdW5jdGlvbiBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlU3RyZWFtQ29udHJvbGxlci5jYWxsKHRoaXMsIGhscywgZnJhZ21lbnRUcmFja2VyLCAnW3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyXScpIHx8IHRoaXM7XG4gICAgX3RoaXMubGV2ZWxzID0gW107XG4gICAgX3RoaXMuY3VycmVudFRyYWNrSWQgPSAtMTtcbiAgICBfdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdO1xuICAgIF90aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcblxuICAgIF90aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm9uSGFuZGxlckRlc3Ryb3lpbmcgPSBmdW5jdGlvbiBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcblxuICAgIHRoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5fcmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHRoaXMub25TdWJ0aXRsZVRyYWNrU3dpdGNoLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHRoaXMub25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5fdW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgdGhpcy5vblN1YnRpdGxlVHJhY2tTd2l0Y2gsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB0aGlzLm9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uIHN0YXJ0TG9hZCgpIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJTdGF0ZVwiXS5JRExFO1xuICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTGV2ZWxMb2FkZWQgPSBmdW5jdGlvbiBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgfTtcblxuICBfcHJvdG8ub25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQgPSBmdW5jdGlvbiBvblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBzdWNjZXNzID0gZGF0YS5zdWNjZXNzO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlN0YXRlXCJdLklETEU7XG5cbiAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLnRyYWNrc0J1ZmZlcmVkW3RoaXMuY3VycmVudFRyYWNrSWRdO1xuXG4gICAgaWYgKCFidWZmZXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ3JlYXRlL3VwZGF0ZSBhIGJ1ZmZlcmVkIGFycmF5IG1hdGNoaW5nIHRoZSBpbnRlcmZhY2UgdXNlZCBieSBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvXG4gICAgLy8gc28gd2UgY2FuIHJlLXVzZSB0aGUgbG9naWMgdXNlZCB0byBkZXRlY3QgaG93IG11Y2ggaGFzIGJlZW4gYnVmZmVyZWRcblxuXG4gICAgdmFyIHRpbWVSYW5nZTtcbiAgICB2YXIgZnJhZ1N0YXJ0ID0gZnJhZy5zdGFydDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChmcmFnU3RhcnQgPj0gYnVmZmVyZWRbaV0uc3RhcnQgJiYgZnJhZ1N0YXJ0IDw9IGJ1ZmZlcmVkW2ldLmVuZCkge1xuICAgICAgICB0aW1lUmFuZ2UgPSBidWZmZXJlZFtpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyYWdFbmQgPSBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcblxuICAgIGlmICh0aW1lUmFuZ2UpIHtcbiAgICAgIHRpbWVSYW5nZS5lbmQgPSBmcmFnRW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lUmFuZ2UgPSB7XG4gICAgICAgIHN0YXJ0OiBmcmFnU3RhcnQsXG4gICAgICAgIGVuZDogZnJhZ0VuZFxuICAgICAgfTtcbiAgICAgIGJ1ZmZlcmVkLnB1c2godGltZVJhbmdlKTtcbiAgICB9XG5cbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5mcmFnQnVmZmVyZWQoZnJhZyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uQnVmZmVyRmx1c2hpbmcgPSBmdW5jdGlvbiBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gZGF0YS5zdGFydE9mZnNldCxcbiAgICAgICAgZW5kT2Zmc2V0ID0gZGF0YS5lbmRPZmZzZXQ7XG5cbiAgICBpZiAoc3RhcnRPZmZzZXQgPT09IDAgJiYgZW5kT2Zmc2V0ICE9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgIHZhciBjdXJyZW50VHJhY2tJZCA9IHRoaXMuY3VycmVudFRyYWNrSWQsXG4gICAgICAgICAgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cbiAgICAgIGlmICghbGV2ZWxzLmxlbmd0aCB8fCAhbGV2ZWxzW2N1cnJlbnRUcmFja0lkXSB8fCAhbGV2ZWxzW2N1cnJlbnRUcmFja0lkXS5kZXRhaWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYWNrRGV0YWlscyA9IGxldmVsc1tjdXJyZW50VHJhY2tJZF0uZGV0YWlscztcbiAgICAgIHZhciB0YXJnZXREdXJhdGlvbiA9IHRyYWNrRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgICAgIHZhciBlbmRPZmZzZXRTdWJ0aXRsZXMgPSBlbmRPZmZzZXQgLSB0YXJnZXREdXJhdGlvbjtcblxuICAgICAgaWYgKGVuZE9mZnNldFN1YnRpdGxlcyA8PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGF0YS5lbmRPZmZzZXRTdWJ0aXRsZXMgPSBNYXRoLm1heCgwLCBlbmRPZmZzZXRTdWJ0aXRsZXMpO1xuICAgICAgdGhpcy50cmFja3NCdWZmZXJlZC5mb3JFYWNoKGZ1bmN0aW9uIChidWZmZXJlZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDspIHtcbiAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uZW5kIDw9IGVuZE9mZnNldFN1YnRpdGxlcykge1xuICAgICAgICAgICAgYnVmZmVyZWQuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyZWRbaV0uc3RhcnQgPCBlbmRPZmZzZXRTdWJ0aXRsZXMpIHtcbiAgICAgICAgICAgIGJ1ZmZlcmVkW2ldLnN0YXJ0ID0gZW5kT2Zmc2V0U3VidGl0bGVzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnRzSW5SYW5nZShzdGFydE9mZnNldCwgZW5kT2Zmc2V0U3VidGl0bGVzLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5TVUJUSVRMRSk7XG4gICAgfVxuICB9IC8vIElmIHNvbWV0aGluZyBnb2VzIHdyb25nLCBwcm9jZWVkIHRvIG5leHQgZnJhZywgaWYgd2Ugd2VyZSBwcm9jZXNzaW5nIG9uZS5cbiAgO1xuXG4gIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIHZhciBfdGhpcyRmcmFnQ3VycmVudDtcblxuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnOyAvLyBkb24ndCBoYW5kbGUgZXJyb3Igbm90IHJlbGF0ZWQgdG8gc3VidGl0bGUgZnJhZ21lbnRcblxuICAgIGlmICghZnJhZyB8fCBmcmFnLnR5cGUgIT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLlNVQlRJVExFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKChfdGhpcyRmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQpICE9PSBudWxsICYmIF90aGlzJGZyYWdDdXJyZW50ICE9PSB2b2lkIDAgJiYgX3RoaXMkZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICB0aGlzLmZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiU3RhdGVcIl0uSURMRTtcbiAgfSAvLyBHb3QgYWxsIG5ldyBzdWJ0aXRsZSBsZXZlbHMuXG4gIDtcblxuICBfcHJvdG8ub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQgPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tzVXBkYXRlZChldmVudCwgX3JlZikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHN1YnRpdGxlVHJhY2tzID0gX3JlZi5zdWJ0aXRsZVRyYWNrcztcbiAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkID0gW107XG4gICAgdGhpcy5sZXZlbHMgPSBzdWJ0aXRsZVRyYWNrcy5tYXAoZnVuY3Rpb24gKG1lZGlhUGxheWxpc3QpIHtcbiAgICAgIHJldHVybiBuZXcgX3R5cGVzX2xldmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJMZXZlbFwiXShtZWRpYVBsYXlsaXN0KTtcbiAgICB9KTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5sZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgIF90aGlzMi50cmFja3NCdWZmZXJlZFtsZXZlbC5pZF0gPSBbXTtcbiAgICB9KTtcbiAgICB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ub25TdWJ0aXRsZVRyYWNrU3dpdGNoID0gZnVuY3Rpb24gb25TdWJ0aXRsZVRyYWNrU3dpdGNoKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5jdXJyZW50VHJhY2tJZCA9IGRhdGEuaWQ7XG5cbiAgICBpZiAoIXRoaXMubGV2ZWxzLmxlbmd0aCB8fCB0aGlzLmN1cnJlbnRUcmFja0lkID09PSAtMSkge1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDaGVjayBpZiB0cmFjayBoYXMgdGhlIG5lY2Vzc2FyeSBkZXRhaWxzIHRvIGxvYWQgZnJhZ21lbnRzXG5cblxuICAgIHZhciBjdXJyZW50VHJhY2sgPSB0aGlzLmxldmVsc1t0aGlzLmN1cnJlbnRUcmFja0lkXTtcblxuICAgIGlmIChjdXJyZW50VHJhY2sgIT09IG51bGwgJiYgY3VycmVudFRyYWNrICE9PSB2b2lkIDAgJiYgY3VycmVudFRyYWNrLmRldGFpbHMpIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhQnVmZmVyVGltZVJhbmdlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRUcmFjaykge1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICB9XG4gIH0gLy8gR290IGEgbmV3IHNldCBvZiBzdWJ0aXRsZSBmcmFnbWVudHMuXG4gIDtcblxuICBfcHJvdG8ub25TdWJ0aXRsZVRyYWNrTG9hZGVkID0gZnVuY3Rpb24gb25TdWJ0aXRsZVRyYWNrTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90cmFjayRkZXRhaWxzO1xuXG4gICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHMsXG4gICAgICAgIHRyYWNrSWQgPSBkYXRhLmlkO1xuICAgIHZhciBjdXJyZW50VHJhY2tJZCA9IHRoaXMuY3VycmVudFRyYWNrSWQsXG4gICAgICAgIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgaWYgKCFsZXZlbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrID0gbGV2ZWxzW2N1cnJlbnRUcmFja0lkXTtcblxuICAgIGlmICh0cmFja0lkID49IGxldmVscy5sZW5ndGggfHwgdHJhY2tJZCAhPT0gY3VycmVudFRyYWNrSWQgfHwgIXRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXJUaW1lUmFuZ2VzO1xuXG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSB8fCAoX3RyYWNrJGRldGFpbHMgPSB0cmFjay5kZXRhaWxzKSAhPT0gbnVsbCAmJiBfdHJhY2skZGV0YWlscyAhPT0gdm9pZCAwICYmIF90cmFjayRkZXRhaWxzLmxpdmUpIHtcbiAgICAgIHZhciBtYWluRGV0YWlscyA9IHRoaXMubWFpbkRldGFpbHM7XG5cbiAgICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkIHx8ICFtYWluRGV0YWlscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQgPSBtYWluRGV0YWlscy5mcmFnbWVudHNbMF07XG5cbiAgICAgIGlmICghdHJhY2suZGV0YWlscykge1xuICAgICAgICBpZiAobmV3RGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgJiYgbWFpbkRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgICAgT2JqZWN0KF91dGlsc19kaXNjb250aW51aXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImFsaWduTWVkaWFQbGF5bGlzdEJ5UERUXCJdKShuZXdEZXRhaWxzLCBtYWluRGV0YWlscyk7XG4gICAgICAgIH0gZWxzZSBpZiAobWFpblNsaWRpbmdTdGFydEZyYWdtZW50KSB7XG4gICAgICAgICAgLy8gbGluZSB1cCBsaXZlIHBsYXlsaXN0IHdpdGggbWFpbiBzbyB0aGF0IGZyYWdtZW50cyBpbiByYW5nZSBhcmUgbG9hZGVkXG4gICAgICAgICAgT2JqZWN0KF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImFkZFNsaWRpbmdcIl0pKG5ld0RldGFpbHMsIG1haW5TbGlkaW5nU3RhcnRGcmFnbWVudC5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzbGlkaW5nID0gdGhpcy5hbGlnblBsYXlsaXN0cyhuZXdEZXRhaWxzLCB0cmFjay5kZXRhaWxzKTtcblxuICAgICAgICBpZiAoc2xpZGluZyA9PT0gMCAmJiBtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQpIHtcbiAgICAgICAgICAvLyByZWFsaWduIHdpdGggbWFpbiB3aGVuIHRoZXJlIGlzIG5vIG92ZXJsYXAgd2l0aCBsYXN0IHJlZnJlc2hcbiAgICAgICAgICBPYmplY3QoX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiYWRkU2xpZGluZ1wiXSkobmV3RGV0YWlscywgbWFpblNsaWRpbmdTdGFydEZyYWdtZW50LnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRyYWNrLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xuICAgIHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gdHJhY2tJZDsgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuXG4gICAgdGhpcy50aWNrKCk7IC8vIElmIHBsYXlsaXN0IGlzIG1pc2FsaWduZWQgYmVjYXVzZSBvZiBiYWQgUERUIG9yIGRyaWZ0LCBkZWxldGUgZGV0YWlscyB0byByZXN5bmMgd2l0aCBtYWluIG9uIHJlbG9hZFxuXG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSAmJiAhdGhpcy5mcmFnQ3VycmVudCAmJiB0aGlzLm1lZGlhICYmIHRoaXMuc3RhdGUgPT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJTdGF0ZVwiXS5JRExFKSB7XG4gICAgICB2YXIgZm91bmRGcmFnID0gT2JqZWN0KF9mcmFnbWVudF9maW5kZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJmaW5kRnJhZ21lbnRCeVBUU1wiXSkobnVsbCwgbmV3RGV0YWlscy5mcmFnbWVudHMsIHRoaXMubWVkaWEuY3VycmVudFRpbWUsIDApO1xuXG4gICAgICBpZiAoIWZvdW5kRnJhZykge1xuICAgICAgICB0aGlzLndhcm4oJ1N1YnRpdGxlIHBsYXlsaXN0IG5vdCBhbGlnbmVkIHdpdGggcGxheWJhY2snKTtcbiAgICAgICAgdHJhY2suZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShmcmFnTG9hZGVkRGF0YSkge1xuICAgIHZhciBmcmFnID0gZnJhZ0xvYWRlZERhdGEuZnJhZyxcbiAgICAgICAgcGF5bG9hZCA9IGZyYWdMb2FkZWREYXRhLnBheWxvYWQ7XG4gICAgdmFyIGRlY3J5cHREYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG5cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBkZWNyeXB0ZWRcblxuXG4gICAgaWYgKHBheWxvYWQgJiYgcGF5bG9hZC5ieXRlTGVuZ3RoID4gMCAmJiBkZWNyeXB0RGF0YSAmJiBkZWNyeXB0RGF0YS5rZXkgJiYgZGVjcnlwdERhdGEuaXYgJiYgZGVjcnlwdERhdGEubWV0aG9kID09PSAnQUVTLTEyOCcpIHtcbiAgICAgIHZhciBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTsgLy8gZGVjcnlwdCB0aGUgc3VidGl0bGVzXG5cbiAgICAgIHRoaXMuZGVjcnlwdGVyLndlYkNyeXB0b0RlY3J5cHQobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIGRlY3J5cHREYXRhLmtleS5idWZmZXIsIGRlY3J5cHREYXRhLml2LmJ1ZmZlcikudGhlbihmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICB2YXIgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRlJBR19ERUNSWVBURUQsIHtcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIHBheWxvYWQ6IGRlY3J5cHRlZERhdGEsXG4gICAgICAgICAgc3RhdHM6IHtcbiAgICAgICAgICAgIHRzdGFydDogc3RhcnRUaW1lLFxuICAgICAgICAgICAgdGRlY3J5cHQ6IGVuZFRpbWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5kb1RpY2sgPSBmdW5jdGlvbiBkb1RpY2soKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlN0YXRlXCJdLklETEU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJTdGF0ZVwiXS5JRExFKSB7XG4gICAgICB2YXIgX2ZvdW5kRnJhZztcblxuICAgICAgdmFyIGN1cnJlbnRUcmFja0lkID0gdGhpcy5jdXJyZW50VHJhY2tJZCxcbiAgICAgICAgICBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuICAgICAgaWYgKCFsZXZlbHMubGVuZ3RoIHx8ICFsZXZlbHNbY3VycmVudFRyYWNrSWRdIHx8ICFsZXZlbHNbY3VycmVudFRyYWNrSWRdLmRldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBFeHBhbmQgcmFuZ2Ugb2Ygc3VicyBsb2FkZWQgYnkgb25lIHRhcmdldC1kdXJhdGlvbiBpbiBlaXRoZXIgZGlyZWN0aW9uIHRvIG1ha2UgdXAgZm9yIG1pc2FsaWduZWQgcGxheWxpc3RzXG5cblxuICAgICAgdmFyIHRyYWNrRGV0YWlscyA9IGxldmVsc1tjdXJyZW50VHJhY2tJZF0uZGV0YWlscztcbiAgICAgIHZhciB0YXJnZXREdXJhdGlvbiA9IHRyYWNrRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICB2YXIgYnVmZmVyZWRJbmZvID0gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkJ1ZmZlckhlbHBlclwiXS5idWZmZXJlZEluZm8odGhpcy5tZWRpYUJ1ZmZlclRpbWVSYW5nZXMsIG1lZGlhLmN1cnJlbnRUaW1lIC0gdGFyZ2V0RHVyYXRpb24sIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICAgIHZhciB0YXJnZXRCdWZmZXJUaW1lID0gYnVmZmVyZWRJbmZvLmVuZCxcbiAgICAgICAgICBidWZmZXJMZW4gPSBidWZmZXJlZEluZm8ubGVuO1xuICAgICAgdmFyIG1heEJ1ZkxlbiA9IHRoaXMuZ2V0TWF4QnVmZmVyTGVuZ3RoKCkgKyB0YXJnZXREdXJhdGlvbjtcblxuICAgICAgaWYgKGJ1ZmZlckxlbiA+IG1heEJ1Zkxlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUuYXNzZXJ0KHRyYWNrRGV0YWlscywgJ1N1YnRpdGxlIHRyYWNrIGRldGFpbHMgYXJlIGRlZmluZWQgb24gaWRsZSBzdWJ0aXRsZSBzdHJlYW0gY29udHJvbGxlciB0aWNrJyk7XG4gICAgICB2YXIgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cztcbiAgICAgIHZhciBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBlbmQgPSB0cmFja0RldGFpbHMuZWRnZTtcbiAgICAgIHZhciBmb3VuZEZyYWc7XG4gICAgICB2YXIgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXM7XG5cbiAgICAgIGlmICh0YXJnZXRCdWZmZXJUaW1lIDwgZW5kKSB7XG4gICAgICAgIHZhciBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAgIGZvdW5kRnJhZyA9IE9iamVjdChfZnJhZ21lbnRfZmluZGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZmluZEZyYWdtZW50QnlQVFNcIl0pKGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBNYXRoLm1heChmcmFnbWVudHNbMF0uc3RhcnQsIHRhcmdldEJ1ZmZlclRpbWUpLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKTtcblxuICAgICAgICBpZiAoIWZvdW5kRnJhZyAmJiBmcmFnUHJldmlvdXMgJiYgZnJhZ1ByZXZpb3VzLnN0YXJ0IDwgZnJhZ21lbnRzWzBdLnN0YXJ0KSB7XG4gICAgICAgICAgZm91bmRGcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZEZyYWcgPSBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoKF9mb3VuZEZyYWcgPSBmb3VuZEZyYWcpICE9PSBudWxsICYmIF9mb3VuZEZyYWcgIT09IHZvaWQgMCAmJiBfZm91bmRGcmFnLmVuY3J5cHRlZCkge1xuICAgICAgICB0aGlzLmxvYWRLZXkoZm91bmRGcmFnLCB0cmFja0RldGFpbHMpO1xuICAgICAgfSBlbHNlIGlmIChmb3VuZEZyYWcgJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZm91bmRGcmFnKSA9PT0gX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkZyYWdtZW50U3RhdGVcIl0uTk9UX0xPQURFRCkge1xuICAgICAgICAvLyBvbmx5IGxvYWQgaWYgZnJhZ21lbnQgaXMgbm90IGxvYWRlZFxuICAgICAgICB0aGlzLmxvYWRGcmFnbWVudChmb3VuZEZyYWcsIHRyYWNrRGV0YWlscywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5sb2FkRnJhZ21lbnQgPSBmdW5jdGlvbiBsb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWxEZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG5cbiAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmxvYWRGcmFnbWVudC5jYWxsKHRoaXMsIGZyYWcsIGxldmVsRGV0YWlscywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwibWVkaWFCdWZmZXJUaW1lUmFuZ2VzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXSB8fCBbXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xufShfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9zdWJ0aXRsZS10cmFjay1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdGV4dHRyYWNrX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90ZXh0dHJhY2stdXRpbHMgKi8gXCIuL3NyYy91dGlscy90ZXh0dHJhY2stdXRpbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2VfcGxheWxpc3RfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLXBsYXlsaXN0LWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2Jhc2UtcGxheWxpc3QtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sb2FkZXIgKi8gXCIuL3NyYy90eXBlcy9sb2FkZXIudHNcIik7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5cblxuXG5cblxudmFyIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVBsYXlsaXN0Q29udHJvbGwpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3VidGl0bGVUcmFja0NvbnRyb2xsZXIsIF9CYXNlUGxheWxpc3RDb250cm9sbCk7XG5cbiAgZnVuY3Rpb24gU3VidGl0bGVUcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQmFzZVBsYXlsaXN0Q29udHJvbGwuY2FsbCh0aGlzLCBobHMsICdbc3VidGl0bGUtdHJhY2stY29udHJvbGxlcl0nKSB8fCB0aGlzO1xuICAgIF90aGlzLm1lZGlhID0gbnVsbDtcbiAgICBfdGhpcy50cmFja3MgPSBbXTtcbiAgICBfdGhpcy5ncm91cElkID0gbnVsbDtcbiAgICBfdGhpcy50cmFja3NJbkdyb3VwID0gW107XG4gICAgX3RoaXMudHJhY2tJZCA9IC0xO1xuICAgIF90aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gICAgX3RoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gLTE7XG5cbiAgICBfdGhpcy50cmFja0NoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLm9uVGV4dFRyYWNrc0NoYW5nZWQoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMucG9sbFRyYWNrQ2hhbmdlKDApO1xuICAgIH07XG5cbiAgICBfdGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nID0gZmFsc2U7XG4gICAgX3RoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwgPSAtMTtcbiAgICBfdGhpcy5fc3VidGl0bGVEaXNwbGF5ID0gdHJ1ZTtcblxuICAgIF90aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3VidGl0bGVUcmFja0NvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnRyYWNrcy5sZW5ndGggPSAwO1xuICAgIHRoaXMudHJhY2tzSW5Hcm91cC5sZW5ndGggPSAwO1xuICAgIHRoaXMudHJhY2tDaGFuZ2VMaXN0ZW5lciA9IHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UgPSBudWxsO1xuXG4gICAgX0Jhc2VQbGF5bGlzdENvbnRyb2xsLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfSAvLyBMaXN0ZW4gZm9yIHN1YnRpdGxlIHRyYWNrIGNoYW5nZSwgdGhlbiBleHRyYWN0IHRoZSBjdXJyZW50IHRyYWNrIElELlxuICA7XG5cbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuXG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID4gLTEpIHtcbiAgICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IHRoaXMucXVldWVkRGVmYXVsdFRyYWNrO1xuICAgICAgdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPSAtMTtcbiAgICB9XG5cbiAgICB0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcgPSAhKHRoaXMubWVkaWEudGV4dFRyYWNrcyAmJiAnb25jaGFuZ2UnIGluIHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG5cbiAgICBpZiAodGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nKSB7XG4gICAgICB0aGlzLnBvbGxUcmFja0NoYW5nZSg1MDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhLnRleHRUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5hc3luY1BvbGxUcmFja0NoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wb2xsVHJhY2tDaGFuZ2UgPSBmdW5jdGlvbiBwb2xsVHJhY2tDaGFuZ2UodGltZW91dCkge1xuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKTtcbiAgICB0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLnRyYWNrQ2hhbmdlTGlzdGVuZXIsIHRpbWVvdXQpO1xuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCk7XG5cbiAgICBpZiAoIXRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgdGhpcy5tZWRpYS50ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRyYWNrSWQgPiAtMSkge1xuICAgICAgdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPSB0aGlzLnRyYWNrSWQ7XG4gICAgfVxuXG4gICAgdmFyIHRleHRUcmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyh0aGlzLm1lZGlhLnRleHRUcmFja3MpOyAvLyBDbGVhciBsb2FkZWQgY3VlcyBvbiBtZWRpYSBkZXRhY2htZW50IGZyb20gdHJhY2tzXG5cbiAgICB0ZXh0VHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICBPYmplY3QoX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiY2xlYXJDdXJyZW50Q3Vlc1wiXSkodHJhY2spO1xuICAgIH0pOyAvLyBEaXNhYmxlIGFsbCBzdWJ0aXRsZSB0cmFja3MgYmVmb3JlIGRldGFjaG1lbnQgc28gd2hlbiByZWF0dGFjaGVkIG9ubHkgdHJhY2tzIGluIHRoYXQgY29udGVudCBhcmUgZW5hYmxlZC5cblxuICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IC0xO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5ncm91cElkID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gIH0gLy8gRmlyZWQgd2hlbmV2ZXIgYSBuZXcgbWFuaWZlc3QgaXMgbG9hZGVkLlxuICA7XG5cbiAgX3Byb3RvLm9uTWFuaWZlc3RQYXJzZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0UGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy50cmFja3MgPSBkYXRhLnN1YnRpdGxlVHJhY2tzO1xuICB9O1xuXG4gIF9wcm90by5vblN1YnRpdGxlVHJhY2tMb2FkZWQgPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgaWQgPSBkYXRhLmlkLFxuICAgICAgICBkZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIHZhciB0cmFja0lkID0gdGhpcy50cmFja0lkO1xuICAgIHZhciBjdXJyZW50VHJhY2sgPSB0aGlzLnRyYWNrc0luR3JvdXBbdHJhY2tJZF07XG5cbiAgICBpZiAoIWN1cnJlbnRUcmFjaykge1xuICAgICAgdGhpcy53YXJuKFwiSW52YWxpZCBzdWJ0aXRsZSB0cmFjayBpZCBcIiArIGlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VyRGV0YWlscyA9IGN1cnJlbnRUcmFjay5kZXRhaWxzO1xuICAgIGN1cnJlbnRUcmFjay5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIHRoaXMubG9nKFwic3VidGl0bGUgdHJhY2sgXCIgKyBpZCArIFwiIGxvYWRlZCBbXCIgKyBkZXRhaWxzLnN0YXJ0U04gKyBcIi1cIiArIGRldGFpbHMuZW5kU04gKyBcIl1cIik7XG5cbiAgICBpZiAoaWQgPT09IHRoaXMudHJhY2tJZCkge1xuICAgICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICAgIHRoaXMucGxheWxpc3RMb2FkZWQoaWQsIGRhdGEsIGN1ckRldGFpbHMpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25MZXZlbExvYWRpbmcgPSBmdW5jdGlvbiBvbkxldmVsTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTGV2ZWxTd2l0Y2hpbmcgPSBmdW5jdGlvbiBvbkxldmVsU3dpdGNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLmxldmVsKTtcbiAgfTtcblxuICBfcHJvdG8uc3dpdGNoTGV2ZWwgPSBmdW5jdGlvbiBzd2l0Y2hMZXZlbChsZXZlbEluZGV4KSB7XG4gICAgdmFyIGxldmVsSW5mbyA9IHRoaXMuaGxzLmxldmVsc1tsZXZlbEluZGV4XTtcblxuICAgIGlmICghKGxldmVsSW5mbyAhPT0gbnVsbCAmJiBsZXZlbEluZm8gIT09IHZvaWQgMCAmJiBsZXZlbEluZm8udGV4dEdyb3VwSWRzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZXh0R3JvdXBJZCA9IGxldmVsSW5mby50ZXh0R3JvdXBJZHNbbGV2ZWxJbmZvLnVybElkXTtcblxuICAgIGlmICh0aGlzLmdyb3VwSWQgIT09IHRleHRHcm91cElkKSB7XG4gICAgICB2YXIgbGFzdFRyYWNrID0gdGhpcy50cmFja3NJbkdyb3VwID8gdGhpcy50cmFja3NJbkdyb3VwW3RoaXMudHJhY2tJZF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgc3VidGl0bGVUcmFja3MgPSB0aGlzLnRyYWNrcy5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHJldHVybiAhdGV4dEdyb3VwSWQgfHwgdHJhY2suZ3JvdXBJZCA9PT0gdGV4dEdyb3VwSWQ7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IHN1YnRpdGxlVHJhY2tzO1xuICAgICAgdmFyIGluaXRpYWxUcmFja0lkID0gdGhpcy5maW5kVHJhY2tJZChsYXN0VHJhY2sgPT09IG51bGwgfHwgbGFzdFRyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0VHJhY2submFtZSkgfHwgdGhpcy5maW5kVHJhY2tJZCgpO1xuICAgICAgdGhpcy5ncm91cElkID0gdGV4dEdyb3VwSWQ7XG4gICAgICB2YXIgc3VidGl0bGVUcmFja3NVcGRhdGVkID0ge1xuICAgICAgICBzdWJ0aXRsZVRyYWNrczogc3VidGl0bGVUcmFja3NcbiAgICAgIH07XG4gICAgICB0aGlzLmxvZyhcIlVwZGF0aW5nIHN1YnRpdGxlIHRyYWNrcywgXCIgKyBzdWJ0aXRsZVRyYWNrcy5sZW5ndGggKyBcIiB0cmFjayhzKSBmb3VuZCBpbiBcXFwiXCIgKyB0ZXh0R3JvdXBJZCArIFwiXFxcIiBncm91cC1pZFwiKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCBzdWJ0aXRsZVRyYWNrc1VwZGF0ZWQpO1xuXG4gICAgICBpZiAoaW5pdGlhbFRyYWNrSWQgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuc2V0U3VidGl0bGVUcmFjayhpbml0aWFsVHJhY2tJZCwgbGFzdFRyYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmZpbmRUcmFja0lkID0gZnVuY3Rpb24gZmluZFRyYWNrSWQobmFtZSkge1xuICAgIHZhciB0ZXh0VHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0ZXh0VHJhY2tzW2ldO1xuXG4gICAgICBpZiAoIXRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrIHx8IHRyYWNrLmRlZmF1bHQpIHtcbiAgICAgICAgaWYgKCFuYW1lIHx8IG5hbWUgPT09IHRyYWNrLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJhY2suaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgX0Jhc2VQbGF5bGlzdENvbnRyb2xsLnByb3RvdHlwZS5vbkVycm9yLmNhbGwodGhpcywgZXZlbnQsIGRhdGEpO1xuXG4gICAgaWYgKGRhdGEuZmF0YWwgfHwgIWRhdGEuY29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmNvbnRleHQudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5TVUJUSVRMRV9UUkFDSyAmJiBkYXRhLmNvbnRleHQuaWQgPT09IHRoaXMudHJhY2tJZCAmJiBkYXRhLmNvbnRleHQuZ3JvdXBJZCA9PT0gdGhpcy5ncm91cElkKSB7XG4gICAgICB0aGlzLnJldHJ5TG9hZGluZ09yRmFpbChkYXRhKTtcbiAgICB9XG4gIH1cbiAgLyoqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdCAqKi9cbiAgO1xuXG4gIF9wcm90by5sb2FkUGxheWxpc3QgPSBmdW5jdGlvbiBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycykge1xuICAgIHZhciBjdXJyZW50VHJhY2sgPSB0aGlzLnRyYWNrc0luR3JvdXBbdGhpcy50cmFja0lkXTtcblxuICAgIGlmICh0aGlzLnNob3VsZExvYWRUcmFjayhjdXJyZW50VHJhY2spKSB7XG4gICAgICB2YXIgaWQgPSBjdXJyZW50VHJhY2suaWQ7XG4gICAgICB2YXIgZ3JvdXBJZCA9IGN1cnJlbnRUcmFjay5ncm91cElkO1xuICAgICAgdmFyIHVybCA9IGN1cnJlbnRUcmFjay51cmw7XG5cbiAgICAgIGlmIChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJsID0gaGxzVXJsUGFyYW1ldGVycy5hZGREaXJlY3RpdmVzKHVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy53YXJuKFwiQ291bGQgbm90IGNvbnN0cnVjdCBuZXcgVVJMIHdpdGggSExTIERlbGl2ZXJ5IERpcmVjdGl2ZXM6IFwiICsgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nKFwiTG9hZGluZyBzdWJ0aXRsZSBwbGF5bGlzdCBmb3IgaWQgXCIgKyBpZCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIGdyb3VwSWQ6IGdyb3VwSWQsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogaGxzVXJsUGFyYW1ldGVycyB8fCBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBvbGQgc3VidGl0bGVUcmFjayBhbmQgc2V0cyBjdXJyZW50IG1vZGUgb24gdGhlIG5leHQgc3VidGl0bGVUcmFjay5cbiAgICogVGhpcyBvcGVyYXRlcyBvbiB0aGUgRE9NIHRleHRUcmFja3MuXG4gICAqIEEgdmFsdWUgb2YgLTEgd2lsbCBkaXNhYmxlIGFsbCBzdWJ0aXRsZSB0cmFja3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvZ2dsZVRyYWNrTW9kZXMgPSBmdW5jdGlvbiB0b2dnbGVUcmFja01vZGVzKG5ld0lkKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICB0cmFja0lkID0gdGhpcy50cmFja0lkO1xuXG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZXh0VHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3MobWVkaWEudGV4dFRyYWNrcyk7XG4gICAgdmFyIGdyb3VwVHJhY2tzID0gdGV4dFRyYWNrcy5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2suZ3JvdXBJZCA9PT0gX3RoaXMyLmdyb3VwSWQ7XG4gICAgfSk7XG5cbiAgICBpZiAobmV3SWQgPT09IC0xKSB7XG4gICAgICBbXS5zbGljZS5jYWxsKHRleHRUcmFja3MpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbGRUcmFjayA9IGdyb3VwVHJhY2tzW3RyYWNrSWRdO1xuXG4gICAgICBpZiAob2xkVHJhY2spIHtcbiAgICAgICAgb2xkVHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5leHRUcmFjayA9IGdyb3VwVHJhY2tzW25ld0lkXTtcblxuICAgIGlmIChuZXh0VHJhY2spIHtcbiAgICAgIG5leHRUcmFjay5tb2RlID0gdGhpcy5zdWJ0aXRsZURpc3BsYXkgPyAnc2hvd2luZycgOiAnaGlkZGVuJztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHJlc3BvbnNpYmxlIGZvciB2YWxpZGF0aW5nIHRoZSBzdWJ0aXRsZSBpbmRleCBhbmQgcGVyaW9kaWNhbGx5IHJlbG9hZGluZyBpZiBsaXZlLlxuICAgKiBEaXNwYXRjaGVzIHRoZSBTVUJUSVRMRV9UUkFDS19TV0lUQ0ggZXZlbnQsIHdoaWNoIGluc3RydWN0cyB0aGUgc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIgdG8gbG9hZCB0aGUgc2VsZWN0ZWQgdHJhY2suXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNldFN1YnRpdGxlVHJhY2sgPSBmdW5jdGlvbiBzZXRTdWJ0aXRsZVRyYWNrKG5ld0lkLCBsYXN0VHJhY2spIHtcbiAgICB2YXIgX3RyYWNrcyRuZXdJZDtcblxuICAgIHZhciB0cmFja3MgPSB0aGlzLnRyYWNrc0luR3JvdXA7IC8vIHNldHRpbmcgdGhpcy5zdWJ0aXRsZVRyYWNrIHdpbGwgdHJpZ2dlciBpbnRlcm5hbCBsb2dpY1xuICAgIC8vIGlmIG1lZGlhIGhhcyBub3QgYmVlbiBhdHRhY2hlZCB5ZXQsIGl0IHdpbGwgZmFpbFxuICAgIC8vIHdlIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGRlZmF1bHQgdHJhY2sgaWRcbiAgICAvLyBhbmQgd2UnbGwgc2V0IHN1YnRpdGxlVHJhY2sgd2hlbiBvbk1lZGlhQXR0YWNoZWQgaXMgdHJpZ2dlcmVkXG5cbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gbmV3SWQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHJhY2tJZCAhPT0gbmV3SWQpIHtcbiAgICAgIHRoaXMudG9nZ2xlVHJhY2tNb2RlcyhuZXdJZCk7XG4gICAgfSAvLyBleGl0IGlmIHRyYWNrIGlkIGFzIGFscmVhZHkgc2V0IG9yIGludmFsaWRcblxuXG4gICAgaWYgKHRoaXMudHJhY2tJZCA9PT0gbmV3SWQgJiYgKG5ld0lkID09PSAtMSB8fCAoX3RyYWNrcyRuZXdJZCA9IHRyYWNrc1tuZXdJZF0pICE9PSBudWxsICYmIF90cmFja3MkbmV3SWQgIT09IHZvaWQgMCAmJiBfdHJhY2tzJG5ld0lkLmRldGFpbHMpIHx8IG5ld0lkIDwgLTEgfHwgbmV3SWQgPj0gdHJhY2tzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG5cblxuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIHZhciB0cmFjayA9IHRyYWNrc1tuZXdJZF07XG4gICAgdGhpcy5sb2coXCJTd2l0Y2hpbmcgdG8gc3VidGl0bGUgdHJhY2sgXCIgKyBuZXdJZCk7XG4gICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG5cbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHZhciBpZCA9IHRyYWNrLmlkLFxuICAgICAgICAgIF90cmFjayRncm91cElkID0gdHJhY2suZ3JvdXBJZCxcbiAgICAgICAgICBncm91cElkID0gX3RyYWNrJGdyb3VwSWQgPT09IHZvaWQgMCA/ICcnIDogX3RyYWNrJGdyb3VwSWQsXG4gICAgICAgICAgbmFtZSA9IHRyYWNrLm5hbWUsXG4gICAgICAgICAgdHlwZSA9IHRyYWNrLnR5cGUsXG4gICAgICAgICAgdXJsID0gdHJhY2sudXJsO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tfU1dJVENILCB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgdXJsOiB1cmxcbiAgICAgIH0pO1xuICAgICAgdmFyIGhsc1VybFBhcmFtZXRlcnMgPSB0aGlzLnN3aXRjaFBhcmFtcyh0cmFjay51cmwsIGxhc3RUcmFjayA9PT0gbnVsbCB8fCBsYXN0VHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RUcmFjay5kZXRhaWxzKTtcbiAgICAgIHRoaXMubG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzd2l0Y2ggdG8gLTFcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwge1xuICAgICAgICBpZDogbmV3SWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25UZXh0VHJhY2tzQ2hhbmdlZCA9IGZ1bmN0aW9uIG9uVGV4dFRyYWNrc0NoYW5nZWQoKSB7XG4gICAgaWYgKCF0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcpIHtcbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKTtcbiAgICB9IC8vIE1lZGlhIGlzIHVuZGVmaW5lZCB3aGVuIHN3aXRjaGluZyBzdHJlYW1zIHZpYSBsb2FkU291cmNlKClcblxuXG4gICAgaWYgKCF0aGlzLm1lZGlhIHx8ICF0aGlzLmhscy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrSWQgPSAtMTtcbiAgICB2YXIgdHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3ModGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcblxuICAgIGZvciAodmFyIGlkID0gMDsgaWQgPCB0cmFja3MubGVuZ3RoOyBpZCsrKSB7XG4gICAgICBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnaGlkZGVuJykge1xuICAgICAgICAvLyBEbyBub3QgYnJlYWsgaW4gY2FzZSB0aGVyZSBpcyBhIGZvbGxvd2luZyB0cmFjayB3aXRoIHNob3dpbmcuXG4gICAgICAgIHRyYWNrSWQgPSBpZDtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgdHJhY2tJZCA9IGlkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIFNldHRpbmcgY3VycmVudCBzdWJ0aXRsZVRyYWNrIHdpbGwgaW52b2tlIGNvZGUuXG5cblxuICAgIGlmICh0aGlzLnN1YnRpdGxlVHJhY2sgIT09IHRyYWNrSWQpIHtcbiAgICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IHRyYWNrSWQ7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwic3VidGl0bGVEaXNwbGF5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3VidGl0bGVEaXNwbGF5O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuX3N1YnRpdGxlRGlzcGxheSA9IHZhbHVlO1xuXG4gICAgICBpZiAodGhpcy50cmFja0lkID4gLTEpIHtcbiAgICAgICAgdGhpcy50b2dnbGVUcmFja01vZGVzKHRoaXMudHJhY2tJZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN1YnRpdGxlVHJhY2tzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFja3NJbkdyb3VwO1xuICAgIH1cbiAgICAvKiogZ2V0L3NldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGJhc2VkIG9uIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKSAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN1YnRpdGxlVHJhY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdJZCkge1xuICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgIHZhciBsYXN0VHJhY2sgPSB0aGlzLnRyYWNrc0luR3JvdXAgPyB0aGlzLnRyYWNrc0luR3JvdXBbdGhpcy50cmFja0lkXSA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuc2V0U3VidGl0bGVUcmFjayhuZXdJZCwgbGFzdFRyYWNrKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG59KF9iYXNlX3BsYXlsaXN0X2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0pO1xuXG5mdW5jdGlvbiBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyh0ZXh0VHJhY2tMaXN0KSB7XG4gIHZhciB0cmFja3MgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRUcmFja0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHJhY2sgPSB0ZXh0VHJhY2tMaXN0W2ldOyAvLyBFZGdlIGFkZHMgYSB0cmFjayB3aXRob3V0IGEgbGFiZWw7IHdlIGRvbid0IHdhbnQgdG8gdXNlIGl0XG5cbiAgICBpZiAodHJhY2sua2luZCA9PT0gJ3N1YnRpdGxlcycgJiYgdHJhY2subGFiZWwpIHtcbiAgICAgIHRyYWNrcy5wdXNoKHRleHRUcmFja0xpc3RbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cmFja3M7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoU3VidGl0bGVUcmFja0NvbnRyb2xsZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvdGltZWxpbmUtY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVGltZWxpbmVDb250cm9sbGVyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlRpbWVsaW5lQ29udHJvbGxlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRpbWVsaW5lQ29udHJvbGxlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jZWFfNjA4X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvY2VhLTYwOC1wYXJzZXIgKi8gXCIuL3NyYy91dGlscy9jZWEtNjA4LXBhcnNlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfb3V0cHV0X2ZpbHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvb3V0cHV0LWZpbHRlciAqLyBcIi4vc3JjL3V0aWxzL291dHB1dC1maWx0ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3dlYnZ0dF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3dlYnZ0dC1wYXJzZXIgKi8gXCIuL3NyYy91dGlscy93ZWJ2dHQtcGFyc2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3RleHR0cmFjay11dGlscyAqLyBcIi4vc3JjL3V0aWxzL3RleHR0cmFjay11dGlscy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfaW1zYzFfdHRtbF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2ltc2MxLXR0bWwtcGFyc2VyICovIFwiLi9zcmMvdXRpbHMvaW1zYzEtdHRtbC1wYXJzZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvbG9hZGVyICovIFwiLi9zcmMvdHlwZXMvbG9hZGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcblxuXG5cblxuXG5cblxuXG5cblxudmFyIFRpbWVsaW5lQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRpbWVsaW5lQ29udHJvbGxlcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuQ3VlcyA9IHZvaWQgMDtcbiAgICB0aGlzLnRleHRUcmFja3MgPSBbXTtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICAgIHRoaXMudGltZXNjYWxlID0gW107XG4gICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgdGhpcy5jYXB0aW9uc1RyYWNrcyA9IHt9O1xuICAgIHRoaXMubm9uTmF0aXZlQ2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgICB0aGlzLmNlYTYwOFBhcnNlcjEgPSB2b2lkIDA7XG4gICAgdGhpcy5jZWE2MDhQYXJzZXIyID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdFNuID0gLTE7XG4gICAgdGhpcy5sYXN0UGFydEluZGV4ID0gLTE7XG4gICAgdGhpcy5wcmV2Q0MgPSAtMTtcbiAgICB0aGlzLnZ0dENDcyA9IG5ld1ZUVENDcygpO1xuICAgIHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzID0gdm9pZCAwO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLkN1ZXMgPSBobHMuY29uZmlnLmN1ZUhhbmRsZXI7XG4gICAgdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXMgPSB7XG4gICAgICB0ZXh0VHJhY2sxOiB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazFMYWJlbCxcbiAgICAgICAgbGFuZ3VhZ2VDb2RlOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGVcbiAgICAgIH0sXG4gICAgICB0ZXh0VHJhY2syOiB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazJMYWJlbCxcbiAgICAgICAgbGFuZ3VhZ2VDb2RlOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGVcbiAgICAgIH0sXG4gICAgICB0ZXh0VHJhY2szOiB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazNMYWJlbCxcbiAgICAgICAgbGFuZ3VhZ2VDb2RlOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazNMYW5ndWFnZUNvZGVcbiAgICAgIH0sXG4gICAgICB0ZXh0VHJhY2s0OiB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazRMYWJlbCxcbiAgICAgICAgbGFuZ3VhZ2VDb2RlOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazRMYW5ndWFnZUNvZGVcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zKSB7XG4gICAgICB2YXIgY2hhbm5lbDEgPSBuZXcgX3V0aWxzX291dHB1dF9maWx0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0odGhpcywgJ3RleHRUcmFjazEnKTtcbiAgICAgIHZhciBjaGFubmVsMiA9IG5ldyBfdXRpbHNfb3V0cHV0X2ZpbHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSh0aGlzLCAndGV4dFRyYWNrMicpO1xuICAgICAgdmFyIGNoYW5uZWwzID0gbmV3IF91dGlsc19vdXRwdXRfZmlsdGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdKHRoaXMsICd0ZXh0VHJhY2szJyk7XG4gICAgICB2YXIgY2hhbm5lbDQgPSBuZXcgX3V0aWxzX291dHB1dF9maWx0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0odGhpcywgJ3RleHRUcmFjazQnKTtcbiAgICAgIHRoaXMuY2VhNjA4UGFyc2VyMSA9IG5ldyBfdXRpbHNfY2VhXzYwOF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0oMSwgY2hhbm5lbDEsIGNoYW5uZWwyKTtcbiAgICAgIHRoaXMuY2VhNjA4UGFyc2VyMiA9IG5ldyBfdXRpbHNfY2VhXzYwOF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0oMywgY2hhbm5lbDMsIGNoYW5uZWw0KTtcbiAgICB9XG5cbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nVXNlcmRhdGEsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19ERUNSWVBURUQsIHRoaXMub25GcmFnRGVjcnlwdGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLklOSVRfUFRTX0ZPVU5ELCB0aGlzLm9uSW5pdFB0c0ZvdW5kLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLU19DTEVBUkVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NDbGVhcmVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUaW1lbGluZUNvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nVXNlcmRhdGEsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfREVDUllQVEVELCB0aGlzLm9uRnJhZ0RlY3J5cHRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLU19DTEVBUkVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NDbGVhcmVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7IC8vIEB0cy1pZ25vcmVcblxuICAgIHRoaXMuaGxzID0gdGhpcy5jb25maWcgPSB0aGlzLmNlYTYwOFBhcnNlcjEgPSB0aGlzLmNlYTYwOFBhcnNlcjIgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5hZGRDdWVzID0gZnVuY3Rpb24gYWRkQ3Vlcyh0cmFja05hbWUsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuLCBjdWVSYW5nZXMpIHtcbiAgICAvLyBza2lwIGN1ZXMgd2hpY2ggb3ZlcmxhcCBtb3JlIHRoYW4gNTAlIHdpdGggcHJldmlvdXNseSBwYXJzZWQgdGltZSByYW5nZXNcbiAgICB2YXIgbWVyZ2VkID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gY3VlUmFuZ2VzLmxlbmd0aDsgaS0tOykge1xuICAgICAgdmFyIGN1ZVJhbmdlID0gY3VlUmFuZ2VzW2ldO1xuICAgICAgdmFyIG92ZXJsYXAgPSBpbnRlcnNlY3Rpb24oY3VlUmFuZ2VbMF0sIGN1ZVJhbmdlWzFdLCBzdGFydFRpbWUsIGVuZFRpbWUpO1xuXG4gICAgICBpZiAob3ZlcmxhcCA+PSAwKSB7XG4gICAgICAgIGN1ZVJhbmdlWzBdID0gTWF0aC5taW4oY3VlUmFuZ2VbMF0sIHN0YXJ0VGltZSk7XG4gICAgICAgIGN1ZVJhbmdlWzFdID0gTWF0aC5tYXgoY3VlUmFuZ2VbMV0sIGVuZFRpbWUpO1xuICAgICAgICBtZXJnZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChvdmVybGFwIC8gKGVuZFRpbWUgLSBzdGFydFRpbWUpID4gMC41KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFtZXJnZWQpIHtcbiAgICAgIGN1ZVJhbmdlcy5wdXNoKFtzdGFydFRpbWUsIGVuZFRpbWVdKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICB2YXIgdHJhY2sgPSB0aGlzLmNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICB0aGlzLkN1ZXMubmV3Q3VlKHRyYWNrLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdWVzID0gdGhpcy5DdWVzLm5ld0N1ZShudWxsLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5DVUVTX1BBUlNFRCwge1xuICAgICAgICB0eXBlOiAnY2FwdGlvbnMnLFxuICAgICAgICBjdWVzOiBjdWVzLFxuICAgICAgICB0cmFjazogdHJhY2tOYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH0gLy8gVHJpZ2dlcmVkIHdoZW4gYW4gaW5pdGlhbCBQVFMgaXMgZm91bmQ7IHVzZWQgZm9yIHN5bmNocm9uaXNhdGlvbiBvZiBXZWJWVFQuXG4gIDtcblxuICBfcHJvdG8ub25Jbml0UHRzRm91bmQgPSBmdW5jdGlvbiBvbkluaXRQdHNGb3VuZChldmVudCwgX3JlZikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZnJhZyA9IF9yZWYuZnJhZyxcbiAgICAgICAgaWQgPSBfcmVmLmlkLFxuICAgICAgICBpbml0UFRTID0gX3JlZi5pbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGUgPSBfcmVmLnRpbWVzY2FsZTtcbiAgICB2YXIgdW5wYXJzZWRWdHRGcmFncyA9IHRoaXMudW5wYXJzZWRWdHRGcmFncztcblxuICAgIGlmIChpZCA9PT0gJ21haW4nKSB7XG4gICAgICB0aGlzLmluaXRQVFNbZnJhZy5jY10gPSBpbml0UFRTO1xuICAgICAgdGhpcy50aW1lc2NhbGVbZnJhZy5jY10gPSB0aW1lc2NhbGU7XG4gICAgfSAvLyBEdWUgdG8gYXN5bmNocm9ub3VzIHByb2Nlc3NpbmcsIGluaXRpYWwgUFRTIG1heSBhcnJpdmUgbGF0ZXIgdGhhbiB0aGUgZmlyc3QgVlRUIGZyYWdtZW50cyBhcmUgbG9hZGVkLlxuICAgIC8vIFBhcnNlIGFueSB1bnBhcnNlZCBmcmFnbWVudHMgdXBvbiByZWNlaXZpbmcgdGhlIGluaXRpYWwgUFRTLlxuXG5cbiAgICBpZiAodW5wYXJzZWRWdHRGcmFncy5sZW5ndGgpIHtcbiAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xuICAgICAgdW5wYXJzZWRWdHRGcmFncy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgIF90aGlzLm9uRnJhZ0xvYWRlZChfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19MT0FERUQsIGZyYWcpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXRFeGlzdGluZ1RyYWNrID0gZnVuY3Rpb24gZ2V0RXhpc3RpbmdUcmFjayh0cmFja05hbWUpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhLnRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRleHRUcmFjayA9IG1lZGlhLnRleHRUcmFja3NbaV07XG5cbiAgICAgICAgaWYgKHRleHRUcmFja1t0cmFja05hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHRUcmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIF9wcm90by5jcmVhdGVDYXB0aW9uc1RyYWNrID0gZnVuY3Rpb24gY3JlYXRlQ2FwdGlvbnNUcmFjayh0cmFja05hbWUpIHtcbiAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICB0aGlzLmNyZWF0ZU5hdGl2ZVRyYWNrKHRyYWNrTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3JlYXRlTm9uTmF0aXZlVHJhY2sodHJhY2tOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNyZWF0ZU5hdGl2ZVRyYWNrID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlVHJhY2sodHJhY2tOYW1lKSB7XG4gICAgaWYgKHRoaXMuY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjYXB0aW9uc1Byb3BlcnRpZXMgPSB0aGlzLmNhcHRpb25zUHJvcGVydGllcyxcbiAgICAgICAgY2FwdGlvbnNUcmFja3MgPSB0aGlzLmNhcHRpb25zVHJhY2tzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgdmFyIF9jYXB0aW9uc1Byb3BlcnRpZXMkdCA9IGNhcHRpb25zUHJvcGVydGllc1t0cmFja05hbWVdLFxuICAgICAgICBsYWJlbCA9IF9jYXB0aW9uc1Byb3BlcnRpZXMkdC5sYWJlbCxcbiAgICAgICAgbGFuZ3VhZ2VDb2RlID0gX2NhcHRpb25zUHJvcGVydGllcyR0Lmxhbmd1YWdlQ29kZTsgLy8gRW5hYmxlIHJldXNlIG9mIGV4aXN0aW5nIHRleHQgdHJhY2suXG5cbiAgICB2YXIgZXhpc3RpbmdUcmFjayA9IHRoaXMuZ2V0RXhpc3RpbmdUcmFjayh0cmFja05hbWUpO1xuXG4gICAgaWYgKCFleGlzdGluZ1RyYWNrKSB7XG4gICAgICB2YXIgdGV4dFRyYWNrID0gdGhpcy5jcmVhdGVUZXh0VHJhY2soJ2NhcHRpb25zJywgbGFiZWwsIGxhbmd1YWdlQ29kZSk7XG5cbiAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgLy8gU2V0IGEgc3BlY2lhbCBwcm9wZXJ0eSBvbiB0aGUgdHJhY2sgc28gd2Uga25vdyBpdCdzIG1hbmFnZWQgYnkgSGxzLmpzXG4gICAgICAgIHRleHRUcmFja1t0cmFja05hbWVdID0gdHJ1ZTtcbiAgICAgICAgY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSA9IHRleHRUcmFjaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSA9IGV4aXN0aW5nVHJhY2s7XG4gICAgICBPYmplY3QoX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiY2xlYXJDdXJyZW50Q3Vlc1wiXSkoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSk7XG4gICAgICBPYmplY3QoX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wic2VuZEFkZFRyYWNrRXZlbnRcIl0pKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0sIG1lZGlhKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNyZWF0ZU5vbk5hdGl2ZVRyYWNrID0gZnVuY3Rpb24gY3JlYXRlTm9uTmF0aXZlVHJhY2sodHJhY2tOYW1lKSB7XG4gICAgaWYgKHRoaXMubm9uTmF0aXZlQ2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ3JlYXRlIGEgbGlzdCBvZiBhIHNpbmdsZSB0cmFjayBmb3IgdGhlIHByb3ZpZGVyIHRvIGNvbnN1bWVcblxuXG4gICAgdmFyIHRyYWNrUHJvcGVydGllcyA9IHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzW3RyYWNrTmFtZV07XG5cbiAgICBpZiAoIXRyYWNrUHJvcGVydGllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsYWJlbCA9IHRyYWNrUHJvcGVydGllcy5sYWJlbDtcbiAgICB2YXIgdHJhY2sgPSB7XG4gICAgICBfaWQ6IHRyYWNrTmFtZSxcbiAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgIGtpbmQ6ICdjYXB0aW9ucycsXG4gICAgICBkZWZhdWx0OiB0cmFja1Byb3BlcnRpZXMubWVkaWEgPyAhIXRyYWNrUHJvcGVydGllcy5tZWRpYS5kZWZhdWx0IDogZmFsc2UsXG4gICAgICBjbG9zZWRDYXB0aW9uczogdHJhY2tQcm9wZXJ0aWVzLm1lZGlhXG4gICAgfTtcbiAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSB0cmFjaztcbiAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5OT05fTkFUSVZFX1RFWFRfVFJBQ0tTX0ZPVU5ELCB7XG4gICAgICB0cmFja3M6IFt0cmFja11cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY3JlYXRlVGV4dFRyYWNrID0gZnVuY3Rpb24gY3JlYXRlVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5nKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcblxuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVkaWEuYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5nKTtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYUF0dGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcblxuICAgIHRoaXMuX2NsZWFuVHJhY2tzKCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHZhciBjYXB0aW9uc1RyYWNrcyA9IHRoaXMuY2FwdGlvbnNUcmFja3M7XG4gICAgT2JqZWN0LmtleXMoY2FwdGlvbnNUcmFja3MpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrTmFtZSkge1xuICAgICAgT2JqZWN0KF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImNsZWFyQ3VycmVudEN1ZXNcIl0pKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pO1xuICAgICAgZGVsZXRlIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV07XG4gICAgfSk7XG4gICAgdGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrcyA9IHt9O1xuICB9O1xuXG4gIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMubGFzdFNuID0gLTE7IC8vIERldGVjdCBkaXNjb250aW51aXR5IGluIGZyYWdtZW50IHBhcnNpbmdcblxuICAgIHRoaXMubGFzdFBhcnRJbmRleCA9IC0xO1xuICAgIHRoaXMucHJldkNDID0gLTE7XG4gICAgdGhpcy52dHRDQ3MgPSBuZXdWVFRDQ3MoKTsgLy8gRGV0ZWN0IGRpc2NvbnRpbnVpdHkgaW4gc3VidGl0bGUgbWFuaWZlc3RzXG5cbiAgICB0aGlzLl9jbGVhblRyYWNrcygpO1xuXG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG4gICAgdGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrcyA9IHt9O1xuICAgIHRoaXMudGV4dFRyYWNrcyA9IFtdO1xuICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IHRoaXMudW5wYXJzZWRWdHRGcmFncyB8fCBbXTtcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgICB0aGlzLnRpbWVzY2FsZSA9IFtdO1xuXG4gICAgaWYgKHRoaXMuY2VhNjA4UGFyc2VyMSAmJiB0aGlzLmNlYTYwOFBhcnNlcjIpIHtcbiAgICAgIHRoaXMuY2VhNjA4UGFyc2VyMS5yZXNldCgpO1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIyLnJlc2V0KCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fY2xlYW5UcmFja3MgPSBmdW5jdGlvbiBfY2xlYW5UcmFja3MoKSB7XG4gICAgLy8gY2xlYXIgb3V0ZGF0ZWQgc3VidGl0bGVzXG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcblxuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGV4dFRyYWNrcyA9IG1lZGlhLnRleHRUcmFja3M7XG5cbiAgICBpZiAodGV4dFRyYWNrcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9iamVjdChfdXRpbHNfdGV4dHRyYWNrX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJjbGVhckN1cnJlbnRDdWVzXCJdKSh0ZXh0VHJhY2tzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkID0gZnVuY3Rpb24gb25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHRoaXMudGV4dFRyYWNrcyA9IFtdO1xuICAgIHZhciB0cmFja3MgPSBkYXRhLnN1YnRpdGxlVHJhY2tzIHx8IFtdO1xuICAgIHZhciBoYXNJTVNDMSA9IHRyYWNrcy5zb21lKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrLnRleHRDb2RlYyA9PT0gX3V0aWxzX2ltc2MxX3R0bWxfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJJTVNDMV9DT0RFQ1wiXTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVXZWJWVFQgfHwgaGFzSU1TQzEgJiYgdGhpcy5jb25maWcuZW5hYmxlSU1TQzEpIHtcbiAgICAgIHZhciBzYW1lVHJhY2tzID0gdGhpcy50cmFja3MgJiYgdHJhY2tzICYmIHRoaXMudHJhY2tzLmxlbmd0aCA9PT0gdHJhY2tzLmxlbmd0aDtcbiAgICAgIHRoaXMudHJhY2tzID0gdHJhY2tzIHx8IFtdO1xuXG4gICAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICAgIHZhciBpblVzZVRyYWNrcyA9IHRoaXMubWVkaWEgPyB0aGlzLm1lZGlhLnRleHRUcmFja3MgOiBbXTtcbiAgICAgICAgdGhpcy50cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2ssIGluZGV4KSB7XG4gICAgICAgICAgdmFyIHRleHRUcmFjaztcblxuICAgICAgICAgIGlmIChpbmRleCA8IGluVXNlVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGluVXNlVHJhY2sgPSBudWxsO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluVXNlVHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChjYW5SZXVzZVZ0dFRleHRUcmFjayhpblVzZVRyYWNrc1tpXSwgdHJhY2spKSB7XG4gICAgICAgICAgICAgICAgaW5Vc2VUcmFjayA9IGluVXNlVHJhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIFJldXNlIHRyYWNrcyB3aXRoIHRoZSBzYW1lIGxhYmVsLCBidXQgZG8gbm90IHJldXNlIDYwOC83MDggdHJhY2tzXG5cblxuICAgICAgICAgICAgaWYgKGluVXNlVHJhY2spIHtcbiAgICAgICAgICAgICAgdGV4dFRyYWNrID0gaW5Vc2VUcmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGV4dFRyYWNrKSB7XG4gICAgICAgICAgICBPYmplY3QoX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiY2xlYXJDdXJyZW50Q3Vlc1wiXSkodGV4dFRyYWNrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dFRyYWNrID0gX3RoaXMyLmNyZWF0ZVRleHRUcmFjaygnc3VidGl0bGVzJywgdHJhY2submFtZSwgdHJhY2subGFuZyk7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgICAgICAgdGV4dFRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgICAgIHRleHRUcmFjay5ncm91cElkID0gdHJhY2suZ3JvdXBJZDtcblxuICAgICAgICAgICAgX3RoaXMyLnRleHRUcmFja3MucHVzaCh0ZXh0VHJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKCFzYW1lVHJhY2tzICYmIHRoaXMudHJhY2tzICYmIHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAvLyBDcmVhdGUgYSBsaXN0IG9mIHRyYWNrcyBmb3IgdGhlIHByb3ZpZGVyIHRvIGNvbnN1bWVcbiAgICAgICAgdmFyIHRyYWNrc0xpc3QgPSB0aGlzLnRyYWNrcy5tYXAoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsOiB0cmFjay5uYW1lLFxuICAgICAgICAgICAga2luZDogdHJhY2sudHlwZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJhY2suZGVmYXVsdCxcbiAgICAgICAgICAgIHN1YnRpdGxlVHJhY2s6IHRyYWNrXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkQsIHtcbiAgICAgICAgICB0cmFja3M6IHRyYWNrc0xpc3RcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbk1hbmlmZXN0TG9hZGVkID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zICYmIGRhdGEuY2FwdGlvbnMpIHtcbiAgICAgIGRhdGEuY2FwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoY2FwdGlvbnNUcmFjaykge1xuICAgICAgICB2YXIgaW5zdHJlYW1JZE1hdGNoID0gLyg/OkNDfFNFUlZJQ0UpKFsxLTRdKS8uZXhlYyhjYXB0aW9uc1RyYWNrLmluc3RyZWFtSWQpO1xuXG4gICAgICAgIGlmICghaW5zdHJlYW1JZE1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYWNrTmFtZSA9IFwidGV4dFRyYWNrXCIgKyBpbnN0cmVhbUlkTWF0Y2hbMV07XG4gICAgICAgIHZhciB0cmFja1Byb3BlcnRpZXMgPSBfdGhpczMuY2FwdGlvbnNQcm9wZXJ0aWVzW3RyYWNrTmFtZV07XG5cbiAgICAgICAgaWYgKCF0cmFja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0cmFja1Byb3BlcnRpZXMubGFiZWwgPSBjYXB0aW9uc1RyYWNrLm5hbWU7XG5cbiAgICAgICAgaWYgKGNhcHRpb25zVHJhY2subGFuZykge1xuICAgICAgICAgIC8vIG9wdGlvbmFsIGF0dHJpYnV0ZVxuICAgICAgICAgIHRyYWNrUHJvcGVydGllcy5sYW5ndWFnZUNvZGUgPSBjYXB0aW9uc1RyYWNrLmxhbmc7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFja1Byb3BlcnRpZXMubWVkaWEgPSBjYXB0aW9uc1RyYWNrO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkZyYWdMb2FkaW5nID0gZnVuY3Rpb24gb25GcmFnTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHZhciBjZWE2MDhQYXJzZXIxID0gdGhpcy5jZWE2MDhQYXJzZXIxLFxuICAgICAgICBjZWE2MDhQYXJzZXIyID0gdGhpcy5jZWE2MDhQYXJzZXIyLFxuICAgICAgICBsYXN0U24gPSB0aGlzLmxhc3RTbixcbiAgICAgICAgbGFzdFBhcnRJbmRleCA9IHRoaXMubGFzdFBhcnRJbmRleDtcblxuICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICEoY2VhNjA4UGFyc2VyMSAmJiBjZWE2MDhQYXJzZXIyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaWYgdGhpcyBmcmFnIGlzbid0IGNvbnRpZ3VvdXMsIGNsZWFyIHRoZSBwYXJzZXIgc28gY3VlcyB3aXRoIGJhZCBzdGFydC9lbmQgdGltZXMgYXJlbid0IGFkZGVkIHRvIHRoZSB0ZXh0VHJhY2tcblxuXG4gICAgaWYgKGRhdGEuZnJhZy50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5NQUlOKSB7XG4gICAgICB2YXIgX2RhdGEkcGFydCRpbmRleCwgX2RhdGEkcGFydDtcblxuICAgICAgdmFyIHNuID0gZGF0YS5mcmFnLnNuO1xuICAgICAgdmFyIHBhcnRJbmRleCA9IChfZGF0YSRwYXJ0JGluZGV4ID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2RhdGEkcGFydCA9IGRhdGEucGFydCkgPT09IG51bGwgfHwgX2RhdGEkcGFydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RhdGEkcGFydC5pbmRleCkgIT0gbnVsbCA/IF9kYXRhJHBhcnQkaW5kZXggOiAtMTtcblxuICAgICAgaWYgKCEoc24gPT09IGxhc3RTbiArIDEgfHwgc24gPT09IGxhc3RTbiAmJiBwYXJ0SW5kZXggPT09IGxhc3RQYXJ0SW5kZXggKyAxKSkge1xuICAgICAgICBjZWE2MDhQYXJzZXIxLnJlc2V0KCk7XG4gICAgICAgIGNlYTYwOFBhcnNlcjIucmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0U24gPSBzbjtcbiAgICAgIHRoaXMubGFzdFBhcnRJbmRleCA9IHBhcnRJbmRleDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ0xvYWRlZCA9IGZ1bmN0aW9uIG9uRnJhZ0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgIHZhciBpbml0UFRTID0gdGhpcy5pbml0UFRTLFxuICAgICAgICB1bnBhcnNlZFZ0dEZyYWdzID0gdGhpcy51bnBhcnNlZFZ0dEZyYWdzO1xuXG4gICAgaWYgKGZyYWcudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uU1VCVElUTEUpIHtcbiAgICAgIC8vIElmIGZyYWdtZW50IGlzIHN1YnRpdGxlIHR5cGUsIHBhcnNlIGFzIFdlYlZUVC5cbiAgICAgIGlmIChwYXlsb2FkLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgLy8gV2UgbmVlZCBhbiBpbml0aWFsIHN5bmNocm9uaXNhdGlvbiBQVFMuIFN0b3JlIGZyYWdtZW50cyBhcyBsb25nIGFzIG5vbmUgaGFzIGFycml2ZWQuXG4gICAgICAgIGlmICghT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShpbml0UFRTW2ZyYWcuY2NdKSkge1xuICAgICAgICAgIHVucGFyc2VkVnR0RnJhZ3MucHVzaChkYXRhKTtcblxuICAgICAgICAgIGlmIChpbml0UFRTLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gZmluaXNoIHVuc3VjY2Vzc2Z1bGx5LCBvdGhlcndpc2UgdGhlIHN1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyIGNvdWxkIGJlIGJsb2NrZWQgZnJvbSBsb2FkaW5nIG5ldyBmcmFncy5cbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdNaXNzaW5nIGluaXRpYWwgc3VidGl0bGUgUFRTJylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWNyeXB0RGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7IC8vIGZyYWdtZW50IGFmdGVyIGRlY3J5cHRpb24gaGFzIGEgc3RhdHMgb2JqZWN0XG5cbiAgICAgICAgdmFyIGRlY3J5cHRlZCA9ICgnc3RhdHMnIGluIGRhdGEpOyAvLyBJZiB0aGUgc3VidGl0bGVzIGFyZSBub3QgZW5jcnlwdGVkLCBwYXJzZSBWVFRzIG5vdy4gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIHdhaXQuXG5cbiAgICAgICAgaWYgKGRlY3J5cHREYXRhID09IG51bGwgfHwgZGVjcnlwdERhdGEua2V5ID09IG51bGwgfHwgZGVjcnlwdERhdGEubWV0aG9kICE9PSAnQUVTLTEyOCcgfHwgZGVjcnlwdGVkKSB7XG4gICAgICAgICAgdmFyIHRyYWNrUGxheWxpc3RNZWRpYSA9IHRoaXMudHJhY2tzW2ZyYWcubGV2ZWxdO1xuICAgICAgICAgIHZhciB2dHRDQ3MgPSB0aGlzLnZ0dENDcztcblxuICAgICAgICAgIGlmICghdnR0Q0NzW2ZyYWcuY2NdKSB7XG4gICAgICAgICAgICB2dHRDQ3NbZnJhZy5jY10gPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBmcmFnLnN0YXJ0LFxuICAgICAgICAgICAgICBwcmV2Q0M6IHRoaXMucHJldkNDLFxuICAgICAgICAgICAgICBuZXc6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnByZXZDQyA9IGZyYWcuY2M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRyYWNrUGxheWxpc3RNZWRpYSAmJiB0cmFja1BsYXlsaXN0TWVkaWEudGV4dENvZGVjID09PSBfdXRpbHNfaW1zYzFfdHRtbF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIklNU0MxX0NPREVDXCJdKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUlNU0MxKGZyYWcsIHBheWxvYWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVZUVHMoZnJhZywgcGF5bG9hZCwgdnR0Q0NzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlcmUgaXMgbm8gcGF5bG9hZCwgZmluaXNoIHVuc3VjY2Vzc2Z1bGx5LlxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignRW1wdHkgc3VidGl0bGUgcGF5bG9hZCcpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX3BhcnNlSU1TQzEgPSBmdW5jdGlvbiBfcGFyc2VJTVNDMShmcmFnLCBwYXlsb2FkKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgT2JqZWN0KF91dGlsc19pbXNjMV90dG1sX3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wicGFyc2VJTVNDMVwiXSkocGF5bG9hZCwgdGhpcy5pbml0UFRTW2ZyYWcuY2NdLCB0aGlzLnRpbWVzY2FsZVtmcmFnLmNjXSwgZnVuY3Rpb24gKGN1ZXMpIHtcbiAgICAgIF90aGlzNC5fYXBwZW5kQ3VlcyhjdWVzLCBmcmFnLmxldmVsKTtcblxuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGZyYWc6IGZyYWdcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wibG9nZ2VyXCJdLmxvZyhcIkZhaWxlZCB0byBwYXJzZSBJTVNDMTogXCIgKyBlcnJvcik7XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLl9wYXJzZVZUVHMgPSBmdW5jdGlvbiBfcGFyc2VWVFRzKGZyYWcsIHBheWxvYWQsIHZ0dENDcykge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgdmFyIGhscyA9IHRoaXMuaGxzOyAvLyBQYXJzZSB0aGUgV2ViVlRUIGZpbGUgY29udGVudHMuXG5cbiAgICBPYmplY3QoX3V0aWxzX3dlYnZ0dF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcInBhcnNlV2ViVlRUXCJdKShwYXlsb2FkLCB0aGlzLmluaXRQVFNbZnJhZy5jY10sIHRoaXMudGltZXNjYWxlW2ZyYWcuY2NdLCB2dHRDQ3MsIGZyYWcuY2MsIGZyYWcuc3RhcnQsIGZ1bmN0aW9uIChjdWVzKSB7XG4gICAgICBfdGhpczUuX2FwcGVuZEN1ZXMoY3VlcywgZnJhZy5sZXZlbCk7XG5cbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBmcmFnOiBmcmFnXG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIF90aGlzNS5fZmFsbGJhY2tUb0lNU0MxKGZyYWcsIHBheWxvYWQpOyAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBwYXJzaW5nLiBUcmlnZ2VyIGV2ZW50IHdpdGggc3VjY2VzcyBmYWxzZS5cblxuXG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJsb2dnZXJcIl0ubG9nKFwiRmFpbGVkIHRvIHBhcnNlIFZUVCBjdWU6IFwiICsgZXJyb3IpO1xuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5fZmFsbGJhY2tUb0lNU0MxID0gZnVuY3Rpb24gX2ZhbGxiYWNrVG9JTVNDMShmcmFnLCBwYXlsb2FkKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAvLyBJZiB0ZXh0Q29kZWMgaXMgdW5rbm93biwgdHJ5IHBhcnNpbmcgYXMgSU1TQzEuIFNldCB0ZXh0Q29kZWMgYmFzZWQgb24gdGhlIHJlc3VsdFxuICAgIHZhciB0cmFja1BsYXlsaXN0TWVkaWEgPSB0aGlzLnRyYWNrc1tmcmFnLmxldmVsXTtcblxuICAgIGlmICghdHJhY2tQbGF5bGlzdE1lZGlhLnRleHRDb2RlYykge1xuICAgICAgT2JqZWN0KF91dGlsc19pbXNjMV90dG1sX3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wicGFyc2VJTVNDMVwiXSkocGF5bG9hZCwgdGhpcy5pbml0UFRTW2ZyYWcuY2NdLCB0aGlzLnRpbWVzY2FsZVtmcmFnLmNjXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0cmFja1BsYXlsaXN0TWVkaWEudGV4dENvZGVjID0gX3V0aWxzX2ltc2MxX3R0bWxfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJJTVNDMV9DT0RFQ1wiXTtcblxuICAgICAgICBfdGhpczYuX3BhcnNlSU1TQzEoZnJhZywgcGF5bG9hZCk7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMgPSAnd3Z0dCc7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9hcHBlbmRDdWVzID0gZnVuY3Rpb24gX2FwcGVuZEN1ZXMoY3VlcywgZnJhZ0xldmVsKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgdmFyIHRleHRUcmFjayA9IHRoaXMudGV4dFRyYWNrc1tmcmFnTGV2ZWxdOyAvLyBXZWJWVFRQYXJzZXIucGFyc2UgaXMgYW4gYXN5bmMgbWV0aG9kIGFuZCBpZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRleHQgdHJhY2sgbW9kZSBpcyBzZXQgdG8gXCJkaXNhYmxlZFwiXG4gICAgICAvLyBiZWZvcmUgcGFyc2luZyBpcyBkb25lIHRoZW4gZG9uJ3QgdHJ5IHRvIGFjY2VzcyBjdXJyZW50VHJhY2suY3Vlcy5nZXRDdWVCeUlkIGFzIGN1ZXMgd2lsbCBiZSBudWxsXG4gICAgICAvLyBhbmQgdHJ5aW5nIHRvIGFjY2VzcyBnZXRDdWVCeUlkIG1ldGhvZCBvZiBjdWVzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uXG4gICAgICAvLyBCZWNhdXNlIHdlIGNoZWNrIGlmIHRoZSBtb2RlIGlzIGRpc2FibGVkLCB3ZSBjYW4gZm9yY2UgY2hlY2sgYGN1ZXNgIGJlbG93LiBUaGV5IGNhbid0IGJlIG51bGwuXG5cbiAgICAgIGlmICghdGV4dFRyYWNrIHx8IHRleHRUcmFjay5tb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3Vlcy5mb3JFYWNoKGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdChfdXRpbHNfdGV4dHRyYWNrX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJhZGRDdWVUb1RyYWNrXCJdKSh0ZXh0VHJhY2ssIGN1ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGN1cnJlbnRUcmFjayA9IHRoaXMudHJhY2tzW2ZyYWdMZXZlbF07XG5cbiAgICAgIGlmICghY3VycmVudFRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYWNrID0gY3VycmVudFRyYWNrLmRlZmF1bHQgPyAnZGVmYXVsdCcgOiAnc3VidGl0bGVzJyArIGZyYWdMZXZlbDtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5DVUVTX1BBUlNFRCwge1xuICAgICAgICB0eXBlOiAnc3VidGl0bGVzJyxcbiAgICAgICAgY3VlczogY3VlcyxcbiAgICAgICAgdHJhY2s6IHRyYWNrXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ0RlY3J5cHRlZCA9IGZ1bmN0aW9uIG9uRnJhZ0RlY3J5cHRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuXG4gICAgaWYgKGZyYWcudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uU1VCVElUTEUpIHtcbiAgICAgIGlmICghT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKSh0aGlzLmluaXRQVFNbZnJhZy5jY10pKSB7XG4gICAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncy5wdXNoKGRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMub25GcmFnTG9hZGVkKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vblN1YnRpdGxlVHJhY2tzQ2xlYXJlZCA9IGZ1bmN0aW9uIG9uU3VidGl0bGVUcmFja3NDbGVhcmVkKCkge1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5jYXB0aW9uc1RyYWNrcyA9IHt9O1xuICB9O1xuXG4gIF9wcm90by5vbkZyYWdQYXJzaW5nVXNlcmRhdGEgPSBmdW5jdGlvbiBvbkZyYWdQYXJzaW5nVXNlcmRhdGEoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgY2VhNjA4UGFyc2VyMSA9IHRoaXMuY2VhNjA4UGFyc2VyMSxcbiAgICAgICAgY2VhNjA4UGFyc2VyMiA9IHRoaXMuY2VhNjA4UGFyc2VyMjtcblxuICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICEoY2VhNjA4UGFyc2VyMSAmJiBjZWE2MDhQYXJzZXIyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSWYgdGhlIGV2ZW50IGNvbnRhaW5zIGNhcHRpb25zIChmb3VuZCBpbiB0aGUgYnl0ZXMgcHJvcGVydHkpLCBwdXNoIGFsbCBieXRlcyBpbnRvIHRoZSBwYXJzZXIgaW1tZWRpYXRlbHlcbiAgICAvLyBJdCB3aWxsIGNyZWF0ZSB0aGUgcHJvcGVyIHRpbWVzdGFtcHMgYmFzZWQgb24gdGhlIFBUUyB2YWx1ZVxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNjQnl0ZXMgPSBkYXRhLnNhbXBsZXNbaV0uYnl0ZXM7XG5cbiAgICAgIGlmIChjY0J5dGVzKSB7XG4gICAgICAgIHZhciBjY2RhdGFzID0gdGhpcy5leHRyYWN0Q2VhNjA4RGF0YShjY0J5dGVzKTtcbiAgICAgICAgY2VhNjA4UGFyc2VyMS5hZGREYXRhKGRhdGEuc2FtcGxlc1tpXS5wdHMsIGNjZGF0YXNbMF0pO1xuICAgICAgICBjZWE2MDhQYXJzZXIyLmFkZERhdGEoZGF0YS5zYW1wbGVzW2ldLnB0cywgY2NkYXRhc1sxXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkJ1ZmZlckZsdXNoaW5nID0gZnVuY3Rpb24gb25CdWZmZXJGbHVzaGluZyhldmVudCwgX3JlZjIpIHtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSBfcmVmMi5zdGFydE9mZnNldCxcbiAgICAgICAgZW5kT2Zmc2V0ID0gX3JlZjIuZW5kT2Zmc2V0LFxuICAgICAgICBlbmRPZmZzZXRTdWJ0aXRsZXMgPSBfcmVmMi5lbmRPZmZzZXRTdWJ0aXRsZXMsXG4gICAgICAgIHR5cGUgPSBfcmVmMi50eXBlO1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG5cbiAgICBpZiAoIW1lZGlhIHx8IG1lZGlhLmN1cnJlbnRUaW1lIDwgZW5kT2Zmc2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDbGVhciA2MDggY2FwdGlvbiBjdWVzIGZyb20gdGhlIGNhcHRpb25zIFRleHRUcmFja3Mgd2hlbiB0aGUgdmlkZW8gYmFjayBidWZmZXIgaXMgZmx1c2hlZFxuICAgIC8vIEZvcndhcmQgY3VlcyBhcmUgbmV2ZXIgcmVtb3ZlZCBiZWNhdXNlIHdlIGNhbiBsb29zZSBzdHJlYW1lZCA2MDggY29udGVudCBmcm9tIHJlY2VudCBmcmFnbWVudHNcblxuXG4gICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgIHZhciBjYXB0aW9uc1RyYWNrcyA9IHRoaXMuY2FwdGlvbnNUcmFja3M7XG4gICAgICBPYmplY3Qua2V5cyhjYXB0aW9uc1RyYWNrcykuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QoX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wicmVtb3ZlQ3Vlc0luUmFuZ2VcIl0pKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0sIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgLy8gQ2xlYXIgVlRUL0lNU0MxIHN1YnRpdGxlIGN1ZXMgZnJvbSB0aGUgc3VidGl0bGUgVGV4dFRyYWNrcyB3aGVuIHRoZSBiYWNrIGJ1ZmZlciBpcyBmbHVzaGVkXG4gICAgICBpZiAoc3RhcnRPZmZzZXQgPT09IDAgJiYgZW5kT2Zmc2V0U3VidGl0bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHRleHRUcmFja3MgPSB0aGlzLnRleHRUcmFja3M7XG4gICAgICAgIE9iamVjdC5rZXlzKHRleHRUcmFja3MpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrTmFtZSkge1xuICAgICAgICAgIHJldHVybiBPYmplY3QoX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wicmVtb3ZlQ3Vlc0luUmFuZ2VcIl0pKHRleHRUcmFja3NbdHJhY2tOYW1lXSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldFN1YnRpdGxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZXh0cmFjdENlYTYwOERhdGEgPSBmdW5jdGlvbiBleHRyYWN0Q2VhNjA4RGF0YShieXRlQXJyYXkpIHtcbiAgICB2YXIgYWN0dWFsQ0NCeXRlcyA9IFtbXSwgW11dO1xuICAgIHZhciBjb3VudCA9IGJ5dGVBcnJheVswXSAmIDB4MWY7XG4gICAgdmFyIHBvc2l0aW9uID0gMjtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgdmFyIHRtcEJ5dGUgPSBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICB2YXIgY2NieXRlMSA9IDB4N2YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICB2YXIgY2NieXRlMiA9IDB4N2YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG5cbiAgICAgIGlmIChjY2J5dGUxID09PSAwICYmIGNjYnl0ZTIgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjY1ZhbGlkID0gKDB4MDQgJiB0bXBCeXRlKSAhPT0gMDsgLy8gU3VwcG9ydCBhbGwgZm91ciBjaGFubmVsc1xuXG4gICAgICBpZiAoY2NWYWxpZCkge1xuICAgICAgICB2YXIgY2NUeXBlID0gMHgwMyAmIHRtcEJ5dGU7XG5cbiAgICAgICAgaWYgKDB4MDBcbiAgICAgICAgLyogQ0VBNjA4IGZpZWxkMSovXG4gICAgICAgID09PSBjY1R5cGUgfHwgMHgwMVxuICAgICAgICAvKiBDRUE2MDggZmllbGQyKi9cbiAgICAgICAgPT09IGNjVHlwZSkge1xuICAgICAgICAgIC8vIEV4Y2x1ZGUgQ0VBNzA4IENDIGRhdGEuXG4gICAgICAgICAgYWN0dWFsQ0NCeXRlc1tjY1R5cGVdLnB1c2goY2NieXRlMSk7XG4gICAgICAgICAgYWN0dWFsQ0NCeXRlc1tjY1R5cGVdLnB1c2goY2NieXRlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWN0dWFsQ0NCeXRlcztcbiAgfTtcblxuICByZXR1cm4gVGltZWxpbmVDb250cm9sbGVyO1xufSgpO1xuXG5mdW5jdGlvbiBjYW5SZXVzZVZ0dFRleHRUcmFjayhpblVzZVRyYWNrLCBtYW5pZmVzdFRyYWNrKSB7XG4gIHJldHVybiBpblVzZVRyYWNrICYmIGluVXNlVHJhY2subGFiZWwgPT09IG1hbmlmZXN0VHJhY2submFtZSAmJiAhKGluVXNlVHJhY2sudGV4dFRyYWNrMSB8fCBpblVzZVRyYWNrLnRleHRUcmFjazIpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oeDEsIHgyLCB5MSwgeTIpIHtcbiAgcmV0dXJuIE1hdGgubWluKHgyLCB5MikgLSBNYXRoLm1heCh4MSwgeTEpO1xufVxuXG5mdW5jdGlvbiBuZXdWVFRDQ3MoKSB7XG4gIHJldHVybiB7XG4gICAgY2NPZmZzZXQ6IDAsXG4gICAgcHJlc2VudGF0aW9uT2Zmc2V0OiAwLFxuICAgIDA6IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgcHJldkNDOiAtMSxcbiAgICAgIG5ldzogZmFsc2VcbiAgICB9XG4gIH07XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NyeXB0L2Flcy1jcnlwdG8udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jcnlwdC9hZXMtY3J5cHRvLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQUVTQ3J5cHRvOyB9KTtcbnZhciBBRVNDcnlwdG8gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBRVNDcnlwdG8oc3VidGxlLCBpdikge1xuICAgIHRoaXMuc3VidGxlID0gdm9pZCAwO1xuICAgIHRoaXMuYWVzSVYgPSB2b2lkIDA7XG4gICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGU7XG4gICAgdGhpcy5hZXNJViA9IGl2O1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEFFU0NyeXB0by5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlY3J5cHQgPSBmdW5jdGlvbiBkZWNyeXB0KGRhdGEsIGtleSkge1xuICAgIHJldHVybiB0aGlzLnN1YnRsZS5kZWNyeXB0KHtcbiAgICAgIG5hbWU6ICdBRVMtQ0JDJyxcbiAgICAgIGl2OiB0aGlzLmFlc0lWXG4gICAgfSwga2V5LCBkYXRhKTtcbiAgfTtcblxuICByZXR1cm4gQUVTQ3J5cHRvO1xufSgpO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY3J5cHQvYWVzLWRlY3J5cHRvci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NyeXB0L2Flcy1kZWNyeXB0b3IudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiByZW1vdmVQYWRkaW5nLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInJlbW92ZVBhZGRpbmdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZW1vdmVQYWRkaW5nOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQUVTRGVjcnlwdG9yOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdHlwZWRfYXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3R5cGVkLWFycmF5ICovIFwiLi9zcmMvdXRpbHMvdHlwZWQtYXJyYXkudHNcIik7XG4gLy8gUEtDUzdcblxuZnVuY3Rpb24gcmVtb3ZlUGFkZGluZyhhcnJheSkge1xuICB2YXIgb3V0cHV0Qnl0ZXMgPSBhcnJheS5ieXRlTGVuZ3RoO1xuICB2YXIgcGFkZGluZ0J5dGVzID0gb3V0cHV0Qnl0ZXMgJiYgbmV3IERhdGFWaWV3KGFycmF5LmJ1ZmZlcikuZ2V0VWludDgob3V0cHV0Qnl0ZXMgLSAxKTtcblxuICBpZiAocGFkZGluZ0J5dGVzKSB7XG4gICAgcmV0dXJuIE9iamVjdChfdXRpbHNfdHlwZWRfYXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInNsaWNlVWludDhcIl0pKGFycmF5LCAwLCBvdXRwdXRCeXRlcyAtIHBhZGRpbmdCeXRlcyk7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG5cbnZhciBBRVNEZWNyeXB0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBRVNEZWNyeXB0b3IoKSB7XG4gICAgdGhpcy5yY29uID0gWzB4MCwgMHgxLCAweDIsIDB4NCwgMHg4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcbiAgICB0aGlzLnN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KV07XG4gICAgdGhpcy5pbnZTdWJNaXggPSBbbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NildO1xuICAgIHRoaXMuc0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHRoaXMuaW52U0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHRoaXMua2V5ID0gbmV3IFVpbnQzMkFycmF5KDApO1xuICAgIHRoaXMua3NSb3dzID0gMDtcbiAgICB0aGlzLmtleVNpemUgPSAwO1xuICAgIHRoaXMua2V5U2NoZWR1bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5pbnZLZXlTY2hlZHVsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRUYWJsZSgpO1xuICB9IC8vIFVzaW5nIHZpZXcuZ2V0VWludDMyKCkgYWxzbyBzd2FwcyB0aGUgYnl0ZSBvcmRlci5cblxuXG4gIHZhciBfcHJvdG8gPSBBRVNEZWNyeXB0b3IucHJvdG90eXBlO1xuXG4gIF9wcm90by51aW50OEFycmF5VG9VaW50MzJBcnJheV8gPSBmdW5jdGlvbiB1aW50OEFycmF5VG9VaW50MzJBcnJheV8oYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgdmFyIG5ld0FycmF5ID0gbmV3IFVpbnQzMkFycmF5KDQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIG5ld0FycmF5W2ldID0gdmlldy5nZXRVaW50MzIoaSAqIDQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfTtcblxuICBfcHJvdG8uaW5pdFRhYmxlID0gZnVuY3Rpb24gaW5pdFRhYmxlKCkge1xuICAgIHZhciBzQm94ID0gdGhpcy5zQm94O1xuICAgIHZhciBpbnZTQm94ID0gdGhpcy5pbnZTQm94O1xuICAgIHZhciBzdWJNaXggPSB0aGlzLnN1Yk1peDtcbiAgICB2YXIgc3ViTWl4MCA9IHN1Yk1peFswXTtcbiAgICB2YXIgc3ViTWl4MSA9IHN1Yk1peFsxXTtcbiAgICB2YXIgc3ViTWl4MiA9IHN1Yk1peFsyXTtcbiAgICB2YXIgc3ViTWl4MyA9IHN1Yk1peFszXTtcbiAgICB2YXIgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgdmFyIGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgdmFyIGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgdmFyIGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgdmFyIGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG4gICAgdmFyIGQgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHhpID0gMDtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGlmIChpIDwgMTI4KSB7XG4gICAgICAgIGRbaV0gPSBpIDw8IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkW2ldID0gaSA8PCAxIF4gMHgxMWI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICB2YXIgc3ggPSB4aSBeIHhpIDw8IDEgXiB4aSA8PCAyIF4geGkgPDwgMyBeIHhpIDw8IDQ7XG4gICAgICBzeCA9IHN4ID4+PiA4IF4gc3ggJiAweGZmIF4gMHg2MztcbiAgICAgIHNCb3hbeF0gPSBzeDtcbiAgICAgIGludlNCb3hbc3hdID0geDsgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuXG4gICAgICB2YXIgeDIgPSBkW3hdO1xuICAgICAgdmFyIHg0ID0gZFt4Ml07XG4gICAgICB2YXIgeDggPSBkW3g0XTsgLy8gQ29tcHV0ZSBzdWIvaW52U3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcblxuICAgICAgdmFyIHQgPSBkW3N4XSAqIDB4MTAxIF4gc3ggKiAweDEwMTAxMDA7XG4gICAgICBzdWJNaXgwW3hdID0gdCA8PCAyNCB8IHQgPj4+IDg7XG4gICAgICBzdWJNaXgxW3hdID0gdCA8PCAxNiB8IHQgPj4+IDE2O1xuICAgICAgc3ViTWl4Mlt4XSA9IHQgPDwgOCB8IHQgPj4+IDI0O1xuICAgICAgc3ViTWl4M1t4XSA9IHQ7IC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuXG4gICAgICB0ID0geDggKiAweDEwMTAxMDEgXiB4NCAqIDB4MTAwMDEgXiB4MiAqIDB4MTAxIF4geCAqIDB4MTAxMDEwMDtcbiAgICAgIGludlN1Yk1peDBbc3hdID0gdCA8PCAyNCB8IHQgPj4+IDg7XG4gICAgICBpbnZTdWJNaXgxW3N4XSA9IHQgPDwgMTYgfCB0ID4+PiAxNjtcbiAgICAgIGludlN1Yk1peDJbc3hdID0gdCA8PCA4IHwgdCA+Pj4gMjQ7XG4gICAgICBpbnZTdWJNaXgzW3N4XSA9IHQ7IC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG5cbiAgICAgIGlmICgheCkge1xuICAgICAgICB4ID0geGkgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcbiAgICAgICAgeGkgXj0gZFtkW3hpXV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5leHBhbmRLZXkgPSBmdW5jdGlvbiBleHBhbmRLZXkoa2V5QnVmZmVyKSB7XG4gICAgLy8gY29udmVydCBrZXlCdWZmZXIgdG8gVWludDMyQXJyYXlcbiAgICB2YXIga2V5ID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oa2V5QnVmZmVyKTtcbiAgICB2YXIgc2FtZUtleSA9IHRydWU7XG4gICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwga2V5Lmxlbmd0aCAmJiBzYW1lS2V5KSB7XG4gICAgICBzYW1lS2V5ID0ga2V5W29mZnNldF0gPT09IHRoaXMua2V5W29mZnNldF07XG4gICAgICBvZmZzZXQrKztcbiAgICB9XG5cbiAgICBpZiAoc2FtZUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHZhciBrZXlTaXplID0gdGhpcy5rZXlTaXplID0ga2V5Lmxlbmd0aDtcblxuICAgIGlmIChrZXlTaXplICE9PSA0ICYmIGtleVNpemUgIT09IDYgJiYga2V5U2l6ZSAhPT0gOCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFlcyBrZXkgc2l6ZT0nICsga2V5U2l6ZSk7XG4gICAgfVxuXG4gICAgdmFyIGtzUm93cyA9IHRoaXMua3NSb3dzID0gKGtleVNpemUgKyA2ICsgMSkgKiA0O1xuICAgIHZhciBrc1JvdztcbiAgICB2YXIgaW52S3NSb3c7XG4gICAgdmFyIGtleVNjaGVkdWxlID0gdGhpcy5rZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xuICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcbiAgICB2YXIgc2JveCA9IHRoaXMuc0JveDtcbiAgICB2YXIgcmNvbiA9IHRoaXMucmNvbjtcbiAgICB2YXIgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgdmFyIGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgdmFyIGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgdmFyIGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgdmFyIGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG4gICAgdmFyIHByZXY7XG4gICAgdmFyIHQ7XG5cbiAgICBmb3IgKGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcbiAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcbiAgICAgICAgcHJldiA9IGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVtrc1Jvd107XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0ID0gcHJldjtcblxuICAgICAgaWYgKGtzUm93ICUga2V5U2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyBSb3Qgd29yZFxuICAgICAgICB0ID0gdCA8PCA4IHwgdCA+Pj4gMjQ7IC8vIFN1YiB3b3JkXG5cbiAgICAgICAgdCA9IHNib3hbdCA+Pj4gMjRdIDw8IDI0IHwgc2JveFt0ID4+PiAxNiAmIDB4ZmZdIDw8IDE2IHwgc2JveFt0ID4+PiA4ICYgMHhmZl0gPDwgOCB8IHNib3hbdCAmIDB4ZmZdOyAvLyBNaXggUmNvblxuXG4gICAgICAgIHQgXj0gcmNvbltrc1JvdyAvIGtleVNpemUgfCAwXSA8PCAyNDtcbiAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0KSB7XG4gICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgIHQgPSBzYm94W3QgPj4+IDI0XSA8PCAyNCB8IHNib3hbdCA+Pj4gMTYgJiAweGZmXSA8PCAxNiB8IHNib3hbdCA+Pj4gOCAmIDB4ZmZdIDw8IDggfCBzYm94W3QgJiAweGZmXTtcbiAgICAgIH1cblxuICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0gcHJldiA9IChrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdCkgPj4+IDA7XG4gICAgfVxuXG4gICAgZm9yIChpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG4gICAgICBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xuXG4gICAgICBpZiAoaW52S3NSb3cgJiAzKSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZTdWJNaXgwW3Nib3hbdCA+Pj4gMjRdXSBeIGludlN1Yk1peDFbc2JveFt0ID4+PiAxNiAmIDB4ZmZdXSBeIGludlN1Yk1peDJbc2JveFt0ID4+PiA4ICYgMHhmZl1dIF4gaW52U3ViTWl4M1tzYm94W3QgJiAweGZmXV07XG4gICAgICB9XG5cbiAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludktleVNjaGVkdWxlW2ludktzUm93XSA+Pj4gMDtcbiAgICB9XG4gIH0gLy8gQWRkaW5nIHRoaXMgYXMgYSBtZXRob2QgZ3JlYXRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZS5cbiAgO1xuXG4gIF9wcm90by5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwID0gZnVuY3Rpb24gbmV0d29ya1RvSG9zdE9yZGVyU3dhcCh3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmQgPDwgMjQgfCAod29yZCAmIDB4ZmYwMCkgPDwgOCB8ICh3b3JkICYgMHhmZjAwMDApID4+IDggfCB3b3JkID4+PiAyNDtcbiAgfTtcblxuICBfcHJvdG8uZGVjcnlwdCA9IGZ1bmN0aW9uIGRlY3J5cHQoaW5wdXRBcnJheUJ1ZmZlciwgb2Zmc2V0LCBhZXNJVikge1xuICAgIHZhciBuUm91bmRzID0gdGhpcy5rZXlTaXplICsgNjtcbiAgICB2YXIgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlO1xuICAgIHZhciBpbnZTQk9YID0gdGhpcy5pbnZTQm94O1xuICAgIHZhciBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICB2YXIgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICB2YXIgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICB2YXIgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICB2YXIgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcbiAgICB2YXIgaW5pdFZlY3RvciA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGFlc0lWKTtcbiAgICB2YXIgaW5pdFZlY3RvcjAgPSBpbml0VmVjdG9yWzBdO1xuICAgIHZhciBpbml0VmVjdG9yMSA9IGluaXRWZWN0b3JbMV07XG4gICAgdmFyIGluaXRWZWN0b3IyID0gaW5pdFZlY3RvclsyXTtcbiAgICB2YXIgaW5pdFZlY3RvcjMgPSBpbml0VmVjdG9yWzNdO1xuICAgIHZhciBpbnB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRBcnJheUJ1ZmZlcik7XG4gICAgdmFyIG91dHB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRJbnQzMi5sZW5ndGgpO1xuICAgIHZhciB0MCwgdDEsIHQyLCB0MztcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG4gICAgdmFyIGlucHV0V29yZHMwLCBpbnB1dFdvcmRzMSwgaW5wdXRXb3JkczIsIGlucHV0V29yZHMzO1xuICAgIHZhciBrc1JvdywgaTtcbiAgICB2YXIgc3dhcFdvcmQgPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXA7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgaW5wdXRJbnQzMi5sZW5ndGgpIHtcbiAgICAgIGlucHV0V29yZHMwID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXRdKTtcbiAgICAgIGlucHV0V29yZHMxID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAxXSk7XG4gICAgICBpbnB1dFdvcmRzMiA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgMl0pO1xuICAgICAgaW5wdXRXb3JkczMgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDNdKTtcbiAgICAgIHMwID0gaW5wdXRXb3JkczAgXiBpbnZLZXlTY2hlZHVsZVswXTtcbiAgICAgIHMxID0gaW5wdXRXb3JkczMgXiBpbnZLZXlTY2hlZHVsZVsxXTtcbiAgICAgIHMyID0gaW5wdXRXb3JkczIgXiBpbnZLZXlTY2hlZHVsZVsyXTtcbiAgICAgIHMzID0gaW5wdXRXb3JkczEgXiBpbnZLZXlTY2hlZHVsZVszXTtcbiAgICAgIGtzUm93ID0gNDsgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSByb3VuZHMgb2YgZGVjcnlwdGlvblxuXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgblJvdW5kczsgaSsrKSB7XG4gICAgICAgIHQwID0gaW52U3ViTWl4MFtzMCA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMSA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMiA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MzICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICAgIHQxID0gaW52U3ViTWl4MFtzMSA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMiA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMyA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MwICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgICB0MiA9IGludlN1Yk1peDBbczIgPj4+IDI0XSBeIGludlN1Yk1peDFbczMgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczAgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMSAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgICAgdDMgPSBpbnZTdWJNaXgwW3MzID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MwID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MxID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczIgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107IC8vIFVwZGF0ZSBzdGF0ZVxuXG4gICAgICAgIHMwID0gdDA7XG4gICAgICAgIHMxID0gdDE7XG4gICAgICAgIHMyID0gdDI7XG4gICAgICAgIHMzID0gdDM7XG4gICAgICAgIGtzUm93ID0ga3NSb3cgKyA0O1xuICAgICAgfSAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcblxuXG4gICAgICB0MCA9IGludlNCT1hbczAgPj4+IDI0XSA8PCAyNCBeIGludlNCT1hbczEgPj4gMTYgJiAweGZmXSA8PCAxNiBeIGludlNCT1hbczIgPj4gOCAmIDB4ZmZdIDw8IDggXiBpbnZTQk9YW3MzICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICB0MSA9IGludlNCT1hbczEgPj4+IDI0XSA8PCAyNCBeIGludlNCT1hbczIgPj4gMTYgJiAweGZmXSA8PCAxNiBeIGludlNCT1hbczMgPj4gOCAmIDB4ZmZdIDw8IDggXiBpbnZTQk9YW3MwICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgdDIgPSBpbnZTQk9YW3MyID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MzID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MwID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMSAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgIHQzID0gaW52U0JPWFtzMyA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMCA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMSA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczIgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107IC8vIFdyaXRlXG5cbiAgICAgIG91dHB1dEludDMyW29mZnNldF0gPSBzd2FwV29yZCh0MCBeIGluaXRWZWN0b3IwKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDFdID0gc3dhcFdvcmQodDMgXiBpbml0VmVjdG9yMSk7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAyXSA9IHN3YXBXb3JkKHQyIF4gaW5pdFZlY3RvcjIpO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgM10gPSBzd2FwV29yZCh0MSBeIGluaXRWZWN0b3IzKTsgLy8gcmVzZXQgaW5pdFZlY3RvciB0byBsYXN0IDQgdW5zaWduZWQgaW50XG5cbiAgICAgIGluaXRWZWN0b3IwID0gaW5wdXRXb3JkczA7XG4gICAgICBpbml0VmVjdG9yMSA9IGlucHV0V29yZHMxO1xuICAgICAgaW5pdFZlY3RvcjIgPSBpbnB1dFdvcmRzMjtcbiAgICAgIGluaXRWZWN0b3IzID0gaW5wdXRXb3JkczM7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgKyA0O1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXRJbnQzMi5idWZmZXI7XG4gIH07XG5cbiAgcmV0dXJuIEFFU0RlY3J5cHRvcjtcbn0oKTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NyeXB0L2RlY3J5cHRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY3J5cHQvZGVjcnlwdGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBEZWNyeXB0ZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hZXNfY3J5cHRvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Flcy1jcnlwdG8gKi8gXCIuL3NyYy9jcnlwdC9hZXMtY3J5cHRvLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mYXN0X2Flc19rZXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZmFzdC1hZXMta2V5ICovIFwiLi9zcmMvY3J5cHQvZmFzdC1hZXMta2V5LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hZXNfZGVjcnlwdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Flcy1kZWNyeXB0b3IgKi8gXCIuL3NyYy9jcnlwdC9hZXMtZGVjcnlwdG9yLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tcDQtdG9vbHMgKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90eXBlZC1hcnJheSAqLyBcIi4vc3JjL3V0aWxzL3R5cGVkLWFycmF5LnRzXCIpO1xuXG5cblxuXG5cblxudmFyIENIVU5LX1NJWkUgPSAxNjsgLy8gMTYgYnl0ZXMsIDEyOCBiaXRzXG5cbnZhciBEZWNyeXB0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEZWNyeXB0ZXIob2JzZXJ2ZXIsIGNvbmZpZywgX3RlbXApIHtcbiAgICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICBfcmVmJHJlbW92ZVBLQ1M3UGFkZGkgPSBfcmVmLnJlbW92ZVBLQ1M3UGFkZGluZyxcbiAgICAgICAgcmVtb3ZlUEtDUzdQYWRkaW5nID0gX3JlZiRyZW1vdmVQS0NTN1BhZGRpID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRyZW1vdmVQS0NTN1BhZGRpO1xuXG4gICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nID0gdm9pZCAwO1xuICAgIHRoaXMuc3VidGxlID0gbnVsbDtcbiAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgdGhpcy5mYXN0QWVzS2V5ID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudElWID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZyA9IHJlbW92ZVBLQ1M3UGFkZGluZzsgLy8gYnVpbHQgaW4gZGVjcnlwdG9yIGV4cGVjdHMgUEtDUzcgcGFkZGluZ1xuXG4gICAgaWYgKHJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGJyb3dzZXJDcnlwdG8gPSBzZWxmLmNyeXB0bztcblxuICAgICAgICBpZiAoYnJvd3NlckNyeXB0bykge1xuICAgICAgICAgIHRoaXMuc3VidGxlID0gYnJvd3NlckNyeXB0by5zdWJ0bGUgfHwgYnJvd3NlckNyeXB0by53ZWJraXRTdWJ0bGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogbm8tb3AgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdWJ0bGUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRGVjcnlwdGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5pc1N5bmMgPSBmdW5jdGlvbiBpc1N5bmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTO1xuICB9O1xuXG4gIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHZhciBjdXJyZW50UmVzdWx0ID0gdGhpcy5jdXJyZW50UmVzdWx0O1xuXG4gICAgaWYgKCFjdXJyZW50UmVzdWx0KSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShjdXJyZW50UmVzdWx0KTtcbiAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICBpZiAodGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcpIHtcbiAgICAgIHJldHVybiBPYmplY3QoX2Flc19kZWNyeXB0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcInJlbW92ZVBhZGRpbmdcIl0pKGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMuY3VycmVudFJlc3VsdCA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50SVYgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5zb2Z0d2FyZURlY3J5cHRlcikge1xuICAgICAgdGhpcy5zb2Z0d2FyZURlY3J5cHRlciA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5kZWNyeXB0ID0gZnVuY3Rpb24gZGVjcnlwdChkYXRhLCBrZXksIGl2LCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUykge1xuICAgICAgdGhpcy5zb2Z0d2FyZURlY3J5cHQobmV3IFVpbnQ4QXJyYXkoZGF0YSksIGtleSwgaXYpO1xuICAgICAgdmFyIGRlY3J5cHRSZXN1bHQgPSB0aGlzLmZsdXNoKCk7XG5cbiAgICAgIGlmIChkZWNyeXB0UmVzdWx0KSB7XG4gICAgICAgIGNhbGxiYWNrKGRlY3J5cHRSZXN1bHQuYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53ZWJDcnlwdG9EZWNyeXB0KG5ldyBVaW50OEFycmF5KGRhdGEpLCBrZXksIGl2KS50aGVuKGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNvZnR3YXJlRGVjcnlwdCA9IGZ1bmN0aW9uIHNvZnR3YXJlRGVjcnlwdChkYXRhLCBrZXksIGl2KSB7XG4gICAgdmFyIGN1cnJlbnRJViA9IHRoaXMuY3VycmVudElWLFxuICAgICAgICBjdXJyZW50UmVzdWx0ID0gdGhpcy5jdXJyZW50UmVzdWx0LFxuICAgICAgICByZW1haW5kZXJEYXRhID0gdGhpcy5yZW1haW5kZXJEYXRhO1xuICAgIHRoaXMubG9nT25jZSgnSlMgQUVTIGRlY3J5cHQnKTsgLy8gVGhlIG91dHB1dCBpcyBzdGFnZ2VyZWQgZHVyaW5nIHByb2dyZXNzaXZlIHBhcnNpbmcgLSB0aGUgY3VycmVudCByZXN1bHQgaXMgY2FjaGVkLCBhbmQgZW1pdHRlZCBvbiB0aGUgbmV4dCBjYWxsXG4gICAgLy8gVGhpcyBpcyBkb25lIGluIG9yZGVyIHRvIHN0cmlwIFBLQ1M3IHBhZGRpbmcsIHdoaWNoIGlzIGZvdW5kIGF0IHRoZSBlbmQgb2YgZWFjaCBzZWdtZW50LiBXZSBvbmx5IGtub3cgd2UndmUgcmVhY2hlZFxuICAgIC8vIHRoZSBlbmQgb24gZmx1c2goKSwgYnV0IGJ5IHRoYXQgdGltZSB3ZSBoYXZlIGFscmVhZHkgcmVjZWl2ZWQgYWxsIGJ5dGVzIGZvciB0aGUgc2VnbWVudC5cbiAgICAvLyBQcm9ncmVzc2l2ZSBkZWNyeXB0aW9uIGRvZXMgbm90IHdvcmsgd2l0aCBXZWJDcnlwdG9cblxuICAgIGlmIChyZW1haW5kZXJEYXRhKSB7XG4gICAgICBkYXRhID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImFwcGVuZFVpbnQ4QXJyYXlcIl0pKHJlbWFpbmRlckRhdGEsIGRhdGEpO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB9IC8vIEJ5dGUgbGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNiAoQUVTLTEyOCA9IDEyOCBiaXQgYmxvY2tzID0gMTYgYnl0ZXMpXG5cblxuICAgIHZhciBjdXJyZW50Q2h1bmsgPSB0aGlzLmdldFZhbGlkQ2h1bmsoZGF0YSk7XG5cbiAgICBpZiAoIWN1cnJlbnRDaHVuay5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50SVYpIHtcbiAgICAgIGl2ID0gY3VycmVudElWO1xuICAgIH1cblxuICAgIHZhciBzb2Z0d2FyZURlY3J5cHRlciA9IHRoaXMuc29mdHdhcmVEZWNyeXB0ZXI7XG5cbiAgICBpZiAoIXNvZnR3YXJlRGVjcnlwdGVyKSB7XG4gICAgICBzb2Z0d2FyZURlY3J5cHRlciA9IHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBuZXcgX2Flc19kZWNyeXB0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0oKTtcbiAgICB9XG5cbiAgICBzb2Z0d2FyZURlY3J5cHRlci5leHBhbmRLZXkoa2V5KTtcbiAgICB2YXIgcmVzdWx0ID0gY3VycmVudFJlc3VsdDtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBzb2Z0d2FyZURlY3J5cHRlci5kZWNyeXB0KGN1cnJlbnRDaHVuay5idWZmZXIsIDAsIGl2KTtcbiAgICB0aGlzLmN1cnJlbnRJViA9IE9iamVjdChfdXRpbHNfdHlwZWRfYXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcInNsaWNlVWludDhcIl0pKGN1cnJlbnRDaHVuaywgLTE2KS5idWZmZXI7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8ud2ViQ3J5cHRvRGVjcnlwdCA9IGZ1bmN0aW9uIHdlYkNyeXB0b0RlY3J5cHQoZGF0YSwga2V5LCBpdikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgc3VidGxlID0gdGhpcy5zdWJ0bGU7XG5cbiAgICBpZiAodGhpcy5rZXkgIT09IGtleSB8fCAhdGhpcy5mYXN0QWVzS2V5KSB7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIHRoaXMuZmFzdEFlc0tleSA9IG5ldyBfZmFzdF9hZXNfa2V5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKHN1YnRsZSwga2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mYXN0QWVzS2V5LmV4cGFuZEtleSgpLnRoZW4oZnVuY3Rpb24gKGFlc0tleSkge1xuICAgICAgLy8gZGVjcnlwdCB1c2luZyB3ZWIgY3J5cHRvXG4gICAgICBpZiAoIXN1YnRsZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCd3ZWIgY3J5cHRvIG5vdCBpbml0aWFsaXplZCcpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNyeXB0byA9IG5ldyBfYWVzX2NyeXB0b19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXShzdWJ0bGUsIGl2KTtcbiAgICAgIHJldHVybiBjcnlwdG8uZGVjcnlwdChkYXRhLmJ1ZmZlciwgYWVzS2V5KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZXR1cm4gX3RoaXMub25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5vbldlYkNyeXB0b0Vycm9yID0gZnVuY3Rpb24gb25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ud2FybignW2RlY3J5cHRlci50c106IFdlYkNyeXB0byBFcnJvciwgZGlzYWJsZSBXZWJDcnlwdG8gQVBJOicsIGVycik7XG4gICAgdGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMgPSB0cnVlO1xuICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuc29mdHdhcmVEZWNyeXB0KGRhdGEsIGtleSwgaXYpO1xuICB9O1xuXG4gIF9wcm90by5nZXRWYWxpZENodW5rID0gZnVuY3Rpb24gZ2V0VmFsaWRDaHVuayhkYXRhKSB7XG4gICAgdmFyIGN1cnJlbnRDaHVuayA9IGRhdGE7XG4gICAgdmFyIHNwbGl0UG9pbnQgPSBkYXRhLmxlbmd0aCAtIGRhdGEubGVuZ3RoICUgQ0hVTktfU0laRTtcblxuICAgIGlmIChzcGxpdFBvaW50ICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgY3VycmVudENodW5rID0gT2JqZWN0KF91dGlsc190eXBlZF9hcnJheV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wic2xpY2VVaW50OFwiXSkoZGF0YSwgMCwgc3BsaXRQb2ludCk7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBPYmplY3QoX3V0aWxzX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJzbGljZVVpbnQ4XCJdKShkYXRhLCBzcGxpdFBvaW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudENodW5rO1xuICB9O1xuXG4gIF9wcm90by5sb2dPbmNlID0gZnVuY3Rpb24gbG9nT25jZShtc2cpIHtcbiAgICBpZiAoIXRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS5sb2coXCJbZGVjcnlwdGVyLnRzXTogXCIgKyBtc2cpO1xuICAgIHRoaXMubG9nRW5hYmxlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHJldHVybiBEZWNyeXB0ZXI7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jcnlwdC9mYXN0LWFlcy1rZXkudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NyeXB0L2Zhc3QtYWVzLWtleS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRmFzdEFFU0tleTsgfSk7XG52YXIgRmFzdEFFU0tleSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZhc3RBRVNLZXkoc3VidGxlLCBrZXkpIHtcbiAgICB0aGlzLnN1YnRsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBGYXN0QUVTS2V5LnByb3RvdHlwZTtcblxuICBfcHJvdG8uZXhwYW5kS2V5ID0gZnVuY3Rpb24gZXhwYW5kS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIHRoaXMua2V5LCB7XG4gICAgICBuYW1lOiAnQUVTLUNCQydcbiAgICB9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gIH07XG5cbiAgcmV0dXJuIEZhc3RBRVNLZXk7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9hYWNkZW11eGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvYWFjZGVtdXhlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2VfYXVkaW9fZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLWF1ZGlvLWRlbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC9iYXNlLWF1ZGlvLWRlbXV4ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWR0cyAqLyBcIi4vc3JjL2RlbXV4L2FkdHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2lkMyAqLyBcIi4vc3JjL2RlbXV4L2lkMy50c1wiKTtcbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG4vKipcbiAqIEFBQyBkZW11eGVyXG4gKi9cblxuXG5cblxuXG52YXIgQUFDRGVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VBdWRpb0RlbXV4ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoQUFDRGVtdXhlciwgX0Jhc2VBdWRpb0RlbXV4ZXIpO1xuXG4gIGZ1bmN0aW9uIEFBQ0RlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2VBdWRpb0RlbXV4ZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIF90aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICBfdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIF90aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQUFDRGVtdXhlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgX0Jhc2VBdWRpb0RlbXV4ZXIucHJvdG90eXBlLnJlc2V0SW5pdFNlZ21lbnQuY2FsbCh0aGlzLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG5cbiAgICB0aGlzLl9hdWRpb1RyYWNrID0ge1xuICAgICAgY29udGFpbmVyOiAnYXVkaW8vYWR0cycsXG4gICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgaWQ6IDIsXG4gICAgICBwaWQ6IC0xLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzZWdtZW50Q29kZWM6ICdhYWMnLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBtYW5pZmVzdENvZGVjOiBhdWRpb0NvZGVjLFxuICAgICAgZHVyYXRpb246IHRyYWNrRHVyYXRpb24sXG4gICAgICBpbnB1dFRpbWVTY2FsZTogOTAwMDAsXG4gICAgICBkcm9wcGVkOiAwXG4gICAgfTtcbiAgfSAvLyBTb3VyY2UgZm9yIHByb2JlIGluZm8gLSBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICA7XG5cbiAgQUFDRGVtdXhlci5wcm9iZSA9IGZ1bmN0aW9uIHByb2JlKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIENoZWNrIGZvciB0aGUgQURUUyBzeW5jIHdvcmRcbiAgICAvLyBMb29rIGZvciBBRFRTIGhlYWRlciB8IDExMTEgMTExMSB8IDExMTEgWDAwWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDFcbiAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcbiAgICAvLyBNb3JlIGluZm8gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcblxuXG4gICAgdmFyIGlkM0RhdGEgPSBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJnZXRJRDNEYXRhXCJdKGRhdGEsIDApIHx8IFtdO1xuICAgIHZhciBvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICBpZiAoX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcInByb2JlXCJdKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZygnQURUUyBzeW5jIHdvcmQgZm91bmQgIScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmNhblBhcnNlID0gZnVuY3Rpb24gY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIF9hZHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJjYW5QYXJzZVwiXShkYXRhLCBvZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5hcHBlbmRGcmFtZSA9IGZ1bmN0aW9uIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHtcbiAgICBfYWR0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiaW5pdFRyYWNrQ29uZmlnXCJdKHRyYWNrLCB0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRyYWNrLm1hbmlmZXN0Q29kZWMpO1xuICAgIHZhciBmcmFtZSA9IF9hZHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJhcHBlbmRGcmFtZVwiXSh0cmFjaywgZGF0YSwgb2Zmc2V0LCB0aGlzLmluaXRQVFMsIHRoaXMuZnJhbWVJbmRleCk7XG5cbiAgICBpZiAoZnJhbWUgJiYgZnJhbWUubWlzc2luZyA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQUFDRGVtdXhlcjtcbn0oX2Jhc2VfYXVkaW9fZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbkFBQ0RlbXV4ZXIubWluUHJvYmVCeXRlTGVuZ3RoID0gOTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQUFDRGVtdXhlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L2FkdHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC9hZHRzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZ2V0QXVkaW9Db25maWcsIGlzSGVhZGVyUGF0dGVybiwgZ2V0SGVhZGVyTGVuZ3RoLCBnZXRGdWxsRnJhbWVMZW5ndGgsIGNhbkdldEZyYW1lTGVuZ3RoLCBpc0hlYWRlciwgY2FuUGFyc2UsIHByb2JlLCBpbml0VHJhY2tDb25maWcsIGdldEZyYW1lRHVyYXRpb24sIHBhcnNlRnJhbWVIZWFkZXIsIGFwcGVuZEZyYW1lICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldEF1ZGlvQ29uZmlnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0QXVkaW9Db25maWc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzSGVhZGVyUGF0dGVyblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzSGVhZGVyUGF0dGVybjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0SGVhZGVyTGVuZ3RoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0SGVhZGVyTGVuZ3RoOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRGdWxsRnJhbWVMZW5ndGhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRGdWxsRnJhbWVMZW5ndGg7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNhbkdldEZyYW1lTGVuZ3RoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2FuR2V0RnJhbWVMZW5ndGg7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzSGVhZGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNIZWFkZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNhblBhcnNlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2FuUGFyc2U7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInByb2JlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcHJvYmU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImluaXRUcmFja0NvbmZpZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGluaXRUcmFja0NvbmZpZzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0RnJhbWVEdXJhdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEZyYW1lRHVyYXRpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInBhcnNlRnJhbWVIZWFkZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwYXJzZUZyYW1lSGVhZGVyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhcHBlbmRGcmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFwcGVuZEZyYW1lOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qKlxuICogQURUUyBwYXJzZXIgaGVscGVyXG4gKiBAbGluayBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICovXG5cblxuXG5mdW5jdGlvbiBnZXRBdWRpb0NvbmZpZyhvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKSB7XG4gIHZhciBhZHRzT2JqZWN0VHlwZTtcbiAgdmFyIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4O1xuICB2YXIgYWR0c0NoYW5lbENvbmZpZztcbiAgdmFyIGNvbmZpZztcbiAgdmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIG1hbmlmZXN0Q29kZWMgPSBhdWRpb0NvZGVjO1xuICB2YXIgYWR0c1NhbXBsZWluZ1JhdGVzID0gWzk2MDAwLCA4ODIwMCwgNjQwMDAsIDQ4MDAwLCA0NDEwMCwgMzIwMDAsIDI0MDAwLCAyMjA1MCwgMTYwMDAsIDEyMDAwLCAxMTAyNSwgODAwMCwgNzM1MF07IC8vIGJ5dGUgMlxuXG4gIGFkdHNPYmplY3RUeXBlID0gKChkYXRhW29mZnNldCArIDJdICYgMHhjMCkgPj4+IDYpICsgMTtcbiAgdmFyIGFkdHNTYW1wbGluZ0luZGV4ID0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDNjKSA+Pj4gMjtcblxuICBpZiAoYWR0c1NhbXBsaW5nSW5kZXggPiBhZHRzU2FtcGxlaW5nUmF0ZXMubGVuZ3RoIC0gMSkge1xuICAgIG9ic2VydmVyLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLk1FRElBX0VSUk9SLFxuICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgcmVhc29uOiBcImludmFsaWQgQURUUyBzYW1wbGluZyBpbmRleDpcIiArIGFkdHNTYW1wbGluZ0luZGV4XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYWR0c0NoYW5lbENvbmZpZyA9IChkYXRhW29mZnNldCArIDJdICYgMHgwMSkgPDwgMjsgLy8gYnl0ZSAzXG5cbiAgYWR0c0NoYW5lbENvbmZpZyB8PSAoZGF0YVtvZmZzZXQgKyAzXSAmIDB4YzApID4+PiA2O1xuICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJsb2dnZXJcIl0ubG9nKFwibWFuaWZlc3QgY29kZWM6XCIgKyBhdWRpb0NvZGVjICsgXCIsIEFEVFMgdHlwZTpcIiArIGFkdHNPYmplY3RUeXBlICsgXCIsIHNhbXBsaW5nSW5kZXg6XCIgKyBhZHRzU2FtcGxpbmdJbmRleCk7IC8vIGZpcmVmb3g6IGZyZXEgbGVzcyB0aGFuIDI0a0h6ID0gQUFDIFNCUiAoSEUtQUFDKVxuXG4gIGlmICgvZmlyZWZveC9pLnRlc3QodXNlckFnZW50KSkge1xuICAgIGlmIChhZHRzU2FtcGxpbmdJbmRleCA+PSA2KSB7XG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7IC8vIEhFLUFBQyB1c2VzIFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbikgLCBoaWdoIGZyZXF1ZW5jaWVzIGFyZSBjb25zdHJ1Y3RlZCBmcm9tIGxvdyBmcmVxdWVuY2llc1xuICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcbiAgICAgIC8vIG11bHRpcGx5IGZyZXF1ZW5jeSBieSAyIChzZWUgdGFibGUgYmVsb3csIGVxdWl2YWxlbnQgdG8gc3Vic3RyYWN0IDMpXG5cbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXggLSAzO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDI7XG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IGFkdHNTYW1wbGluZ0luZGV4O1xuICAgIH0gLy8gQW5kcm9pZCA6IGFsd2F5cyB1c2UgQUFDXG5cbiAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSkge1xuICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleDtcbiAgfSBlbHNlIHtcbiAgICAvKiAgZm9yIG90aGVyIGJyb3dzZXJzIChDaHJvbWUvVml2YWxkaS9PcGVyYSAuLi4pXG4gICAgICAgIGFsd2F5cyBmb3JjZSBhdWRpbyB0eXBlIHRvIGJlIEhFLUFBQyBTQlIsIGFzIHNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgYXVkaW8gY29kZWMgc3dpdGNoIHByb3Blcmx5IChsaWtlIENocm9tZSAuLi4pXG4gICAgKi9cbiAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgY29uZmlnID0gbmV3IEFycmF5KDQpOyAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgSEUtQUFDIG9yIEhFLUFBQ3YyKSBPUiAobWFuaWZlc3QgY29kZWMgbm90IHNwZWNpZmllZCBBTkQgZnJlcXVlbmN5IGxlc3MgdGhhbiAyNGtIeilcblxuICAgIGlmIChhdWRpb0NvZGVjICYmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMjknKSAhPT0gLTEgfHwgYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHx8ICFhdWRpb0NvZGVjICYmIGFkdHNTYW1wbGluZ0luZGV4ID49IDYpIHtcbiAgICAgIC8vIEhFLUFBQyB1c2VzIFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbikgLCBoaWdoIGZyZXF1ZW5jaWVzIGFyZSBjb25zdHJ1Y3RlZCBmcm9tIGxvdyBmcmVxdWVuY2llc1xuICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcbiAgICAgIC8vIG11bHRpcGx5IGZyZXF1ZW5jeSBieSAyIChzZWUgdGFibGUgYmVsb3csIGVxdWl2YWxlbnQgdG8gc3Vic3RyYWN0IDMpXG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IGFkdHNTYW1wbGluZ0luZGV4IC0gMztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEFBQykgQU5EIChmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6IEFORCBuYiBjaGFubmVsIGlzIDEpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIGFuZCBtb25vIGF1ZGlvKVxuICAgICAgLy8gQ2hyb21lIGZhaWxzIHRvIHBsYXkgYmFjayB3aXRoIGxvdyBmcmVxdWVuY3kgQUFDIExDIG1vbm8gd2hlbiBpbml0aWFsaXplZCB3aXRoIEhFLUFBQy4gIFRoaXMgaXMgbm90IGEgcHJvYmxlbSB3aXRoIHN0ZXJlby5cbiAgICAgIGlmIChhdWRpb0NvZGVjICYmIGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xICYmIChhZHRzU2FtcGxpbmdJbmRleCA+PSA2ICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEgfHwgL3ZpdmFsZGkvaS50ZXN0KHVzZXJBZ2VudCkpIHx8ICFhdWRpb0NvZGVjICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpIHtcbiAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICB9XG5cbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXg7XG4gICAgfVxuICB9XG4gIC8qIHJlZmVyIHRvIGh0dHA6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPU1QRUctNF9BdWRpbyNBdWRpb19TcGVjaWZpY19Db25maWdcbiAgICAgIElTTyAxNDQ5Ni0zIChBQUMpLnBkZiAtIFRhYmxlIDEuMTMg4oCUIFN5bnRheCBvZiBBdWRpb1NwZWNpZmljQ29uZmlnKClcbiAgICBBdWRpbyBQcm9maWxlIC8gQXVkaW8gT2JqZWN0IFR5cGVcbiAgICAwOiBOdWxsXG4gICAgMTogQUFDIE1haW5cbiAgICAyOiBBQUMgTEMgKExvdyBDb21wbGV4aXR5KVxuICAgIDM6IEFBQyBTU1IgKFNjYWxhYmxlIFNhbXBsZSBSYXRlKVxuICAgIDQ6IEFBQyBMVFAgKExvbmcgVGVybSBQcmVkaWN0aW9uKVxuICAgIDU6IFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbilcbiAgICA2OiBBQUMgU2NhbGFibGVcbiAgIHNhbXBsaW5nIGZyZXFcbiAgICAwOiA5NjAwMCBIelxuICAgIDE6IDg4MjAwIEh6XG4gICAgMjogNjQwMDAgSHpcbiAgICAzOiA0ODAwMCBIelxuICAgIDQ6IDQ0MTAwIEh6XG4gICAgNTogMzIwMDAgSHpcbiAgICA2OiAyNDAwMCBIelxuICAgIDc6IDIyMDUwIEh6XG4gICAgODogMTYwMDAgSHpcbiAgICA5OiAxMjAwMCBIelxuICAgIDEwOiAxMTAyNSBIelxuICAgIDExOiA4MDAwIEh6XG4gICAgMTI6IDczNTAgSHpcbiAgICAxMzogUmVzZXJ2ZWRcbiAgICAxNDogUmVzZXJ2ZWRcbiAgICAxNTogZnJlcXVlbmN5IGlzIHdyaXR0ZW4gZXhwbGljdGx5XG4gICAgQ2hhbm5lbCBDb25maWd1cmF0aW9uc1xuICAgIFRoZXNlIGFyZSB0aGUgY2hhbm5lbCBjb25maWd1cmF0aW9uczpcbiAgICAwOiBEZWZpbmVkIGluIEFPVCBTcGVjaWZjIENvbmZpZ1xuICAgIDE6IDEgY2hhbm5lbDogZnJvbnQtY2VudGVyXG4gICAgMjogMiBjaGFubmVsczogZnJvbnQtbGVmdCwgZnJvbnQtcmlnaHRcbiAgKi9cbiAgLy8gYXVkaW9PYmplY3RUeXBlID0gcHJvZmlsZSA9PiBwcm9maWxlLCB0aGUgTVBFRy00IEF1ZGlvIE9iamVjdCBUeXBlIG1pbnVzIDFcblxuXG4gIGNvbmZpZ1swXSA9IGFkdHNPYmplY3RUeXBlIDw8IDM7IC8vIHNhbXBsaW5nRnJlcXVlbmN5SW5kZXhcblxuICBjb25maWdbMF0gfD0gKGFkdHNTYW1wbGluZ0luZGV4ICYgMHgwZSkgPj4gMTtcbiAgY29uZmlnWzFdIHw9IChhZHRzU2FtcGxpbmdJbmRleCAmIDB4MDEpIDw8IDc7IC8vIGNoYW5uZWxDb25maWd1cmF0aW9uXG5cbiAgY29uZmlnWzFdIHw9IGFkdHNDaGFuZWxDb25maWcgPDwgMztcblxuICBpZiAoYWR0c09iamVjdFR5cGUgPT09IDUpIHtcbiAgICAvLyBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXhcbiAgICBjb25maWdbMV0gfD0gKGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ICYgMHgwZSkgPj4gMTtcbiAgICBjb25maWdbMl0gPSAoYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggJiAweDAxKSA8PCA3OyAvLyBhZHRzT2JqZWN0VHlwZSAoZm9yY2UgdG8gMiwgY2hyb21lIGlzIGNoZWNraW5nIHRoYXQgb2JqZWN0IHR5cGUgaXMgbGVzcyB0aGFuIDUgPz8/XG4gICAgLy8gICAgaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy5naXQvKy9tYXN0ZXIvbWVkaWEvZm9ybWF0cy9tcDQvYWFjLmNjXG5cbiAgICBjb25maWdbMl0gfD0gMiA8PCAyO1xuICAgIGNvbmZpZ1szXSA9IDA7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbmZpZzogY29uZmlnLFxuICAgIHNhbXBsZXJhdGU6IGFkdHNTYW1wbGVpbmdSYXRlc1thZHRzU2FtcGxpbmdJbmRleF0sXG4gICAgY2hhbm5lbENvdW50OiBhZHRzQ2hhbmVsQ29uZmlnLFxuICAgIGNvZGVjOiAnbXA0YS40MC4nICsgYWR0c09iamVjdFR5cGUsXG4gICAgbWFuaWZlc3RDb2RlYzogbWFuaWZlc3RDb2RlY1xuICB9O1xufVxuZnVuY3Rpb24gaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gZGF0YVtvZmZzZXRdID09PSAweGZmICYmIChkYXRhW29mZnNldCArIDFdICYgMHhmNikgPT09IDB4ZjA7XG59XG5mdW5jdGlvbiBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBkYXRhW29mZnNldCArIDFdICYgMHgwMSA/IDcgOiA5O1xufVxuZnVuY3Rpb24gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gKGRhdGFbb2Zmc2V0ICsgM10gJiAweDAzKSA8PCAxMSB8IGRhdGFbb2Zmc2V0ICsgNF0gPDwgMyB8IChkYXRhW29mZnNldCArIDVdICYgMHhlMCkgPj4+IDU7XG59XG5mdW5jdGlvbiBjYW5HZXRGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldCArIDUgPCBkYXRhLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGlzSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAvLyBMb29rIGZvciBBRFRTIGhlYWRlciB8IDExMTEgMTExMSB8IDExMTEgWDAwWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDFcbiAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXG4gIC8vIE1vcmUgaW5mbyBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICByZXR1cm4gb2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpO1xufVxuZnVuY3Rpb24gY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBjYW5HZXRGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpICYmIGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpIDw9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xufVxuZnVuY3Rpb24gcHJvYmUoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIHNhbWUgYXMgaXNIZWFkZXIgYnV0IHdlIGFsc28gY2hlY2sgdGhhdCBBRFRTIGZyYW1lIGZvbGxvd3MgbGFzdCBBRFRTIGZyYW1lXG4gIC8vIG9yIGVuZCBvZiBkYXRhIGlzIHJlYWNoZWRcbiAgaWYgKGlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAvLyBBRFRTIGhlYWRlciBMZW5ndGhcbiAgICB2YXIgaGVhZGVyTGVuZ3RoID0gZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG5cbiAgICBpZiAob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBBRFRTIGZyYW1lIExlbmd0aFxuXG5cbiAgICB2YXIgZnJhbWVMZW5ndGggPSBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcblxuICAgIGlmIChmcmFtZUxlbmd0aCA8PSBoZWFkZXJMZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgZnJhbWVMZW5ndGg7XG4gICAgcmV0dXJuIG5ld09mZnNldCA9PT0gZGF0YS5sZW5ndGggfHwgaXNIZWFkZXIoZGF0YSwgbmV3T2Zmc2V0KTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGluaXRUcmFja0NvbmZpZyh0cmFjaywgb2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYykge1xuICBpZiAoIXRyYWNrLnNhbXBsZXJhdGUpIHtcbiAgICB2YXIgY29uZmlnID0gZ2V0QXVkaW9Db25maWcob2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYyk7XG5cbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgdHJhY2suc2FtcGxlcmF0ZSA9IGNvbmZpZy5zYW1wbGVyYXRlO1xuICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNvbmZpZy5jaGFubmVsQ291bnQ7XG4gICAgdHJhY2suY29kZWMgPSBjb25maWcuY29kZWM7XG4gICAgdHJhY2subWFuaWZlc3RDb2RlYyA9IGNvbmZpZy5tYW5pZmVzdENvZGVjO1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImxvZ2dlclwiXS5sb2coXCJwYXJzZWQgY29kZWM6XCIgKyB0cmFjay5jb2RlYyArIFwiLCByYXRlOlwiICsgY29uZmlnLnNhbXBsZXJhdGUgKyBcIiwgY2hhbm5lbHM6XCIgKyBjb25maWcuY2hhbm5lbENvdW50KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RnJhbWVEdXJhdGlvbihzYW1wbGVyYXRlKSB7XG4gIHJldHVybiAxMDI0ICogOTAwMDAgLyBzYW1wbGVyYXRlO1xufVxuZnVuY3Rpb24gcGFyc2VGcmFtZUhlYWRlcihkYXRhLCBvZmZzZXQpIHtcbiAgLy8gVGhlIHByb3RlY3Rpb24gc2tpcCBiaXQgdGVsbHMgdXMgaWYgd2UgaGF2ZSAyIGJ5dGVzIG9mIENSQyBkYXRhIGF0IHRoZSBlbmQgb2YgdGhlIEFEVFMgaGVhZGVyXG4gIHZhciBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcblxuICBpZiAob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgLy8gcmV0cmlldmUgZnJhbWUgc2l6ZVxuICAgIHZhciBmcmFtZUxlbmd0aCA9IGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpIC0gaGVhZGVyTGVuZ3RoO1xuXG4gICAgaWYgKGZyYW1lTGVuZ3RoID4gMCkge1xuICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofWApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZGVyTGVuZ3RoOiBoZWFkZXJMZW5ndGgsXG4gICAgICAgIGZyYW1lTGVuZ3RoOiBmcmFtZUxlbmd0aFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCkge1xuICB2YXIgZnJhbWVEdXJhdGlvbiA9IGdldEZyYW1lRHVyYXRpb24odHJhY2suc2FtcGxlcmF0ZSk7XG4gIHZhciBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICB2YXIgaGVhZGVyID0gcGFyc2VGcmFtZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICB2YXIgdW5pdDtcblxuICBpZiAoaGVhZGVyKSB7XG4gICAgdmFyIGZyYW1lTGVuZ3RoID0gaGVhZGVyLmZyYW1lTGVuZ3RoLFxuICAgICAgICBoZWFkZXJMZW5ndGggPSBoZWFkZXIuaGVhZGVyTGVuZ3RoO1xuXG4gICAgdmFyIF9sZW5ndGggPSBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aDtcblxuICAgIHZhciBtaXNzaW5nID0gTWF0aC5tYXgoMCwgb2Zmc2V0ICsgX2xlbmd0aCAtIGRhdGEubGVuZ3RoKTsgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lICR7ZnJhbWVJbmRleH0sIHB0czoke3N0YW1wfSBsZW5ndGhAb2Zmc2V0L3RvdGFsOiAke2ZyYW1lTGVuZ3RofUAke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofSBtaXNzaW5nOiAke21pc3Npbmd9YCk7XG5cbiAgICBpZiAobWlzc2luZykge1xuICAgICAgdW5pdCA9IG5ldyBVaW50OEFycmF5KF9sZW5ndGggLSBoZWFkZXJMZW5ndGgpO1xuICAgICAgdW5pdC5zZXQoZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIGRhdGEubGVuZ3RoKSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXQgPSBkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgb2Zmc2V0ICsgX2xlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIF9zYW1wbGUgPSB7XG4gICAgICB1bml0OiB1bml0LFxuICAgICAgcHRzOiBzdGFtcFxuICAgIH07XG5cbiAgICBpZiAoIW1pc3NpbmcpIHtcbiAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChfc2FtcGxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2FtcGxlOiBfc2FtcGxlLFxuICAgICAgbGVuZ3RoOiBfbGVuZ3RoLFxuICAgICAgbWlzc2luZzogbWlzc2luZ1xuICAgIH07XG4gIH0gLy8gb3ZlcmZsb3cgaW5jb21wbGV0ZSBoZWFkZXJcblxuXG4gIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbiAgdW5pdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIHVuaXQuc2V0KGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBkYXRhLmxlbmd0aCksIDApO1xuICB2YXIgc2FtcGxlID0ge1xuICAgIHVuaXQ6IHVuaXQsXG4gICAgcHRzOiBzdGFtcFxuICB9O1xuICByZXR1cm4ge1xuICAgIHNhbXBsZTogc2FtcGxlLFxuICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgIG1pc3Npbmc6IC0xXG4gIH07XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L2Jhc2UtYXVkaW8tZGVtdXhlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvYmFzZS1hdWRpby1kZW11eGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBpbml0UFRTRm4sIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW5pdFBUU0ZuXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaW5pdFBUU0ZuOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9pZDMgKi8gXCIuL3NyYy9kZW11eC9pZDMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2RlbXV4ZXIgKi8gXCIuL3NyYy90eXBlcy9kZW11eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2R1bW15LWRlbXV4ZWQtdHJhY2sgKi8gXCIuL3NyYy9kZW11eC9kdW1teS1kZW11eGVkLXRyYWNrLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL21wNC10b29scyAqLyBcIi4vc3JjL3V0aWxzL21wNC10b29scy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdHlwZWRfYXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3R5cGVkLWFycmF5ICovIFwiLi9zcmMvdXRpbHMvdHlwZWQtYXJyYXkudHNcIik7XG5cblxuXG5cblxuXG5cbnZhciBCYXNlQXVkaW9EZW11eGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZUF1ZGlvRGVtdXhlcigpIHtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuX2lkM1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhbWVJbmRleCA9IDA7XG4gICAgdGhpcy5jYWNoZWREYXRhID0gbnVsbDtcbiAgICB0aGlzLmluaXRQVFMgPSBudWxsO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEJhc2VBdWRpb0RlbXV4ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZXNldEluaXRTZWdtZW50ID0gZnVuY3Rpb24gcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgIHRoaXMuX2lkM1RyYWNrID0ge1xuICAgICAgdHlwZTogJ2lkMycsXG4gICAgICBpZDogMyxcbiAgICAgIHBpZDogLTEsXG4gICAgICBpbnB1dFRpbWVTY2FsZTogOTAwMDAsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgZHJvcHBlZDogMFxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0VGltZVN0YW1wID0gZnVuY3Rpb24gcmVzZXRUaW1lU3RhbXAoKSB7fTtcblxuICBfcHJvdG8ucmVzZXRDb250aWd1aXR5ID0gZnVuY3Rpb24gcmVzZXRDb250aWd1aXR5KCkge307XG5cbiAgX3Byb3RvLmNhblBhcnNlID0gZnVuY3Rpb24gY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5hcHBlbmRGcmFtZSA9IGZ1bmN0aW9uIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHt9IC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgO1xuXG4gIF9wcm90by5kZW11eCA9IGZ1bmN0aW9uIGRlbXV4KGRhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICBpZiAodGhpcy5jYWNoZWREYXRhKSB7XG4gICAgICBkYXRhID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImFwcGVuZFVpbnQ4QXJyYXlcIl0pKHRoaXMuY2FjaGVkRGF0YSwgZGF0YSk7XG4gICAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBpZDNEYXRhID0gX2RlbXV4X2lkM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZ2V0SUQzRGF0YVwiXShkYXRhLCAwKTtcbiAgICB2YXIgb2Zmc2V0ID0gaWQzRGF0YSA/IGlkM0RhdGEubGVuZ3RoIDogMDtcbiAgICB2YXIgbGFzdERhdGFJbmRleDtcbiAgICB2YXIgcHRzO1xuICAgIHZhciB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG4gICAgdmFyIGlkM1RyYWNrID0gdGhpcy5faWQzVHJhY2s7XG4gICAgdmFyIHRpbWVzdGFtcCA9IGlkM0RhdGEgPyBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJnZXRUaW1lU3RhbXBcIl0oaWQzRGF0YSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMuZnJhbWVJbmRleCA9PT0gMCB8fCB0aGlzLmluaXRQVFMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuaW5pdFBUUyA9IGluaXRQVFNGbih0aW1lc3RhbXAsIHRpbWVPZmZzZXQpO1xuICAgIH0gLy8gbW9yZSBleHByZXNzaXZlIHRoYW4gYWx0ZXJuYXRpdmU6IGlkM0RhdGE/Lmxlbmd0aFxuXG5cbiAgICBpZiAoaWQzRGF0YSAmJiBpZDNEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgIHB0czogdGhpcy5pbml0UFRTLFxuICAgICAgICBkdHM6IHRoaXMuaW5pdFBUUyxcbiAgICAgICAgZGF0YTogaWQzRGF0YSxcbiAgICAgICAgdHlwZTogX3R5cGVzX2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIk1ldGFkYXRhU2NoZW1hXCJdLmF1ZGlvSWQzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwdHMgPSB0aGlzLmluaXRQVFM7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5jYW5QYXJzZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIHZhciBmcmFtZSA9IHRoaXMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCk7XG5cbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgdGhpcy5mcmFtZUluZGV4Kys7XG4gICAgICAgICAgcHRzID0gZnJhbWUuc2FtcGxlLnB0cztcbiAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgIGxhc3REYXRhSW5kZXggPSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImNhblBhcnNlXCJdKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgLy8gYWZ0ZXIgYSBJRDMuY2FuUGFyc2UsIGEgY2FsbCB0byBJRDMuZ2V0SUQzRGF0YSAqc2hvdWxkKiBhbHdheXMgcmV0dXJucyBzb21lIGRhdGFcbiAgICAgICAgaWQzRGF0YSA9IF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdldElEM0RhdGFcIl0oZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICBwdHM6IHB0cyxcbiAgICAgICAgICBkdHM6IHB0cyxcbiAgICAgICAgICBkYXRhOiBpZDNEYXRhLFxuICAgICAgICAgIHR5cGU6IF90eXBlc19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJNZXRhZGF0YVNjaGVtYVwiXS5hdWRpb0lkM1xuICAgICAgICB9KTtcbiAgICAgICAgb2Zmc2V0ICs9IGlkM0RhdGEubGVuZ3RoO1xuICAgICAgICBsYXN0RGF0YUluZGV4ID0gb2Zmc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9XG5cbiAgICAgIGlmIChvZmZzZXQgPT09IGxlbmd0aCAmJiBsYXN0RGF0YUluZGV4ICE9PSBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxEYXRhID0gT2JqZWN0KF91dGlsc190eXBlZF9hcnJheV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wic2xpY2VVaW50OFwiXSkoZGF0YSwgbGFzdERhdGFJbmRleCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkRGF0YSkge1xuICAgICAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IE9iamVjdChfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJhcHBlbmRVaW50OEFycmF5XCJdKSh0aGlzLmNhY2hlZERhdGEsIHBhcnRpYWxEYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNhY2hlZERhdGEgPSBwYXJ0aWFsRGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhdWRpb1RyYWNrOiB0cmFjayxcbiAgICAgIHZpZGVvVHJhY2s6IE9iamVjdChfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZHVtbXlUcmFja1wiXSkoKSxcbiAgICAgIGlkM1RyYWNrOiBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogT2JqZWN0KF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkdW1teVRyYWNrXCJdKSgpXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZGVtdXhTYW1wbGVBZXMgPSBmdW5jdGlvbiBkZW11eFNhbXBsZUFlcyhkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIltcIiArIHRoaXMgKyBcIl0gVGhpcyBkZW11eGVyIGRvZXMgbm90IHN1cHBvcnQgU2FtcGxlLUFFUyBkZWNyeXB0aW9uXCIpKTtcbiAgfTtcblxuICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCh0aW1lT2Zmc2V0KSB7XG4gICAgLy8gUGFyc2UgY2FjaGUgaW4gY2FzZSBvZiByZW1haW5pbmcgZnJhbWVzLlxuICAgIHZhciBjYWNoZWREYXRhID0gdGhpcy5jYWNoZWREYXRhO1xuXG4gICAgaWYgKGNhY2hlZERhdGEpIHtcbiAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLmRlbXV4KGNhY2hlZERhdGEsIDApO1xuICAgIH1cblxuICAgIHRoaXMuZnJhbWVJbmRleCA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvVHJhY2s6IHRoaXMuX2F1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrOiBPYmplY3QoX2R1bW15X2RlbXV4ZWRfdHJhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImR1bW15VHJhY2tcIl0pKCksXG4gICAgICBpZDNUcmFjazogdGhpcy5faWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IE9iamVjdChfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZHVtbXlUcmFja1wiXSkoKVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge307XG5cbiAgcmV0dXJuIEJhc2VBdWRpb0RlbXV4ZXI7XG59KCk7XG4vKipcbiAqIEluaXRpYWxpemUgUFRTXG4gKiA8cD5cbiAqICAgIHVzZSB0aW1lc3RhbXAgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgTmFOIG9yIEluZmluaXR5XG4gKiA8L3A+XG4gKi9cblxuXG52YXIgaW5pdFBUU0ZuID0gZnVuY3Rpb24gaW5pdFBUU0ZuKHRpbWVzdGFtcCwgdGltZU9mZnNldCkge1xuICByZXR1cm4gT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKSh0aW1lc3RhbXApID8gdGltZXN0YW1wICogOTAgOiB0aW1lT2Zmc2V0ICogOTAwMDA7XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChCYXNlQXVkaW9EZW11eGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvY2h1bmstY2FjaGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvY2h1bmstY2FjaGUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ2h1bmtDYWNoZTsgfSk7XG52YXIgQ2h1bmtDYWNoZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENodW5rQ2FjaGUoKSB7XG4gICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICB0aGlzLmRhdGFMZW5ndGggPSAwO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENodW5rQ2FjaGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5wdXNoID0gZnVuY3Rpb24gcHVzaChjaHVuaykge1xuICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xuICAgIHRoaXMuZGF0YUxlbmd0aCArPSBjaHVuay5sZW5ndGg7XG4gIH07XG5cbiAgX3Byb3RvLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgdmFyIGNodW5rcyA9IHRoaXMuY2h1bmtzLFxuICAgICAgICBkYXRhTGVuZ3RoID0gdGhpcy5kYXRhTGVuZ3RoO1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBpZiAoIWNodW5rcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9IGVsc2UgaWYgKGNodW5rcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJlc3VsdCA9IGNodW5rc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY29uY2F0VWludDhBcnJheXMoY2h1bmtzLCBkYXRhTGVuZ3RoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLmNodW5rcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGF0YUxlbmd0aCA9IDA7XG4gIH07XG5cbiAgcmV0dXJuIENodW5rQ2FjaGU7XG59KCk7XG5cblxuXG5mdW5jdGlvbiBjb25jYXRVaW50OEFycmF5cyhjaHVua3MsIGRhdGFMZW5ndGgpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGRhdGFMZW5ndGgpO1xuICB2YXIgb2Zmc2V0ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaHVuayA9IGNodW5rc1tpXTtcbiAgICByZXN1bHQuc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9kdW1teS1kZW11eGVkLXRyYWNrLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvZHVtbXktZGVtdXhlZC10cmFjay50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGR1bW15VHJhY2sgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZHVtbXlUcmFja1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGR1bW15VHJhY2s7IH0pO1xuZnVuY3Rpb24gZHVtbXlUcmFjayh0eXBlLCBpbnB1dFRpbWVTY2FsZSkge1xuICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgdHlwZSA9ICcnO1xuICB9XG5cbiAgaWYgKGlucHV0VGltZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbnB1dFRpbWVTY2FsZSA9IDkwMDAwO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGlkOiAtMSxcbiAgICBwaWQ6IC0xLFxuICAgIGlucHV0VGltZVNjYWxlOiBpbnB1dFRpbWVTY2FsZSxcbiAgICBzZXF1ZW5jZU51bWJlcjogLTEsXG4gICAgc2FtcGxlczogW10sXG4gICAgZHJvcHBlZDogMFxuICB9O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9leHAtZ29sb21iLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvZXhwLWdvbG9tYi50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyoqXG4gKiBQYXJzZXIgZm9yIGV4cG9uZW50aWFsIEdvbG9tYiBjb2RlcywgYSB2YXJpYWJsZS1iaXR3aWR0aCBudW1iZXIgZW5jb2Rpbmcgc2NoZW1lIHVzZWQgYnkgaDI2NC5cbiAqL1xuXG5cbnZhciBFeHBHb2xvbWIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFeHBHb2xvbWIoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlID0gdm9pZCAwO1xuICAgIHRoaXMud29yZCA9IHZvaWQgMDtcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy5kYXRhID0gZGF0YTsgLy8gdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhpcy5kYXRhXG5cbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlID0gZGF0YS5ieXRlTGVuZ3RoOyAvLyB0aGUgY3VycmVudCB3b3JkIGJlaW5nIGV4YW1pbmVkXG5cbiAgICB0aGlzLndvcmQgPSAwOyAvLyA6dWludFxuICAgIC8vIHRoZSBudW1iZXIgb2YgYml0cyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhlIGN1cnJlbnQgd29yZFxuXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gMDsgLy8gOnVpbnRcbiAgfSAvLyAoKTp2b2lkXG5cblxuICB2YXIgX3Byb3RvID0gRXhwR29sb21iLnByb3RvdHlwZTtcblxuICBfcHJvdG8ubG9hZFdvcmQgPSBmdW5jdGlvbiBsb2FkV29yZCgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgYnl0ZXNBdmFpbGFibGUgPSB0aGlzLmJ5dGVzQXZhaWxhYmxlO1xuICAgIHZhciBwb3NpdGlvbiA9IGRhdGEuYnl0ZUxlbmd0aCAtIGJ5dGVzQXZhaWxhYmxlO1xuICAgIHZhciB3b3JraW5nQnl0ZXMgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICB2YXIgYXZhaWxhYmxlQnl0ZXMgPSBNYXRoLm1pbig0LCBieXRlc0F2YWlsYWJsZSk7XG5cbiAgICBpZiAoYXZhaWxhYmxlQnl0ZXMgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gYnl0ZXMgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgd29ya2luZ0J5dGVzLnNldChkYXRhLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGF2YWlsYWJsZUJ5dGVzKSk7XG4gICAgdGhpcy53b3JkID0gbmV3IERhdGFWaWV3KHdvcmtpbmdCeXRlcy5idWZmZXIpLmdldFVpbnQzMigwKTsgLy8gdHJhY2sgdGhlIGFtb3VudCBvZiB0aGlzLmRhdGEgdGhhdCBoYXMgYmVlbiBwcm9jZXNzZWRcblxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IGF2YWlsYWJsZUJ5dGVzICogODtcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IGF2YWlsYWJsZUJ5dGVzO1xuICB9IC8vIChjb3VudDppbnQpOnZvaWRcbiAgO1xuXG4gIF9wcm90by5za2lwQml0cyA9IGZ1bmN0aW9uIHNraXBCaXRzKGNvdW50KSB7XG4gICAgdmFyIHNraXBCeXRlczsgLy8gOmludFxuXG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IGNvdW50KSB7XG4gICAgICB0aGlzLndvcmQgPDw9IGNvdW50O1xuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCAtPSB0aGlzLmJpdHNBdmFpbGFibGU7XG4gICAgICBza2lwQnl0ZXMgPSBjb3VudCA+PiAzO1xuICAgICAgY291bnQgLT0gc2tpcEJ5dGVzID4+IDM7XG4gICAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IHNraXBCeXRlcztcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfVxuICB9IC8vIChzaXplOmludCk6dWludFxuICA7XG5cbiAgX3Byb3RvLnJlYWRCaXRzID0gZnVuY3Rpb24gcmVhZEJpdHMoc2l6ZSkge1xuICAgIHZhciBiaXRzID0gTWF0aC5taW4odGhpcy5iaXRzQXZhaWxhYmxlLCBzaXplKTsgLy8gOnVpbnRcblxuICAgIHZhciB2YWx1ID0gdGhpcy53b3JkID4+PiAzMiAtIGJpdHM7IC8vIDp1aW50XG5cbiAgICBpZiAoc2l6ZSA+IDMyKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJsb2dnZXJcIl0uZXJyb3IoJ0Nhbm5vdCByZWFkIG1vcmUgdGhhbiAzMiBiaXRzIGF0IGEgdGltZScpO1xuICAgIH1cblxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBiaXRzO1xuXG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMud29yZCA8PD0gYml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXNBdmFpbGFibGUgPiAwKSB7XG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgfVxuXG4gICAgYml0cyA9IHNpemUgLSBiaXRzO1xuXG4gICAgaWYgKGJpdHMgPiAwICYmIHRoaXMuYml0c0F2YWlsYWJsZSkge1xuICAgICAgcmV0dXJuIHZhbHUgPDwgYml0cyB8IHRoaXMucmVhZEJpdHMoYml0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWx1O1xuICAgIH1cbiAgfSAvLyAoKTp1aW50XG4gIDtcblxuICBfcHJvdG8uc2tpcExaID0gZnVuY3Rpb24gc2tpcExaKCkge1xuICAgIHZhciBsZWFkaW5nWmVyb0NvdW50OyAvLyA6dWludFxuXG4gICAgZm9yIChsZWFkaW5nWmVyb0NvdW50ID0gMDsgbGVhZGluZ1plcm9Db3VudCA8IHRoaXMuYml0c0F2YWlsYWJsZTsgKytsZWFkaW5nWmVyb0NvdW50KSB7XG4gICAgICBpZiAoKHRoaXMud29yZCAmIDB4ODAwMDAwMDAgPj4+IGxlYWRpbmdaZXJvQ291bnQpICE9PSAwKSB7XG4gICAgICAgIC8vIHRoZSBmaXJzdCBiaXQgb2Ygd29ya2luZyB3b3JkIGlzIDFcbiAgICAgICAgdGhpcy53b3JkIDw8PSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICB9XG4gICAgfSAvLyB3ZSBleGhhdXN0ZWQgd29yZCBhbmQgc3RpbGwgaGF2ZSBub3QgZm91bmQgYSAxXG5cblxuICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudCArIHRoaXMuc2tpcExaKCk7XG4gIH0gLy8gKCk6dm9pZFxuICA7XG5cbiAgX3Byb3RvLnNraXBVRUcgPSBmdW5jdGlvbiBza2lwVUVHKCkge1xuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICB9IC8vICgpOnZvaWRcbiAgO1xuXG4gIF9wcm90by5za2lwRUcgPSBmdW5jdGlvbiBza2lwRUcoKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH0gLy8gKCk6dWludFxuICA7XG5cbiAgX3Byb3RvLnJlYWRVRUcgPSBmdW5jdGlvbiByZWFkVUVHKCkge1xuICAgIHZhciBjbHogPSB0aGlzLnNraXBMWigpOyAvLyA6dWludFxuXG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoY2x6ICsgMSkgLSAxO1xuICB9IC8vICgpOmludFxuICA7XG5cbiAgX3Byb3RvLnJlYWRFRyA9IGZ1bmN0aW9uIHJlYWRFRygpIHtcbiAgICB2YXIgdmFsdSA9IHRoaXMucmVhZFVFRygpOyAvLyA6aW50XG5cbiAgICBpZiAoMHgwMSAmIHZhbHUpIHtcbiAgICAgIC8vIHRoZSBudW1iZXIgaXMgb2RkIGlmIHRoZSBsb3cgb3JkZXIgYml0IGlzIHNldFxuICAgICAgcmV0dXJuIDEgKyB2YWx1ID4+PiAxOyAvLyBhZGQgMSB0byBtYWtlIGl0IGV2ZW4sIGFuZCBkaXZpZGUgYnkgMlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTEgKiAodmFsdSA+Pj4gMSk7IC8vIGRpdmlkZSBieSB0d28gdGhlbiBtYWtlIGl0IG5lZ2F0aXZlXG4gICAgfVxuICB9IC8vIFNvbWUgY29udmVuaWVuY2UgZnVuY3Rpb25zXG4gIC8vIDpCb29sZWFuXG4gIDtcblxuICBfcHJvdG8ucmVhZEJvb2xlYW4gPSBmdW5jdGlvbiByZWFkQm9vbGVhbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygxKSA9PT0gMTtcbiAgfSAvLyAoKTppbnRcbiAgO1xuXG4gIF9wcm90by5yZWFkVUJ5dGUgPSBmdW5jdGlvbiByZWFkVUJ5dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoOCk7XG4gIH0gLy8gKCk6aW50XG4gIDtcblxuICBfcHJvdG8ucmVhZFVTaG9ydCA9IGZ1bmN0aW9uIHJlYWRVU2hvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMTYpO1xuICB9IC8vICgpOmludFxuICA7XG5cbiAgX3Byb3RvLnJlYWRVSW50ID0gZnVuY3Rpb24gcmVhZFVJbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMzIpO1xuICB9XG4gIC8qKlxuICAgKiBBZHZhbmNlIHRoZSBFeHBHb2xvbWIgZGVjb2RlciBwYXN0IGEgc2NhbGluZyBsaXN0LiBUaGUgc2NhbGluZ1xuICAgKiBsaXN0IGlzIG9wdGlvbmFsbHkgdHJhbnNtaXR0ZWQgYXMgcGFydCBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlclxuICAgKiBzZXQgYW5kIGlzIG5vdCByZWxldmFudCB0byB0cmFuc211eGluZy5cbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHNjYWxpbmcgbGlzdFxuICAgKiBAc2VlIFJlY29tbWVuZGF0aW9uIElUVS1UIEguMjY0LCBTZWN0aW9uIDcuMy4yLjEuMS4xXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNraXBTY2FsaW5nTGlzdCA9IGZ1bmN0aW9uIHNraXBTY2FsaW5nTGlzdChjb3VudCkge1xuICAgIHZhciBsYXN0U2NhbGUgPSA4O1xuICAgIHZhciBuZXh0U2NhbGUgPSA4O1xuICAgIHZhciBkZWx0YVNjYWxlO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICBpZiAobmV4dFNjYWxlICE9PSAwKSB7XG4gICAgICAgIGRlbHRhU2NhbGUgPSB0aGlzLnJlYWRFRygpO1xuICAgICAgICBuZXh0U2NhbGUgPSAobGFzdFNjYWxlICsgZGVsdGFTY2FsZSArIDI1NikgJSAyNTY7XG4gICAgICB9XG5cbiAgICAgIGxhc3RTY2FsZSA9IG5leHRTY2FsZSA9PT0gMCA/IGxhc3RTY2FsZSA6IG5leHRTY2FsZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGFuZCByZXR1cm4gc29tZSBpbnRlcmVzdGluZyB2aWRlb1xuICAgKiBwcm9wZXJ0aWVzLiBBIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgaXMgdGhlIEgyNjQgbWV0YWRhdGEgdGhhdFxuICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxuICAgKiBAcGFyYW0gZGF0YSB7VWludDhBcnJheX0gdGhlIGJ5dGVzIG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldFxuICAgKiBAcmV0dXJuIHtvYmplY3R9IGFuIG9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gcGFyc2VkIGZyb20gdGhlXG4gICAqIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQsIGluY2x1ZGluZyB0aGUgZGltZW5zaW9ucyBvZiB0aGVcbiAgICogYXNzb2NpYXRlZCB2aWRlbyBmcmFtZXMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlYWRTUFMgPSBmdW5jdGlvbiByZWFkU1BTKCkge1xuICAgIHZhciBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gMDtcbiAgICB2YXIgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSAwO1xuICAgIHZhciBmcmFtZUNyb3BUb3BPZmZzZXQgPSAwO1xuICAgIHZhciBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSAwO1xuICAgIHZhciBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGU7XG4gICAgdmFyIHNjYWxpbmdMaXN0Q291bnQ7XG4gICAgdmFyIGk7XG4gICAgdmFyIHJlYWRVQnl0ZSA9IHRoaXMucmVhZFVCeXRlLmJpbmQodGhpcyk7XG4gICAgdmFyIHJlYWRCaXRzID0gdGhpcy5yZWFkQml0cy5iaW5kKHRoaXMpO1xuICAgIHZhciByZWFkVUVHID0gdGhpcy5yZWFkVUVHLmJpbmQodGhpcyk7XG4gICAgdmFyIHJlYWRCb29sZWFuID0gdGhpcy5yZWFkQm9vbGVhbi5iaW5kKHRoaXMpO1xuICAgIHZhciBza2lwQml0cyA9IHRoaXMuc2tpcEJpdHMuYmluZCh0aGlzKTtcbiAgICB2YXIgc2tpcEVHID0gdGhpcy5za2lwRUcuYmluZCh0aGlzKTtcbiAgICB2YXIgc2tpcFVFRyA9IHRoaXMuc2tpcFVFRy5iaW5kKHRoaXMpO1xuICAgIHZhciBza2lwU2NhbGluZ0xpc3QgPSB0aGlzLnNraXBTY2FsaW5nTGlzdC5iaW5kKHRoaXMpO1xuICAgIHJlYWRVQnl0ZSgpO1xuICAgIHZhciBwcm9maWxlSWRjID0gcmVhZFVCeXRlKCk7IC8vIHByb2ZpbGVfaWRjXG5cbiAgICByZWFkQml0cyg1KTsgLy8gcHJvZmlsZUNvbXBhdCBjb25zdHJhaW50X3NldFswLTRdX2ZsYWcsIHUoNSlcblxuICAgIHNraXBCaXRzKDMpOyAvLyByZXNlcnZlZF96ZXJvXzNiaXRzIHUoMyksXG5cbiAgICByZWFkVUJ5dGUoKTsgLy8gbGV2ZWxfaWRjIHUoOClcblxuICAgIHNraXBVRUcoKTsgLy8gc2VxX3BhcmFtZXRlcl9zZXRfaWRcbiAgICAvLyBzb21lIHByb2ZpbGVzIGhhdmUgbW9yZSBvcHRpb25hbCBkYXRhIHdlIGRvbid0IG5lZWRcblxuICAgIGlmIChwcm9maWxlSWRjID09PSAxMDAgfHwgcHJvZmlsZUlkYyA9PT0gMTEwIHx8IHByb2ZpbGVJZGMgPT09IDEyMiB8fCBwcm9maWxlSWRjID09PSAyNDQgfHwgcHJvZmlsZUlkYyA9PT0gNDQgfHwgcHJvZmlsZUlkYyA9PT0gODMgfHwgcHJvZmlsZUlkYyA9PT0gODYgfHwgcHJvZmlsZUlkYyA9PT0gMTE4IHx8IHByb2ZpbGVJZGMgPT09IDEyOCkge1xuICAgICAgdmFyIGNocm9tYUZvcm1hdElkYyA9IHJlYWRVRUcoKTtcblxuICAgICAgaWYgKGNocm9tYUZvcm1hdElkYyA9PT0gMykge1xuICAgICAgICBza2lwQml0cygxKTtcbiAgICAgIH0gLy8gc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWdcblxuXG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9sdW1hX21pbnVzOFxuXG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9jaHJvbWFfbWludXM4XG5cbiAgICAgIHNraXBCaXRzKDEpOyAvLyBxcHByaW1lX3lfemVyb190cmFuc2Zvcm1fYnlwYXNzX2ZsYWdcblxuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgLy8gc2VxX3NjYWxpbmdfbWF0cml4X3ByZXNlbnRfZmxhZ1xuICAgICAgICBzY2FsaW5nTGlzdENvdW50ID0gY2hyb21hRm9ybWF0SWRjICE9PSAzID8gOCA6IDEyO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FsaW5nTGlzdENvdW50OyBpKyspIHtcbiAgICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgICAgLy8gc2VxX3NjYWxpbmdfbGlzdF9wcmVzZW50X2ZsYWdbIGkgXVxuICAgICAgICAgICAgaWYgKGkgPCA2KSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCgxNik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBza2lwU2NhbGluZ0xpc3QoNjQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNraXBVRUcoKTsgLy8gbG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNFxuXG4gICAgdmFyIHBpY09yZGVyQ250VHlwZSA9IHJlYWRVRUcoKTtcblxuICAgIGlmIChwaWNPcmRlckNudFR5cGUgPT09IDApIHtcbiAgICAgIHJlYWRVRUcoKTsgLy8gbG9nMl9tYXhfcGljX29yZGVyX2NudF9sc2JfbWludXM0XG4gICAgfSBlbHNlIGlmIChwaWNPcmRlckNudFR5cGUgPT09IDEpIHtcbiAgICAgIHNraXBCaXRzKDEpOyAvLyBkZWx0YV9waWNfb3JkZXJfYWx3YXlzX3plcm9fZmxhZ1xuXG4gICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl9ub25fcmVmX3BpY1xuXG4gICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl90b3BfdG9fYm90dG9tX2ZpZWxkXG5cbiAgICAgIG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZSA9IHJlYWRVRUcoKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTsgaSsrKSB7XG4gICAgICAgIHNraXBFRygpO1xuICAgICAgfSAvLyBvZmZzZXRfZm9yX3JlZl9mcmFtZVsgaSBdXG5cbiAgICB9XG5cbiAgICBza2lwVUVHKCk7IC8vIG1heF9udW1fcmVmX2ZyYW1lc1xuXG4gICAgc2tpcEJpdHMoMSk7IC8vIGdhcHNfaW5fZnJhbWVfbnVtX3ZhbHVlX2FsbG93ZWRfZmxhZ1xuXG4gICAgdmFyIHBpY1dpZHRoSW5NYnNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgdmFyIHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgdmFyIGZyYW1lTWJzT25seUZsYWcgPSByZWFkQml0cygxKTtcblxuICAgIGlmIChmcmFtZU1ic09ubHlGbGFnID09PSAwKSB7XG4gICAgICBza2lwQml0cygxKTtcbiAgICB9IC8vIG1iX2FkYXB0aXZlX2ZyYW1lX2ZpZWxkX2ZsYWdcblxuXG4gICAgc2tpcEJpdHMoMSk7IC8vIGRpcmVjdF84eDhfaW5mZXJlbmNlX2ZsYWdcblxuICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAvLyBmcmFtZV9jcm9wcGluZ19mbGFnXG4gICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgfVxuXG4gICAgdmFyIHBpeGVsUmF0aW8gPSBbMSwgMV07XG5cbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAvLyBhc3BlY3RfcmF0aW9faW5mb19wcmVzZW50X2ZsYWdcbiAgICAgICAgdmFyIGFzcGVjdFJhdGlvSWRjID0gcmVhZFVCeXRlKCk7XG5cbiAgICAgICAgc3dpdGNoIChhc3BlY3RSYXRpb0lkYykge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMSwgMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTIsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxMCwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE2LCAxMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNDAsIDMzXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsyNCwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzIwLCAxMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMzIsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs4MCwgMzNdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxOCwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxNSwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs2NCwgMzNdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxNjAsIDk5XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNCwgM107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzMsIDJdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsyLCAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyNTU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbcmVhZFVCeXRlKCkgPDwgOCB8IHJlYWRVQnl0ZSgpLCByZWFkVUJ5dGUoKSA8PCA4IHwgcmVhZFVCeXRlKCldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogTWF0aC5jZWlsKChwaWNXaWR0aEluTWJzTWludXMxICsgMSkgKiAxNiAtIGZyYW1lQ3JvcExlZnRPZmZzZXQgKiAyIC0gZnJhbWVDcm9wUmlnaHRPZmZzZXQgKiAyKSxcbiAgICAgIGhlaWdodDogKDIgLSBmcmFtZU1ic09ubHlGbGFnKSAqIChwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxICsgMSkgKiAxNiAtIChmcmFtZU1ic09ubHlGbGFnID8gMiA6IDQpICogKGZyYW1lQ3JvcFRvcE9mZnNldCArIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCksXG4gICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8ucmVhZFNsaWNlVHlwZSA9IGZ1bmN0aW9uIHJlYWRTbGljZVR5cGUoKSB7XG4gICAgLy8gc2tpcCBOQUx1IHR5cGVcbiAgICB0aGlzLnJlYWRVQnl0ZSgpOyAvLyBkaXNjYXJkIGZpcnN0X21iX2luX3NsaWNlXG5cbiAgICB0aGlzLnJlYWRVRUcoKTsgLy8gcmV0dXJuIHNsaWNlX3R5cGVcblxuICAgIHJldHVybiB0aGlzLnJlYWRVRUcoKTtcbiAgfTtcblxuICByZXR1cm4gRXhwR29sb21iO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKEV4cEdvbG9tYik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L2lkMy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvaWQzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBpc0hlYWRlciwgaXNGb290ZXIsIGdldElEM0RhdGEsIGNhblBhcnNlLCBnZXRUaW1lU3RhbXAsIGlzVGltZVN0YW1wRnJhbWUsIGdldElEM0ZyYW1lcywgZGVjb2RlRnJhbWUsIHV0ZjhBcnJheVRvU3RyLCB0ZXN0YWJsZXMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNIZWFkZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0hlYWRlcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNGb290ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0Zvb3RlcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0SUQzRGF0YVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldElEM0RhdGE7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNhblBhcnNlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2FuUGFyc2U7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldFRpbWVTdGFtcFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFRpbWVTdGFtcDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNUaW1lU3RhbXBGcmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzVGltZVN0YW1wRnJhbWU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldElEM0ZyYW1lc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldElEM0ZyYW1lczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVjb2RlRnJhbWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkZWNvZGVGcmFtZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidXRmOEFycmF5VG9TdHJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB1dGY4QXJyYXlUb1N0cjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidGVzdGFibGVzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGVzdGFibGVzOyB9KTtcbi8vIGJyZWFraW5nIHVwIHRob3NlIHR3byB0eXBlcyBpbiBvcmRlciB0byBjbGFyaWZ5IHdoYXQgaXMgaGFwcGVuaW5nIGluIHRoZSBkZWNvZGluZyBwYXRoLlxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGlzIGZvdW5kXG4gKi9cbnZhciBpc0hlYWRlciA9IGZ1bmN0aW9uIGlzSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAvKlxuICAgKiBodHRwOi8vaWQzLm9yZy9pZDN2Mi4zLjBcbiAgICogWzBdICAgICA9ICdJJ1xuICAgKiBbMV0gICAgID0gJ0QnXG4gICAqIFsyXSAgICAgPSAnMydcbiAgICogWzMsNF0gICA9IHtWZXJzaW9ufVxuICAgKiBbNV0gICAgID0ge0ZsYWdzfVxuICAgKiBbNi05XSAgID0ge0lEMyBTaXplfVxuICAgKlxuICAgKiBBbiBJRDN2MiB0YWcgY2FuIGJlIGRldGVjdGVkIHdpdGggdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxuICAgKiAgJDQ5IDQ0IDMzIHl5IHl5IHh4IHp6IHp6IHp6IHp6XG4gICAqIFdoZXJlIHl5IGlzIGxlc3MgdGhhbiAkRkYsIHh4IGlzIHRoZSAnZmxhZ3MnIGJ5dGUgYW5kIHp6IGlzIGxlc3MgdGhhbiAkODBcbiAgICovXG4gIGlmIChvZmZzZXQgKyAxMCA8PSBkYXRhLmxlbmd0aCkge1xuICAgIC8vIGxvb2sgZm9yICdJRDMnIGlkZW50aWZpZXJcbiAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweDQ5ICYmIGRhdGFbb2Zmc2V0ICsgMV0gPT09IDB4NDQgJiYgZGF0YVtvZmZzZXQgKyAyXSA9PT0gMHgzMykge1xuICAgICAgLy8gY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhmZiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhmZikge1xuICAgICAgICAvLyBjaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA3XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA4XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgZm9vdGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhbiBJRDMgZm9vdGVyIGlzIGZvdW5kXG4gKi9cblxudmFyIGlzRm9vdGVyID0gZnVuY3Rpb24gaXNGb290ZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIC8qXG4gICAqIFRoZSBmb290ZXIgaXMgYSBjb3B5IG9mIHRoZSBoZWFkZXIsIGJ1dCB3aXRoIGEgZGlmZmVyZW50IGlkZW50aWZpZXJcbiAgICovXG4gIGlmIChvZmZzZXQgKyAxMCA8PSBkYXRhLmxlbmd0aCkge1xuICAgIC8vIGxvb2sgZm9yICczREknIGlkZW50aWZpZXJcbiAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweDMzICYmIGRhdGFbb2Zmc2V0ICsgMV0gPT09IDB4NDQgJiYgZGF0YVtvZmZzZXQgKyAyXSA9PT0gMHg0OSkge1xuICAgICAgLy8gY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhmZiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhmZikge1xuICAgICAgICAvLyBjaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA3XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA4XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIFJldHVybnMgYW55IGFkamFjZW50IElEMyB0YWdzIGZvdW5kIGluIGRhdGEgc3RhcnRpbmcgYXQgb2Zmc2V0LCBhcyBvbmUgYmxvY2sgb2YgZGF0YVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXkgfCB1bmRlZmluZWR9IC0gVGhlIGJsb2NrIG9mIGRhdGEgY29udGFpbmluZyBhbnkgSUQzIHRhZ3MgZm91bmRcbiAqIG9yICp1bmRlZmluZWQqIGlmIG5vIGhlYWRlciBpcyBmb3VuZCBhdCB0aGUgc3RhcnRpbmcgb2Zmc2V0XG4gKi9cblxudmFyIGdldElEM0RhdGEgPSBmdW5jdGlvbiBnZXRJRDNEYXRhKGRhdGEsIG9mZnNldCkge1xuICB2YXIgZnJvbnQgPSBvZmZzZXQ7XG4gIHZhciBsZW5ndGggPSAwO1xuXG4gIHdoaWxlIChpc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgLy8gSUQzIGhlYWRlciBpcyAxMCBieXRlc1xuICAgIGxlbmd0aCArPSAxMDtcbiAgICB2YXIgc2l6ZSA9IHJlYWRTaXplKGRhdGEsIG9mZnNldCArIDYpO1xuICAgIGxlbmd0aCArPSBzaXplO1xuXG4gICAgaWYgKGlzRm9vdGVyKGRhdGEsIG9mZnNldCArIDEwKSkge1xuICAgICAgLy8gSUQzIGZvb3RlciBpcyAxMCBieXRlc1xuICAgICAgbGVuZ3RoICs9IDEwO1xuICAgIH1cblxuICAgIG9mZnNldCArPSBsZW5ndGg7XG4gIH1cblxuICBpZiAobGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkYXRhLnN1YmFycmF5KGZyb250LCBmcm9udCArIGxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxudmFyIHJlYWRTaXplID0gZnVuY3Rpb24gcmVhZFNpemUoZGF0YSwgb2Zmc2V0KSB7XG4gIHZhciBzaXplID0gMDtcbiAgc2l6ZSA9IChkYXRhW29mZnNldF0gJiAweDdmKSA8PCAyMTtcbiAgc2l6ZSB8PSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4N2YpIDw8IDE0O1xuICBzaXplIHw9IChkYXRhW29mZnNldCArIDJdICYgMHg3ZikgPDwgNztcbiAgc2l6ZSB8PSBkYXRhW29mZnNldCArIDNdICYgMHg3ZjtcbiAgcmV0dXJuIHNpemU7XG59O1xuXG52YXIgY2FuUGFyc2UgPSBmdW5jdGlvbiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGlzSGVhZGVyKGRhdGEsIG9mZnNldCkgJiYgcmVhZFNpemUoZGF0YSwgb2Zmc2V0ICsgNikgKyAxMCA8PSBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbn07XG4vKipcbiAqIFNlYXJjaGVzIGZvciB0aGUgRWxlbWVudGFyeSBTdHJlYW0gdGltZXN0YW1wIGZvdW5kIGluIHRoZSBJRDMgZGF0YSBjaHVua1xuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gQmxvY2sgb2YgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXG4gKiBAcmV0dXJuIHtudW1iZXIgfCB1bmRlZmluZWR9IC0gVGhlIHRpbWVzdGFtcFxuICovXG5cbnZhciBnZXRUaW1lU3RhbXAgPSBmdW5jdGlvbiBnZXRUaW1lU3RhbXAoZGF0YSkge1xuICB2YXIgZnJhbWVzID0gZ2V0SUQzRnJhbWVzKGRhdGEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGZyYW1lID0gZnJhbWVzW2ldO1xuXG4gICAgaWYgKGlzVGltZVN0YW1wRnJhbWUoZnJhbWUpKSB7XG4gICAgICByZXR1cm4gcmVhZFRpbWVTdGFtcChmcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSUQzIGZyYW1lIGlzIGFuIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmcmFtZVxuICogQHBhcmFtIHtJRDMgZnJhbWV9IGZyYW1lXG4gKi9cblxudmFyIGlzVGltZVN0YW1wRnJhbWUgPSBmdW5jdGlvbiBpc1RpbWVTdGFtcEZyYW1lKGZyYW1lKSB7XG4gIHJldHVybiBmcmFtZSAmJiBmcmFtZS5rZXkgPT09ICdQUklWJyAmJiBmcmFtZS5pbmZvID09PSAnY29tLmFwcGxlLnN0cmVhbWluZy50cmFuc3BvcnRTdHJlYW1UaW1lc3RhbXAnO1xufTtcblxudmFyIGdldEZyYW1lRGF0YSA9IGZ1bmN0aW9uIGdldEZyYW1lRGF0YShkYXRhKSB7XG4gIC8qXG4gIEZyYW1lIElEICAgICAgICR4eCB4eCB4eCB4eCAoZm91ciBjaGFyYWN0ZXJzKVxuICBTaXplICAgICAgICAgICAkeHggeHggeHggeHhcbiAgRmxhZ3MgICAgICAgICAgJHh4IHh4XG4gICovXG4gIHZhciB0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhWzBdLCBkYXRhWzFdLCBkYXRhWzJdLCBkYXRhWzNdKTtcbiAgdmFyIHNpemUgPSByZWFkU2l6ZShkYXRhLCA0KTsgLy8gc2tpcCBmcmFtZSBpZCwgc2l6ZSwgYW5kIGZsYWdzXG5cbiAgdmFyIG9mZnNldCA9IDEwO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgc2l6ZTogc2l6ZSxcbiAgICBkYXRhOiBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSlcbiAgfTtcbn07XG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgSUQzIGZyYW1lcyBmb3VuZCBpbiBhbGwgdGhlIElEMyB0YWdzIGluIHRoZSBpZDNEYXRhXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlkM0RhdGEgLSBUaGUgSUQzIGRhdGEgY29udGFpbmluZyBvbmUgb3IgbW9yZSBJRDMgdGFnc1xuICogQHJldHVybiB7SUQzLkZyYW1lW119IC0gQXJyYXkgb2YgSUQzIGZyYW1lIG9iamVjdHNcbiAqL1xuXG5cbnZhciBnZXRJRDNGcmFtZXMgPSBmdW5jdGlvbiBnZXRJRDNGcmFtZXMoaWQzRGF0YSkge1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIGZyYW1lcyA9IFtdO1xuXG4gIHdoaWxlIChpc0hlYWRlcihpZDNEYXRhLCBvZmZzZXQpKSB7XG4gICAgdmFyIHNpemUgPSByZWFkU2l6ZShpZDNEYXRhLCBvZmZzZXQgKyA2KTsgLy8gc2tpcCBwYXN0IElEMyBoZWFkZXJcblxuICAgIG9mZnNldCArPSAxMDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0ICsgc2l6ZTsgLy8gbG9vcCB0aHJvdWdoIGZyYW1lcyBpbiB0aGUgSUQzIHRhZ1xuXG4gICAgd2hpbGUgKG9mZnNldCArIDggPCBlbmQpIHtcbiAgICAgIHZhciBmcmFtZURhdGEgPSBnZXRGcmFtZURhdGEoaWQzRGF0YS5zdWJhcnJheShvZmZzZXQpKTtcbiAgICAgIHZhciBmcmFtZSA9IGRlY29kZUZyYW1lKGZyYW1lRGF0YSk7XG5cbiAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICBmcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICB9IC8vIHNraXAgZnJhbWUgaGVhZGVyIGFuZCBmcmFtZSBkYXRhXG5cblxuICAgICAgb2Zmc2V0ICs9IGZyYW1lRGF0YS5zaXplICsgMTA7XG4gICAgfVxuXG4gICAgaWYgKGlzRm9vdGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICAgIG9mZnNldCArPSAxMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnJhbWVzO1xufTtcbnZhciBkZWNvZGVGcmFtZSA9IGZ1bmN0aW9uIGRlY29kZUZyYW1lKGZyYW1lKSB7XG4gIGlmIChmcmFtZS50eXBlID09PSAnUFJJVicpIHtcbiAgICByZXR1cm4gZGVjb2RlUHJpdkZyYW1lKGZyYW1lKTtcbiAgfSBlbHNlIGlmIChmcmFtZS50eXBlWzBdID09PSAnVycpIHtcbiAgICByZXR1cm4gZGVjb2RlVVJMRnJhbWUoZnJhbWUpO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZVRleHRGcmFtZShmcmFtZSk7XG59O1xuXG52YXIgZGVjb2RlUHJpdkZyYW1lID0gZnVuY3Rpb24gZGVjb2RlUHJpdkZyYW1lKGZyYW1lKSB7XG4gIC8qXG4gIEZvcm1hdDogPHRleHQgc3RyaW5nPlxcMDxiaW5hcnkgZGF0YT5cbiAgKi9cbiAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBvd25lciA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEsIHRydWUpO1xuICB2YXIgcHJpdmF0ZURhdGEgPSBuZXcgVWludDhBcnJheShmcmFtZS5kYXRhLnN1YmFycmF5KG93bmVyLmxlbmd0aCArIDEpKTtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IGZyYW1lLnR5cGUsXG4gICAgaW5mbzogb3duZXIsXG4gICAgZGF0YTogcHJpdmF0ZURhdGEuYnVmZmVyXG4gIH07XG59O1xuXG52YXIgZGVjb2RlVGV4dEZyYW1lID0gZnVuY3Rpb24gZGVjb2RlVGV4dEZyYW1lKGZyYW1lKSB7XG4gIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoZnJhbWUudHlwZSA9PT0gJ1RYWFgnKSB7XG4gICAgLypcbiAgICBGb3JtYXQ6XG4gICAgWzBdICAgPSB7VGV4dCBFbmNvZGluZ31cbiAgICBbMS0/XSA9IHtEZXNjcmlwdGlvbn1cXDB7VmFsdWV9XG4gICAgKi9cbiAgICB2YXIgaW5kZXggPSAxO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpLCB0cnVlKTtcbiAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgIHZhciB2YWx1ZSA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBmcmFtZS50eXBlLFxuICAgICAgaW5mbzogZGVzY3JpcHRpb24sXG4gICAgICBkYXRhOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgLypcbiAgRm9ybWF0OlxuICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICBbMS0/XSA9IHtWYWx1ZX1cbiAgKi9cblxuXG4gIHZhciB0ZXh0ID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheSgxKSk7XG4gIHJldHVybiB7XG4gICAga2V5OiBmcmFtZS50eXBlLFxuICAgIGRhdGE6IHRleHRcbiAgfTtcbn07XG5cbnZhciBkZWNvZGVVUkxGcmFtZSA9IGZ1bmN0aW9uIGRlY29kZVVSTEZyYW1lKGZyYW1lKSB7XG4gIGlmIChmcmFtZS50eXBlID09PSAnV1hYWCcpIHtcbiAgICAvKlxuICAgIEZvcm1hdDpcbiAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtVUkx9XG4gICAgKi9cbiAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gMTtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSwgdHJ1ZSk7XG4gICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICB2YXIgdmFsdWUgPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogZnJhbWUudHlwZSxcbiAgICAgIGluZm86IGRlc2NyaXB0aW9uLFxuICAgICAgZGF0YTogdmFsdWVcbiAgICB9O1xuICB9XG4gIC8qXG4gIEZvcm1hdDpcbiAgWzAtP10gPSB7VVJMfVxuICAqL1xuXG5cbiAgdmFyIHVybCA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEpO1xuICByZXR1cm4ge1xuICAgIGtleTogZnJhbWUudHlwZSxcbiAgICBkYXRhOiB1cmxcbiAgfTtcbn07XG5cbnZhciByZWFkVGltZVN0YW1wID0gZnVuY3Rpb24gcmVhZFRpbWVTdGFtcCh0aW1lU3RhbXBGcmFtZSkge1xuICBpZiAodGltZVN0YW1wRnJhbWUuZGF0YS5ieXRlTGVuZ3RoID09PSA4KSB7XG4gICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSh0aW1lU3RhbXBGcmFtZS5kYXRhKTsgLy8gdGltZXN0YW1wIGlzIDMzIGJpdCBleHByZXNzZWQgYXMgYSBiaWctZW5kaWFuIGVpZ2h0LW9jdGV0IG51bWJlcixcbiAgICAvLyB3aXRoIHRoZSB1cHBlciAzMSBiaXRzIHNldCB0byB6ZXJvLlxuXG4gICAgdmFyIHB0czMzQml0ID0gZGF0YVszXSAmIDB4MTtcbiAgICB2YXIgdGltZXN0YW1wID0gKGRhdGFbNF0gPDwgMjMpICsgKGRhdGFbNV0gPDwgMTUpICsgKGRhdGFbNl0gPDwgNykgKyBkYXRhWzddO1xuICAgIHRpbWVzdGFtcCAvPSA0NTtcblxuICAgIGlmIChwdHMzM0JpdCkge1xuICAgICAgdGltZXN0YW1wICs9IDQ3NzIxODU4Ljg0O1xuICAgIH0gLy8gMl4zMiAvIDkwXG5cblxuICAgIHJldHVybiBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTsgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84OTM2OTg0L3VpbnQ4YXJyYXktdG8tc3RyaW5nLWluLWphdmFzY3JpcHQvMjIzNzMxOTdcbi8vIGh0dHA6Ly93d3cub25pY29zLmNvbS9zdGFmZi9pei9hbXVzZS9qYXZhc2NyaXB0L2V4cGVydC91dGYudHh0XG5cbi8qIHV0Zi5qcyAtIFVURi04IDw9PiBVVEYtMTYgY29udmVydGlvblxuICpcbiAqIENvcHlyaWdodCAoQykgMTk5OSBNYXNhbmFvIEl6dW1vIDxpekBvbmljb3MuY28uanA+XG4gKiBWZXJzaW9uOiAxLjBcbiAqIExhc3RNb2RpZmllZDogRGVjIDI1IDE5OTlcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlLiAgWW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdC5cbiAqL1xuXG5cbnZhciB1dGY4QXJyYXlUb1N0ciA9IGZ1bmN0aW9uIHV0ZjhBcnJheVRvU3RyKGFycmF5LCBleGl0T25OdWxsKSB7XG4gIGlmIChleGl0T25OdWxsID09PSB2b2lkIDApIHtcbiAgICBleGl0T25OdWxsID0gZmFsc2U7XG4gIH1cblxuICB2YXIgZGVjb2RlciA9IGdldFRleHREZWNvZGVyKCk7XG5cbiAgaWYgKGRlY29kZXIpIHtcbiAgICB2YXIgZGVjb2RlZCA9IGRlY29kZXIuZGVjb2RlKGFycmF5KTtcblxuICAgIGlmIChleGl0T25OdWxsKSB7XG4gICAgICAvLyBncmFiIHVwIHRvIHRoZSBmaXJzdCBudWxsXG4gICAgICB2YXIgaWR4ID0gZGVjb2RlZC5pbmRleE9mKCdcXDAnKTtcbiAgICAgIHJldHVybiBpZHggIT09IC0xID8gZGVjb2RlZC5zdWJzdHJpbmcoMCwgaWR4KSA6IGRlY29kZWQ7XG4gICAgfSAvLyByZW1vdmUgYW55IG51bGwgY2hhcmFjdGVyc1xuXG5cbiAgICByZXR1cm4gZGVjb2RlZC5yZXBsYWNlKC9cXDAvZywgJycpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIGM7XG4gIHZhciBjaGFyMjtcbiAgdmFyIGNoYXIzO1xuICB2YXIgb3V0ID0gJyc7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGMgPSBhcnJheVtpKytdO1xuXG4gICAgaWYgKGMgPT09IDB4MDAgJiYgZXhpdE9uTnVsbCkge1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2UgaWYgKGMgPT09IDB4MDAgfHwgYyA9PT0gMHgwMykge1xuICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyAzIChFTkRfT0ZfVEVYVCkgb3IgMCAoTlVMTCkgdGhlbiBza2lwIGl0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGMgPj4gNCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAxOlxuICAgICAgY2FzZSAyOlxuICAgICAgY2FzZSAzOlxuICAgICAgY2FzZSA0OlxuICAgICAgY2FzZSA1OlxuICAgICAgY2FzZSA2OlxuICAgICAgY2FzZSA3OlxuICAgICAgICAvLyAweHh4eHh4eFxuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMTI6XG4gICAgICBjYXNlIDEzOlxuICAgICAgICAvLyAxMTB4IHh4eHggICAxMHh4IHh4eHhcbiAgICAgICAgY2hhcjIgPSBhcnJheVtpKytdO1xuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDB4MWYpIDw8IDYgfCBjaGFyMiAmIDB4M2YpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxNDpcbiAgICAgICAgLy8gMTExMCB4eHh4ICAxMHh4IHh4eHggIDEweHggeHh4eFxuICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgIGNoYXIzID0gYXJyYXlbaSsrXTtcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAweDBmKSA8PCAxMiB8IChjaGFyMiAmIDB4M2YpIDw8IDYgfCAoY2hhcjMgJiAweDNmKSA8PCAwKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG52YXIgdGVzdGFibGVzID0ge1xuICBkZWNvZGVUZXh0RnJhbWU6IGRlY29kZVRleHRGcmFtZVxufTtcbnZhciBkZWNvZGVyO1xuXG5mdW5jdGlvbiBnZXRUZXh0RGVjb2RlcigpIHtcbiAgaWYgKCFkZWNvZGVyICYmIHR5cGVvZiBzZWxmLlRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRlY29kZXIgPSBuZXcgc2VsZi5UZXh0RGVjb2RlcigndXRmLTgnKTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVyO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9tcDNkZW11eGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvbXAzZGVtdXhlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2VfYXVkaW9fZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLWF1ZGlvLWRlbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC9iYXNlLWF1ZGlvLWRlbXV4ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X2lkM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvaWQzICovIFwiLi9zcmMvZGVtdXgvaWQzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbXBlZ2F1ZGlvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21wZWdhdWRpbyAqLyBcIi4vc3JjL2RlbXV4L21wZWdhdWRpby50c1wiKTtcbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG4vKipcbiAqIE1QMyBkZW11eGVyXG4gKi9cblxuXG5cblxuXG52YXIgTVAzRGVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VBdWRpb0RlbXV4ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoTVAzRGVtdXhlciwgX0Jhc2VBdWRpb0RlbXV4ZXIpO1xuXG4gIGZ1bmN0aW9uIE1QM0RlbXV4ZXIoKSB7XG4gICAgcmV0dXJuIF9CYXNlQXVkaW9EZW11eGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBNUDNEZW11eGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICBfQmFzZUF1ZGlvRGVtdXhlci5wcm90b3R5cGUucmVzZXRJbml0U2VnbWVudC5jYWxsKHRoaXMsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKTtcblxuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7XG4gICAgICBjb250YWluZXI6ICdhdWRpby9tcGVnJyxcbiAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICBpZDogMixcbiAgICAgIHBpZDogLTEsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNlZ21lbnRDb2RlYzogJ21wMycsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICBkdXJhdGlvbjogdHJhY2tEdXJhdGlvbixcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICB9O1xuXG4gIE1QM0RlbXV4ZXIucHJvYmUgPSBmdW5jdGlvbiBwcm9iZShkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjaGVjayBpZiBkYXRhIGNvbnRhaW5zIElEMyB0aW1lc3RhbXAgYW5kIE1QRUcgc3luYyB3b3JkXG4gICAgLy8gTG9vayBmb3IgTVBFRyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTFYIFhZWlggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxIGFuZCBZIG9yIFogc2hvdWxkIGJlIDFcbiAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxuICAgIC8vIE1vcmUgaW5mbyBodHRwOi8vd3d3Lm1wMy10ZWNoLm9yZy9wcm9ncmFtbWVyL2ZyYW1lX2hlYWRlci5odG1sXG5cblxuICAgIHZhciBpZDNEYXRhID0gX2RlbXV4X2lkM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZ2V0SUQzRGF0YVwiXShkYXRhLCAwKSB8fCBbXTtcbiAgICB2YXIgb2Zmc2V0ID0gaWQzRGF0YS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgaWYgKF9tcGVnYXVkaW9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcInByb2JlXCJdKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZygnTVBFRyBBdWRpbyBzeW5jIHdvcmQgZm91bmQgIScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmNhblBhcnNlID0gZnVuY3Rpb24gY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIF9tcGVnYXVkaW9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImNhblBhcnNlXCJdKGRhdGEsIG9mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLmFwcGVuZEZyYW1lID0gZnVuY3Rpb24gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge1xuICAgIGlmICh0aGlzLmluaXRQVFMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gX21wZWdhdWRpb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiYXBwZW5kRnJhbWVcIl0odHJhY2ssIGRhdGEsIG9mZnNldCwgdGhpcy5pbml0UFRTLCB0aGlzLmZyYW1lSW5kZXgpO1xuICB9O1xuXG4gIHJldHVybiBNUDNEZW11eGVyO1xufShfYmFzZV9hdWRpb19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuTVAzRGVtdXhlci5taW5Qcm9iZUJ5dGVMZW5ndGggPSA0O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChNUDNEZW11eGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvbXA0ZGVtdXhlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L21wNGRlbXV4ZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9kZW11eGVyICovIFwiLi9zcmMvdHlwZXMvZGVtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tcDQtdG9vbHMgKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2R1bW15X2RlbXV4ZWRfdHJhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZHVtbXktZGVtdXhlZC10cmFjayAqLyBcIi4vc3JjL2RlbXV4L2R1bW15LWRlbXV4ZWQtdHJhY2sudHNcIik7XG5cblxuLyoqXG4gKiBNUDQgZGVtdXhlclxuICovXG5cblxuXG52YXIgZW1zZ1NjaGVtZVBhdHRlcm4gPSAvXFwvZW1zZ1stL11JRDMvaTtcblxudmFyIE1QNERlbXV4ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNUDREZW11eGVyKG9ic2VydmVyLCBjb25maWcpIHtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMudGltZU9mZnNldCA9IDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy52aWRlb1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuYXVkaW9UcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmlkM1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMudHh0VHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTVA0RGVtdXhlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlc2V0VGltZVN0YW1wID0gZnVuY3Rpb24gcmVzZXRUaW1lU3RhbXAoKSB7fTtcblxuICBfcHJvdG8ucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICB2YXIgaW5pdERhdGEgPSBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wicGFyc2VJbml0U2VnbWVudFwiXSkoaW5pdFNlZ21lbnQpO1xuICAgIHZhciB2aWRlb1RyYWNrID0gdGhpcy52aWRlb1RyYWNrID0gT2JqZWN0KF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkdW1teVRyYWNrXCJdKSgndmlkZW8nLCAxKTtcbiAgICB2YXIgYXVkaW9UcmFjayA9IHRoaXMuYXVkaW9UcmFjayA9IE9iamVjdChfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZHVtbXlUcmFja1wiXSkoJ2F1ZGlvJywgMSk7XG4gICAgdmFyIGNhcHRpb25UcmFjayA9IHRoaXMudHh0VHJhY2sgPSBPYmplY3QoX2R1bW15X2RlbXV4ZWRfdHJhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImR1bW15VHJhY2tcIl0pKCd0ZXh0JywgMSk7XG4gICAgdGhpcy5pZDNUcmFjayA9IE9iamVjdChfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZHVtbXlUcmFja1wiXSkoJ2lkMycsIDEpO1xuICAgIHRoaXMudGltZU9mZnNldCA9IDA7XG5cbiAgICBpZiAoaW5pdERhdGEudmlkZW8pIHtcbiAgICAgIHZhciBfaW5pdERhdGEkdmlkZW8gPSBpbml0RGF0YS52aWRlbyxcbiAgICAgICAgICBpZCA9IF9pbml0RGF0YSR2aWRlby5pZCxcbiAgICAgICAgICB0aW1lc2NhbGUgPSBfaW5pdERhdGEkdmlkZW8udGltZXNjYWxlLFxuICAgICAgICAgIGNvZGVjID0gX2luaXREYXRhJHZpZGVvLmNvZGVjO1xuICAgICAgdmlkZW9UcmFjay5pZCA9IGlkO1xuICAgICAgdmlkZW9UcmFjay50aW1lc2NhbGUgPSBjYXB0aW9uVHJhY2sudGltZXNjYWxlID0gdGltZXNjYWxlO1xuICAgICAgdmlkZW9UcmFjay5jb2RlYyA9IGNvZGVjO1xuICAgIH1cblxuICAgIGlmIChpbml0RGF0YS5hdWRpbykge1xuICAgICAgdmFyIF9pbml0RGF0YSRhdWRpbyA9IGluaXREYXRhLmF1ZGlvLFxuICAgICAgICAgIF9pZCA9IF9pbml0RGF0YSRhdWRpby5pZCxcbiAgICAgICAgICBfdGltZXNjYWxlID0gX2luaXREYXRhJGF1ZGlvLnRpbWVzY2FsZSxcbiAgICAgICAgICBfY29kZWMgPSBfaW5pdERhdGEkYXVkaW8uY29kZWM7XG4gICAgICBhdWRpb1RyYWNrLmlkID0gX2lkO1xuICAgICAgYXVkaW9UcmFjay50aW1lc2NhbGUgPSBfdGltZXNjYWxlO1xuICAgICAgYXVkaW9UcmFjay5jb2RlYyA9IF9jb2RlYztcbiAgICB9XG5cbiAgICBjYXB0aW9uVHJhY2suaWQgPSBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJSZW11eGVyVHJhY2tJZENvbmZpZ1wiXS50ZXh0O1xuICAgIHZpZGVvVHJhY2suc2FtcGxlRHVyYXRpb24gPSAwO1xuICAgIHZpZGVvVHJhY2suZHVyYXRpb24gPSBhdWRpb1RyYWNrLmR1cmF0aW9uID0gdHJhY2tEdXJhdGlvbjtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXRDb250aWd1aXR5ID0gZnVuY3Rpb24gcmVzZXRDb250aWd1aXR5KCkge307XG5cbiAgTVA0RGVtdXhlci5wcm9iZSA9IGZ1bmN0aW9uIHByb2JlKGRhdGEpIHtcbiAgICAvLyBlbnN1cmUgd2UgZmluZCBhIG1vb2YgYm94IGluIHRoZSBmaXJzdCAxNiBrQlxuICAgIGRhdGEgPSBkYXRhLmxlbmd0aCA+IDE2Mzg0ID8gZGF0YS5zdWJhcnJheSgwLCAxNjM4NCkgOiBkYXRhO1xuICAgIHJldHVybiBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZmluZEJveFwiXSkoZGF0YSwgWydtb29mJ10pLmxlbmd0aCA+IDA7XG4gIH07XG5cbiAgX3Byb3RvLmRlbXV4ID0gZnVuY3Rpb24gZGVtdXgoZGF0YSwgdGltZU9mZnNldCkge1xuICAgIHRoaXMudGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7IC8vIExvYWQgYWxsIGRhdGEgaW50byB0aGUgYXZjIHRyYWNrLiBUaGUgQ01BRiByZW11eGVyIHdpbGwgbG9vayBmb3IgdGhlIGRhdGEgaW4gdGhlIHNhbXBsZXMgb2JqZWN0OyB0aGUgcmVzdCBvZiB0aGUgZmllbGRzIGRvIG5vdCBtYXR0ZXJcblxuICAgIHZhciB2aWRlb1NhbXBsZXMgPSBkYXRhO1xuICAgIHZhciB2aWRlb1RyYWNrID0gdGhpcy52aWRlb1RyYWNrO1xuICAgIHZhciB0ZXh0VHJhY2sgPSB0aGlzLnR4dFRyYWNrO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLnByb2dyZXNzaXZlKSB7XG4gICAgICAvLyBTcGxpdCB0aGUgYnl0ZXN0cmVhbSBpbnRvIHR3byByYW5nZXM6IG9uZSBlbmNvbXBhc3NpbmcgYWxsIGRhdGEgdXAgdW50aWwgdGhlIHN0YXJ0IG9mIHRoZSBsYXN0IG1vb2YsIGFuZCBldmVyeXRoaW5nIGVsc2UuXG4gICAgICAvLyBUaGlzIGlzIGRvbmUgdG8gZ3VhcmFudGVlIHRoYXQgd2UncmUgc2VuZGluZyB2YWxpZCBkYXRhIHRvIE1TRSAtIHdoZW4gZGVtdXhpbmcgcHJvZ3Jlc3NpdmVseSwgd2UgaGF2ZSBubyBndWFyYW50ZWVcbiAgICAgIC8vIHRoYXQgdGhlIGZldGNoIGxvYWRlciBnaXZlcyB1cyBmbHVzaCBtb29mK21kYXQgcGFpcnMuIElmIHdlIHB1c2ggamFnZ2VkIGRhdGEgdG8gTVNFLCBpdCB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbi5cbiAgICAgIGlmICh0aGlzLnJlbWFpbmRlckRhdGEpIHtcbiAgICAgICAgdmlkZW9TYW1wbGVzID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImFwcGVuZFVpbnQ4QXJyYXlcIl0pKHRoaXMucmVtYWluZGVyRGF0YSwgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWdtZW50ZWREYXRhID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcInNlZ21lbnRWYWxpZFJhbmdlXCJdKSh2aWRlb1NhbXBsZXMpO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gc2VnbWVudGVkRGF0YS5yZW1haW5kZXI7XG4gICAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSBzZWdtZW50ZWREYXRhLnZhbGlkIHx8IG5ldyBVaW50OEFycmF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHZpZGVvU2FtcGxlcztcbiAgICB9XG5cbiAgICB2YXIgaWQzVHJhY2sgPSB0aGlzLmV4dHJhY3RJRDNUcmFjayh2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICB0ZXh0VHJhY2suc2FtcGxlcyA9IE9iamVjdChfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJwYXJzZVNhbXBsZXNcIl0pKHRpbWVPZmZzZXQsIHZpZGVvVHJhY2spO1xuICAgIHJldHVybiB7XG4gICAgICB2aWRlb1RyYWNrOiB2aWRlb1RyYWNrLFxuICAgICAgYXVkaW9UcmFjazogdGhpcy5hdWRpb1RyYWNrLFxuICAgICAgaWQzVHJhY2s6IGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrOiB0aGlzLnR4dFRyYWNrXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICB2YXIgdGltZU9mZnNldCA9IHRoaXMudGltZU9mZnNldDtcbiAgICB2YXIgdmlkZW9UcmFjayA9IHRoaXMudmlkZW9UcmFjaztcbiAgICB2YXIgdGV4dFRyYWNrID0gdGhpcy50eHRUcmFjaztcbiAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSB0aGlzLnJlbWFpbmRlckRhdGEgfHwgbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHZhciBpZDNUcmFjayA9IHRoaXMuZXh0cmFjdElEM1RyYWNrKHZpZGVvVHJhY2ssIHRoaXMudGltZU9mZnNldCk7XG4gICAgdGV4dFRyYWNrLnNhbXBsZXMgPSBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wicGFyc2VTYW1wbGVzXCJdKSh0aW1lT2Zmc2V0LCB2aWRlb1RyYWNrKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmlkZW9UcmFjazogdmlkZW9UcmFjayxcbiAgICAgIGF1ZGlvVHJhY2s6IE9iamVjdChfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZHVtbXlUcmFja1wiXSkoKSxcbiAgICAgIGlkM1RyYWNrOiBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogT2JqZWN0KF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkdW1teVRyYWNrXCJdKSgpXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZXh0cmFjdElEM1RyYWNrID0gZnVuY3Rpb24gZXh0cmFjdElEM1RyYWNrKHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpIHtcbiAgICB2YXIgaWQzVHJhY2sgPSB0aGlzLmlkM1RyYWNrO1xuXG4gICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBlbXNncyA9IE9iamVjdChfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJmaW5kQm94XCJdKSh2aWRlb1RyYWNrLnNhbXBsZXMsIFsnZW1zZyddKTtcblxuICAgICAgaWYgKGVtc2dzKSB7XG4gICAgICAgIGVtc2dzLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICB2YXIgZW1zZ0luZm8gPSBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wicGFyc2VFbXNnXCJdKShkYXRhKTtcblxuICAgICAgICAgIGlmIChlbXNnU2NoZW1lUGF0dGVybi50ZXN0KGVtc2dJbmZvLnNjaGVtZUlkVXJpKSkge1xuICAgICAgICAgICAgdmFyIHB0cyA9IE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoZW1zZ0luZm8ucHJlc2VudGF0aW9uVGltZSkgPyBlbXNnSW5mby5wcmVzZW50YXRpb25UaW1lIC8gZW1zZ0luZm8udGltZVNjYWxlIDogdGltZU9mZnNldCArIGVtc2dJbmZvLnByZXNlbnRhdGlvblRpbWVEZWx0YSAvIGVtc2dJbmZvLnRpbWVTY2FsZTtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gZW1zZ0luZm8ucGF5bG9hZDtcbiAgICAgICAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgICAgIGRhdGE6IHBheWxvYWQsXG4gICAgICAgICAgICAgIGxlbjogcGF5bG9hZC5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICBkdHM6IHB0cyxcbiAgICAgICAgICAgICAgcHRzOiBwdHMsXG4gICAgICAgICAgICAgIHR5cGU6IF90eXBlc19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJNZXRhZGF0YVNjaGVtYVwiXS5lbXNnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpZDNUcmFjaztcbiAgfTtcblxuICBfcHJvdG8uZGVtdXhTYW1wbGVBZXMgPSBmdW5jdGlvbiBkZW11eFNhbXBsZUFlcyhkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVGhlIE1QNCBkZW11eGVyIGRvZXMgbm90IHN1cHBvcnQgU0FNUExFLUFFUyBkZWNyeXB0aW9uJykpO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHt9O1xuXG4gIHJldHVybiBNUDREZW11eGVyO1xufSgpO1xuXG5NUDREZW11eGVyLm1pblByb2JlQnl0ZUxlbmd0aCA9IDEwMjQ7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKE1QNERlbXV4ZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9tcGVnYXVkaW8udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L21wZWdhdWRpby50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogYXBwZW5kRnJhbWUsIHBhcnNlSGVhZGVyLCBpc0hlYWRlclBhdHRlcm4sIGlzSGVhZGVyLCBjYW5QYXJzZSwgcHJvYmUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYXBwZW5kRnJhbWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhcHBlbmRGcmFtZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicGFyc2VIZWFkZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwYXJzZUhlYWRlcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNIZWFkZXJQYXR0ZXJuXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNIZWFkZXJQYXR0ZXJuOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpc0hlYWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzSGVhZGVyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjYW5QYXJzZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNhblBhcnNlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwcm9iZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHByb2JlOyB9KTtcbi8qKlxuICogIE1QRUcgcGFyc2VyIGhlbHBlclxuICovXG52YXIgY2hyb21lVmVyc2lvbiA9IG51bGw7XG52YXIgQml0cmF0ZXNNYXAgPSBbMzIsIDY0LCA5NiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDI4OCwgMzIwLCAzNTIsIDM4NCwgNDE2LCA0NDgsIDMyLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCwgMzg0LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLCAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjAsIDE3NiwgMTkyLCAyMjQsIDI1NiwgOCwgMTYsIDI0LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwXTtcbnZhciBTYW1wbGluZ1JhdGVNYXAgPSBbNDQxMDAsIDQ4MDAwLCAzMjAwMCwgMjIwNTAsIDI0MDAwLCAxNjAwMCwgMTEwMjUsIDEyMDAwLCA4MDAwXTtcbnZhciBTYW1wbGVzQ29lZmZpY2llbnRzID0gWy8vIE1QRUcgMi41XG5bMCwgLy8gUmVzZXJ2ZWRcbjcyLCAvLyBMYXllcjNcbjE0NCwgLy8gTGF5ZXIyXG4xMiAvLyBMYXllcjFcbl0sIC8vIFJlc2VydmVkXG5bMCwgLy8gUmVzZXJ2ZWRcbjAsIC8vIExheWVyM1xuMCwgLy8gTGF5ZXIyXG4wIC8vIExheWVyMVxuXSwgLy8gTVBFRyAyXG5bMCwgLy8gUmVzZXJ2ZWRcbjcyLCAvLyBMYXllcjNcbjE0NCwgLy8gTGF5ZXIyXG4xMiAvLyBMYXllcjFcbl0sIC8vIE1QRUcgMVxuWzAsIC8vIFJlc2VydmVkXG4xNDQsIC8vIExheWVyM1xuMTQ0LCAvLyBMYXllcjJcbjEyIC8vIExheWVyMVxuXV07XG52YXIgQnl0ZXNJblNsb3QgPSBbMCwgLy8gUmVzZXJ2ZWRcbjEsIC8vIExheWVyM1xuMSwgLy8gTGF5ZXIyXG40IC8vIExheWVyMVxuXTtcbmZ1bmN0aW9uIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCkge1xuICAvLyBVc2luZyBodHRwOi8vd3d3LmRhdGF2b3lhZ2UuY29tL21wZ3NjcmlwdC9tcGVnaGRyLmh0bSBhcyBhIHJlZmVyZW5jZVxuICBpZiAob2Zmc2V0ICsgMjQgPiBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBoZWFkZXIgPSBwYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuXG4gIGlmIChoZWFkZXIgJiYgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgdmFyIGZyYW1lRHVyYXRpb24gPSBoZWFkZXIuc2FtcGxlc1BlckZyYW1lICogOTAwMDAgLyBoZWFkZXIuc2FtcGxlUmF0ZTtcbiAgICB2YXIgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICB2YXIgc2FtcGxlID0ge1xuICAgICAgdW5pdDogZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGhlYWRlci5mcmFtZUxlbmd0aCksXG4gICAgICBwdHM6IHN0YW1wLFxuICAgICAgZHRzOiBzdGFtcFxuICAgIH07XG4gICAgdHJhY2suY29uZmlnID0gW107XG4gICAgdHJhY2suY2hhbm5lbENvdW50ID0gaGVhZGVyLmNoYW5uZWxDb3VudDtcbiAgICB0cmFjay5zYW1wbGVyYXRlID0gaGVhZGVyLnNhbXBsZVJhdGU7XG4gICAgdHJhY2suc2FtcGxlcy5wdXNoKHNhbXBsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbXBsZTogc2FtcGxlLFxuICAgICAgbGVuZ3RoOiBoZWFkZXIuZnJhbWVMZW5ndGgsXG4gICAgICBtaXNzaW5nOiAwXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIHZhciBtcGVnVmVyc2lvbiA9IGRhdGFbb2Zmc2V0ICsgMV0gPj4gMyAmIDM7XG4gIHZhciBtcGVnTGF5ZXIgPSBkYXRhW29mZnNldCArIDFdID4+IDEgJiAzO1xuICB2YXIgYml0UmF0ZUluZGV4ID0gZGF0YVtvZmZzZXQgKyAyXSA+PiA0ICYgMTU7XG4gIHZhciBzYW1wbGVSYXRlSW5kZXggPSBkYXRhW29mZnNldCArIDJdID4+IDIgJiAzO1xuXG4gIGlmIChtcGVnVmVyc2lvbiAhPT0gMSAmJiBiaXRSYXRlSW5kZXggIT09IDAgJiYgYml0UmF0ZUluZGV4ICE9PSAxNSAmJiBzYW1wbGVSYXRlSW5kZXggIT09IDMpIHtcbiAgICB2YXIgcGFkZGluZ0JpdCA9IGRhdGFbb2Zmc2V0ICsgMl0gPj4gMSAmIDE7XG4gICAgdmFyIGNoYW5uZWxNb2RlID0gZGF0YVtvZmZzZXQgKyAzXSA+PiA2O1xuICAgIHZhciBjb2x1bW5JbkJpdHJhdGVzID0gbXBlZ1ZlcnNpb24gPT09IDMgPyAzIC0gbXBlZ0xheWVyIDogbXBlZ0xheWVyID09PSAzID8gMyA6IDQ7XG4gICAgdmFyIGJpdFJhdGUgPSBCaXRyYXRlc01hcFtjb2x1bW5JbkJpdHJhdGVzICogMTQgKyBiaXRSYXRlSW5kZXggLSAxXSAqIDEwMDA7XG4gICAgdmFyIGNvbHVtbkluU2FtcGxlUmF0ZXMgPSBtcGVnVmVyc2lvbiA9PT0gMyA/IDAgOiBtcGVnVmVyc2lvbiA9PT0gMiA/IDEgOiAyO1xuICAgIHZhciBzYW1wbGVSYXRlID0gU2FtcGxpbmdSYXRlTWFwW2NvbHVtbkluU2FtcGxlUmF0ZXMgKiAzICsgc2FtcGxlUmF0ZUluZGV4XTtcbiAgICB2YXIgY2hhbm5lbENvdW50ID0gY2hhbm5lbE1vZGUgPT09IDMgPyAxIDogMjsgLy8gSWYgYml0cyBvZiBjaGFubmVsIG1vZGUgYXJlIGAxMWAgdGhlbiBpdCBpcyBhIHNpbmdsZSBjaGFubmVsIChNb25vKVxuXG4gICAgdmFyIHNhbXBsZUNvZWZmaWNpZW50ID0gU2FtcGxlc0NvZWZmaWNpZW50c1ttcGVnVmVyc2lvbl1bbXBlZ0xheWVyXTtcbiAgICB2YXIgYnl0ZXNJblNsb3QgPSBCeXRlc0luU2xvdFttcGVnTGF5ZXJdO1xuICAgIHZhciBzYW1wbGVzUGVyRnJhbWUgPSBzYW1wbGVDb2VmZmljaWVudCAqIDggKiBieXRlc0luU2xvdDtcbiAgICB2YXIgZnJhbWVMZW5ndGggPSBNYXRoLmZsb29yKHNhbXBsZUNvZWZmaWNpZW50ICogYml0UmF0ZSAvIHNhbXBsZVJhdGUgKyBwYWRkaW5nQml0KSAqIGJ5dGVzSW5TbG90O1xuXG4gICAgaWYgKGNocm9tZVZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xuICAgICAgdmFyIHJlc3VsdCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspL2kpO1xuICAgICAgY2hyb21lVmVyc2lvbiA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgIH1cblxuICAgIHZhciBuZWVkQ2hyb21lRml4ID0gISFjaHJvbWVWZXJzaW9uICYmIGNocm9tZVZlcnNpb24gPD0gODc7XG5cbiAgICBpZiAobmVlZENocm9tZUZpeCAmJiBtcGVnTGF5ZXIgPT09IDIgJiYgYml0UmF0ZSA+PSAyMjQwMDAgJiYgY2hhbm5lbE1vZGUgPT09IDApIHtcbiAgICAgIC8vIFdvcmsgYXJvdW5kIGJ1ZyBpbiBDaHJvbWl1bSBieSBzZXR0aW5nIGNoYW5uZWxNb2RlIHRvIGR1YWwtY2hhbm5lbCAoMDEpIGluc3RlYWQgb2Ygc3RlcmVvICgwMClcbiAgICAgIGRhdGFbb2Zmc2V0ICsgM10gPSBkYXRhW29mZnNldCArIDNdIHwgMHg4MDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2FtcGxlUmF0ZTogc2FtcGxlUmF0ZSxcbiAgICAgIGNoYW5uZWxDb3VudDogY2hhbm5lbENvdW50LFxuICAgICAgZnJhbWVMZW5ndGg6IGZyYW1lTGVuZ3RoLFxuICAgICAgc2FtcGxlc1BlckZyYW1lOiBzYW1wbGVzUGVyRnJhbWVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGUwKSA9PT0gMHhlMCAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDYpICE9PSAweDAwO1xufVxuZnVuY3Rpb24gaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIExvb2sgZm9yIE1QRUcgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExWCBYWVpYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMSBhbmQgWSBvciBaIHNob3VsZCBiZSAxXG4gIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgZGlmZmVyZW50IGZyb20gMCAoTGF5ZXIgSSBvciBMYXllciBJSSBvciBMYXllciBJSUkpXG4gIC8vIE1vcmUgaW5mbyBodHRwOi8vd3d3Lm1wMy10ZWNoLm9yZy9wcm9ncmFtbWVyL2ZyYW1lX2hlYWRlci5odG1sXG4gIHJldHVybiBvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCk7XG59XG5mdW5jdGlvbiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgdmFyIGhlYWRlclNpemUgPSA0O1xuICByZXR1cm4gaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkgJiYgaGVhZGVyU2l6ZSA8PSBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbn1cbmZ1bmN0aW9uIHByb2JlKGRhdGEsIG9mZnNldCkge1xuICAvLyBzYW1lIGFzIGlzSGVhZGVyIGJ1dCB3ZSBhbHNvIGNoZWNrIHRoYXQgTVBFRyBmcmFtZSBmb2xsb3dzIGxhc3QgTVBFRyBmcmFtZVxuICAvLyBvciBlbmQgb2YgZGF0YSBpcyByZWFjaGVkXG4gIGlmIChvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkpIHtcbiAgICAvLyBNUEVHIGhlYWRlciBMZW5ndGhcbiAgICB2YXIgaGVhZGVyTGVuZ3RoID0gNDsgLy8gTVBFRyBmcmFtZSBMZW5ndGhcblxuICAgIHZhciBoZWFkZXIgPSBwYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICAgIHZhciBmcmFtZUxlbmd0aCA9IGhlYWRlckxlbmd0aDtcblxuICAgIGlmIChoZWFkZXIgIT09IG51bGwgJiYgaGVhZGVyICE9PSB2b2lkIDAgJiYgaGVhZGVyLmZyYW1lTGVuZ3RoKSB7XG4gICAgICBmcmFtZUxlbmd0aCA9IGhlYWRlci5mcmFtZUxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgZnJhbWVMZW5ndGg7XG4gICAgcmV0dXJuIG5ld09mZnNldCA9PT0gZGF0YS5sZW5ndGggfHwgaXNIZWFkZXIoZGF0YSwgbmV3T2Zmc2V0KTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvc2FtcGxlLWFlcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L3NhbXBsZS1hZXMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jcnlwdF9kZWNyeXB0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NyeXB0L2RlY3J5cHRlciAqLyBcIi4vc3JjL2NyeXB0L2RlY3J5cHRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHNkZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RzZGVtdXhlciAqLyBcIi4vc3JjL2RlbXV4L3RzZGVtdXhlci50c1wiKTtcbi8qKlxuICogU0FNUExFLUFFUyBkZWNyeXB0ZXJcbiAqL1xuXG5cblxudmFyIFNhbXBsZUFlc0RlY3J5cHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNhbXBsZUFlc0RlY3J5cHRlcihvYnNlcnZlciwgY29uZmlnLCBrZXlEYXRhKSB7XG4gICAgdGhpcy5rZXlEYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gdm9pZCAwO1xuICAgIHRoaXMua2V5RGF0YSA9IGtleURhdGE7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSBuZXcgX2NyeXB0X2RlY3J5cHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXShvYnNlcnZlciwgY29uZmlnLCB7XG4gICAgICByZW1vdmVQS0NTN1BhZGRpbmc6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2FtcGxlQWVzRGVjcnlwdGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVjcnlwdEJ1ZmZlciA9IGZ1bmN0aW9uIGRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KGVuY3J5cHRlZERhdGEsIHRoaXMua2V5RGF0YS5rZXkuYnVmZmVyLCB0aGlzLmtleURhdGEuaXYuYnVmZmVyLCBjYWxsYmFjayk7XG4gIH0gLy8gQUFDIC0gZW5jcnlwdCBhbGwgZnVsbCAxNiBieXRlcyBibG9ja3Mgc3RhcnRpbmcgZnJvbSBvZmZzZXQgMTZcbiAgO1xuXG4gIF9wcm90by5kZWNyeXB0QWFjU2FtcGxlID0gZnVuY3Rpb24gZGVjcnlwdEFhY1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2ssIHN5bmMpIHtcbiAgICB2YXIgY3VyVW5pdCA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXQ7XG5cbiAgICBpZiAoY3VyVW5pdC5sZW5ndGggPD0gMTYpIHtcbiAgICAgIC8vIE5vIGVuY3J5cHRlZCBwb3J0aW9uIGluIHRoaXMgc2FtcGxlIChmaXJzdCAxNiBieXRlcyBpcyBub3RcbiAgICAgIC8vIGVuY3J5cHRlZCwgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2FyY2hpdmUvZG9jdW1lbnRhdGlvbi9BdWRpb1ZpZGVvL0NvbmNlcHR1YWwvSExTX1NhbXBsZV9FbmNyeXB0aW9uL0VuY3J5cHRpb24vRW5jcnlwdGlvbi5odG1sKSxcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZW5jcnlwdGVkRGF0YSA9IGN1clVuaXQuc3ViYXJyYXkoMTYsIGN1clVuaXQubGVuZ3RoIC0gY3VyVW5pdC5sZW5ndGggJSAxNik7XG4gICAgdmFyIGVuY3J5cHRlZEJ1ZmZlciA9IGVuY3J5cHRlZERhdGEuYnVmZmVyLnNsaWNlKGVuY3J5cHRlZERhdGEuYnl0ZU9mZnNldCwgZW5jcnlwdGVkRGF0YS5ieXRlT2Zmc2V0ICsgZW5jcnlwdGVkRGF0YS5sZW5ndGgpO1xuICAgIHZhciBsb2NhbHRoaXMgPSB0aGlzO1xuICAgIHRoaXMuZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWRCdWZmZXIsIGZ1bmN0aW9uIChkZWNyeXB0ZWRCdWZmZXIpIHtcbiAgICAgIHZhciBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkQnVmZmVyKTtcbiAgICAgIGN1clVuaXQuc2V0KGRlY3J5cHRlZERhdGEsIDE2KTtcblxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGxvY2FsdGhpcy5kZWNyeXB0QWFjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZGVjcnlwdEFhY1NhbXBsZXMgPSBmdW5jdGlvbiBkZWNyeXB0QWFjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2spIHtcbiAgICBmb3IgKDs7IHNhbXBsZUluZGV4KyspIHtcbiAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0Lmxlbmd0aCA8IDMyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3luYyA9IHRoaXMuZGVjcnlwdGVyLmlzU3luYygpO1xuICAgICAgdGhpcy5kZWNyeXB0QWFjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaywgc3luYyk7XG5cbiAgICAgIGlmICghc3luYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEFWQyAtIGVuY3J5cHQgb25lIDE2IGJ5dGVzIGJsb2NrIG91dCBvZiB0ZW4sIHN0YXJ0aW5nIGZyb20gb2Zmc2V0IDMyXG4gIDtcblxuICBfcHJvdG8uZ2V0QXZjRW5jcnlwdGVkRGF0YSA9IGZ1bmN0aW9uIGdldEF2Y0VuY3J5cHRlZERhdGEoZGVjb2RlZERhdGEpIHtcbiAgICB2YXIgZW5jcnlwdGVkRGF0YUxlbiA9IE1hdGguZmxvb3IoKGRlY29kZWREYXRhLmxlbmd0aCAtIDQ4KSAvIDE2MCkgKiAxNiArIDE2O1xuICAgIHZhciBlbmNyeXB0ZWREYXRhID0gbmV3IEludDhBcnJheShlbmNyeXB0ZWREYXRhTGVuKTtcbiAgICB2YXIgb3V0cHV0UG9zID0gMDtcblxuICAgIGZvciAodmFyIGlucHV0UG9zID0gMzI7IGlucHV0UG9zIDwgZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7IGlucHV0UG9zICs9IDE2MCwgb3V0cHV0UG9zICs9IDE2KSB7XG4gICAgICBlbmNyeXB0ZWREYXRhLnNldChkZWNvZGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksIG91dHB1dFBvcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY3J5cHRlZERhdGE7XG4gIH07XG5cbiAgX3Byb3RvLmdldEF2Y0RlY3J5cHRlZFVuaXQgPSBmdW5jdGlvbiBnZXRBdmNEZWNyeXB0ZWRVbml0KGRlY29kZWREYXRhLCBkZWNyeXB0ZWREYXRhKSB7XG4gICAgdmFyIHVpbnQ4RGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xuICAgIHZhciBpbnB1dFBvcyA9IDA7XG5cbiAgICBmb3IgKHZhciBvdXRwdXRQb3MgPSAzMjsgb3V0cHV0UG9zIDwgZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7IG91dHB1dFBvcyArPSAxNjAsIGlucHV0UG9zICs9IDE2KSB7XG4gICAgICBkZWNvZGVkRGF0YS5zZXQodWludDhEZWNyeXB0ZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSwgb3V0cHV0UG9zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVjb2RlZERhdGE7XG4gIH07XG5cbiAgX3Byb3RvLmRlY3J5cHRBdmNTYW1wbGUgPSBmdW5jdGlvbiBkZWNyeXB0QXZjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0LCBzeW5jKSB7XG4gICAgdmFyIGRlY29kZWREYXRhID0gT2JqZWN0KF90c2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRpc2NhcmRFUEJcIl0pKGN1clVuaXQuZGF0YSk7XG4gICAgdmFyIGVuY3J5cHRlZERhdGEgPSB0aGlzLmdldEF2Y0VuY3J5cHRlZERhdGEoZGVjb2RlZERhdGEpO1xuICAgIHZhciBsb2NhbHRoaXMgPSB0aGlzO1xuICAgIHRoaXMuZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWREYXRhLmJ1ZmZlciwgZnVuY3Rpb24gKGRlY3J5cHRlZEJ1ZmZlcikge1xuICAgICAgY3VyVW5pdC5kYXRhID0gbG9jYWx0aGlzLmdldEF2Y0RlY3J5cHRlZFVuaXQoZGVjb2RlZERhdGEsIGRlY3J5cHRlZEJ1ZmZlcik7XG5cbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBsb2NhbHRoaXMuZGVjcnlwdEF2Y1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZGVjcnlwdEF2Y1NhbXBsZXMgPSBmdW5jdGlvbiBkZWNyeXB0QXZjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaykge1xuICAgIGlmIChzYW1wbGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVjcnlwdCBzYW1wbGVzIG9mIHR5cGUgVWludDhBcnJheScpO1xuICAgIH1cblxuICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKywgdW5pdEluZGV4ID0gMCkge1xuICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1clVuaXRzID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdHM7XG5cbiAgICAgIGZvciAoOzsgdW5pdEluZGV4KyspIHtcbiAgICAgICAgaWYgKHVuaXRJbmRleCA+PSBjdXJVbml0cy5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJVbml0ID0gY3VyVW5pdHNbdW5pdEluZGV4XTtcblxuICAgICAgICBpZiAoY3VyVW5pdC5kYXRhLmxlbmd0aCA8PSA0OCB8fCBjdXJVbml0LnR5cGUgIT09IDEgJiYgY3VyVW5pdC50eXBlICE9PSA1KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3luYyA9IHRoaXMuZGVjcnlwdGVyLmlzU3luYygpO1xuICAgICAgICB0aGlzLmRlY3J5cHRBdmNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2ssIGN1clVuaXQsIHN5bmMpO1xuXG4gICAgICAgIGlmICghc3luYykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU2FtcGxlQWVzRGVjcnlwdGVyO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFNhbXBsZUFlc0RlY3J5cHRlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L3RyYW5zbXV4ZXItaW50ZXJmYWNlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L3RyYW5zbXV4ZXItaW50ZXJmYWNlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRyYW5zbXV4ZXJJbnRlcmZhY2U7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHdlYndvcmtpZnlfd2VicGFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgd2Vid29ya2lmeS13ZWJwYWNrICovIFwiLi9ub2RlX21vZHVsZXMvd2Vid29ya2lmeS13ZWJwYWNrL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHdlYndvcmtpZnlfd2VicGFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHdlYndvcmtpZnlfd2VicGFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L3RyYW5zbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC90cmFuc211eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21lZGlhc291cmNlX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyICovIFwiLi9zcmMvdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGV2ZW50ZW1pdHRlcjMgKi8gXCIuL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18pO1xuXG5cblxuXG5cblxuXG52YXIgTWVkaWFTb3VyY2UgPSBPYmplY3QoX3V0aWxzX21lZGlhc291cmNlX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZ2V0TWVkaWFTb3VyY2VcIl0pKCkgfHwge1xuICBpc1R5cGVTdXBwb3J0ZWQ6IGZ1bmN0aW9uIGlzVHlwZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBUcmFuc211eGVySW50ZXJmYWNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJhbnNtdXhlckludGVyZmFjZShobHMsIGlkLCBvblRyYW5zbXV4Q29tcGxldGUsIG9uRmx1c2gpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgdGhpcy5wYXJ0ID0gbnVsbDtcbiAgICB0aGlzLndvcmtlciA9IHZvaWQgMDtcbiAgICB0aGlzLm9ud21zZyA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgIHRoaXMub25UcmFuc211eENvbXBsZXRlID0gdm9pZCAwO1xuICAgIHRoaXMub25GbHVzaCA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5vblRyYW5zbXV4Q29tcGxldGUgPSBvblRyYW5zbXV4Q29tcGxldGU7XG4gICAgdGhpcy5vbkZsdXNoID0gb25GbHVzaDtcbiAgICB2YXIgY29uZmlnID0gaGxzLmNvbmZpZztcblxuICAgIHZhciBmb3J3YXJkTWVzc2FnZSA9IGZ1bmN0aW9uIGZvcndhcmRNZXNzYWdlKGV2LCBkYXRhKSB7XG4gICAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgIGRhdGEuZnJhZyA9IF90aGlzLmZyYWc7XG4gICAgICBkYXRhLmlkID0gX3RoaXMuaWQ7XG4gICAgICBobHMudHJpZ2dlcihldiwgZGF0YSk7XG4gICAgfTsgLy8gZm9yd2FyZCBldmVudHMgdG8gbWFpbiB0aHJlYWRcblxuXG4gICAgdGhpcy5vYnNlcnZlciA9IG5ldyBldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJFdmVudEVtaXR0ZXJcIl0oKTtcbiAgICB0aGlzLm9ic2VydmVyLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIHRoaXMub2JzZXJ2ZXIub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgdmFyIHR5cGVTdXBwb3J0ZWQgPSB7XG4gICAgICBtcDQ6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXA0JyksXG4gICAgICBtcGVnOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wZWcnKSxcbiAgICAgIG1wMzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcDQ7IGNvZGVjcz1cIm1wM1wiJylcbiAgICB9OyAvLyBuYXZpZ2F0b3IudmVuZG9yIGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJcbiAgICAvLyByZWZlciB0byBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV29ya2VyR2xvYmFsU2NvcGUvbmF2aWdhdG9yXG5cbiAgICB2YXIgdmVuZG9yID0gbmF2aWdhdG9yLnZlbmRvcjtcblxuICAgIGlmIChjb25maWcuZW5hYmxlV29ya2VyICYmIHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ubG9nKCdkZW11eGluZyBpbiB3ZWJ3b3JrZXInKTtcbiAgICAgIHZhciB3b3JrZXI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHdvcmtlciA9IHRoaXMud29ya2VyID0gd2Vid29ya2lmeV93ZWJwYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18oLypyZXF1aXJlLnJlc29sdmUqLygvKiEgLi4vZGVtdXgvdHJhbnNtdXhlci13b3JrZXIudHMgKi8gXCIuL3NyYy9kZW11eC90cmFuc211eGVyLXdvcmtlci50c1wiKSk7XG4gICAgICAgIHRoaXMub253bXNnID0gdGhpcy5vbldvcmtlck1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyk7XG5cbiAgICAgICAgd29ya2VyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkVycm9yVHlwZXNcIl0uT1RIRVJfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJFcnJvckRldGFpbHNcIl0uSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICBldmVudDogJ2RlbXV4ZXJXb3JrZXInLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihldmVudC5tZXNzYWdlICsgXCIgIChcIiArIGV2ZW50LmZpbGVuYW1lICsgXCI6XCIgKyBldmVudC5saW5lbm8gKyBcIilcIilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGNtZDogJ2luaXQnLFxuICAgICAgICAgIHR5cGVTdXBwb3J0ZWQ6IHR5cGVTdXBwb3J0ZWQsXG4gICAgICAgICAgdmVuZG9yOiB2ZW5kb3IsXG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIGNvbmZpZzogSlNPTi5zdHJpbmdpZnkoY29uZmlnKVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ud2FybignRXJyb3IgaW4gd29ya2VyOicsIGVycik7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS5lcnJvcignRXJyb3Igd2hpbGUgaW5pdGlhbGl6aW5nIERlbXV4ZXJXb3JrZXIsIGZhbGxiYWNrIHRvIGlubGluZScpO1xuXG4gICAgICAgIGlmICh3b3JrZXIpIHtcbiAgICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgdHJhbnNtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgICAgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKHdvcmtlci5vYmplY3RVUkwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmFuc211eGVyID0gbmV3IF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKHRoaXMub2JzZXJ2ZXIsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgdmVuZG9yLCBpZCk7XG4gICAgICAgIHRoaXMud29ya2VyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc211eGVyID0gbmV3IF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKHRoaXMub2JzZXJ2ZXIsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgdmVuZG9yLCBpZCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90byA9IFRyYW5zbXV4ZXJJbnRlcmZhY2UucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgdyA9IHRoaXMud29ya2VyO1xuXG4gICAgaWYgKHcpIHtcbiAgICAgIHcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMub253bXNnKTtcbiAgICAgIHcudGVybWluYXRlKCk7XG4gICAgICB0aGlzLndvcmtlciA9IG51bGw7XG4gICAgICB0aGlzLm9ud21zZyA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXI7XG5cbiAgICAgIGlmICh0cmFuc211eGVyKSB7XG4gICAgICAgIHRyYW5zbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG5cbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgIG9ic2VydmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHRoaXMuZnJhZyA9IG51bGw7IC8vIEB0cy1pZ25vcmVcblxuICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsOyAvLyBAdHMtaWdub3JlXG5cbiAgICB0aGlzLmhscyA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLnB1c2ggPSBmdW5jdGlvbiBwdXNoKGRhdGEsIGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZnJhZywgcGFydCwgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhLCBkZWZhdWx0SW5pdFBUUykge1xuICAgIHZhciBfZnJhZyRpbml0U2VnbWVudCxcbiAgICAgICAgX2xhc3RGcmFnJGluaXRTZWdtZW50LFxuICAgICAgICBfdGhpczIgPSB0aGlzO1xuXG4gICAgY2h1bmtNZXRhLnRyYW5zbXV4aW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB2YXIgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcixcbiAgICAgICAgd29ya2VyID0gdGhpcy53b3JrZXI7XG4gICAgdmFyIHRpbWVPZmZzZXQgPSBwYXJ0ID8gcGFydC5zdGFydCA6IGZyYWcuc3RhcnQ7XG4gICAgdmFyIGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICB2YXIgbGFzdEZyYWcgPSB0aGlzLmZyYWc7XG4gICAgdmFyIGRpc2NvbnRpbnVpdHkgPSAhKGxhc3RGcmFnICYmIGZyYWcuY2MgPT09IGxhc3RGcmFnLmNjKTtcbiAgICB2YXIgdHJhY2tTd2l0Y2ggPSAhKGxhc3RGcmFnICYmIGNodW5rTWV0YS5sZXZlbCA9PT0gbGFzdEZyYWcubGV2ZWwpO1xuICAgIHZhciBzbkRpZmYgPSBsYXN0RnJhZyA/IGNodW5rTWV0YS5zbiAtIGxhc3RGcmFnLnNuIDogLTE7XG4gICAgdmFyIHBhcnREaWZmID0gdGhpcy5wYXJ0ID8gY2h1bmtNZXRhLnBhcnQgLSB0aGlzLnBhcnQuaW5kZXggOiAtMTtcbiAgICB2YXIgY29udGlndW91cyA9ICF0cmFja1N3aXRjaCAmJiAoc25EaWZmID09PSAxIHx8IHNuRGlmZiA9PT0gMCAmJiBwYXJ0RGlmZiA9PT0gMSk7XG4gICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICBpZiAodHJhY2tTd2l0Y2ggfHwgc25EaWZmIHx8IGZyYWcuc3RhdHMucGFyc2luZy5zdGFydCA9PT0gMCkge1xuICAgICAgZnJhZy5zdGF0cy5wYXJzaW5nLnN0YXJ0ID0gbm93O1xuICAgIH1cblxuICAgIGlmIChwYXJ0ICYmIChwYXJ0RGlmZiB8fCAhY29udGlndW91cykpIHtcbiAgICAgIHBhcnQuc3RhdHMucGFyc2luZy5zdGFydCA9IG5vdztcbiAgICB9XG5cbiAgICB2YXIgaW5pdFNlZ21lbnRDaGFuZ2UgPSAhKGxhc3RGcmFnICYmICgoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSA9PT0gbnVsbCB8fCBfZnJhZyRpbml0U2VnbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZyYWckaW5pdFNlZ21lbnQudXJsKSA9PT0gKChfbGFzdEZyYWckaW5pdFNlZ21lbnQgPSBsYXN0RnJhZy5pbml0U2VnbWVudCkgPT09IG51bGwgfHwgX2xhc3RGcmFnJGluaXRTZWdtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGFzdEZyYWckaW5pdFNlZ21lbnQudXJsKSk7XG4gICAgdmFyIHN0YXRlID0gbmV3IF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJUcmFuc211eFN0YXRlXCJdKGRpc2NvbnRpbnVpdHksIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgdHJhY2tTd2l0Y2gsIHRpbWVPZmZzZXQsIGluaXRTZWdtZW50Q2hhbmdlKTtcblxuICAgIGlmICghY29udGlndW91cyB8fCBkaXNjb250aW51aXR5IHx8IGluaXRTZWdtZW50Q2hhbmdlKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ubG9nKFwiW3RyYW5zbXV4ZXItaW50ZXJmYWNlLCBcIiArIGZyYWcudHlwZSArIFwiXTogU3RhcnRpbmcgbmV3IHRyYW5zbXV4IHNlc3Npb24gZm9yIHNuOiBcIiArIGNodW5rTWV0YS5zbiArIFwiIHA6IFwiICsgY2h1bmtNZXRhLnBhcnQgKyBcIiBsZXZlbDogXCIgKyBjaHVua01ldGEubGV2ZWwgKyBcIiBpZDogXCIgKyBjaHVua01ldGEuaWQgKyBcIlxcbiAgICAgICAgZGlzY29udGludWl0eTogXCIgKyBkaXNjb250aW51aXR5ICsgXCJcXG4gICAgICAgIHRyYWNrU3dpdGNoOiBcIiArIHRyYWNrU3dpdGNoICsgXCJcXG4gICAgICAgIGNvbnRpZ3VvdXM6IFwiICsgY29udGlndW91cyArIFwiXFxuICAgICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQ6IFwiICsgYWNjdXJhdGVUaW1lT2Zmc2V0ICsgXCJcXG4gICAgICAgIHRpbWVPZmZzZXQ6IFwiICsgdGltZU9mZnNldCArIFwiXFxuICAgICAgICBpbml0U2VnbWVudENoYW5nZTogXCIgKyBpbml0U2VnbWVudENoYW5nZSk7XG4gICAgICB2YXIgY29uZmlnID0gbmV3IF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJUcmFuc211eENvbmZpZ1wiXShhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBpbml0U2VnbWVudERhdGEsIGR1cmF0aW9uLCBkZWZhdWx0SW5pdFBUUyk7XG4gICAgICB0aGlzLmNvbmZpZ3VyZVRyYW5zbXV4ZXIoY29uZmlnKTtcbiAgICB9XG5cbiAgICB0aGlzLmZyYWcgPSBmcmFnO1xuICAgIHRoaXMucGFydCA9IHBhcnQ7IC8vIEZyYWdzIHdpdGggc24gb2YgJ2luaXRTZWdtZW50JyBhcmUgbm90IHRyYW5zbXV4ZWRcblxuICAgIGlmICh3b3JrZXIpIHtcbiAgICAgIC8vIHBvc3QgZnJhZ21lbnQgcGF5bG9hZCBhcyB0cmFuc2ZlcmFibGUgb2JqZWN0cyBmb3IgQXJyYXlCdWZmZXIgKG5vIGNvcHkpXG4gICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjbWQ6ICdkZW11eCcsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGRlY3J5cHRkYXRhOiBkZWNyeXB0ZGF0YSxcbiAgICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGEsXG4gICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgfSwgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gW2RhdGFdIDogW10pO1xuICAgIH0gZWxzZSBpZiAodHJhbnNtdXhlcikge1xuICAgICAgdmFyIF90cmFuc211eFJlc3VsdCA9IHRyYW5zbXV4ZXIucHVzaChkYXRhLCBkZWNyeXB0ZGF0YSwgY2h1bmtNZXRhLCBzdGF0ZSk7XG5cbiAgICAgIGlmIChPYmplY3QoX2RlbXV4X3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImlzUHJvbWlzZVwiXSkoX3RyYW5zbXV4UmVzdWx0KSkge1xuICAgICAgICBfdHJhbnNtdXhSZXN1bHQudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIF90aGlzMi5oYW5kbGVUcmFuc211eENvbXBsZXRlKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShfdHJhbnNtdXhSZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaChjaHVua01ldGEpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIGNodW5rTWV0YS50cmFuc211eGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdmFyIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIsXG4gICAgICAgIHdvcmtlciA9IHRoaXMud29ya2VyO1xuXG4gICAgaWYgKHdvcmtlcikge1xuICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnZmx1c2gnLFxuICAgICAgICBjaHVua01ldGE6IGNodW5rTWV0YVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0cmFuc211eGVyKSB7XG4gICAgICB2YXIgX3RyYW5zbXV4UmVzdWx0MiA9IHRyYW5zbXV4ZXIuZmx1c2goY2h1bmtNZXRhKTtcblxuICAgICAgaWYgKE9iamVjdChfZGVtdXhfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiaXNQcm9taXNlXCJdKShfdHJhbnNtdXhSZXN1bHQyKSkge1xuICAgICAgICBfdHJhbnNtdXhSZXN1bHQyLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBfdGhpczMuaGFuZGxlRmx1c2hSZXN1bHQoZGF0YSwgY2h1bmtNZXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUZsdXNoUmVzdWx0KF90cmFuc211eFJlc3VsdDIsIGNodW5rTWV0YSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5oYW5kbGVGbHVzaFJlc3VsdCA9IGZ1bmN0aW9uIGhhbmRsZUZsdXNoUmVzdWx0KHJlc3VsdHMsIGNodW5rTWV0YSkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgcmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIF90aGlzNC5oYW5kbGVUcmFuc211eENvbXBsZXRlKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgdGhpcy5vbkZsdXNoKGNodW5rTWV0YSk7XG4gIH07XG5cbiAgX3Byb3RvLm9uV29ya2VyTWVzc2FnZSA9IGZ1bmN0aW9uIG9uV29ya2VyTWVzc2FnZShldikge1xuICAgIHZhciBkYXRhID0gZXYuZGF0YTtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG5cbiAgICBzd2l0Y2ggKGRhdGEuZXZlbnQpIHtcbiAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRyYW5zbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICAgIHNlbGYuVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLndvcmtlci5vYmplY3RVUkwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3RyYW5zbXV4Q29tcGxldGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKGRhdGEuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZmx1c2gnOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5vbkZsdXNoKGRhdGEuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgZGF0YS5kYXRhID0gZGF0YS5kYXRhIHx8IHt9O1xuICAgICAgICAgIGRhdGEuZGF0YS5mcmFnID0gdGhpcy5mcmFnO1xuICAgICAgICAgIGRhdGEuZGF0YS5pZCA9IHRoaXMuaWQ7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoZGF0YS5ldmVudCwgZGF0YS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29uZmlndXJlVHJhbnNtdXhlciA9IGZ1bmN0aW9uIGNvbmZpZ3VyZVRyYW5zbXV4ZXIoY29uZmlnKSB7XG4gICAgdmFyIHdvcmtlciA9IHRoaXMud29ya2VyLFxuICAgICAgICB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyO1xuXG4gICAgaWYgKHdvcmtlcikge1xuICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnY29uZmlndXJlJyxcbiAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHJhbnNtdXhlcikge1xuICAgICAgdHJhbnNtdXhlci5jb25maWd1cmUoY29uZmlnKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUgPSBmdW5jdGlvbiBoYW5kbGVUcmFuc211eENvbXBsZXRlKHJlc3VsdCkge1xuICAgIHJlc3VsdC5jaHVua01ldGEudHJhbnNtdXhpbmcuZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLm9uVHJhbnNtdXhDb21wbGV0ZShyZXN1bHQpO1xuICB9O1xuXG4gIHJldHVybiBUcmFuc211eGVySW50ZXJmYWNlO1xufSgpO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvdHJhbnNtdXhlci13b3JrZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvdHJhbnNtdXhlci13b3JrZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVHJhbnNtdXhlcldvcmtlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L3RyYW5zbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC90cmFuc211eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZXZlbnRlbWl0dGVyMyAqLyBcIi4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XG5cblxuXG5cbmZ1bmN0aW9uIFRyYW5zbXV4ZXJXb3JrZXIoc2VsZikge1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRFbWl0dGVyXCJdKCk7XG5cbiAgdmFyIGZvcndhcmRNZXNzYWdlID0gZnVuY3Rpb24gZm9yd2FyZE1lc3NhZ2UoZXYsIGRhdGEpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgIGV2ZW50OiBldixcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfTsgLy8gZm9yd2FyZCBldmVudHMgdG8gbWFpbiB0aHJlYWRcblxuXG4gIG9ic2VydmVyLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICBvYnNlcnZlci5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRVJST1IsIGZvcndhcmRNZXNzYWdlKTtcbiAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgdmFyIGRhdGEgPSBldi5kYXRhO1xuXG4gICAgc3dpdGNoIChkYXRhLmNtZCkge1xuICAgICAgY2FzZSAnaW5pdCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29uZmlnID0gSlNPTi5wYXJzZShkYXRhLmNvbmZpZyk7XG4gICAgICAgICAgc2VsZi50cmFuc211eGVyID0gbmV3IF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKG9ic2VydmVyLCBkYXRhLnR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgZGF0YS52ZW5kb3IsIGRhdGEuaWQpO1xuICAgICAgICAgIE9iamVjdChfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJlbmFibGVMb2dzXCJdKShjb25maWcuZGVidWcpO1xuICAgICAgICAgIGZvcndhcmRNZXNzYWdlKCdpbml0JywgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnY29uZmlndXJlJzpcbiAgICAgICAge1xuICAgICAgICAgIHNlbGYudHJhbnNtdXhlci5jb25maWd1cmUoZGF0YS5jb25maWcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbXV4JzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0cmFuc211eFJlc3VsdCA9IHNlbGYudHJhbnNtdXhlci5wdXNoKGRhdGEuZGF0YSwgZGF0YS5kZWNyeXB0ZGF0YSwgZGF0YS5jaHVua01ldGEsIGRhdGEuc3RhdGUpO1xuXG4gICAgICAgICAgaWYgKE9iamVjdChfZGVtdXhfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNQcm9taXNlXCJdKSh0cmFuc211eFJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRyYW5zbXV4UmVzdWx0LnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgZW1pdFRyYW5zbXV4Q29tcGxldGUoc2VsZiwgZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW1pdFRyYW5zbXV4Q29tcGxldGUoc2VsZiwgdHJhbnNtdXhSZXN1bHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2ZsdXNoJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpZCA9IGRhdGEuY2h1bmtNZXRhO1xuXG4gICAgICAgICAgdmFyIF90cmFuc211eFJlc3VsdCA9IHNlbGYudHJhbnNtdXhlci5mbHVzaChpZCk7XG5cbiAgICAgICAgICBpZiAoT2JqZWN0KF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc1Byb21pc2VcIl0pKF90cmFuc211eFJlc3VsdCkpIHtcbiAgICAgICAgICAgIF90cmFuc211eFJlc3VsdC50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgIGhhbmRsZUZsdXNoUmVzdWx0KHNlbGYsIHJlc3VsdHMsIGlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVGbHVzaFJlc3VsdChzZWxmLCBfdHJhbnNtdXhSZXN1bHQsIGlkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlbWl0VHJhbnNtdXhDb21wbGV0ZShzZWxmLCB0cmFuc211eFJlc3VsdCkge1xuICBpZiAoaXNFbXB0eVJlc3VsdCh0cmFuc211eFJlc3VsdC5yZW11eFJlc3VsdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdHJhbnNmZXJhYmxlID0gW107XG4gIHZhciBfdHJhbnNtdXhSZXN1bHQkcmVtdXggPSB0cmFuc211eFJlc3VsdC5yZW11eFJlc3VsdCxcbiAgICAgIGF1ZGlvID0gX3RyYW5zbXV4UmVzdWx0JHJlbXV4LmF1ZGlvLFxuICAgICAgdmlkZW8gPSBfdHJhbnNtdXhSZXN1bHQkcmVtdXgudmlkZW87XG5cbiAgaWYgKGF1ZGlvKSB7XG4gICAgYWRkVG9UcmFuc2ZlcmFibGUodHJhbnNmZXJhYmxlLCBhdWRpbyk7XG4gIH1cblxuICBpZiAodmlkZW8pIHtcbiAgICBhZGRUb1RyYW5zZmVyYWJsZSh0cmFuc2ZlcmFibGUsIHZpZGVvKTtcbiAgfVxuXG4gIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgIGV2ZW50OiAndHJhbnNtdXhDb21wbGV0ZScsXG4gICAgZGF0YTogdHJhbnNtdXhSZXN1bHRcbiAgfSwgdHJhbnNmZXJhYmxlKTtcbiAgcmV0dXJuIHRydWU7XG59IC8vIENvbnZlcnRzIGRhdGEgdG8gYSB0cmFuc2ZlcmFibGUgb2JqZWN0IGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTEvMTIvVHJhbnNmZXJhYmxlLU9iamVjdHMtTGlnaHRuaW5nLUZhc3QpXG4vLyBpbiBvcmRlciB0byBtaW5pbWl6ZSBtZXNzYWdlIHBhc3Npbmcgb3ZlcmhlYWRcblxuXG5mdW5jdGlvbiBhZGRUb1RyYW5zZmVyYWJsZSh0cmFuc2ZlcmFibGUsIHRyYWNrKSB7XG4gIGlmICh0cmFjay5kYXRhMSkge1xuICAgIHRyYW5zZmVyYWJsZS5wdXNoKHRyYWNrLmRhdGExLmJ1ZmZlcik7XG4gIH1cblxuICBpZiAodHJhY2suZGF0YTIpIHtcbiAgICB0cmFuc2ZlcmFibGUucHVzaCh0cmFjay5kYXRhMi5idWZmZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZsdXNoUmVzdWx0KHNlbGYsIHJlc3VsdHMsIGNodW5rTWV0YSkge1xuICB2YXIgcGFyc2VkID0gcmVzdWx0cy5yZWR1Y2UoZnVuY3Rpb24gKHBhcnNlZCwgcmVzdWx0KSB7XG4gICAgcmV0dXJuIGVtaXRUcmFuc211eENvbXBsZXRlKHNlbGYsIHJlc3VsdCkgfHwgcGFyc2VkO1xuICB9LCBmYWxzZSk7XG5cbiAgaWYgKCFwYXJzZWQpIHtcbiAgICAvLyBFbWl0IGF0IGxlYXN0IG9uZSBcInRyYW5zbXV4Q29tcGxldGVcIiBtZXNzYWdlIGV2ZW4gaWYgbWVkaWEgaXMgbm90IGZvdW5kIHRvIHVwZGF0ZSBzdHJlYW0tY29udHJvbGxlciBzdGF0ZSB0byBQQVJTSU5HXG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICBldmVudDogJ3RyYW5zbXV4Q29tcGxldGUnLFxuICAgICAgZGF0YTogcmVzdWx0c1swXVxuICAgIH0pO1xuICB9XG5cbiAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgZXZlbnQ6ICdmbHVzaCcsXG4gICAgZGF0YTogY2h1bmtNZXRhXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0VtcHR5UmVzdWx0KHJlbXV4UmVzdWx0KSB7XG4gIHJldHVybiAhcmVtdXhSZXN1bHQuYXVkaW8gJiYgIXJlbXV4UmVzdWx0LnZpZGVvICYmICFyZW11eFJlc3VsdC50ZXh0ICYmICFyZW11eFJlc3VsdC5pZDMgJiYgIXJlbXV4UmVzdWx0LmluaXRTZWdtZW50O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC90cmFuc211eGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvdHJhbnNtdXhlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQsIGlzUHJvbWlzZSwgVHJhbnNtdXhDb25maWcsIFRyYW5zbXV4U3RhdGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRyYW5zbXV4ZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzUHJvbWlzZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzUHJvbWlzZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVHJhbnNtdXhDb25maWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUcmFuc211eENvbmZpZzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVHJhbnNtdXhTdGF0ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRyYW5zbXV4U3RhdGU7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NyeXB0X2RlY3J5cHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY3J5cHQvZGVjcnlwdGVyICovIFwiLi9zcmMvY3J5cHQvZGVjcnlwdGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF9hYWNkZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9hYWNkZW11eGVyICovIFwiLi9zcmMvZGVtdXgvYWFjZGVtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfbXA0ZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvbXA0ZGVtdXhlciAqLyBcIi4vc3JjL2RlbXV4L21wNGRlbXV4ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X3RzZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvdHNkZW11eGVyICovIFwiLi9zcmMvZGVtdXgvdHNkZW11eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF9tcDNkZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9tcDNkZW11eGVyICovIFwiLi9zcmMvZGVtdXgvbXAzZGVtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcmVtdXhfbXA0X3JlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3JlbXV4L21wNC1yZW11eGVyICovIFwiLi9zcmMvcmVtdXgvbXA0LXJlbXV4ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3JlbXV4X3Bhc3N0aHJvdWdoX3JlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3JlbXV4L3Bhc3N0aHJvdWdoLXJlbXV4ZXIgKi8gXCIuL3NyYy9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jaHVua19jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jaHVuay1jYWNoZSAqLyBcIi4vc3JjL2RlbXV4L2NodW5rLWNhY2hlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tcDQtdG9vbHMgKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBub3c7IC8vIHBlcmZvcm1hbmNlLm5vdygpIG5vdCBhdmFpbGFibGUgb24gV2ViV29ya2VyLCBhdCBsZWFzdCBvbiBTYWZhcmkgRGVza3RvcFxuXG50cnkge1xuICBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdy5iaW5kKHNlbGYucGVyZm9ybWFuY2UpO1xufSBjYXRjaCAoZXJyKSB7XG4gIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXCJsb2dnZXJcIl0uZGVidWcoJ1VuYWJsZSB0byB1c2UgUGVyZm9ybWFuY2UgQVBJIG9uIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgbm93ID0gc2VsZi5EYXRlLm5vdztcbn1cblxudmFyIG11eENvbmZpZyA9IFt7XG4gIGRlbXV4OiBfZGVtdXhfdHNkZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdLFxuICByZW11eDogX3JlbXV4X21wNF9yZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJkZWZhdWx0XCJdXG59LCB7XG4gIGRlbXV4OiBfZGVtdXhfbXA0ZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXSxcbiAgcmVtdXg6IF9yZW11eF9wYXNzdGhyb3VnaF9yZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJkZWZhdWx0XCJdXG59LCB7XG4gIGRlbXV4OiBfZGVtdXhfYWFjZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSxcbiAgcmVtdXg6IF9yZW11eF9tcDRfcmVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZGVmYXVsdFwiXVxufSwge1xuICBkZW11eDogX2RlbXV4X21wM2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImRlZmF1bHRcIl0sXG4gIHJlbXV4OiBfcmVtdXhfbXA0X3JlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImRlZmF1bHRcIl1cbn1dO1xudmFyIG1pblByb2JlQnl0ZUxlbmd0aCA9IDEwMjQ7XG5tdXhDb25maWcuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgZGVtdXggPSBfcmVmLmRlbXV4O1xuICBtaW5Qcm9iZUJ5dGVMZW5ndGggPSBNYXRoLm1heChtaW5Qcm9iZUJ5dGVMZW5ndGgsIGRlbXV4Lm1pblByb2JlQnl0ZUxlbmd0aCk7XG59KTtcblxudmFyIFRyYW5zbXV4ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFuc211eGVyKG9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvciwgaWQpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLnZlbmRvciA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMuZGVtdXhlciA9IHZvaWQgMDtcbiAgICB0aGlzLnJlbXV4ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5wcm9iZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRlY3J5cHRpb25Qcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zbXV4Q29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jYWNoZSA9IG5ldyBfY2h1bmtfY2FjaGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImRlZmF1bHRcIl0oKTtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnZlbmRvciA9IHZlbmRvcjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVHJhbnNtdXhlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIGNvbmZpZ3VyZSh0cmFuc211eENvbmZpZykge1xuICAgIHRoaXMudHJhbnNtdXhDb25maWcgPSB0cmFuc211eENvbmZpZztcblxuICAgIGlmICh0aGlzLmRlY3J5cHRlcikge1xuICAgICAgdGhpcy5kZWNyeXB0ZXIucmVzZXQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnB1c2ggPSBmdW5jdGlvbiBwdXNoKGRhdGEsIGRlY3J5cHRkYXRhLCBjaHVua01ldGEsIHN0YXRlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBzdGF0cyA9IGNodW5rTWV0YS50cmFuc211eGluZztcbiAgICBzdGF0cy5leGVjdXRlU3RhcnQgPSBub3coKTtcbiAgICB2YXIgdWludERhdGEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlLFxuICAgICAgICBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgY3VycmVudFRyYW5zbXV4U3RhdGUgPSB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlLFxuICAgICAgICB0cmFuc211eENvbmZpZyA9IHRoaXMudHJhbnNtdXhDb25maWc7XG5cbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUgPSBzdGF0ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5RGF0YSA9IGdldEVuY3J5cHRpb25UeXBlKHVpbnREYXRhLCBkZWNyeXB0ZGF0YSk7XG5cbiAgICBpZiAoa2V5RGF0YSAmJiBrZXlEYXRhLm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSB7XG4gICAgICB2YXIgZGVjcnlwdGVyID0gdGhpcy5nZXREZWNyeXB0ZXIoKTsgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBzeW5jaHJvbm91czsgd2ViQ3J5cHRvIGlzIG5vdFxuXG4gICAgICBpZiAoY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTKSB7XG4gICAgICAgIC8vIFNvZnR3YXJlIGRlY3J5cHRpb24gaXMgcHJvZ3Jlc3NpdmUuIFByb2dyZXNzaXZlIGRlY3J5cHRpb24gbWF5IG5vdCByZXR1cm4gYSByZXN1bHQgb24gZWFjaCBjYWxsLiBBbnkgY2FjaGVkXG4gICAgICAgIC8vIGRhdGEgaXMgaGFuZGxlZCBpbiB0aGUgZmx1c2goKSBjYWxsXG4gICAgICAgIHZhciBkZWNyeXB0ZWREYXRhID0gZGVjcnlwdGVyLnNvZnR3YXJlRGVjcnlwdCh1aW50RGF0YSwga2V5RGF0YS5rZXkuYnVmZmVyLCBrZXlEYXRhLml2LmJ1ZmZlcik7XG5cbiAgICAgICAgaWYgKCFkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgICAgICAgIHJldHVybiBlbXB0eVJlc3VsdChjaHVua01ldGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdWludERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBkZWNyeXB0ZXIud2ViQ3J5cHRvRGVjcnlwdCh1aW50RGF0YSwga2V5RGF0YS5rZXkuYnVmZmVyLCBrZXlEYXRhLml2LmJ1ZmZlcikudGhlbihmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICAgIC8vIENhbGxpbmcgcHVzaCBoZXJlIGlzIGltcG9ydGFudDsgaWYgZmx1c2goKSBpcyBjYWxsZWQgd2hpbGUgdGhpcyBpcyBzdGlsbCByZXNvbHZpbmcsIHRoaXMgZW5zdXJlcyB0aGF0XG4gICAgICAgICAgLy8gdGhlIGRlY3J5cHRlZCBkYXRhIGhhcyBiZWVuIHRyYW5zbXV4ZWRcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMucHVzaChkZWNyeXB0ZWREYXRhLCBudWxsLCBjaHVua01ldGEpO1xuXG4gICAgICAgICAgX3RoaXMuZGVjcnlwdGlvblByb21pc2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0aW9uUHJvbWlzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX3JlZjIgPSBzdGF0ZSB8fCBjdXJyZW50VHJhbnNtdXhTdGF0ZSxcbiAgICAgICAgY29udGlndW91cyA9IF9yZWYyLmNvbnRpZ3VvdXMsXG4gICAgICAgIGRpc2NvbnRpbnVpdHkgPSBfcmVmMi5kaXNjb250aW51aXR5LFxuICAgICAgICB0cmFja1N3aXRjaCA9IF9yZWYyLnRyYWNrU3dpdGNoLFxuICAgICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBfcmVmMi5hY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICAgIHRpbWVPZmZzZXQgPSBfcmVmMi50aW1lT2Zmc2V0LFxuICAgICAgICBpbml0U2VnbWVudENoYW5nZSA9IF9yZWYyLmluaXRTZWdtZW50Q2hhbmdlO1xuXG4gICAgdmFyIGF1ZGlvQ29kZWMgPSB0cmFuc211eENvbmZpZy5hdWRpb0NvZGVjLFxuICAgICAgICB2aWRlb0NvZGVjID0gdHJhbnNtdXhDb25maWcudmlkZW9Db2RlYyxcbiAgICAgICAgZGVmYXVsdEluaXRQdHMgPSB0cmFuc211eENvbmZpZy5kZWZhdWx0SW5pdFB0cyxcbiAgICAgICAgZHVyYXRpb24gPSB0cmFuc211eENvbmZpZy5kdXJhdGlvbixcbiAgICAgICAgaW5pdFNlZ21lbnREYXRhID0gdHJhbnNtdXhDb25maWcuaW5pdFNlZ21lbnREYXRhOyAvLyBSZXNldCBtdXhlcnMgYmVmb3JlIHByb2JpbmcgdG8gZW5zdXJlIHRoYXQgdGhlaXIgc3RhdGUgaXMgY2xlYW4sIGV2ZW4gaWYgZmx1c2hpbmcgb2NjdXJzIGJlZm9yZSBhIHN1Y2Nlc3NmdWwgcHJvYmVcblxuICAgIGlmIChkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoIHx8IGluaXRTZWdtZW50Q2hhbmdlKSB7XG4gICAgICB0aGlzLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGRpc2NvbnRpbnVpdHkgfHwgaW5pdFNlZ21lbnRDaGFuZ2UpIHtcbiAgICAgIHRoaXMucmVzZXRJbml0aWFsVGltZXN0YW1wKGRlZmF1bHRJbml0UHRzKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbnRpZ3VvdXMpIHtcbiAgICAgIHRoaXMucmVzZXRDb250aWd1aXR5KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmVlZHNQcm9iaW5nKHVpbnREYXRhLCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCkpIHtcbiAgICAgIGlmIChjYWNoZS5kYXRhTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjYWNoZWREYXRhID0gY2FjaGUuZmx1c2goKTtcbiAgICAgICAgdWludERhdGEgPSBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcImFwcGVuZFVpbnQ4QXJyYXlcIl0pKGNhY2hlZERhdGEsIHVpbnREYXRhKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb25maWd1cmVUcmFuc211eGVyKHVpbnREYXRhLCB0cmFuc211eENvbmZpZyk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMudHJhbnNtdXgodWludERhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKTtcbiAgICB2YXIgY3VycmVudFN0YXRlID0gdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZTtcbiAgICBjdXJyZW50U3RhdGUuY29udGlndW91cyA9IHRydWU7XG4gICAgY3VycmVudFN0YXRlLmRpc2NvbnRpbnVpdHkgPSBmYWxzZTtcbiAgICBjdXJyZW50U3RhdGUudHJhY2tTd2l0Y2ggPSBmYWxzZTtcbiAgICBzdGF0cy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSAvLyBEdWUgdG8gZGF0YSBjYWNoaW5nLCBmbHVzaCBjYWxscyBjYW4gcHJvZHVjZSBtb3JlIHRoYW4gb25lIFRyYW5zbXV4ZXJSZXN1bHQgKGhlbmNlIHRoZSBBcnJheSB0eXBlKVxuICA7XG5cbiAgX3Byb3RvLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goY2h1bmtNZXRhKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgc3RhdHMgPSBjaHVua01ldGEudHJhbnNtdXhpbmc7XG4gICAgc3RhdHMuZXhlY3V0ZVN0YXJ0ID0gbm93KCk7XG4gICAgdmFyIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyLFxuICAgICAgICBjYWNoZSA9IHRoaXMuY2FjaGUsXG4gICAgICAgIGN1cnJlbnRUcmFuc211eFN0YXRlID0gdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSxcbiAgICAgICAgZGVjcnlwdGlvblByb21pc2UgPSB0aGlzLmRlY3J5cHRpb25Qcm9taXNlO1xuXG4gICAgaWYgKGRlY3J5cHRpb25Qcm9taXNlKSB7XG4gICAgICAvLyBVcG9uIHJlc29sdXRpb24sIHRoZSBkZWNyeXB0aW9uIHByb21pc2UgY2FsbHMgcHVzaCgpIGFuZCByZXR1cm5zIGl0cyBUcmFuc211eGVyUmVzdWx0IHVwIHRoZSBzdGFjay4gVGhlcmVmb3JlXG4gICAgICAvLyBvbmx5IGZsdXNoaW5nIGlzIHJlcXVpcmVkIGZvciBhc3luYyBkZWNyeXB0aW9uXG4gICAgICByZXR1cm4gZGVjcnlwdGlvblByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuZmx1c2goY2h1bmtNZXRhKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciB0cmFuc211eFJlc3VsdHMgPSBbXTtcbiAgICB2YXIgdGltZU9mZnNldCA9IGN1cnJlbnRUcmFuc211eFN0YXRlLnRpbWVPZmZzZXQ7XG5cbiAgICBpZiAoZGVjcnlwdGVyKSB7XG4gICAgICAvLyBUaGUgZGVjcnlwdGVyIG1heSBoYXZlIGRhdGEgY2FjaGVkLCB3aGljaCBuZWVkcyB0byBiZSBkZW11eGVkLiBJbiB0aGlzIGNhc2Ugd2UnbGwgaGF2ZSB0d28gVHJhbnNtdXhSZXN1bHRzXG4gICAgICAvLyBUaGlzIGhhcHBlbnMgaW4gdGhlIGNhc2UgdGhhdCB3ZSByZWNlaXZlIG9ubHkgMSBwdXNoIGNhbGwgZm9yIGEgc2VnbWVudCAoZWl0aGVyIGZvciBub24tcHJvZ3Jlc3NpdmUgZG93bmxvYWRzLFxuICAgICAgLy8gb3IgZm9yIHByb2dyZXNzaXZlIGRvd25sb2FkcyB3aXRoIHNtYWxsIHNlZ21lbnRzKVxuICAgICAgdmFyIGRlY3J5cHRlZERhdGEgPSBkZWNyeXB0ZXIuZmx1c2goKTtcblxuICAgICAgaWYgKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgLy8gUHVzaCBhbHdheXMgcmV0dXJucyBhIFRyYW5zbXV4ZXJSZXN1bHQgaWYgZGVjcnlwdGRhdGEgaXMgbnVsbFxuICAgICAgICB0cmFuc211eFJlc3VsdHMucHVzaCh0aGlzLnB1c2goZGVjcnlwdGVkRGF0YSwgbnVsbCwgY2h1bmtNZXRhKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJ5dGVzU2VlbiA9IGNhY2hlLmRhdGFMZW5ndGg7XG4gICAgY2FjaGUucmVzZXQoKTtcbiAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlcixcbiAgICAgICAgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcblxuICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgLy8gSWYgcHJvYmluZyBmYWlsZWQsIGFuZCBlYWNoIGRlbXV4ZXIgc2F3IGVub3VnaCBieXRlcyB0byBiZSBhYmxlIHRvIHByb2JlLCB0aGVuIEhscy5qcyBoYXMgYmVlbiBnaXZlbiBjb250ZW50IGl0cyBub3QgYWJsZSB0byBoYW5kbGVcbiAgICAgIGlmIChieXRlc1NlZW4gPj0gbWluUHJvYmVCeXRlTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRVJST1IsIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICByZWFzb246ICdubyBkZW11eCBtYXRjaGluZyB3aXRoIGNvbnRlbnQgZm91bmQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzdGF0cy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgICByZXR1cm4gW2VtcHR5UmVzdWx0KGNodW5rTWV0YSldO1xuICAgIH1cblxuICAgIHZhciBkZW11eFJlc3VsdE9yUHJvbWlzZSA9IGRlbXV4ZXIuZmx1c2godGltZU9mZnNldCk7XG5cbiAgICBpZiAoaXNQcm9taXNlKGRlbXV4UmVzdWx0T3JQcm9taXNlKSkge1xuICAgICAgLy8gRGVjcnlwdCBmaW5hbCBTQU1QTEUtQUVTIHNhbXBsZXNcbiAgICAgIHJldHVybiBkZW11eFJlc3VsdE9yUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChkZW11eFJlc3VsdCkge1xuICAgICAgICBfdGhpczIuZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0LCBjaHVua01ldGEpO1xuXG4gICAgICAgIHJldHVybiB0cmFuc211eFJlc3VsdHM7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmZsdXNoUmVtdXgodHJhbnNtdXhSZXN1bHRzLCBkZW11eFJlc3VsdE9yUHJvbWlzZSwgY2h1bmtNZXRhKTtcbiAgICByZXR1cm4gdHJhbnNtdXhSZXN1bHRzO1xuICB9O1xuXG4gIF9wcm90by5mbHVzaFJlbXV4ID0gZnVuY3Rpb24gZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0LCBjaHVua01ldGEpIHtcbiAgICB2YXIgYXVkaW9UcmFjayA9IGRlbXV4UmVzdWx0LmF1ZGlvVHJhY2ssXG4gICAgICAgIHZpZGVvVHJhY2sgPSBkZW11eFJlc3VsdC52aWRlb1RyYWNrLFxuICAgICAgICBpZDNUcmFjayA9IGRlbXV4UmVzdWx0LmlkM1RyYWNrLFxuICAgICAgICB0ZXh0VHJhY2sgPSBkZW11eFJlc3VsdC50ZXh0VHJhY2s7XG4gICAgdmFyIF90aGlzJGN1cnJlbnRUcmFuc211eCA9IHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUsXG4gICAgICAgIGFjY3VyYXRlVGltZU9mZnNldCA9IF90aGlzJGN1cnJlbnRUcmFuc211eC5hY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICAgIHRpbWVPZmZzZXQgPSBfdGhpcyRjdXJyZW50VHJhbnNtdXgudGltZU9mZnNldDtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wibG9nZ2VyXCJdLmxvZyhcIlt0cmFuc211eGVyLnRzXTogRmx1c2hlZCBmcmFnbWVudCBcIiArIGNodW5rTWV0YS5zbiArIChjaHVua01ldGEucGFydCA+IC0xID8gJyBwOiAnICsgY2h1bmtNZXRhLnBhcnQgOiAnJykgKyBcIiBvZiBsZXZlbCBcIiArIGNodW5rTWV0YS5sZXZlbCk7XG4gICAgdmFyIHJlbXV4UmVzdWx0ID0gdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgdHJ1ZSwgdGhpcy5pZCk7XG4gICAgdHJhbnNtdXhSZXN1bHRzLnB1c2goe1xuICAgICAgcmVtdXhSZXN1bHQ6IHJlbXV4UmVzdWx0LFxuICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGFcbiAgICB9KTtcbiAgICBjaHVua01ldGEudHJhbnNtdXhpbmcuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICB9O1xuXG4gIF9wcm90by5yZXNldEluaXRpYWxUaW1lc3RhbXAgPSBmdW5jdGlvbiByZXNldEluaXRpYWxUaW1lc3RhbXAoZGVmYXVsdEluaXRQdHMpIHtcbiAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlcixcbiAgICAgICAgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcblxuICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICAgIHJlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICB9O1xuXG4gIF9wcm90by5yZXNldENvbnRpZ3VpdHkgPSBmdW5jdGlvbiByZXNldENvbnRpZ3VpdHkoKSB7XG4gICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXIsXG4gICAgICAgIHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG5cbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZW11eGVyLnJlc2V0Q29udGlndWl0eSgpO1xuICAgIHJlbXV4ZXIucmVzZXROZXh0VGltZXN0YW1wKCk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyLFxuICAgICAgICByZW11eGVyID0gdGhpcy5yZW11eGVyO1xuXG4gICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVtdXhlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG4gICAgcmVtdXhlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYyk7XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmRlbXV4ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVtdXhlcikge1xuICAgICAgdGhpcy5yZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMucmVtdXhlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnRyYW5zbXV4ID0gZnVuY3Rpb24gdHJhbnNtdXgoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgaWYgKGtleURhdGEgJiYga2V5RGF0YS5tZXRob2QgPT09ICdTQU1QTEUtQUVTJykge1xuICAgICAgcmVzdWx0ID0gdGhpcy50cmFuc211eFNhbXBsZUFlcyhkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMudHJhbnNtdXhVbmVuY3J5cHRlZChkYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8udHJhbnNtdXhVbmVuY3J5cHRlZCA9IGZ1bmN0aW9uIHRyYW5zbXV4VW5lbmNyeXB0ZWQoZGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpIHtcbiAgICB2YXIgX2RlbXV4ID0gdGhpcy5kZW11eGVyLmRlbXV4KGRhdGEsIHRpbWVPZmZzZXQsIGZhbHNlLCAhdGhpcy5jb25maWcucHJvZ3Jlc3NpdmUpLFxuICAgICAgICBhdWRpb1RyYWNrID0gX2RlbXV4LmF1ZGlvVHJhY2ssXG4gICAgICAgIHZpZGVvVHJhY2sgPSBfZGVtdXgudmlkZW9UcmFjayxcbiAgICAgICAgaWQzVHJhY2sgPSBfZGVtdXguaWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjayA9IF9kZW11eC50ZXh0VHJhY2s7XG5cbiAgICB2YXIgcmVtdXhSZXN1bHQgPSB0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBmYWxzZSwgdGhpcy5pZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbXV4UmVzdWx0OiByZW11eFJlc3VsdCxcbiAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8udHJhbnNtdXhTYW1wbGVBZXMgPSBmdW5jdGlvbiB0cmFuc211eFNhbXBsZUFlcyhkYXRhLCBkZWNyeXB0RGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLmRlbXV4ZXIuZGVtdXhTYW1wbGVBZXMoZGF0YSwgZGVjcnlwdERhdGEsIHRpbWVPZmZzZXQpLnRoZW4oZnVuY3Rpb24gKGRlbXV4UmVzdWx0KSB7XG4gICAgICB2YXIgcmVtdXhSZXN1bHQgPSBfdGhpczMucmVtdXhlci5yZW11eChkZW11eFJlc3VsdC5hdWRpb1RyYWNrLCBkZW11eFJlc3VsdC52aWRlb1RyYWNrLCBkZW11eFJlc3VsdC5pZDNUcmFjaywgZGVtdXhSZXN1bHQudGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGZhbHNlLCBfdGhpczMuaWQpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW11eFJlc3VsdDogcmVtdXhSZXN1bHQsXG4gICAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5jb25maWd1cmVUcmFuc211eGVyID0gZnVuY3Rpb24gY29uZmlndXJlVHJhbnNtdXhlcihkYXRhLCB0cmFuc211eENvbmZpZykge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyLFxuICAgICAgICB0eXBlU3VwcG9ydGVkID0gdGhpcy50eXBlU3VwcG9ydGVkLFxuICAgICAgICB2ZW5kb3IgPSB0aGlzLnZlbmRvcjtcbiAgICB2YXIgYXVkaW9Db2RlYyA9IHRyYW5zbXV4Q29uZmlnLmF1ZGlvQ29kZWMsXG4gICAgICAgIGRlZmF1bHRJbml0UHRzID0gdHJhbnNtdXhDb25maWcuZGVmYXVsdEluaXRQdHMsXG4gICAgICAgIGR1cmF0aW9uID0gdHJhbnNtdXhDb25maWcuZHVyYXRpb24sXG4gICAgICAgIGluaXRTZWdtZW50RGF0YSA9IHRyYW5zbXV4Q29uZmlnLmluaXRTZWdtZW50RGF0YSxcbiAgICAgICAgdmlkZW9Db2RlYyA9IHRyYW5zbXV4Q29uZmlnLnZpZGVvQ29kZWM7IC8vIHByb2JlIGZvciBjb250ZW50IHR5cGVcblxuICAgIHZhciBtdXg7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbXV4Q29uZmlnLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAobXV4Q29uZmlnW2ldLmRlbXV4LnByb2JlKGRhdGEpKSB7XG4gICAgICAgIG11eCA9IG11eENvbmZpZ1tpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFtdXgpIHtcbiAgICAgIC8vIElmIHByb2JpbmcgcHJldmlvdXMgY29uZmlncyBmYWlsLCB1c2UgbXA0IHBhc3N0aHJvdWdoXG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wibG9nZ2VyXCJdLndhcm4oJ0ZhaWxlZCB0byBmaW5kIGRlbXV4ZXIgYnkgcHJvYmluZyBmcmFnLCB0cmVhdGluZyBhcyBtcDQgcGFzc3Rocm91Z2gnKTtcbiAgICAgIG11eCA9IHtcbiAgICAgICAgZGVtdXg6IF9kZW11eF9tcDRkZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdLFxuICAgICAgICByZW11eDogX3JlbXV4X3Bhc3N0aHJvdWdoX3JlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImRlZmF1bHRcIl1cbiAgICAgIH07XG4gICAgfSAvLyBzbyBsZXQncyBjaGVjayB0aGF0IGN1cnJlbnQgcmVtdXhlciBhbmQgZGVtdXhlciBhcmUgc3RpbGwgdmFsaWRcblxuXG4gICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgdmFyIHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG4gICAgdmFyIFJlbXV4ZXIgPSBtdXgucmVtdXg7XG4gICAgdmFyIERlbXV4ZXIgPSBtdXguZGVtdXg7XG5cbiAgICBpZiAoIXJlbXV4ZXIgfHwgIShyZW11eGVyIGluc3RhbmNlb2YgUmVtdXhlcikpIHtcbiAgICAgIHRoaXMucmVtdXhlciA9IG5ldyBSZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQsIHZlbmRvcik7XG4gICAgfVxuXG4gICAgaWYgKCFkZW11eGVyIHx8ICEoZGVtdXhlciBpbnN0YW5jZW9mIERlbXV4ZXIpKSB7XG4gICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkKTtcbiAgICAgIHRoaXMucHJvYmUgPSBEZW11eGVyLnByb2JlO1xuICAgIH0gLy8gRW5zdXJlIHRoYXQgbXV4ZXJzIGFyZSBhbHdheXMgaW5pdGlhbGl6ZWQgd2l0aCBhbiBpbml0U2VnbWVudFxuXG5cbiAgICB0aGlzLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbik7XG4gICAgdGhpcy5yZXNldEluaXRpYWxUaW1lc3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICB9O1xuXG4gIF9wcm90by5uZWVkc1Byb2JpbmcgPSBmdW5jdGlvbiBuZWVkc1Byb2JpbmcoZGF0YSwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbnRpbnVpdHkgY2hhbmdlLCBvciB0cmFjayBzd2l0Y2hcbiAgICAvLyB3ZSBtaWdodCBzd2l0Y2ggZnJvbSBjb250ZW50IHR5cGUgKEFBQyBjb250YWluZXIgdG8gVFMgY29udGFpbmVyLCBvciBUUyB0byBmbXA0IGZvciBleGFtcGxlKVxuICAgIHJldHVybiAhdGhpcy5kZW11eGVyIHx8ICF0aGlzLnJlbXV4ZXIgfHwgZGlzY29udGludWl0eSB8fCB0cmFja1N3aXRjaDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0RGVjcnlwdGVyID0gZnVuY3Rpb24gZ2V0RGVjcnlwdGVyKCkge1xuICAgIHZhciBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlcjtcblxuICAgIGlmICghZGVjcnlwdGVyKSB7XG4gICAgICBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlciA9IG5ldyBfY3J5cHRfZGVjcnlwdGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKHRoaXMub2JzZXJ2ZXIsIHRoaXMuY29uZmlnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVjcnlwdGVyO1xuICB9O1xuXG4gIHJldHVybiBUcmFuc211eGVyO1xufSgpO1xuXG5cblxuZnVuY3Rpb24gZ2V0RW5jcnlwdGlvblR5cGUoZGF0YSwgZGVjcnlwdERhdGEpIHtcbiAgdmFyIGVuY3J5cHRpb25UeXBlID0gbnVsbDtcblxuICBpZiAoZGF0YS5ieXRlTGVuZ3RoID4gMCAmJiBkZWNyeXB0RGF0YSAhPSBudWxsICYmIGRlY3J5cHREYXRhLmtleSAhPSBudWxsICYmIGRlY3J5cHREYXRhLml2ICE9PSBudWxsICYmIGRlY3J5cHREYXRhLm1ldGhvZCAhPSBudWxsKSB7XG4gICAgZW5jcnlwdGlvblR5cGUgPSBkZWNyeXB0RGF0YTtcbiAgfVxuXG4gIHJldHVybiBlbmNyeXB0aW9uVHlwZTtcbn1cblxudmFyIGVtcHR5UmVzdWx0ID0gZnVuY3Rpb24gZW1wdHlSZXN1bHQoY2h1bmtNZXRhKSB7XG4gIHJldHVybiB7XG4gICAgcmVtdXhSZXN1bHQ6IHt9LFxuICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gIH07XG59O1xuXG5mdW5jdGlvbiBpc1Byb21pc2UocCkge1xuICByZXR1cm4gJ3RoZW4nIGluIHAgJiYgcC50aGVuIGluc3RhbmNlb2YgRnVuY3Rpb247XG59XG52YXIgVHJhbnNtdXhDb25maWcgPSBmdW5jdGlvbiBUcmFuc211eENvbmZpZyhhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBpbml0U2VnbWVudERhdGEsIGR1cmF0aW9uLCBkZWZhdWx0SW5pdFB0cykge1xuICB0aGlzLmF1ZGlvQ29kZWMgPSB2b2lkIDA7XG4gIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgdGhpcy5pbml0U2VnbWVudERhdGEgPSB2b2lkIDA7XG4gIHRoaXMuZHVyYXRpb24gPSB2b2lkIDA7XG4gIHRoaXMuZGVmYXVsdEluaXRQdHMgPSB2b2lkIDA7XG4gIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gIHRoaXMuaW5pdFNlZ21lbnREYXRhID0gaW5pdFNlZ21lbnREYXRhO1xuICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gIHRoaXMuZGVmYXVsdEluaXRQdHMgPSBkZWZhdWx0SW5pdFB0cztcbn07XG52YXIgVHJhbnNtdXhTdGF0ZSA9IGZ1bmN0aW9uIFRyYW5zbXV4U3RhdGUoZGlzY29udGludWl0eSwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCB0cmFja1N3aXRjaCwgdGltZU9mZnNldCwgaW5pdFNlZ21lbnRDaGFuZ2UpIHtcbiAgdGhpcy5kaXNjb250aW51aXR5ID0gdm9pZCAwO1xuICB0aGlzLmNvbnRpZ3VvdXMgPSB2b2lkIDA7XG4gIHRoaXMuYWNjdXJhdGVUaW1lT2Zmc2V0ID0gdm9pZCAwO1xuICB0aGlzLnRyYWNrU3dpdGNoID0gdm9pZCAwO1xuICB0aGlzLnRpbWVPZmZzZXQgPSB2b2lkIDA7XG4gIHRoaXMuaW5pdFNlZ21lbnRDaGFuZ2UgPSB2b2lkIDA7XG4gIHRoaXMuZGlzY29udGludWl0eSA9IGRpc2NvbnRpbnVpdHk7XG4gIHRoaXMuY29udGlndW91cyA9IGNvbnRpZ3VvdXM7XG4gIHRoaXMuYWNjdXJhdGVUaW1lT2Zmc2V0ID0gYWNjdXJhdGVUaW1lT2Zmc2V0O1xuICB0aGlzLnRyYWNrU3dpdGNoID0gdHJhY2tTd2l0Y2g7XG4gIHRoaXMudGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG4gIHRoaXMuaW5pdFNlZ21lbnRDaGFuZ2UgPSBpbml0U2VnbWVudENoYW5nZTtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L3RzZGVtdXhlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvdHNkZW11eGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkaXNjYXJkRVBCLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRpc2NhcmRFUEJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkaXNjYXJkRVBCOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYWR0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hZHRzICovIFwiLi9zcmMvZGVtdXgvYWR0cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbXBlZ2F1ZGlvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21wZWdhdWRpbyAqLyBcIi4vc3JjL2RlbXV4L21wZWdhdWRpby50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXhwX2dvbG9tYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9leHAtZ29sb21iICovIFwiLi9zcmMvZGVtdXgvZXhwLWdvbG9tYi50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2FtcGxlX2Flc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zYW1wbGUtYWVzICovIFwiLi9zcmMvZGVtdXgvc2FtcGxlLWFlcy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbXA0LXRvb2xzICovIFwiLi9zcmMvdXRpbHMvbXA0LXRvb2xzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2RlbXV4ZXIgKi8gXCIuL3NyYy90eXBlcy9kZW11eGVyLnRzXCIpO1xuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbi8qKlxuICogaGlnaGx5IG9wdGltaXplZCBUUyBkZW11eGVyOlxuICogcGFyc2UgUEFULCBQTVRcbiAqIGV4dHJhY3QgUEVTIHBhY2tldCBmcm9tIGF1ZGlvIGFuZCB2aWRlbyBQSURzXG4gKiBleHRyYWN0IEFWQy9IMjY0IE5BTCB1bml0cyBhbmQgQUFDL0FEVFMgc2FtcGxlcyBmcm9tIFBFUyBwYWNrZXRcbiAqIHRyaWdnZXIgdGhlIHJlbXV4ZXIgdXBvbiBwYXJzaW5nIGNvbXBsZXRpb25cbiAqIGl0IGFsc28gdHJpZXMgdG8gd29ya2Fyb3VuZCBhcyBiZXN0IGFzIGl0IGNhbiBhdWRpbyBjb2RlYyBzd2l0Y2ggKEhFLUFBQyB0byBBQUMgYW5kIHZpY2UgdmVyc2EpLCB3aXRob3V0IGhhdmluZyB0byByZXN0YXJ0IHRoZSBNZWRpYVNvdXJjZS5cbiAqIGl0IGFsc28gY29udHJvbHMgdGhlIHJlbXV4aW5nIHByb2Nlc3MgOlxuICogdXBvbiBkaXNjb250aW51aXR5IG9yIGxldmVsIHN3aXRjaCBkZXRlY3Rpb24sIGl0IHdpbGwgYWxzbyBub3RpZmllcyB0aGUgcmVtdXhlciBzbyB0aGF0IGl0IGNhbiByZXNldCBpdHMgc3RhdGUuXG4gKi9cblxuXG5cblxuXG5cblxuXG5cblxudmFyIFRTRGVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRTRGVtdXhlcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICAgIHRoaXMucG10UGFyc2VkID0gZmFsc2U7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5fcG10SWQgPSAtMTtcbiAgICB0aGlzLl9hdmNUcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuX2lkM1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuX3R4dFRyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICB9XG5cbiAgVFNEZW11eGVyLnByb2JlID0gZnVuY3Rpb24gcHJvYmUoZGF0YSkge1xuICAgIHZhciBzeW5jT2Zmc2V0ID0gVFNEZW11eGVyLnN5bmNPZmZzZXQoZGF0YSk7XG5cbiAgICBpZiAoc3luY09mZnNldCA8IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN5bmNPZmZzZXQpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wibG9nZ2VyXCJdLndhcm4oXCJNUEVHMi1UUyBkZXRlY3RlZCBidXQgZmlyc3Qgc3luYyB3b3JkIGZvdW5kIEAgb2Zmc2V0IFwiICsgc3luY09mZnNldCArIFwiLCBqdW5rIGFoZWFkID9cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBUU0RlbXV4ZXIuc3luY09mZnNldCA9IGZ1bmN0aW9uIHN5bmNPZmZzZXQoZGF0YSkge1xuICAgIC8vIHNjYW4gMTAwMCBmaXJzdCBieXRlc1xuICAgIHZhciBzY2Fud2luZG93ID0gTWF0aC5taW4oMTAwMCwgZGF0YS5sZW5ndGggLSAzICogMTg4KTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHNjYW53aW5kb3cpIHtcbiAgICAgIC8vIGEgVFMgZnJhZ21lbnQgc2hvdWxkIGNvbnRhaW4gYXQgbGVhc3QgMyBUUyBwYWNrZXRzLCBhIFBBVCwgYSBQTVQsIGFuZCBvbmUgUElELCBlYWNoIHN0YXJ0aW5nIHdpdGggMHg0N1xuICAgICAgaWYgKGRhdGFbaV0gPT09IDB4NDcgJiYgZGF0YVtpICsgMTg4XSA9PT0gMHg0NyAmJiBkYXRhW2kgKyAyICogMTg4XSA9PT0gMHg0Nykge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0cmFjayBtb2RlbCBpbnRlcm5hbCB0byBkZW11eGVyIHVzZWQgdG8gZHJpdmUgcmVtdXhpbmcgaW5wdXRcbiAgICpcbiAgICogQHBhcmFtIHR5cGUgJ2F1ZGlvJyB8ICd2aWRlbycgfCAnaWQzJyB8ICd0ZXh0J1xuICAgKiBAcGFyYW0gZHVyYXRpb25cbiAgICogQHJldHVybiBUU0RlbXV4ZXIncyBpbnRlcm5hbCB0cmFjayBtb2RlbFxuICAgKi9cbiAgO1xuXG4gIFRTRGVtdXhlci5jcmVhdGVUcmFjayA9IGZ1bmN0aW9uIGNyZWF0ZVRyYWNrKHR5cGUsIGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRhaW5lcjogdHlwZSA9PT0gJ3ZpZGVvJyB8fCB0eXBlID09PSAnYXVkaW8nID8gJ3ZpZGVvL21wMnQnIDogdW5kZWZpbmVkLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGlkOiBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJSZW11eGVyVHJhY2tJZENvbmZpZ1wiXVt0eXBlXSxcbiAgICAgIHBpZDogLTEsXG4gICAgICBpbnB1dFRpbWVTY2FsZTogOTAwMDAsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgZHJvcHBlZDogMCxcbiAgICAgIGR1cmF0aW9uOiB0eXBlID09PSAnYXVkaW8nID8gZHVyYXRpb24gOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbml0IHNlZ21lbnQgb24gdGhlIGRlbXV4ZXIvcmVtdXhlciBpbnRlcmZhY2UuIE5lZWRlZCBmb3IgZGlzY29udGludWl0aWVzL3RyYWNrLXN3aXRjaGVzIChvciBhdCBzdHJlYW0gc3RhcnQpXG4gICAqIFJlc2V0cyBhbGwgaW50ZXJuYWwgdHJhY2sgaW5zdGFuY2VzIG9mIHRoZSBkZW11eGVyLlxuICAgKi9cbiAgO1xuXG4gIHZhciBfcHJvdG8gPSBUU0RlbXV4ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZXNldEluaXRTZWdtZW50ID0gZnVuY3Rpb24gcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgIHRoaXMucG10UGFyc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcG10SWQgPSAtMTtcbiAgICB0aGlzLl9hdmNUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygndmlkZW8nKTtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCdhdWRpbycsIHRyYWNrRHVyYXRpb24pO1xuICAgIHRoaXMuX2lkM1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCdpZDMnKTtcbiAgICB0aGlzLl90eHRUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygndGV4dCcpO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2suc2VnbWVudENvZGVjID0gJ2FhYyc7IC8vIGZsdXNoIGFueSBwYXJ0aWFsIGNvbnRlbnRcblxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0cmFja0R1cmF0aW9uO1xuICB9O1xuXG4gIF9wcm90by5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uIHJlc2V0VGltZVN0YW1wKCkge307XG5cbiAgX3Byb3RvLnJlc2V0Q29udGlndWl0eSA9IGZ1bmN0aW9uIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICB2YXIgX2F1ZGlvVHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrLFxuICAgICAgICBfYXZjVHJhY2sgPSB0aGlzLl9hdmNUcmFjayxcbiAgICAgICAgX2lkM1RyYWNrID0gdGhpcy5faWQzVHJhY2s7XG5cbiAgICBpZiAoX2F1ZGlvVHJhY2spIHtcbiAgICAgIF9hdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChfYXZjVHJhY2spIHtcbiAgICAgIF9hdmNUcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoX2lkM1RyYWNrKSB7XG4gICAgICBfaWQzVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmRlbXV4ID0gZnVuY3Rpb24gZGVtdXgoZGF0YSwgdGltZU9mZnNldCwgaXNTYW1wbGVBZXMsIGZsdXNoKSB7XG4gICAgaWYgKGlzU2FtcGxlQWVzID09PSB2b2lkIDApIHtcbiAgICAgIGlzU2FtcGxlQWVzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZsdXNoID09PSB2b2lkIDApIHtcbiAgICAgIGZsdXNoID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBwZXM7XG4gICAgdmFyIHZpZGVvVHJhY2sgPSB0aGlzLl9hdmNUcmFjaztcbiAgICB2YXIgYXVkaW9UcmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG4gICAgdmFyIGlkM1RyYWNrID0gdGhpcy5faWQzVHJhY2s7XG4gICAgdmFyIHRleHRUcmFjayA9IHRoaXMuX3R4dFRyYWNrO1xuICAgIHZhciBhdmNJZCA9IHZpZGVvVHJhY2sucGlkO1xuICAgIHZhciBhdmNEYXRhID0gdmlkZW9UcmFjay5wZXNEYXRhO1xuICAgIHZhciBhdWRpb0lkID0gYXVkaW9UcmFjay5waWQ7XG4gICAgdmFyIGlkM0lkID0gaWQzVHJhY2sucGlkO1xuICAgIHZhciBhdWRpb0RhdGEgPSBhdWRpb1RyYWNrLnBlc0RhdGE7XG4gICAgdmFyIGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhO1xuICAgIHZhciB1bmtub3duUElEcyA9IGZhbHNlO1xuICAgIHZhciBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZDtcbiAgICB2YXIgcG10SWQgPSB0aGlzLl9wbXRJZDtcbiAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAodGhpcy5yZW1haW5kZXJEYXRhKSB7XG4gICAgICBkYXRhID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImFwcGVuZFVpbnQ4QXJyYXlcIl0pKHRoaXMucmVtYWluZGVyRGF0YSwgZGF0YSk7XG4gICAgICBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGxlbiA8IDE4OCAmJiAhZmx1c2gpIHtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IGRhdGE7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdWRpb1RyYWNrOiBhdWRpb1RyYWNrLFxuICAgICAgICB2aWRlb1RyYWNrOiB2aWRlb1RyYWNrLFxuICAgICAgICBpZDNUcmFjazogaWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjazogdGV4dFRyYWNrXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBzeW5jT2Zmc2V0ID0gTWF0aC5tYXgoMCwgVFNEZW11eGVyLnN5bmNPZmZzZXQoZGF0YSkpO1xuICAgIGxlbiAtPSAobGVuICsgc3luY09mZnNldCkgJSAxODg7XG5cbiAgICBpZiAobGVuIDwgZGF0YS5ieXRlTGVuZ3RoICYmICFmbHVzaCkge1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGxlbiwgZGF0YS5idWZmZXIuYnl0ZUxlbmd0aCAtIGxlbik7XG4gICAgfSAvLyBsb29wIHRocm91Z2ggVFMgcGFja2V0c1xuXG5cbiAgICB2YXIgdHNQYWNrZXRFcnJvcnMgPSAwO1xuXG4gICAgZm9yICh2YXIgc3RhcnQgPSBzeW5jT2Zmc2V0OyBzdGFydCA8IGxlbjsgc3RhcnQgKz0gMTg4KSB7XG4gICAgICBpZiAoZGF0YVtzdGFydF0gPT09IDB4NDcpIHtcbiAgICAgICAgdmFyIHN0dCA9ICEhKGRhdGFbc3RhcnQgKyAxXSAmIDB4NDApOyAvLyBwaWQgaXMgYSAxMy1iaXQgZmllbGQgc3RhcnRpbmcgYXQgdGhlIGxhc3QgYml0IG9mIFRTWzFdXG5cbiAgICAgICAgdmFyIHBpZCA9ICgoZGF0YVtzdGFydCArIDFdICYgMHgxZikgPDwgOCkgKyBkYXRhW3N0YXJ0ICsgMl07XG4gICAgICAgIHZhciBhdGYgPSAoZGF0YVtzdGFydCArIDNdICYgMHgzMCkgPj4gNDsgLy8gaWYgYW4gYWRhcHRpb24gZmllbGQgaXMgcHJlc2VudCwgaXRzIGxlbmd0aCBpcyBzcGVjaWZpZWQgYnkgdGhlIGZpZnRoIGJ5dGUgb2YgdGhlIFRTIHBhY2tldCBoZWFkZXIuXG5cbiAgICAgICAgdmFyIG9mZnNldCA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoYXRmID4gMSkge1xuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNSArIGRhdGFbc3RhcnQgKyA0XTsgLy8gY29udGludWUgaWYgdGhlcmUgaXMgb25seSBhZGFwdGF0aW9uIGZpZWxkXG5cbiAgICAgICAgICBpZiAob2Zmc2V0ID09PSBzdGFydCArIDE4OCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAocGlkKSB7XG4gICAgICAgICAgY2FzZSBhdmNJZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGF2Y0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF2Y0RhdGEpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBVkNQRVModmlkZW9UcmFjaywgdGV4dFRyYWNrLCBwZXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGF2Y0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgc2l6ZTogMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXZjRGF0YSkge1xuICAgICAgICAgICAgICBhdmNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcbiAgICAgICAgICAgICAgYXZjRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgYXVkaW9JZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF1ZGlvVHJhY2suc2VnbWVudENvZGVjKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICdhYWMnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlQUFDUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlICdtcDMnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlTVBFR1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhdWRpb0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgc2l6ZTogMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXVkaW9EYXRhKSB7XG4gICAgICAgICAgICAgIGF1ZGlvRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICAgIGF1ZGlvRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgaWQzSWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlSUQzUEVTKGlkM1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWQzRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICBzaXplOiAwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpZDNEYXRhKSB7XG4gICAgICAgICAgICAgIGlkM0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIDE4OCkpO1xuICAgICAgICAgICAgICBpZDNEYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG10SWQgPSB0aGlzLl9wbXRJZCA9IHBhcnNlUEFUKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgcG10SWQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBwYXJzZWRQSURzID0gcGFyc2VQTVQoZGF0YSwgb2Zmc2V0LCB0aGlzLnR5cGVTdXBwb3J0ZWQsIGlzU2FtcGxlQWVzKTsgLy8gb25seSB1cGRhdGUgdHJhY2sgaWQgaWYgdHJhY2sgUElEIGZvdW5kIHdoaWxlIHBhcnNpbmcgUE1UXG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gYXZvaWQgcmVzZXR0aW5nIHRoZSBQSUQgdG8gLTEgaW4gY2FzZVxuICAgICAgICAgICAgICAvLyB0cmFjayBQSUQgdHJhbnNpZW50bHkgZGlzYXBwZWFycyBmcm9tIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaW4gY2FzZSBvZiB0cmFuc2llbnQgbWlzc2luZyBhdWRpbyBzYW1wbGVzIGZvciBleGFtcGxlXG4gICAgICAgICAgICAgIC8vIE5PVEUgdGhpcyBpcyBvbmx5IHRoZSBQSUQgb2YgdGhlIHRyYWNrIGFzIGZvdW5kIGluIFRTLFxuICAgICAgICAgICAgICAvLyBidXQgd2UgYXJlIG5vdCB1c2luZyB0aGlzIGZvciBNUDQgdHJhY2sgSURzLlxuXG4gICAgICAgICAgICAgIGF2Y0lkID0gcGFyc2VkUElEcy5hdmM7XG5cbiAgICAgICAgICAgICAgaWYgKGF2Y0lkID4gMCkge1xuICAgICAgICAgICAgICAgIHZpZGVvVHJhY2sucGlkID0gYXZjSWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhdWRpb0lkID0gcGFyc2VkUElEcy5hdWRpbztcblxuICAgICAgICAgICAgICBpZiAoYXVkaW9JZCA+IDApIHtcbiAgICAgICAgICAgICAgICBhdWRpb1RyYWNrLnBpZCA9IGF1ZGlvSWQ7XG4gICAgICAgICAgICAgICAgYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPSBwYXJzZWRQSURzLnNlZ21lbnRDb2RlYztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlkM0lkID0gcGFyc2VkUElEcy5pZDM7XG5cbiAgICAgICAgICAgICAgaWYgKGlkM0lkID4gMCkge1xuICAgICAgICAgICAgICAgIGlkM1RyYWNrLnBpZCA9IGlkM0lkO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHVua25vd25QSURzICYmICFwbXRQYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJsb2dnZXJcIl0ubG9nKCdyZXBhcnNlIGZyb20gYmVnaW5uaW5nJyk7XG4gICAgICAgICAgICAgICAgdW5rbm93blBJRHMgPSBmYWxzZTsgLy8gd2Ugc2V0IGl0IHRvIC0xODgsIHRoZSArPSAxODggaW4gdGhlIGZvciBsb29wIHdpbGwgcmVzZXQgc3RhcnQgdG8gMFxuXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBzeW5jT2Zmc2V0IC0gMTg4O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgY2FzZSAweDFmZmY6XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB1bmtub3duUElEcyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHNQYWNrZXRFcnJvcnMrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHNQYWNrZXRFcnJvcnMgPiAwKSB7XG4gICAgICB0aGlzLm9ic2VydmVyLmVtaXQoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiRXZlbnRzXCJdLkVSUk9SLCBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiRXJyb3JUeXBlc1wiXS5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiRXJyb3JEZXRhaWxzXCJdLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICByZWFzb246IFwiRm91bmQgXCIgKyB0c1BhY2tldEVycm9ycyArIFwiIFRTIHBhY2tldC9zIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGggMHg0N1wiXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2aWRlb1RyYWNrLnBlc0RhdGEgPSBhdmNEYXRhO1xuICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IGF1ZGlvRGF0YTtcbiAgICBpZDNUcmFjay5wZXNEYXRhID0gaWQzRGF0YTtcbiAgICB2YXIgZGVtdXhSZXN1bHQgPSB7XG4gICAgICBhdWRpb1RyYWNrOiBhdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjazogdmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrOiBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogdGV4dFRyYWNrXG4gICAgfTtcblxuICAgIGlmIChmbHVzaCkge1xuICAgICAgdGhpcy5leHRyYWN0UmVtYWluaW5nU2FtcGxlcyhkZW11eFJlc3VsdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbXV4UmVzdWx0O1xuICB9O1xuXG4gIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHZhciByZW1haW5kZXJEYXRhID0gdGhpcy5yZW1haW5kZXJEYXRhO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGlmIChyZW1haW5kZXJEYXRhKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLmRlbXV4KHJlbWFpbmRlckRhdGEsIC0xLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdmlkZW9UcmFjazogdGhpcy5fYXZjVHJhY2ssXG4gICAgICAgIGF1ZGlvVHJhY2s6IHRoaXMuX2F1ZGlvVHJhY2ssXG4gICAgICAgIGlkM1RyYWNrOiB0aGlzLl9pZDNUcmFjayxcbiAgICAgICAgdGV4dFRyYWNrOiB0aGlzLl90eHRUcmFja1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmV4dHJhY3RSZW1haW5pbmdTYW1wbGVzKHJlc3VsdCk7XG5cbiAgICBpZiAodGhpcy5zYW1wbGVBZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY3J5cHQocmVzdWx0LCB0aGlzLnNhbXBsZUFlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8uZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXMgPSBmdW5jdGlvbiBleHRyYWN0UmVtYWluaW5nU2FtcGxlcyhkZW11eFJlc3VsdCkge1xuICAgIHZhciBhdWRpb1RyYWNrID0gZGVtdXhSZXN1bHQuYXVkaW9UcmFjayxcbiAgICAgICAgdmlkZW9UcmFjayA9IGRlbXV4UmVzdWx0LnZpZGVvVHJhY2ssXG4gICAgICAgIGlkM1RyYWNrID0gZGVtdXhSZXN1bHQuaWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjayA9IGRlbXV4UmVzdWx0LnRleHRUcmFjaztcbiAgICB2YXIgYXZjRGF0YSA9IHZpZGVvVHJhY2sucGVzRGF0YTtcbiAgICB2YXIgYXVkaW9EYXRhID0gYXVkaW9UcmFjay5wZXNEYXRhO1xuICAgIHZhciBpZDNEYXRhID0gaWQzVHJhY2sucGVzRGF0YTsgLy8gdHJ5IHRvIHBhcnNlIGxhc3QgUEVTIHBhY2tldHNcblxuICAgIHZhciBwZXM7XG5cbiAgICBpZiAoYXZjRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXZjRGF0YSkpKSB7XG4gICAgICB0aGlzLnBhcnNlQVZDUEVTKHZpZGVvVHJhY2ssIHRleHRUcmFjaywgcGVzLCB0cnVlKTtcbiAgICAgIHZpZGVvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVpdGhlciBhdmNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIHZpZGVvVHJhY2sucGVzRGF0YSA9IGF2Y0RhdGE7XG4gICAgfVxuXG4gICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkpIHtcbiAgICAgIHN3aXRjaCAoYXVkaW9UcmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgY2FzZSAnYWFjJzpcbiAgICAgICAgICB0aGlzLnBhcnNlQUFDUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICB0aGlzLnBhcnNlTVBFR1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXVkaW9EYXRhICE9PSBudWxsICYmIGF1ZGlvRGF0YSAhPT0gdm9pZCAwICYmIGF1ZGlvRGF0YS5zaXplKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImxvZ2dlclwiXS5sb2coJ2xhc3QgQUFDIFBFUyBwYWNrZXQgdHJ1bmNhdGVkLG1pZ2h0IG92ZXJsYXAgYmV0d2VlbiBmcmFnbWVudHMnKTtcbiAgICAgIH0gLy8gZWl0aGVyIGF1ZGlvRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG5cblxuICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gYXVkaW9EYXRhO1xuICAgIH1cblxuICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcbiAgICAgIHRoaXMucGFyc2VJRDNQRVMoaWQzVHJhY2ssIHBlcyk7XG4gICAgICBpZDNUcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWl0aGVyIGlkM0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5kZW11eFNhbXBsZUFlcyA9IGZ1bmN0aW9uIGRlbXV4U2FtcGxlQWVzKGRhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICB2YXIgZGVtdXhSZXN1bHQgPSB0aGlzLmRlbXV4KGRhdGEsIHRpbWVPZmZzZXQsIHRydWUsICF0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZSk7XG4gICAgdmFyIHNhbXBsZUFlcyA9IHRoaXMuc2FtcGxlQWVzID0gbmV3IF9zYW1wbGVfYWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdKHRoaXMub2JzZXJ2ZXIsIHRoaXMuY29uZmlnLCBrZXlEYXRhKTtcbiAgICByZXR1cm4gdGhpcy5kZWNyeXB0KGRlbXV4UmVzdWx0LCBzYW1wbGVBZXMpO1xuICB9O1xuXG4gIF9wcm90by5kZWNyeXB0ID0gZnVuY3Rpb24gZGVjcnlwdChkZW11eFJlc3VsdCwgc2FtcGxlQWVzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICB2YXIgYXVkaW9UcmFjayA9IGRlbXV4UmVzdWx0LmF1ZGlvVHJhY2ssXG4gICAgICAgICAgdmlkZW9UcmFjayA9IGRlbXV4UmVzdWx0LnZpZGVvVHJhY2s7XG5cbiAgICAgIGlmIChhdWRpb1RyYWNrLnNhbXBsZXMgJiYgYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICAgIHNhbXBsZUFlcy5kZWNyeXB0QWFjU2FtcGxlcyhhdWRpb1RyYWNrLnNhbXBsZXMsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzKSB7XG4gICAgICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoZGVtdXhSZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoZGVtdXhSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHZpZGVvVHJhY2suc2FtcGxlcykge1xuICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZShkZW11eFJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IDA7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlQVZDUEVTID0gZnVuY3Rpb24gcGFyc2VBVkNQRVModHJhY2ssIHRleHRUcmFjaywgcGVzLCBsYXN0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciB1bml0cyA9IHRoaXMucGFyc2VBVkNOQUx1KHRyYWNrLCBwZXMuZGF0YSk7XG4gICAgdmFyIGRlYnVnID0gZmFsc2U7XG4gICAgdmFyIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlO1xuICAgIHZhciBwdXNoO1xuICAgIHZhciBzcHNmb3VuZCA9IGZhbHNlOyAvLyBmcmVlIHBlcy5kYXRhIHRvIHNhdmUgdXAgc29tZSBtZW1vcnlcblxuICAgIHBlcy5kYXRhID0gbnVsbDsgLy8gaWYgbmV3IE5BTCB1bml0cyBmb3VuZCBhbmQgbGFzdCBzYW1wbGUgc3RpbGwgdGhlcmUsIGxldCdzIHB1c2ggLi4uXG4gICAgLy8gdGhpcyBoZWxwcyBwYXJzaW5nIHN0cmVhbXMgd2l0aCBtaXNzaW5nIEFVRCAob25seSBkbyB0aGlzIGlmIEFVRCBuZXZlciBmb3VuZClcblxuICAgIGlmIChhdmNTYW1wbGUgJiYgdW5pdHMubGVuZ3RoICYmICF0cmFjay5hdWRGb3VuZCkge1xuICAgICAgcHVzaEFjY2Vzc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZShmYWxzZSwgcGVzLnB0cywgcGVzLmR0cywgJycpO1xuICAgIH1cblxuICAgIHVuaXRzLmZvckVhY2goZnVuY3Rpb24gKHVuaXQpIHtcbiAgICAgIHN3aXRjaCAodW5pdC50eXBlKSB7XG4gICAgICAgIC8vIE5EUlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcHVzaCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICghYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICAgIGF2Y1NhbXBsZSA9IF90aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ05EUiAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdmNTYW1wbGUuZnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB1bml0LmRhdGE7IC8vIG9ubHkgY2hlY2sgc2xpY2UgdHlwZSB0byBkZXRlY3QgS0YgaW4gY2FzZSBTUFMgZm91bmQgaW4gc2FtZSBwYWNrZXQgKGFueSBrZXlmcmFtZSBpcyBwcmVjZWRlZCBieSBTUFMgLi4uKVxuXG4gICAgICAgICAgICBpZiAoc3BzZm91bmQgJiYgZGF0YS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgIC8vIHJldHJpZXZlIHNsaWNlIHR5cGUgYnkgcGFyc2luZyBiZWdpbm5pbmcgb2YgTkFMIHVuaXQgKGZvbGxvdyBIMjY0IHNwZWMsIHNsaWNlX2hlYWRlciBkZWZpbml0aW9uKSB0byBkZXRlY3Qga2V5ZnJhbWUgZW1iZWRkZWQgaW4gTkRSXG4gICAgICAgICAgICAgIHZhciBzbGljZVR5cGUgPSBuZXcgX2V4cF9nb2xvbWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0oZGF0YSkucmVhZFNsaWNlVHlwZSgpOyAvLyAyIDogSSBzbGljZSwgNCA6IFNJIHNsaWNlLCA3IDogSSBzbGljZSwgOTogU0kgc2xpY2VcbiAgICAgICAgICAgICAgLy8gU0kgc2xpY2UgOiBBIHNsaWNlIHRoYXQgaXMgY29kZWQgdXNpbmcgaW50cmEgcHJlZGljdGlvbiBvbmx5IGFuZCB1c2luZyBxdWFudGlzYXRpb24gb2YgdGhlIHByZWRpY3Rpb24gc2FtcGxlcy5cbiAgICAgICAgICAgICAgLy8gQW4gU0kgc2xpY2UgY2FuIGJlIGNvZGVkIHN1Y2ggdGhhdCBpdHMgZGVjb2RlZCBzYW1wbGVzIGNhbiBiZSBjb25zdHJ1Y3RlZCBpZGVudGljYWxseSB0byBhbiBTUCBzbGljZS5cbiAgICAgICAgICAgICAgLy8gSSBzbGljZTogQSBzbGljZSB0aGF0IGlzIG5vdCBhbiBTSSBzbGljZSB0aGF0IGlzIGRlY29kZWQgdXNpbmcgaW50cmEgcHJlZGljdGlvbiBvbmx5LlxuICAgICAgICAgICAgICAvLyBpZiAoc2xpY2VUeXBlID09PSAyIHx8IHNsaWNlVHlwZSA9PT0gNykge1xuXG4gICAgICAgICAgICAgIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA0IHx8IHNsaWNlVHlwZSA9PT0gNyB8fCBzbGljZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhazsgLy8gSURSXG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTsgLy8gaGFuZGxlIFBFUyBub3Qgc3RhcnRpbmcgd2l0aCBBVURcblxuICAgICAgICAgIGlmICghYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUgPSBfdGhpcy5hdmNTYW1wbGUgPSBjcmVhdGVBVkNTYW1wbGUodHJ1ZSwgcGVzLnB0cywgcGVzLmR0cywgJycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdJRFIgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICBhdmNTYW1wbGUuZnJhbWUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBTRUlcblxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcHVzaCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdTRUkgJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcInBhcnNlU0VJTWVzc2FnZUZyb21OQUx1XCJdKShkaXNjYXJkRVBCKHVuaXQuZGF0YSksIHBlcy5wdHMsIHRleHRUcmFjay5zYW1wbGVzKTtcbiAgICAgICAgICAgIGJyZWFrOyAvLyBTUFNcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIHNwc2ZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnU1BTICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0cmFjay5zcHMpIHtcbiAgICAgICAgICAgIHZhciBleHBHb2xvbWJEZWNvZGVyID0gbmV3IF9leHBfZ29sb21iX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKHVuaXQuZGF0YSk7XG4gICAgICAgICAgICB2YXIgY29uZmlnID0gZXhwR29sb21iRGVjb2Rlci5yZWFkU1BTKCk7XG4gICAgICAgICAgICB0cmFjay53aWR0aCA9IGNvbmZpZy53aWR0aDtcbiAgICAgICAgICAgIHRyYWNrLmhlaWdodCA9IGNvbmZpZy5oZWlnaHQ7XG4gICAgICAgICAgICB0cmFjay5waXhlbFJhdGlvID0gY29uZmlnLnBpeGVsUmF0aW87IC8vIFRPRE86IGB0cmFjay5zcHNgIGlzIGRlZmluZWQgYXMgYSBgbnVtYmVyW11gLCBidXQgd2UncmUgc2V0dGluZyBpdCB0byBhIGBVaW50OEFycmF5W11gLlxuXG4gICAgICAgICAgICB0cmFjay5zcHMgPSBbdW5pdC5kYXRhXTtcbiAgICAgICAgICAgIHRyYWNrLmR1cmF0aW9uID0gX3RoaXMuX2R1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIGNvZGVjYXJyYXkgPSB1bml0LmRhdGEuc3ViYXJyYXkoMSwgNCk7XG4gICAgICAgICAgICB2YXIgY29kZWNzdHJpbmcgPSAnYXZjMS4nO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgaCA9IGNvZGVjYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuXG4gICAgICAgICAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICBoID0gJzAnICsgaDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvZGVjc3RyaW5nICs9IGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyYWNrLmNvZGVjID0gY29kZWNzdHJpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFBQU1xuXG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnUFBTICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0cmFjay5wcHMpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGB0cmFjay5wc3NgIGlzIGRlZmluZWQgYXMgYSBgbnVtYmVyW11gLCBidXQgd2UncmUgc2V0dGluZyBpdCB0byBhIGBVaW50OEFycmF5W11gLlxuICAgICAgICAgICAgdHJhY2sucHBzID0gW3VuaXQuZGF0YV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEFVRFxuXG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgdHJhY2suYXVkRm91bmQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgcHVzaEFjY2Vzc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXZjU2FtcGxlID0gX3RoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCBkZWJ1ZyA/ICdBVUQgJyA6ICcnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRmlsbGVyIERhdGFcblxuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICd1bmtub3duIE5BTCAnICsgdW5pdC50eXBlICsgJyAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXZjU2FtcGxlICYmIHB1c2gpIHtcbiAgICAgICAgdmFyIF91bml0cyA9IGF2Y1NhbXBsZS51bml0cztcblxuICAgICAgICBfdW5pdHMucHVzaCh1bml0KTtcbiAgICAgIH1cbiAgICB9KTsgLy8gaWYgbGFzdCBQRVMgcGFja2V0LCBwdXNoIHNhbXBsZXNcblxuICAgIGlmIChsYXN0ICYmIGF2Y1NhbXBsZSkge1xuICAgICAgcHVzaEFjY2Vzc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXRMYXN0TmFsVW5pdCA9IGZ1bmN0aW9uIGdldExhc3ROYWxVbml0KHNhbXBsZXMpIHtcbiAgICB2YXIgX2F2Y1NhbXBsZTtcblxuICAgIHZhciBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZTtcbiAgICB2YXIgbGFzdFVuaXQ7IC8vIHRyeSB0byBmYWxsYmFjayB0byBwcmV2aW91cyBzYW1wbGUgaWYgY3VycmVudCBvbmUgaXMgZW1wdHlcblxuICAgIGlmICghYXZjU2FtcGxlIHx8IGF2Y1NhbXBsZS51bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGF2Y1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBpZiAoKF9hdmNTYW1wbGUgPSBhdmNTYW1wbGUpICE9PSBudWxsICYmIF9hdmNTYW1wbGUgIT09IHZvaWQgMCAmJiBfYXZjU2FtcGxlLnVuaXRzKSB7XG4gICAgICB2YXIgdW5pdHMgPSBhdmNTYW1wbGUudW5pdHM7XG4gICAgICBsYXN0VW5pdCA9IHVuaXRzW3VuaXRzLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIHJldHVybiBsYXN0VW5pdDtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VBVkNOQUx1ID0gZnVuY3Rpb24gcGFyc2VBVkNOQUx1KHRyYWNrLCBhcnJheSkge1xuICAgIHZhciBsZW4gPSBhcnJheS5ieXRlTGVuZ3RoO1xuICAgIHZhciBzdGF0ZSA9IHRyYWNrLm5hbHVTdGF0ZSB8fCAwO1xuICAgIHZhciBsYXN0U3RhdGUgPSBzdGF0ZTtcbiAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBvdmVyZmxvdztcbiAgICB2YXIgdW5pdFR5cGU7XG4gICAgdmFyIGxhc3RVbml0U3RhcnQgPSAtMTtcbiAgICB2YXIgbGFzdFVuaXRUeXBlID0gMDsgLy8gbG9nZ2VyLmxvZygnUEVTOicgKyBIZXguaGV4RHVtcChhcnJheSkpO1xuXG4gICAgaWYgKHN0YXRlID09PSAtMSkge1xuICAgICAgLy8gc3BlY2lhbCB1c2UgY2FzZSB3aGVyZSB3ZSBmb3VuZCAzIG9yIDQtYnl0ZSBzdGFydCBjb2RlcyBleGFjdGx5IGF0IHRoZSBlbmQgb2YgcHJldmlvdXMgUEVTIHBhY2tldFxuICAgICAgbGFzdFVuaXRTdGFydCA9IDA7IC8vIE5BTHUgdHlwZSBpcyB2YWx1ZSByZWFkIGZyb20gb2Zmc2V0IDBcblxuICAgICAgbGFzdFVuaXRUeXBlID0gYXJyYXlbMF0gJiAweDFmO1xuICAgICAgc3RhdGUgPSAwO1xuICAgICAgaSA9IDE7XG4gICAgfVxuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIHZhbHVlID0gYXJyYXlbaSsrXTsgLy8gb3B0aW1pemF0aW9uLiBzdGF0ZSAwIGFuZCAxIGFyZSB0aGUgcHJlZG9taW5hbnQgY2FzZS4gbGV0J3MgaGFuZGxlIHRoZW0gb3V0c2lkZSBvZiB0aGUgc3dpdGNoL2Nhc2VcblxuICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IDEpIHtcbiAgICAgICAgc3RhdGUgPSB2YWx1ZSA/IDAgOiAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gaGVyZSB3ZSBoYXZlIHN0YXRlIGVpdGhlciBlcXVhbCB0byAyIG9yIDNcblxuXG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHN0YXRlID0gMztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDEpIHtcbiAgICAgICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCkge1xuICAgICAgICAgIHZhciB1bml0ID0ge1xuICAgICAgICAgICAgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgaSAtIHN0YXRlIC0gMSksXG4gICAgICAgICAgICB0eXBlOiBsYXN0VW5pdFR5cGVcbiAgICAgICAgICB9OyAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuXG4gICAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsYXN0VW5pdFN0YXJ0IGlzIHVuZGVmaW5lZCA9PiB0aGlzIGlzIHRoZSBmaXJzdCBzdGFydCBjb2RlIGZvdW5kIGluIHRoaXMgUEVTIHBhY2tldFxuICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIGlmIHN0YXJ0IGNvZGUgZGVsaW1pdGVyIGlzIG92ZXJsYXBwaW5nIGJldHdlZW4gMiBQRVMgcGFja2V0cyxcbiAgICAgICAgICAvLyBpZSBpdCBzdGFydGVkIGluIGxhc3QgcGFja2V0IChsYXN0U3RhdGUgbm90IHplcm8pXG4gICAgICAgICAgLy8gYW5kIGVuZGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBQRVMgcGFja2V0IChpIDw9IDQgLSBsYXN0U3RhdGUpXG4gICAgICAgICAgdmFyIGxhc3RVbml0ID0gdGhpcy5nZXRMYXN0TmFsVW5pdCh0cmFjay5zYW1wbGVzKTtcblxuICAgICAgICAgIGlmIChsYXN0VW5pdCkge1xuICAgICAgICAgICAgaWYgKGxhc3RTdGF0ZSAmJiBpIDw9IDQgLSBsYXN0U3RhdGUpIHtcbiAgICAgICAgICAgICAgLy8gc3RhcnQgZGVsaW1pdGVyIG92ZXJsYXBwaW5nIGJldHdlZW4gUEVTIHBhY2tldHNcbiAgICAgICAgICAgICAgLy8gc3RyaXAgc3RhcnQgZGVsaW1pdGVyIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBsYXN0IE5BTCB1bml0XG4gICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGxhc3RVbml0IGhhZCBhIHN0YXRlIGRpZmZlcmVudCBmcm9tIHplcm9cbiAgICAgICAgICAgICAgaWYgKGxhc3RVbml0LnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgbGFzdCBieXRlc1xuICAgICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEgPSBsYXN0VW5pdC5kYXRhLnN1YmFycmF5KDAsIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCAtIGxhc3RTdGF0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gSWYgTkFMIHVuaXRzIGFyZSBub3Qgc3RhcnRpbmcgcmlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBhY2tldCwgcHVzaCBwcmVjZWRpbmcgZGF0YSBpbnRvIHByZXZpb3VzIE5BTCB1bml0LlxuXG5cbiAgICAgICAgICAgIG92ZXJmbG93ID0gaSAtIHN0YXRlIC0gMTtcblxuICAgICAgICAgICAgaWYgKG92ZXJmbG93ID4gMCkge1xuICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaXJzdCBOQUxVIGZvdW5kIHdpdGggb3ZlcmZsb3c6JyArIG92ZXJmbG93KTtcbiAgICAgICAgICAgICAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIG92ZXJmbG93KTtcbiAgICAgICAgICAgICAgdG1wLnNldChsYXN0VW5pdC5kYXRhLCAwKTtcbiAgICAgICAgICAgICAgdG1wLnNldChhcnJheS5zdWJhcnJheSgwLCBvdmVyZmxvdyksIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEgPSB0bXA7XG4gICAgICAgICAgICAgIGxhc3RVbml0LnN0YXRlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gY2hlY2sgaWYgd2UgY2FuIHJlYWQgdW5pdCB0eXBlXG5cblxuICAgICAgICBpZiAoaSA8IGxlbikge1xuICAgICAgICAgIHVuaXRUeXBlID0gYXJyYXlbaV0gJiAweDFmOyAvLyBsb2dnZXIubG9nKCdmaW5kIE5BTFUgQCBvZmZzZXQ6JyArIGkgKyAnLHR5cGU6JyArIHVuaXRUeXBlKTtcblxuICAgICAgICAgIGxhc3RVbml0U3RhcnQgPSBpO1xuICAgICAgICAgIGxhc3RVbml0VHlwZSA9IHVuaXRUeXBlO1xuICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBub3QgZW5vdWdoIGJ5dGUgdG8gcmVhZCB1bml0IHR5cGUuIGxldCdzIHJlYWQgaXQgb24gbmV4dCBQRVMgcGFyc2luZ1xuICAgICAgICAgIHN0YXRlID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGFzdFVuaXRTdGFydCA+PSAwICYmIHN0YXRlID49IDApIHtcbiAgICAgIHZhciBfdW5pdCA9IHtcbiAgICAgICAgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgbGVuKSxcbiAgICAgICAgdHlwZTogbGFzdFVuaXRUeXBlLFxuICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICAgIH07XG4gICAgICB1bml0cy5wdXNoKF91bml0KTsgLy8gbG9nZ2VyLmxvZygncHVzaGluZyBOQUxVLCB0eXBlL3NpemUvc3RhdGU6JyArIHVuaXQudHlwZSArICcvJyArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgJy8nICsgc3RhdGUpO1xuICAgIH0gLy8gbm8gTkFMdSBmb3VuZFxuXG5cbiAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBhcHBlbmQgcGVzLmRhdGEgdG8gcHJldmlvdXMgTkFMIHVuaXRcbiAgICAgIHZhciBfbGFzdFVuaXQgPSB0aGlzLmdldExhc3ROYWxVbml0KHRyYWNrLnNhbXBsZXMpO1xuXG4gICAgICBpZiAoX2xhc3RVbml0KSB7XG4gICAgICAgIHZhciBfdG1wID0gbmV3IFVpbnQ4QXJyYXkoX2xhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIGFycmF5LmJ5dGVMZW5ndGgpO1xuXG4gICAgICAgIF90bXAuc2V0KF9sYXN0VW5pdC5kYXRhLCAwKTtcblxuICAgICAgICBfdG1wLnNldChhcnJheSwgX2xhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgX2xhc3RVbml0LmRhdGEgPSBfdG1wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyYWNrLm5hbHVTdGF0ZSA9IHN0YXRlO1xuICAgIHJldHVybiB1bml0cztcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VBQUNQRVMgPSBmdW5jdGlvbiBwYXJzZUFBQ1BFUyh0cmFjaywgcGVzKSB7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICB2YXIgYWFjT3ZlckZsb3cgPSB0aGlzLmFhY092ZXJGbG93O1xuICAgIHZhciBkYXRhID0gcGVzLmRhdGE7XG5cbiAgICBpZiAoYWFjT3ZlckZsb3cpIHtcbiAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgICAgdmFyIGZyYW1lTWlzc2luZ0J5dGVzID0gYWFjT3ZlckZsb3cubWlzc2luZztcbiAgICAgIHZhciBzYW1wbGVMZW5ndGggPSBhYWNPdmVyRmxvdy5zYW1wbGUudW5pdC5ieXRlTGVuZ3RoOyAvLyBsb2dnZXIubG9nKGBBQUM6IGFwcGVuZCBvdmVyZmxvd2luZyAke3NhbXBsZUxlbmd0aH0gYnl0ZXMgdG8gYmVnaW5uaW5nIG9mIG5ldyBQRVNgKTtcblxuICAgICAgaWYgKGZyYW1lTWlzc2luZ0J5dGVzID09PSAtMSkge1xuICAgICAgICB2YXIgdG1wID0gbmV3IFVpbnQ4QXJyYXkoc2FtcGxlTGVuZ3RoICsgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdG1wLnNldChhYWNPdmVyRmxvdy5zYW1wbGUudW5pdCwgMCk7XG4gICAgICAgIHRtcC5zZXQoZGF0YSwgc2FtcGxlTGVuZ3RoKTtcbiAgICAgICAgZGF0YSA9IHRtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmcmFtZU92ZXJmbG93Qnl0ZXMgPSBzYW1wbGVMZW5ndGggLSBmcmFtZU1pc3NpbmdCeXRlcztcbiAgICAgICAgYWFjT3ZlckZsb3cuc2FtcGxlLnVuaXQuc2V0KGRhdGEuc3ViYXJyYXkoMCwgZnJhbWVNaXNzaW5nQnl0ZXMpLCBmcmFtZU92ZXJmbG93Qnl0ZXMpO1xuICAgICAgICB0cmFjay5zYW1wbGVzLnB1c2goYWFjT3ZlckZsb3cuc2FtcGxlKTtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBhYWNPdmVyRmxvdy5taXNzaW5nO1xuICAgICAgfVxuICAgIH0gLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcblxuXG4gICAgdmFyIG9mZnNldDtcbiAgICB2YXIgbGVuO1xuXG4gICAgZm9yIChvZmZzZXQgPSBzdGFydE9mZnNldCwgbGVuID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICBpZiAoX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzSGVhZGVyXCJdKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBpZiBBRFRTIGhlYWRlciBkb2VzIG5vdCBzdGFydCBzdHJhaWdodCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYXlsb2FkLCByYWlzZSBhbiBlcnJvclxuXG5cbiAgICBpZiAob2Zmc2V0ICE9PSBzdGFydE9mZnNldCkge1xuICAgICAgdmFyIHJlYXNvbjtcbiAgICAgIHZhciBmYXRhbDtcblxuICAgICAgaWYgKG9mZnNldCA8IGxlbiAtIDEpIHtcbiAgICAgICAgcmVhc29uID0gXCJBQUMgUEVTIGRpZCBub3Qgc3RhcnQgd2l0aCBBRFRTIGhlYWRlcixvZmZzZXQ6XCIgKyBvZmZzZXQ7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWFzb24gPSAnbm8gQURUUyBoZWFkZXIgZm91bmQgaW4gQUFDIFBFUyc7XG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wibG9nZ2VyXCJdLndhcm4oXCJwYXJzaW5nIGVycm9yOlwiICsgcmVhc29uKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJFdmVudHNcIl0uRVJST1IsIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJFcnJvclR5cGVzXCJdLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmF0YWwsXG4gICAgICAgIHJlYXNvbjogcmVhc29uXG4gICAgICB9KTtcblxuICAgICAgaWYgKGZhdGFsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfYWR0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaW5pdFRyYWNrQ29uZmlnXCJdKHRyYWNrLCB0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRoaXMuYXVkaW9Db2RlYyk7XG4gICAgdmFyIHB0cztcblxuICAgIGlmIChwZXMucHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHB0cyA9IHBlcy5wdHM7XG4gICAgfSBlbHNlIGlmIChhYWNPdmVyRmxvdykge1xuICAgICAgLy8gaWYgbGFzdCBBQUMgZnJhbWUgaXMgb3ZlcmZsb3dpbmcsIHdlIHNob3VsZCBlbnN1cmUgdGltZXN0YW1wcyBhcmUgY29udGlndW91czpcbiAgICAgIC8vIGZpcnN0IHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGZyYW1lRHVyYXRpb25cbiAgICAgIHZhciBmcmFtZUR1cmF0aW9uID0gX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldEZyYW1lRHVyYXRpb25cIl0odHJhY2suc2FtcGxlcmF0ZSk7XG4gICAgICBwdHMgPSBhYWNPdmVyRmxvdy5zYW1wbGUucHRzICsgZnJhbWVEdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wibG9nZ2VyXCJdLndhcm4oJ1t0c2RlbXV4ZXJdOiBBQUMgUEVTIHVua25vd24gUFRTJyk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBzY2FuIGZvciBhYWMgc2FtcGxlc1xuXG5cbiAgICB2YXIgZnJhbWVJbmRleCA9IDA7XG4gICAgdmFyIGZyYW1lO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbikge1xuICAgICAgZnJhbWUgPSBfYWR0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiYXBwZW5kRnJhbWVcIl0odHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG5cbiAgICAgIGlmICghZnJhbWUubWlzc2luZykge1xuICAgICAgICBmcmFtZUluZGV4Kys7XG5cbiAgICAgICAgZm9yICg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICAgICAgaWYgKF9hZHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0hlYWRlclwiXShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBmcmFtZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wYXJzZU1QRUdQRVMgPSBmdW5jdGlvbiBwYXJzZU1QRUdQRVModHJhY2ssIHBlcykge1xuICAgIHZhciBkYXRhID0gcGVzLmRhdGE7XG4gICAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIHZhciBmcmFtZUluZGV4ID0gMDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgcHRzID0gcGVzLnB0cztcblxuICAgIGlmIChwdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wibG9nZ2VyXCJdLndhcm4oJ1t0c2RlbXV4ZXJdOiBNUEVHIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgIGlmIChfbXBlZ2F1ZGlvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJpc0hlYWRlclwiXShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIHZhciBmcmFtZSA9IF9tcGVnYXVkaW9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImFwcGVuZEZyYW1lXCJdKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCk7XG5cbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnVW5hYmxlIHRvIHBhcnNlIE1wZWcgYXVkaW8gZnJhbWUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBmb3VuZCwga2VlcCBsb29raW5nXG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucGFyc2VJRDNQRVMgPSBmdW5jdGlvbiBwYXJzZUlEM1BFUyhpZDNUcmFjaywgcGVzKSB7XG4gICAgaWYgKHBlcy5wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wibG9nZ2VyXCJdLndhcm4oJ1t0c2RlbXV4ZXJdOiBJRDMgUEVTIHVua25vd24gUFRTJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlkM1NhbXBsZSA9IF9leHRlbmRzKHt9LCBwZXMsIHtcbiAgICAgIHR5cGU6IHRoaXMuX2F2Y1RyYWNrID8gX3R5cGVzX2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcIk1ldGFkYXRhU2NoZW1hXCJdLmVtc2cgOiBfdHlwZXNfZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wiTWV0YWRhdGFTY2hlbWFcIl0uYXVkaW9JZDNcbiAgICB9KTtcblxuICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaChpZDNTYW1wbGUpO1xuICB9O1xuXG4gIHJldHVybiBUU0RlbXV4ZXI7XG59KCk7XG5cblRTRGVtdXhlci5taW5Qcm9iZUJ5dGVMZW5ndGggPSAxODg7XG5cbmZ1bmN0aW9uIGNyZWF0ZUFWQ1NhbXBsZShrZXksIHB0cywgZHRzLCBkZWJ1Zykge1xuICByZXR1cm4ge1xuICAgIGtleToga2V5LFxuICAgIGZyYW1lOiBmYWxzZSxcbiAgICBwdHM6IHB0cyxcbiAgICBkdHM6IGR0cyxcbiAgICB1bml0czogW10sXG4gICAgZGVidWc6IGRlYnVnLFxuICAgIGxlbmd0aDogMFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVBBVChkYXRhLCBvZmZzZXQpIHtcbiAgLy8gc2tpcCB0aGUgUFNJIGhlYWRlciBhbmQgcGFyc2UgdGhlIGZpcnN0IFBNVCBlbnRyeVxuICByZXR1cm4gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgxZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdOyAvLyBsb2dnZXIubG9nKCdQTVQgUElEOicgICsgdGhpcy5fcG10SWQpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBNVChkYXRhLCBvZmZzZXQsIHR5cGVTdXBwb3J0ZWQsIGlzU2FtcGxlQWVzKSB7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgYXVkaW86IC0xLFxuICAgIGF2YzogLTEsXG4gICAgaWQzOiAtMSxcbiAgICBzZWdtZW50Q29kZWM6ICdhYWMnXG4gIH07XG4gIHZhciBzZWN0aW9uTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAyXTtcbiAgdmFyIHRhYmxlRW5kID0gb2Zmc2V0ICsgMyArIHNlY3Rpb25MZW5ndGggLSA0OyAvLyB0byBkZXRlcm1pbmUgd2hlcmUgdGhlIHRhYmxlIGlzLCB3ZSBoYXZlIHRvIGZpZ3VyZSBvdXQgaG93XG4gIC8vIGxvbmcgdGhlIHByb2dyYW0gaW5mbyBkZXNjcmlwdG9ycyBhcmVcblxuICB2YXIgcHJvZ3JhbUluZm9MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07IC8vIGFkdmFuY2UgdGhlIG9mZnNldCB0byB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIG1hcHBpbmcgdGFibGVcblxuICBvZmZzZXQgKz0gMTIgKyBwcm9ncmFtSW5mb0xlbmd0aDtcblxuICB3aGlsZSAob2Zmc2V0IDwgdGFibGVFbmQpIHtcbiAgICB2YXIgcGlkID0gKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDFmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAyXTtcblxuICAgIHN3aXRjaCAoZGF0YVtvZmZzZXRdKSB7XG4gICAgICBjYXNlIDB4Y2Y6XG4gICAgICAgIC8vIFNBTVBMRS1BRVMgQUFDXG4gICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJsb2dnZXJcIl0ubG9nKCdBRFRTIEFBQyB3aXRoIEFFUy0xMjgtQ0JDIGZyYW1lIGVuY3J5cHRpb24gZm91bmQgaW4gdW5lbmNyeXB0ZWQgc3RyZWFtJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuXG4gICAgICBjYXNlIDB4MGY6XG4gICAgICAgIC8vIElTTy9JRUMgMTM4MTgtNyBBRFRTIEFBQyAoTVBFRy0yIGxvd2VyIGJpdC1yYXRlIGF1ZGlvKVxuICAgICAgICAvLyBsb2dnZXIubG9nKCdBQUMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuYXVkaW8gPSBwaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIC8vIFBhY2tldGl6ZWQgbWV0YWRhdGEgKElEMylcblxuICAgICAgY2FzZSAweDE1OlxuICAgICAgICAvLyBsb2dnZXIubG9nKCdJRDMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pZDMgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmlkMyA9IHBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4ZGI6XG4gICAgICAgIC8vIFNBTVBMRS1BRVMgQVZDXG4gICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJsb2dnZXJcIl0ubG9nKCdILjI2NCB3aXRoIEFFUy0xMjgtQ0JDIHNsaWNlIGVuY3J5cHRpb24gZm91bmQgaW4gdW5lbmNyeXB0ZWQgc3RyZWFtJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuXG4gICAgICBjYXNlIDB4MWI6XG4gICAgICAgIC8vIElUVS1UIFJlYy4gSC4yNjQgYW5kIElTTy9JRUMgMTQ0OTYtMTAgKGxvd2VyIGJpdC1yYXRlIHZpZGVvKVxuICAgICAgICAvLyBsb2dnZXIubG9nKCdBVkMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5hdmMgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmF2YyA9IHBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gSVNPL0lFQyAxMTE3Mi0zIChNUEVHLTEgYXVkaW8pXG4gICAgICAvLyBvciBJU08vSUVDIDEzODE4LTMgKE1QRUctMiBoYWx2ZWQgc2FtcGxlIHJhdGUgYXVkaW8pXG5cbiAgICAgIGNhc2UgMHgwMzpcbiAgICAgIGNhc2UgMHgwNDpcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnTVBFRyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAodHlwZVN1cHBvcnRlZC5tcGVnICE9PSB0cnVlICYmIHR5cGVTdXBwb3J0ZWQubXAzICE9PSB0cnVlKSB7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wibG9nZ2VyXCJdLmxvZygnTVBFRyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuYXVkaW8gPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmF1ZGlvID0gcGlkO1xuICAgICAgICAgIHJlc3VsdC5zZWdtZW50Q29kZWMgPSAnbXAzJztcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4MjQ6XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImxvZ2dlclwiXS53YXJuKCdVbnN1cHBvcnRlZCBIRVZDIHN0cmVhbSB0eXBlIGZvdW5kJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBsb2dnZXIubG9nKCd1bmtub3duIHN0cmVhbSB0eXBlOicgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICBicmVhaztcbiAgICB9IC8vIG1vdmUgdG8gdGhlIG5leHQgdGFibGUgZW50cnlcbiAgICAvLyBza2lwIHBhc3QgdGhlIGVsZW1lbnRhcnkgc3RyZWFtIGRlc2NyaXB0b3JzLCBpZiBwcmVzZW50XG5cblxuICAgIG9mZnNldCArPSAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyA0XSkgKyA1O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VQRVMoc3RyZWFtKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIGZyYWc7XG4gIHZhciBwZXNMZW47XG4gIHZhciBwZXNIZHJMZW47XG4gIHZhciBwZXNQdHM7XG4gIHZhciBwZXNEdHM7XG4gIHZhciBkYXRhID0gc3RyZWFtLmRhdGE7IC8vIHNhZmV0eSBjaGVja1xuXG4gIGlmICghc3RyZWFtIHx8IHN0cmVhbS5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gd2UgbWlnaHQgbmVlZCB1cCB0byAxOSBieXRlcyB0byByZWFkIFBFUyBoZWFkZXJcbiAgLy8gaWYgZmlyc3QgY2h1bmsgb2YgZGF0YSBpcyBsZXNzIHRoYW4gMTkgYnl0ZXMsIGxldCdzIG1lcmdlIGl0IHdpdGggZm9sbG93aW5nIG9uZXMgdW50aWwgd2UgZ2V0IDE5IGJ5dGVzXG4gIC8vIHVzdWFsbHkgb25seSBvbmUgbWVyZ2UgaXMgbmVlZGVkIChhbmQgdGhpcyBpcyByYXJlIC4uLilcblxuXG4gIHdoaWxlIChkYXRhWzBdLmxlbmd0aCA8IDE5ICYmIGRhdGEubGVuZ3RoID4gMSkge1xuICAgIHZhciBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YVswXS5sZW5ndGggKyBkYXRhWzFdLmxlbmd0aCk7XG4gICAgbmV3RGF0YS5zZXQoZGF0YVswXSk7XG4gICAgbmV3RGF0YS5zZXQoZGF0YVsxXSwgZGF0YVswXS5sZW5ndGgpO1xuICAgIGRhdGFbMF0gPSBuZXdEYXRhO1xuICAgIGRhdGEuc3BsaWNlKDEsIDEpO1xuICB9IC8vIHJldHJpZXZlIFBUUy9EVFMgZnJvbSBmaXJzdCBmcmFnbWVudFxuXG5cbiAgZnJhZyA9IGRhdGFbMF07XG4gIHZhciBwZXNQcmVmaXggPSAoZnJhZ1swXSA8PCAxNikgKyAoZnJhZ1sxXSA8PCA4KSArIGZyYWdbMl07XG5cbiAgaWYgKHBlc1ByZWZpeCA9PT0gMSkge1xuICAgIHBlc0xlbiA9IChmcmFnWzRdIDw8IDgpICsgZnJhZ1s1XTsgLy8gaWYgUEVTIHBhcnNlZCBsZW5ndGggaXMgbm90IHplcm8gYW5kIGdyZWF0ZXIgdGhhbiB0b3RhbCByZWNlaXZlZCBsZW5ndGgsIHN0b3AgcGFyc2luZy4gUEVTIG1pZ2h0IGJlIHRydW5jYXRlZFxuICAgIC8vIG1pbnVzIDYgOiBQRVMgaGVhZGVyIHNpemVcblxuICAgIGlmIChwZXNMZW4gJiYgcGVzTGVuID4gc3RyZWFtLnNpemUgLSA2KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcGVzRmxhZ3MgPSBmcmFnWzddO1xuXG4gICAgaWYgKHBlc0ZsYWdzICYgMHhjMCkge1xuICAgICAgLyogUEVTIGhlYWRlciBkZXNjcmliZWQgaGVyZSA6IGh0dHA6Ly9kdmQuc291cmNlZm9yZ2UubmV0L2R2ZGluZm8vcGVzLWhkci5odG1sXG4gICAgICAgICAgYXMgUFRTIC8gRFRTIGlzIDMzIGJpdCB3ZSBjYW5ub3QgdXNlIGJpdHdpc2Ugb3BlcmF0b3IgaW4gSlMsXG4gICAgICAgICAgYXMgQml0d2lzZSBvcGVyYXRvcnMgdHJlYXQgdGhlaXIgb3BlcmFuZHMgYXMgYSBzZXF1ZW5jZSBvZiAzMiBiaXRzICovXG4gICAgICBwZXNQdHMgPSAoZnJhZ1s5XSAmIDB4MGUpICogNTM2ODcwOTEyICsgLy8gMSA8PCAyOVxuICAgICAgKGZyYWdbMTBdICYgMHhmZikgKiA0MTk0MzA0ICsgLy8gMSA8PCAyMlxuICAgICAgKGZyYWdbMTFdICYgMHhmZSkgKiAxNjM4NCArIC8vIDEgPDwgMTRcbiAgICAgIChmcmFnWzEyXSAmIDB4ZmYpICogMTI4ICsgLy8gMSA8PCA3XG4gICAgICAoZnJhZ1sxM10gJiAweGZlKSAvIDI7XG5cbiAgICAgIGlmIChwZXNGbGFncyAmIDB4NDApIHtcbiAgICAgICAgcGVzRHRzID0gKGZyYWdbMTRdICYgMHgwZSkgKiA1MzY4NzA5MTIgKyAvLyAxIDw8IDI5XG4gICAgICAgIChmcmFnWzE1XSAmIDB4ZmYpICogNDE5NDMwNCArIC8vIDEgPDwgMjJcbiAgICAgICAgKGZyYWdbMTZdICYgMHhmZSkgKiAxNjM4NCArIC8vIDEgPDwgMTRcbiAgICAgICAgKGZyYWdbMTddICYgMHhmZikgKiAxMjggKyAvLyAxIDw8IDdcbiAgICAgICAgKGZyYWdbMThdICYgMHhmZSkgLyAyO1xuXG4gICAgICAgIGlmIChwZXNQdHMgLSBwZXNEdHMgPiA2MCAqIDkwMDAwKSB7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wibG9nZ2VyXCJdLndhcm4oTWF0aC5yb3VuZCgocGVzUHRzIC0gcGVzRHRzKSAvIDkwMDAwKSArIFwicyBkZWx0YSBiZXR3ZWVuIFBUUyBhbmQgRFRTLCBhbGlnbiB0aGVtXCIpO1xuICAgICAgICAgIHBlc1B0cyA9IHBlc0R0cztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVzRHRzID0gcGVzUHRzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBlc0hkckxlbiA9IGZyYWdbOF07IC8vIDkgYnl0ZXMgOiA2IGJ5dGVzIGZvciBQRVMgaGVhZGVyICsgMyBieXRlcyBmb3IgUEVTIGV4dGVuc2lvblxuXG4gICAgdmFyIHBheWxvYWRTdGFydE9mZnNldCA9IHBlc0hkckxlbiArIDk7XG5cbiAgICBpZiAoc3RyZWFtLnNpemUgPD0gcGF5bG9hZFN0YXJ0T2Zmc2V0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzdHJlYW0uc2l6ZSAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7IC8vIHJlYXNzZW1ibGUgUEVTIHBhY2tldFxuXG4gICAgdmFyIHBlc0RhdGEgPSBuZXcgVWludDhBcnJheShzdHJlYW0uc2l6ZSk7XG5cbiAgICBmb3IgKHZhciBqID0gMCwgZGF0YUxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgZGF0YUxlbjsgaisrKSB7XG4gICAgICBmcmFnID0gZGF0YVtqXTtcbiAgICAgIHZhciBsZW4gPSBmcmFnLmJ5dGVMZW5ndGg7XG5cbiAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgICAgaWYgKHBheWxvYWRTdGFydE9mZnNldCA+IGxlbikge1xuICAgICAgICAgIC8vIHRyaW0gZnVsbCBmcmFnIGlmIFBFUyBoZWFkZXIgYmlnZ2VyIHRoYW4gZnJhZ1xuICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCAtPSBsZW47XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdHJpbSBwYXJ0aWFsIGZyYWcgaWYgUEVTIGhlYWRlciBzbWFsbGVyIHRoYW4gZnJhZ1xuICAgICAgICAgIGZyYWcgPSBmcmFnLnN1YmFycmF5KHBheWxvYWRTdGFydE9mZnNldCk7XG4gICAgICAgICAgbGVuIC09IHBheWxvYWRTdGFydE9mZnNldDtcbiAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBlc0RhdGEuc2V0KGZyYWcsIGkpO1xuICAgICAgaSArPSBsZW47XG4gICAgfVxuXG4gICAgaWYgKHBlc0xlbikge1xuICAgICAgLy8gcGF5bG9hZCBzaXplIDogcmVtb3ZlIFBFUyBoZWFkZXIgKyBQRVMgZXh0ZW5zaW9uXG4gICAgICBwZXNMZW4gLT0gcGVzSGRyTGVuICsgMztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogcGVzRGF0YSxcbiAgICAgIHB0czogcGVzUHRzLFxuICAgICAgZHRzOiBwZXNEdHMsXG4gICAgICBsZW46IHBlc0xlblxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaEFjY2Vzc1VuaXQoYXZjU2FtcGxlLCBhdmNUcmFjaykge1xuICBpZiAoYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCAmJiBhdmNTYW1wbGUuZnJhbWUpIHtcbiAgICAvLyBpZiBzYW1wbGUgZG9lcyBub3QgaGF2ZSBQVFMvRFRTLCBwYXRjaCB3aXRoIGxhc3Qgc2FtcGxlIFBUUy9EVFNcbiAgICBpZiAoYXZjU2FtcGxlLnB0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgc2FtcGxlcyA9IGF2Y1RyYWNrLnNhbXBsZXM7XG4gICAgICB2YXIgbmJTYW1wbGVzID0gc2FtcGxlcy5sZW5ndGg7XG5cbiAgICAgIGlmIChuYlNhbXBsZXMpIHtcbiAgICAgICAgdmFyIGxhc3RTYW1wbGUgPSBzYW1wbGVzW25iU2FtcGxlcyAtIDFdO1xuICAgICAgICBhdmNTYW1wbGUucHRzID0gbGFzdFNhbXBsZS5wdHM7XG4gICAgICAgIGF2Y1NhbXBsZS5kdHMgPSBsYXN0U2FtcGxlLmR0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRyb3BwaW5nIHNhbXBsZXMsIG5vIHRpbWVzdGFtcCBmb3VuZFxuICAgICAgICBhdmNUcmFjay5kcm9wcGVkKys7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhdmNUcmFjay5zYW1wbGVzLnB1c2goYXZjU2FtcGxlKTtcbiAgfVxuXG4gIGlmIChhdmNTYW1wbGUuZGVidWcubGVuZ3RoKSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wibG9nZ2VyXCJdLmxvZyhhdmNTYW1wbGUucHRzICsgJy8nICsgYXZjU2FtcGxlLmR0cyArICc6JyArIGF2Y1NhbXBsZS5kZWJ1Zyk7XG4gIH1cbn1cbi8qKlxuICogcmVtb3ZlIEVtdWxhdGlvbiBQcmV2ZW50aW9uIGJ5dGVzIGZyb20gYSBSQlNQXG4gKi9cblxuXG5mdW5jdGlvbiBkaXNjYXJkRVBCKGRhdGEpIHtcbiAgdmFyIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgdmFyIEVQQlBvc2l0aW9ucyA9IFtdO1xuICB2YXIgaSA9IDE7IC8vIEZpbmQgYWxsIGBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlc2BcblxuICB3aGlsZSAoaSA8IGxlbmd0aCAtIDIpIHtcbiAgICBpZiAoZGF0YVtpXSA9PT0gMCAmJiBkYXRhW2kgKyAxXSA9PT0gMCAmJiBkYXRhW2kgKyAyXSA9PT0gMHgwMykge1xuICAgICAgRVBCUG9zaXRpb25zLnB1c2goaSArIDIpO1xuICAgICAgaSArPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgfVxuICB9IC8vIElmIG5vIEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzIHdlcmUgZm91bmQganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gIC8vIGFycmF5XG5cblxuICBpZiAoRVBCUG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9IC8vIENyZWF0ZSBhIG5ldyBhcnJheSB0byBob2xkIHRoZSBOQUwgdW5pdCBkYXRhXG5cblxuICB2YXIgbmV3TGVuZ3RoID0gbGVuZ3RoIC0gRVBCUG9zaXRpb25zLmxlbmd0aDtcbiAgdmFyIG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xuICB2YXIgc291cmNlSW5kZXggPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuZXdMZW5ndGg7IHNvdXJjZUluZGV4KyssIGkrKykge1xuICAgIGlmIChzb3VyY2VJbmRleCA9PT0gRVBCUG9zaXRpb25zWzBdKSB7XG4gICAgICAvLyBTa2lwIHRoaXMgYnl0ZVxuICAgICAgc291cmNlSW5kZXgrKzsgLy8gUmVtb3ZlIHRoaXMgcG9zaXRpb24gaW5kZXhcblxuICAgICAgRVBCUG9zaXRpb25zLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgbmV3RGF0YVtpXSA9IGRhdGFbc291cmNlSW5kZXhdO1xuICB9XG5cbiAgcmV0dXJuIG5ld0RhdGE7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFRTRGVtdXhlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2Vycm9ycy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZXJyb3JzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiRXJyb3JUeXBlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEVycm9yVHlwZXM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkVycm9yRGV0YWlsc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEVycm9yRGV0YWlsczsgfSk7XG52YXIgRXJyb3JUeXBlcztcbi8qKlxuICogQGVudW0ge0Vycm9yRGV0YWlsc31cbiAqIEB0eXBlZGVmIHtzdHJpbmd9IEVycm9yRGV0YWlsXG4gKi9cblxuKGZ1bmN0aW9uIChFcnJvclR5cGVzKSB7XG4gIEVycm9yVHlwZXNbXCJORVRXT1JLX0VSUk9SXCJdID0gXCJuZXR3b3JrRXJyb3JcIjtcbiAgRXJyb3JUeXBlc1tcIk1FRElBX0VSUk9SXCJdID0gXCJtZWRpYUVycm9yXCI7XG4gIEVycm9yVHlwZXNbXCJLRVlfU1lTVEVNX0VSUk9SXCJdID0gXCJrZXlTeXN0ZW1FcnJvclwiO1xuICBFcnJvclR5cGVzW1wiTVVYX0VSUk9SXCJdID0gXCJtdXhFcnJvclwiO1xuICBFcnJvclR5cGVzW1wiT1RIRVJfRVJST1JcIl0gPSBcIm90aGVyRXJyb3JcIjtcbn0pKEVycm9yVHlwZXMgfHwgKEVycm9yVHlwZXMgPSB7fSkpO1xuXG52YXIgRXJyb3JEZXRhaWxzO1xuXG4oZnVuY3Rpb24gKEVycm9yRGV0YWlscykge1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX05PX0tFWVNcIl0gPSBcImtleVN5c3RlbU5vS2V5c1wiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX05PX0FDQ0VTU1wiXSA9IFwia2V5U3lzdGVtTm9BY2Nlc3NcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19TRVNTSU9OXCJdID0gXCJrZXlTeXN0ZW1Ob1Nlc3Npb25cIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9MSUNFTlNFX1JFUVVFU1RfRkFJTEVEXCJdID0gXCJrZXlTeXN0ZW1MaWNlbnNlUmVxdWVzdEZhaWxlZFwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX05PX0lOSVRfREFUQVwiXSA9IFwia2V5U3lzdGVtTm9Jbml0RGF0YVwiO1xuICBFcnJvckRldGFpbHNbXCJNQU5JRkVTVF9MT0FEX0VSUk9SXCJdID0gXCJtYW5pZmVzdExvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJNQU5JRkVTVF9MT0FEX1RJTUVPVVRcIl0gPSBcIm1hbmlmZXN0TG9hZFRpbWVPdXRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfUEFSU0lOR19FUlJPUlwiXSA9IFwibWFuaWZlc3RQYXJzaW5nRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUlwiXSA9IFwibWFuaWZlc3RJbmNvbXBhdGlibGVDb2RlY3NFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9FTVBUWV9FUlJPUlwiXSA9IFwibGV2ZWxFbXB0eUVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkxFVkVMX0xPQURfRVJST1JcIl0gPSBcImxldmVsTG9hZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkxFVkVMX0xPQURfVElNRU9VVFwiXSA9IFwibGV2ZWxMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9TV0lUQ0hfRVJST1JcIl0gPSBcImxldmVsU3dpdGNoRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQVVESU9fVFJBQ0tfTE9BRF9FUlJPUlwiXSA9IFwiYXVkaW9UcmFja0xvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJBVURJT19UUkFDS19MT0FEX1RJTUVPVVRcIl0gPSBcImF1ZGlvVHJhY2tMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJTVUJUSVRMRV9MT0FEX0VSUk9SXCJdID0gXCJzdWJ0aXRsZVRyYWNrTG9hZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIlNVQlRJVExFX1RSQUNLX0xPQURfVElNRU9VVFwiXSA9IFwic3VidGl0bGVUcmFja0xvYWRUaW1lT3V0XCI7XG4gIEVycm9yRGV0YWlsc1tcIkZSQUdfTE9BRF9FUlJPUlwiXSA9IFwiZnJhZ0xvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJGUkFHX0xPQURfVElNRU9VVFwiXSA9IFwiZnJhZ0xvYWRUaW1lT3V0XCI7XG4gIEVycm9yRGV0YWlsc1tcIkZSQUdfREVDUllQVF9FUlJPUlwiXSA9IFwiZnJhZ0RlY3J5cHRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJGUkFHX1BBUlNJTkdfRVJST1JcIl0gPSBcImZyYWdQYXJzaW5nRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiUkVNVVhfQUxMT0NfRVJST1JcIl0gPSBcInJlbXV4QWxsb2NFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfTE9BRF9FUlJPUlwiXSA9IFwia2V5TG9hZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9MT0FEX1RJTUVPVVRcIl0gPSBcImtleUxvYWRUaW1lT3V0XCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BRERfQ09ERUNfRVJST1JcIl0gPSBcImJ1ZmZlckFkZENvZGVjRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1JcIl0gPSBcImJ1ZmZlckluY29tcGF0aWJsZUNvZGVjc0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BUFBFTkRfRVJST1JcIl0gPSBcImJ1ZmZlckFwcGVuZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BUFBFTkRJTkdfRVJST1JcIl0gPSBcImJ1ZmZlckFwcGVuZGluZ0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9TVEFMTEVEX0VSUk9SXCJdID0gXCJidWZmZXJTdGFsbGVkRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX0ZVTExfRVJST1JcIl0gPSBcImJ1ZmZlckZ1bGxFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfU0VFS19PVkVSX0hPTEVcIl0gPSBcImJ1ZmZlclNlZWtPdmVySG9sZVwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfTlVER0VfT05fU1RBTExcIl0gPSBcImJ1ZmZlck51ZGdlT25TdGFsbFwiO1xuICBFcnJvckRldGFpbHNbXCJJTlRFUk5BTF9FWENFUFRJT05cIl0gPSBcImludGVybmFsRXhjZXB0aW9uXCI7XG4gIEVycm9yRGV0YWlsc1tcIklOVEVSTkFMX0FCT1JURURcIl0gPSBcImFib3J0ZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xufSkoRXJyb3JEZXRhaWxzIHx8IChFcnJvckRldGFpbHMgPSB7fSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9ldmVudHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2V2ZW50cy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogRXZlbnRzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkV2ZW50c1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEV2ZW50czsgfSk7XG4vKipcbiAqIEByZWFkb25seVxuICogQGVudW0ge3N0cmluZ31cbiAqL1xudmFyIEV2ZW50cztcblxuKGZ1bmN0aW9uIChFdmVudHMpIHtcbiAgRXZlbnRzW1wiTUVESUFfQVRUQUNISU5HXCJdID0gXCJobHNNZWRpYUF0dGFjaGluZ1wiO1xuICBFdmVudHNbXCJNRURJQV9BVFRBQ0hFRFwiXSA9IFwiaGxzTWVkaWFBdHRhY2hlZFwiO1xuICBFdmVudHNbXCJNRURJQV9ERVRBQ0hJTkdcIl0gPSBcImhsc01lZGlhRGV0YWNoaW5nXCI7XG4gIEV2ZW50c1tcIk1FRElBX0RFVEFDSEVEXCJdID0gXCJobHNNZWRpYURldGFjaGVkXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9SRVNFVFwiXSA9IFwiaGxzQnVmZmVyUmVzZXRcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX0NPREVDU1wiXSA9IFwiaGxzQnVmZmVyQ29kZWNzXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9DUkVBVEVEXCJdID0gXCJobHNCdWZmZXJDcmVhdGVkXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9BUFBFTkRJTkdcIl0gPSBcImhsc0J1ZmZlckFwcGVuZGluZ1wiO1xuICBFdmVudHNbXCJCVUZGRVJfQVBQRU5ERURcIl0gPSBcImhsc0J1ZmZlckFwcGVuZGVkXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9FT1NcIl0gPSBcImhsc0J1ZmZlckVvc1wiO1xuICBFdmVudHNbXCJCVUZGRVJfRkxVU0hJTkdcIl0gPSBcImhsc0J1ZmZlckZsdXNoaW5nXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9GTFVTSEVEXCJdID0gXCJobHNCdWZmZXJGbHVzaGVkXCI7XG4gIEV2ZW50c1tcIk1BTklGRVNUX0xPQURJTkdcIl0gPSBcImhsc01hbmlmZXN0TG9hZGluZ1wiO1xuICBFdmVudHNbXCJNQU5JRkVTVF9MT0FERURcIl0gPSBcImhsc01hbmlmZXN0TG9hZGVkXCI7XG4gIEV2ZW50c1tcIk1BTklGRVNUX1BBUlNFRFwiXSA9IFwiaGxzTWFuaWZlc3RQYXJzZWRcIjtcbiAgRXZlbnRzW1wiTEVWRUxfU1dJVENISU5HXCJdID0gXCJobHNMZXZlbFN3aXRjaGluZ1wiO1xuICBFdmVudHNbXCJMRVZFTF9TV0lUQ0hFRFwiXSA9IFwiaGxzTGV2ZWxTd2l0Y2hlZFwiO1xuICBFdmVudHNbXCJMRVZFTF9MT0FESU5HXCJdID0gXCJobHNMZXZlbExvYWRpbmdcIjtcbiAgRXZlbnRzW1wiTEVWRUxfTE9BREVEXCJdID0gXCJobHNMZXZlbExvYWRlZFwiO1xuICBFdmVudHNbXCJMRVZFTF9VUERBVEVEXCJdID0gXCJobHNMZXZlbFVwZGF0ZWRcIjtcbiAgRXZlbnRzW1wiTEVWRUxfUFRTX1VQREFURURcIl0gPSBcImhsc0xldmVsUHRzVXBkYXRlZFwiO1xuICBFdmVudHNbXCJMRVZFTFNfVVBEQVRFRFwiXSA9IFwiaGxzTGV2ZWxzVXBkYXRlZFwiO1xuICBFdmVudHNbXCJBVURJT19UUkFDS1NfVVBEQVRFRFwiXSA9IFwiaGxzQXVkaW9UcmFja3NVcGRhdGVkXCI7XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLX1NXSVRDSElOR1wiXSA9IFwiaGxzQXVkaW9UcmFja1N3aXRjaGluZ1wiO1xuICBFdmVudHNbXCJBVURJT19UUkFDS19TV0lUQ0hFRFwiXSA9IFwiaGxzQXVkaW9UcmFja1N3aXRjaGVkXCI7XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLX0xPQURJTkdcIl0gPSBcImhsc0F1ZGlvVHJhY2tMb2FkaW5nXCI7XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLX0xPQURFRFwiXSA9IFwiaGxzQXVkaW9UcmFja0xvYWRlZFwiO1xuICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS1NfVVBEQVRFRFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja3NVcGRhdGVkXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLU19DTEVBUkVEXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrc0NsZWFyZWRcIjtcbiAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tfU1dJVENIXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrU3dpdGNoXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLX0xPQURJTkdcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tMb2FkaW5nXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLX0xPQURFRFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja0xvYWRlZFwiO1xuICBFdmVudHNbXCJTVUJUSVRMRV9GUkFHX1BST0NFU1NFRFwiXSA9IFwiaGxzU3VidGl0bGVGcmFnUHJvY2Vzc2VkXCI7XG4gIEV2ZW50c1tcIkNVRVNfUEFSU0VEXCJdID0gXCJobHNDdWVzUGFyc2VkXCI7XG4gIEV2ZW50c1tcIk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkRcIl0gPSBcImhsc05vbk5hdGl2ZVRleHRUcmFja3NGb3VuZFwiO1xuICBFdmVudHNbXCJJTklUX1BUU19GT1VORFwiXSA9IFwiaGxzSW5pdFB0c0ZvdW5kXCI7XG4gIEV2ZW50c1tcIkZSQUdfTE9BRElOR1wiXSA9IFwiaGxzRnJhZ0xvYWRpbmdcIjtcbiAgRXZlbnRzW1wiRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVEXCJdID0gXCJobHNGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWRcIjtcbiAgRXZlbnRzW1wiRlJBR19MT0FERURcIl0gPSBcImhsc0ZyYWdMb2FkZWRcIjtcbiAgRXZlbnRzW1wiRlJBR19ERUNSWVBURURcIl0gPSBcImhsc0ZyYWdEZWNyeXB0ZWRcIjtcbiAgRXZlbnRzW1wiRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVFwiXSA9IFwiaGxzRnJhZ1BhcnNpbmdJbml0U2VnbWVudFwiO1xuICBFdmVudHNbXCJGUkFHX1BBUlNJTkdfVVNFUkRBVEFcIl0gPSBcImhsc0ZyYWdQYXJzaW5nVXNlcmRhdGFcIjtcbiAgRXZlbnRzW1wiRlJBR19QQVJTSU5HX01FVEFEQVRBXCJdID0gXCJobHNGcmFnUGFyc2luZ01ldGFkYXRhXCI7XG4gIEV2ZW50c1tcIkZSQUdfUEFSU0VEXCJdID0gXCJobHNGcmFnUGFyc2VkXCI7XG4gIEV2ZW50c1tcIkZSQUdfQlVGRkVSRURcIl0gPSBcImhsc0ZyYWdCdWZmZXJlZFwiO1xuICBFdmVudHNbXCJGUkFHX0NIQU5HRURcIl0gPSBcImhsc0ZyYWdDaGFuZ2VkXCI7XG4gIEV2ZW50c1tcIkZQU19EUk9QXCJdID0gXCJobHNGcHNEcm9wXCI7XG4gIEV2ZW50c1tcIkZQU19EUk9QX0xFVkVMX0NBUFBJTkdcIl0gPSBcImhsc0Zwc0Ryb3BMZXZlbENhcHBpbmdcIjtcbiAgRXZlbnRzW1wiRVJST1JcIl0gPSBcImhsc0Vycm9yXCI7XG4gIEV2ZW50c1tcIkRFU1RST1lJTkdcIl0gPSBcImhsc0Rlc3Ryb3lpbmdcIjtcbiAgRXZlbnRzW1wiS0VZX0xPQURJTkdcIl0gPSBcImhsc0tleUxvYWRpbmdcIjtcbiAgRXZlbnRzW1wiS0VZX0xPQURFRFwiXSA9IFwiaGxzS2V5TG9hZGVkXCI7XG4gIEV2ZW50c1tcIkxJVkVfQkFDS19CVUZGRVJfUkVBQ0hFRFwiXSA9IFwiaGxzTGl2ZUJhY2tCdWZmZXJSZWFjaGVkXCI7XG4gIEV2ZW50c1tcIkJBQ0tfQlVGRkVSX1JFQUNIRURcIl0gPSBcImhsc0JhY2tCdWZmZXJSZWFjaGVkXCI7XG59KShFdmVudHMgfHwgKEV2ZW50cyA9IHt9KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2hscy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaGxzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBIbHM7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB1cmwtdG9vbGtpdCAqLyBcIi4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2FkZXJfcGxheWxpc3RfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvYWRlci9wbGF5bGlzdC1sb2FkZXIgKi8gXCIuL3NyYy9sb2FkZXIvcGxheWxpc3QtbG9hZGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2FkZXJfa2V5X2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2FkZXIva2V5LWxvYWRlciAqLyBcIi4vc3JjL2xvYWRlci9rZXktbG9hZGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2lkM190cmFja19jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvaWQzLXRyYWNrLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2lkMy10cmFjay1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2xhdGVuY3lfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2xhdGVuY3ktY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGF0ZW5jeS1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2xldmVsX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyICovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pc19zdXBwb3J0ZWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtc3VwcG9ydGVkICovIFwiLi9zcmMvaXMtc3VwcG9ydGVkLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb25maWdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbmZpZyAqLyBcIi4vc3JjL2NvbmZpZy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZXZlbnRlbWl0dGVyMyAqLyBcIi4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKipcbiAqIEBtb2R1bGUgSGxzXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSGxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgSGxzLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIE9iamVjdChfaXNfc3VwcG9ydGVkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJpc1N1cHBvcnRlZFwiXSkoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhbiBITFMgY2xpZW50IHRoYXQgY2FuIGF0dGFjaCB0byBleGFjdGx5IG9uZSBgSFRNTE1lZGlhRWxlbWVudGAuXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RzIEhsc1xuICAgKiBAcGFyYW0ge0hsc0NvbmZpZ30gY29uZmlnXG4gICAqL1xuICBmdW5jdGlvbiBIbHModXNlckNvbmZpZykge1xuICAgIGlmICh1c2VyQ29uZmlnID09PSB2b2lkIDApIHtcbiAgICAgIHVzZXJDb25maWcgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLnVzZXJDb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycyA9IHZvaWQgMDtcbiAgICB0aGlzLl9lbWl0dGVyID0gbmV3IGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXCJFdmVudEVtaXR0ZXJcIl0oKTtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gdm9pZCAwO1xuICAgIHRoaXMuYWJyQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXRlbmN5Q29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuZW1lQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNtY2RDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuX21lZGlhID0gbnVsbDtcbiAgICB0aGlzLnVybCA9IG51bGw7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnID0gT2JqZWN0KF9jb25maWdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJtZXJnZUNvbmZpZ1wiXSkoSGxzLkRlZmF1bHRDb25maWcsIHVzZXJDb25maWcpO1xuICAgIHRoaXMudXNlckNvbmZpZyA9IHVzZXJDb25maWc7XG4gICAgT2JqZWN0KF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImVuYWJsZUxvZ3NcIl0pKGNvbmZpZy5kZWJ1Zyk7XG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuXG4gICAgaWYgKGNvbmZpZy5wcm9ncmVzc2l2ZSkge1xuICAgICAgT2JqZWN0KF9jb25maWdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJlbmFibGVTdHJlYW1pbmdNb2RlXCJdKShjb25maWcpO1xuICAgIH0gLy8gY29yZSBjb250cm9sbGVycyBhbmQgbmV0d29yayBsb2FkZXJzXG5cblxuICAgIHZhciBDb25maWdBYnJDb250cm9sbGVyID0gY29uZmlnLmFickNvbnRyb2xsZXIsXG4gICAgICAgIENvbmZpZ0J1ZmZlckNvbnRyb2xsZXIgPSBjb25maWcuYnVmZmVyQ29udHJvbGxlcixcbiAgICAgICAgQ29uZmlnQ2FwTGV2ZWxDb250cm9sbGVyID0gY29uZmlnLmNhcExldmVsQ29udHJvbGxlcixcbiAgICAgICAgQ29uZmlnRnBzQ29udHJvbGxlciA9IGNvbmZpZy5mcHNDb250cm9sbGVyO1xuICAgIHZhciBhYnJDb250cm9sbGVyID0gdGhpcy5hYnJDb250cm9sbGVyID0gbmV3IENvbmZpZ0FickNvbnRyb2xsZXIodGhpcyk7XG4gICAgdmFyIGJ1ZmZlckNvbnRyb2xsZXIgPSB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIgPSBuZXcgQ29uZmlnQnVmZmVyQ29udHJvbGxlcih0aGlzKTtcbiAgICB2YXIgY2FwTGV2ZWxDb250cm9sbGVyID0gdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIgPSBuZXcgQ29uZmlnQ2FwTGV2ZWxDb250cm9sbGVyKHRoaXMpO1xuICAgIHZhciBmcHNDb250cm9sbGVyID0gbmV3IENvbmZpZ0Zwc0NvbnRyb2xsZXIodGhpcyk7XG4gICAgdmFyIHBsYXlMaXN0TG9hZGVyID0gbmV3IF9sb2FkZXJfcGxheWxpc3RfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKHRoaXMpO1xuICAgIHZhciBrZXlMb2FkZXIgPSBuZXcgX2xvYWRlcl9rZXlfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKHRoaXMpO1xuICAgIHZhciBpZDNUcmFja0NvbnRyb2xsZXIgPSBuZXcgX2NvbnRyb2xsZXJfaWQzX3RyYWNrX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0odGhpcyk7IC8vIG5ldHdvcmsgY29udHJvbGxlcnNcblxuICAgIHZhciBsZXZlbENvbnRyb2xsZXIgPSB0aGlzLmxldmVsQ29udHJvbGxlciA9IG5ldyBfY29udHJvbGxlcl9sZXZlbF9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdKHRoaXMpOyAvLyBGcmFnbWVudFRyYWNrZXIgbXVzdCBiZSBkZWZpbmVkIGJlZm9yZSBTdHJlYW1Db250cm9sbGVyIGJlY2F1c2UgdGhlIG9yZGVyIG9mIGV2ZW50IGhhbmRsaW5nIGlzIGltcG9ydGFudFxuXG4gICAgdmFyIGZyYWdtZW50VHJhY2tlciA9IG5ldyBfY29udHJvbGxlcl9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJGcmFnbWVudFRyYWNrZXJcIl0odGhpcyk7XG4gICAgdmFyIHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBuZXcgX2NvbnRyb2xsZXJfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImRlZmF1bHRcIl0odGhpcywgZnJhZ21lbnRUcmFja2VyKTsgLy8gQ2FwIGxldmVsIGNvbnRyb2xsZXIgdXNlcyBzdHJlYW1Db250cm9sbGVyIHRvIGZsdXNoIHRoZSBidWZmZXJcblxuICAgIGNhcExldmVsQ29udHJvbGxlci5zZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpOyAvLyBmcHNDb250cm9sbGVyIHVzZXMgc3RyZWFtQ29udHJvbGxlciB0byBzd2l0Y2ggd2hlbiBmcmFtZXMgYXJlIGJlaW5nIGRyb3BwZWRcblxuICAgIGZwc0NvbnRyb2xsZXIuc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKTtcbiAgICB2YXIgbmV0d29ya0NvbnRyb2xsZXJzID0gW2xldmVsQ29udHJvbGxlciwgc3RyZWFtQ29udHJvbGxlcl07XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMgPSBuZXR3b3JrQ29udHJvbGxlcnM7XG4gICAgdmFyIGNvcmVDb21wb25lbnRzID0gW3BsYXlMaXN0TG9hZGVyLCBrZXlMb2FkZXIsIGFickNvbnRyb2xsZXIsIGJ1ZmZlckNvbnRyb2xsZXIsIGNhcExldmVsQ29udHJvbGxlciwgZnBzQ29udHJvbGxlciwgaWQzVHJhY2tDb250cm9sbGVyLCBmcmFnbWVudFRyYWNrZXJdO1xuICAgIHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLmF1ZGlvVHJhY2tDb250cm9sbGVyLCBudWxsLCBuZXR3b3JrQ29udHJvbGxlcnMpO1xuICAgIHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcuYXVkaW9TdHJlYW1Db250cm9sbGVyLCBmcmFnbWVudFRyYWNrZXIsIG5ldHdvcmtDb250cm9sbGVycyk7IC8vIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyIG11c3QgYmUgZGVmaW5lZCBiZWZvcmUgIGJlY2F1c2UgdGhlIG9yZGVyIG9mIGV2ZW50IGhhbmRsaW5nIGlzIGltcG9ydGFudFxuXG4gICAgdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIsIG51bGwsIG5ldHdvcmtDb250cm9sbGVycyk7XG4gICAgdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5zdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIsIGZyYWdtZW50VHJhY2tlciwgbmV0d29ya0NvbnRyb2xsZXJzKTtcbiAgICB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLnRpbWVsaW5lQ29udHJvbGxlciwgbnVsbCwgY29yZUNvbXBvbmVudHMpO1xuICAgIHRoaXMuZW1lQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcuZW1lQ29udHJvbGxlciwgbnVsbCwgY29yZUNvbXBvbmVudHMpO1xuICAgIHRoaXMuY21jZENvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLmNtY2RDb250cm9sbGVyLCBudWxsLCBjb3JlQ29tcG9uZW50cyk7XG4gICAgdGhpcy5sYXRlbmN5Q29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihfY29udHJvbGxlcl9sYXRlbmN5X2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0sIG51bGwsIGNvcmVDb21wb25lbnRzKTtcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzID0gY29yZUNvbXBvbmVudHM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSGxzLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY3JlYXRlQ29udHJvbGxlciA9IGZ1bmN0aW9uIGNyZWF0ZUNvbnRyb2xsZXIoQ29udHJvbGxlckNsYXNzLCBmcmFnbWVudFRyYWNrZXIsIGNvbXBvbmVudHMpIHtcbiAgICBpZiAoQ29udHJvbGxlckNsYXNzKSB7XG4gICAgICB2YXIgY29udHJvbGxlckluc3RhbmNlID0gZnJhZ21lbnRUcmFja2VyID8gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzLCBmcmFnbWVudFRyYWNrZXIpIDogbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzKTtcblxuICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbnRyb2xsZXJJbnN0YW5jZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250cm9sbGVySW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gRGVsZWdhdGUgdGhlIEV2ZW50RW1pdHRlciB0aHJvdWdoIHRoZSBwdWJsaWMgQVBJIG9mIEhscy5qc1xuICA7XG5cbiAgX3Byb3RvLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdHRlci5vbihldmVudCwgbGlzdGVuZXIsIGNvbnRleHQpO1xuICB9O1xuXG4gIF9wcm90by5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgbGlzdGVuZXIsIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLl9lbWl0dGVyLm9uY2UoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgdGhpcy5fZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpO1xuICB9O1xuXG4gIF9wcm90by5vZmYgPSBmdW5jdGlvbiBvZmYoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0LCBvbmNlKSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdHRlci5vZmYoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0LCBvbmNlKTtcbiAgfTtcblxuICBfcHJvdG8ubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIubGlzdGVuZXJzKGV2ZW50KTtcbiAgfTtcblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIG5hbWUsIGV2ZW50T2JqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIuZW1pdChldmVudCwgbmFtZSwgZXZlbnRPYmplY3QpO1xuICB9O1xuXG4gIF9wcm90by50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlcihldmVudCwgZXZlbnRPYmplY3QpIHtcbiAgICBpZiAodGhpcy5jb25maWcuZGVidWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnQsIGV2ZW50LCBldmVudE9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnQsIGV2ZW50LCBldmVudE9iamVjdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImxvZ2dlclwiXS5lcnJvcignQW4gaW50ZXJuYWwgZXJyb3IgaGFwcGVuZWQgd2hpbGUgaGFuZGxpbmcgZXZlbnQgJyArIGV2ZW50ICsgJy4gRXJyb3IgbWVzc2FnZTogXCInICsgZS5tZXNzYWdlICsgJ1wiLiBIZXJlIGlzIGEgc3RhY2t0cmFjZTonLCBlKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wiRXJyb3JUeXBlc1wiXS5PVEhFUl9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wiRXJyb3JEZXRhaWxzXCJdLklOVEVSTkFMX0VYQ0VQVElPTixcbiAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8ubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5saXN0ZW5lckNvdW50KGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogRGlzcG9zZSBvZiB0aGUgaW5zdGFuY2VcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wibG9nZ2VyXCJdLmxvZygnZGVzdHJveScpO1xuICAgIHRoaXMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1wiRXZlbnRzXCJdLkRFU1RST1lJTkcsIHVuZGVmaW5lZCk7XG4gICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgIHRoaXMudXJsID0gbnVsbDtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnQuZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnQuZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIHRoaXMuY29yZUNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgfVxuICAvKipcbiAgICogQXR0YWNoZXMgSGxzLmpzIHRvIGEgbWVkaWEgZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR9IG1lZGlhXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmF0dGFjaE1lZGlhID0gZnVuY3Rpb24gYXR0YWNoTWVkaWEobWVkaWEpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJsb2dnZXJcIl0ubG9nKCdhdHRhY2hNZWRpYScpO1xuICAgIHRoaXMuX21lZGlhID0gbWVkaWE7XG4gICAgdGhpcy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNISU5HLCB7XG4gICAgICBtZWRpYTogbWVkaWFcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGV0YWNoIEhscy5qcyBmcm9tIHRoZSBtZWRpYVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXRhY2hNZWRpYSA9IGZ1bmN0aW9uIGRldGFjaE1lZGlhKCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImxvZ2dlclwiXS5sb2coJ2RldGFjaE1lZGlhJyk7XG4gICAgdGhpcy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB1bmRlZmluZWQpO1xuICAgIHRoaXMuX21lZGlhID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgVVJMLiBDYW4gYmUgcmVsYXRpdmUgb3IgYWJzb2x1dGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICovXG4gIDtcblxuICBfcHJvdG8ubG9hZFNvdXJjZSA9IGZ1bmN0aW9uIGxvYWRTb3VyY2UodXJsKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgdmFyIGxvYWRlZFNvdXJjZSA9IHRoaXMudXJsO1xuICAgIHZhciBsb2FkaW5nU291cmNlID0gdGhpcy51cmwgPSB1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiYnVpbGRBYnNvbHV0ZVVSTFwiXShzZWxmLmxvY2F0aW9uLmhyZWYsIHVybCwge1xuICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgfSk7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wibG9nZ2VyXCJdLmxvZyhcImxvYWRTb3VyY2U6XCIgKyBsb2FkaW5nU291cmNlKTtcblxuICAgIGlmIChtZWRpYSAmJiBsb2FkZWRTb3VyY2UgJiYgbG9hZGVkU291cmNlICE9PSBsb2FkaW5nU291cmNlICYmIHRoaXMuYnVmZmVyQ29udHJvbGxlci5oYXNTb3VyY2VUeXBlcygpKSB7XG4gICAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgICB0aGlzLmF0dGFjaE1lZGlhKG1lZGlhKTtcbiAgICB9IC8vIHdoZW4gYXR0YWNoaW5nIHRvIGEgc291cmNlIFVSTCwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWRcblxuXG4gICAgdGhpcy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BRElORywge1xuICAgICAgdXJsOiB1cmxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3RhcnQgbG9hZGluZyBkYXRhIGZyb20gdGhlIHN0cmVhbSBzb3VyY2UuXG4gICAqIERlcGVuZGluZyBvbiBkZWZhdWx0IGNvbmZpZywgY2xpZW50IHN0YXJ0cyBsb2FkaW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBhIHNvdXJjZSBpcyBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFBvc2l0aW9uIFNldCB0aGUgc3RhcnQgcG9zaXRpb24gdG8gc3RyZWFtIGZyb21cbiAgICogQGRlZmF1bHQgLTEgTm9uZSAoZnJvbSBlYXJsaWVzdCBwb2ludClcbiAgICovXG4gIDtcblxuICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGFydFBvc2l0aW9uID0gLTE7XG4gICAgfVxuXG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wibG9nZ2VyXCJdLmxvZyhcInN0YXJ0TG9hZChcIiArIHN0YXJ0UG9zaXRpb24gKyBcIilcIik7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5zdGFydExvYWQoc3RhcnRQb3NpdGlvbik7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3AgbG9hZGluZyBvZiBhbnkgc3RyZWFtIGRhdGEuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnN0b3BMb2FkID0gZnVuY3Rpb24gc3RvcExvYWQoKSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wibG9nZ2VyXCJdLmxvZygnc3RvcExvYWQnKTtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLnN0b3BMb2FkKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFN3YXAgdGhyb3VnaCBwb3NzaWJsZSBhdWRpbyBjb2RlY3MgaW4gdGhlIHN0cmVhbSAoZm9yIGV4YW1wbGUgdG8gc3dpdGNoIGZyb20gc3RlcmVvIHRvIDUuMSlcbiAgICovXG4gIDtcblxuICBfcHJvdG8uc3dhcEF1ZGlvQ29kZWMgPSBmdW5jdGlvbiBzd2FwQXVkaW9Db2RlYygpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJsb2dnZXJcIl0ubG9nKCdzd2FwQXVkaW9Db2RlYycpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zd2FwQXVkaW9Db2RlYygpO1xuICB9XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBtZWRpYS1lbGVtZW50IGZhaWxzLCB0aGlzIGFsbG93cyB0byBkZXRhY2ggYW5kIHRoZW4gcmUtYXR0YWNoIGl0XG4gICAqIGFzIG9uZSBjYWxsIChjb252ZW5pZW5jZSBtZXRob2QpLlxuICAgKlxuICAgKiBBdXRvbWF0aWMgcmVjb3Zlcnkgb2YgbWVkaWEtZXJyb3JzIGJ5IHRoaXMgcHJvY2VzcyBpcyBjb25maWd1cmFibGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlY292ZXJNZWRpYUVycm9yID0gZnVuY3Rpb24gcmVjb3Zlck1lZGlhRXJyb3IoKSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wibG9nZ2VyXCJdLmxvZygncmVjb3Zlck1lZGlhRXJyb3InKTtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLl9tZWRpYTtcbiAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG5cbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHRoaXMuYXR0YWNoTWVkaWEobWVkaWEpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlTGV2ZWwgPSBmdW5jdGlvbiByZW1vdmVMZXZlbChsZXZlbEluZGV4LCB1cmxJZCkge1xuICAgIGlmICh1cmxJZCA9PT0gdm9pZCAwKSB7XG4gICAgICB1cmxJZCA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIucmVtb3ZlTGV2ZWwobGV2ZWxJbmRleCwgdXJsSWQpO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7TGV2ZWxbXX1cbiAgICovXG4gIDtcblxuICBfY3JlYXRlQ2xhc3MoSGxzLCBbe1xuICAgIGtleTogXCJsZXZlbHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbHM7XG4gICAgICByZXR1cm4gbGV2ZWxzID8gbGV2ZWxzIDogW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIHF1YWxpdHkgbGV2ZWwgY3VycmVudGx5IHBsYXllZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjdXJyZW50TGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuY3VycmVudExldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBpbW1lZGlhdGVseSAuXG4gICAgICogVGhpcyB3aWxsIGZsdXNoIHRoZSBjdXJyZW50IGJ1ZmZlciB0byByZXBsYWNlIHRoZSBxdWFsaXR5IGFzYXAuXG4gICAgICogVGhhdCBtZWFucyBwbGF5YmFjayB3aWxsIGludGVycnVwdCBhdCBsZWFzdCBzaG9ydGx5IHRvIHJlLWJ1ZmZlciBhbmQgcmUtc3luYyBldmVudHVhbGx5LlxuICAgICAqIEB0eXBlIHtudW1iZXJ9IC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJsb2dnZXJcIl0ubG9nKFwic2V0IGN1cnJlbnRMZXZlbDpcIiArIG5ld0xldmVsKTtcbiAgICAgIHRoaXMubG9hZExldmVsID0gbmV3TGV2ZWw7XG4gICAgICB0aGlzLmFickNvbnRyb2xsZXIuY2xlYXJUaW1lcigpO1xuICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLmltbWVkaWF0ZUxldmVsU3dpdGNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIG5leHQgcXVhbGl0eSBsZXZlbCBsb2FkZWQgYXMgc2NoZWR1bGVkIGJ5IHN0cmVhbSBjb250cm9sbGVyLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXh0TGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YS5cbiAgICAgKiBUaGlzIHdpbGwgc3dpdGNoIHRoZSB2aWRlbyBxdWFsaXR5IGFzYXAsIHdpdGhvdXQgaW50ZXJydXB0aW5nIHBsYXliYWNrLlxuICAgICAqIE1heSBhYm9ydCBjdXJyZW50IGxvYWRpbmcgb2YgZGF0YSwgYW5kIGZsdXNoIHBhcnRzIG9mIGJ1ZmZlciAob3V0c2lkZSBjdXJyZW50bHkgcGxheWVkIGZyYWdtZW50IHJlZ2lvbikuXG4gICAgICogQHR5cGUge251bWJlcn0gLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImxvZ2dlclwiXS5sb2coXCJzZXQgbmV4dExldmVsOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIHRoZSBjdXJyZW50bHkgb3IgbGFzdCAob2Ygbm9uZSBpcyBsb2FkZWQgY3VycmVudGx5KSBzZWdtZW50XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvYWRMZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YSBpbiBhIGNvbnNlcnZhdGl2ZSB3YXkuXG4gICAgICogVGhpcyB3aWxsIHN3aXRjaCB0aGUgcXVhbGl0eSB3aXRob3V0IGZsdXNoaW5nLCBidXQgaW50ZXJydXB0IGN1cnJlbnQgbG9hZGluZy5cbiAgICAgKiBUaHVzIHRoZSBtb21lbnQgd2hlbiB0aGUgcXVhbGl0eSBzd2l0Y2ggd2lsbCBhcHBlYXIgaW4gZWZmZWN0IHdpbGwgb25seSBiZSBhZnRlciB0aGUgYWxyZWFkeSBleGlzdGluZyBidWZmZXIuXG4gICAgICogQHR5cGUge251bWJlcn0gbmV3TGV2ZWwgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImxvZ2dlclwiXS5sb2coXCJzZXQgbG9hZExldmVsOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IG5leHQgcXVhbGl0eSBsZXZlbCBsb2FkZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmV4dExvYWRMZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIHNlZ21lbnQgaW4gYSBmdWxseSBcIm5vbi1kZXN0cnVjdGl2ZVwiIHdheS5cbiAgICAgKiBTYW1lIGFzIGBsb2FkTGV2ZWxgIGJ1dCB3aWxsIHdhaXQgZm9yIG5leHQgc3dpdGNoICh1bnRpbCBjdXJyZW50IGxvYWRpbmcgaXMgZG9uZSkuXG4gICAgICogQHR5cGUge251bWJlcn0gbGV2ZWxcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobGV2ZWwpIHtcbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIFwiZmlyc3QgbGV2ZWxcIjogbGlrZSBhIGRlZmF1bHQgbGV2ZWwsIGlmIG5vdCBzZXQsXG4gICAgICogZmFsbHMgYmFjayB0byBpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0TGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgXCJmaXJzdC1sZXZlbFwiLCBzZWUgZ2V0dGVyLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJsb2dnZXJcIl0ubG9nKFwic2V0IGZpcnN0TGV2ZWw6XCIgKyBuZXdMZXZlbCk7XG4gICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBzdGFydCBsZXZlbCAobGV2ZWwgb2YgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIHBsYXllZCBiYWNrKVxuICAgICAqIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgICAqIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aFxuICAgICAqIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRMZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldCAgc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICAgKiBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcbiAgICAgKiBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGhcbiAgICAgKiAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICAgICogQHR5cGUge251bWJlcn0gbmV3TGV2ZWxcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImxvZ2dlclwiXS5sb2coXCJzZXQgc3RhcnRMZXZlbDpcIiArIG5ld0xldmVsKTsgLy8gaWYgbm90IGluIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBkZXRlY3Rpb24sIGVuc3VyZSBzdGFydExldmVsIGlzIGdyZWF0ZXIgdGhhbiBtaW5BdXRvTGV2ZWxcblxuICAgICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgICBuZXdMZXZlbCA9IE1hdGgubWF4KG5ld0xldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHNldHRpbmcgZm9yIGNhcExldmVsVG9QbGF5ZXJTaXplXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhcExldmVsVG9QbGF5ZXJTaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldCAgZHluYW1pY2FsbHkgc2V0IGNhcExldmVsVG9QbGF5ZXJTaXplIGFnYWluc3QgKGBDYXBMZXZlbENvbnRyb2xsZXJgKVxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHNob3VsZFN0YXJ0Q2FwcGluZykge1xuICAgICAgdmFyIG5ld0NhcExldmVsVG9QbGF5ZXJTaXplID0gISFzaG91bGRTdGFydENhcHBpbmc7XG5cbiAgICAgIGlmIChuZXdDYXBMZXZlbFRvUGxheWVyU2l6ZSAhPT0gdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUpIHtcbiAgICAgICAgaWYgKG5ld0NhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICAgICAgdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIuc3RhcnRDYXBwaW5nKCk7IC8vIElmIGNhcHBpbmcgb2NjdXJzLCBuZXh0TGV2ZWxTd2l0Y2ggd2lsbCBoYXBwZW4gYmFzZWQgb24gc2l6ZS5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlci5zdG9wQ2FwcGluZygpO1xuICAgICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTsgLy8gTm93IHdlJ3JlIHVuY2FwcGVkLCBnZXQgdGhlIG5leHQgbGV2ZWwgYXNhcC5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplID0gbmV3Q2FwTGV2ZWxUb1BsYXllclNpemU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXV0b0xldmVsQ2FwcGluZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2F1dG9MZXZlbENhcHBpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCBiYW5kd2lkdGggZXN0aW1hdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6XG4gICAgLyoqXG4gICAgICogQ2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAoYEFCUkNvbnRyb2xsZXJgKVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICBpZiAodGhpcy5fYXV0b0xldmVsQ2FwcGluZyAhPT0gbmV3TGV2ZWwpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wibG9nZ2VyXCJdLmxvZyhcInNldCBhdXRvTGV2ZWxDYXBwaW5nOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gbmV3TGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRydWUgd2hlbiBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGVuYWJsZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImJhbmR3aWR0aEVzdGltYXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgYndFc3RpbWF0b3IgPSB0aGlzLmFickNvbnRyb2xsZXIuYndFc3RpbWF0b3I7XG5cbiAgICAgIGlmICghYndFc3RpbWF0b3IpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF1dG9MZXZlbEVuYWJsZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9PT0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExldmVsIHNldCBtYW51YWxseSAoaWYgYW55KVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYW51YWxMZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtaW4gbGV2ZWwgc2VsZWN0YWJsZSBpbiBhdXRvIG1vZGUgYWNjb3JkaW5nIHRvIGNvbmZpZy5taW5BdXRvQml0cmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtaW5BdXRvTGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgICBtaW5BdXRvQml0cmF0ZSA9IHRoaXMuY29uZmlnLm1pbkF1dG9CaXRyYXRlO1xuICAgICAgaWYgKCFsZXZlbHMpIHJldHVybiAwO1xuICAgICAgdmFyIGxlbiA9IGxldmVscy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGxldmVsc1tpXS5tYXhCaXRyYXRlID49IG1pbkF1dG9CaXRyYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1heCBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gYXV0b0xldmVsQ2FwcGluZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXhBdXRvTGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgICBhdXRvTGV2ZWxDYXBwaW5nID0gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgdmFyIG1heEF1dG9MZXZlbDtcblxuICAgICAgaWYgKGF1dG9MZXZlbENhcHBpbmcgPT09IC0xICYmIGxldmVscyAmJiBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgIG1heEF1dG9MZXZlbCA9IGxldmVscy5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4QXV0b0xldmVsID0gYXV0b0xldmVsQ2FwcGluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1heEF1dG9MZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbmV4dCBhdXRvbWF0aWNhbGx5IHNlbGVjdGVkIHF1YWxpdHkgbGV2ZWxcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmV4dEF1dG9MZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gZW5zdXJlIG5leHQgYXV0byBsZXZlbCBpcyBiZXR3ZWVuICBtaW4gYW5kIG1heCBhdXRvIGxldmVsXG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodGhpcy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwsIHRoaXMubWluQXV0b0xldmVsKSwgdGhpcy5tYXhBdXRvTGV2ZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0aGlzIHNldHRlciBpcyB1c2VkIHRvIGZvcmNlIG5leHQgYXV0byBsZXZlbC5cbiAgICAgKiB0aGlzIGlzIHVzZWZ1bCB0byBmb3JjZSBhIHN3aXRjaCBkb3duIGluIGF1dG8gbW9kZTpcbiAgICAgKiBpbiBjYXNlIG9mIGxvYWQgZXJyb3Igb24gbGV2ZWwgTiwgaGxzLmpzIGNhbiBzZXQgbmV4dEF1dG9MZXZlbCB0byBOLTEgZm9yIGV4YW1wbGUpXG4gICAgICogZm9yY2VkIHZhbHVlIGlzIHZhbGlkIGZvciBvbmUgZnJhZ21lbnQuIHVwb24gc3VjY2Vzc2Z1bCBmcmFnIGxvYWRpbmcgYXQgZm9yY2VkIGxldmVsLFxuICAgICAqIHRoaXMgdmFsdWUgd2lsbCBiZSByZXNldHRlZCB0byAtMSBieSBBQlIgY29udHJvbGxlci5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXh0TGV2ZWwpIHtcbiAgICAgIHRoaXMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsID0gTWF0aC5tYXgodGhpcy5taW5BdXRvTGV2ZWwsIG5leHRMZXZlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgZGF0ZXRpbWUgdmFsdWUgcmVsYXRpdmUgdG8gbWVkaWEuY3VycmVudFRpbWUgZm9yIHRoZSBhY3RpdmUgbGV2ZWwgUHJvZ3JhbSBEYXRlIFRpbWUgaWYgcHJlc2VudFxuICAgICAqIEB0eXBlIHtEYXRlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGxheWluZ0RhdGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuY3VycmVudFByb2dyYW1EYXRlVGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHR5cGUge0F1ZGlvVHJhY2tbXX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImF1ZGlvVHJhY2tzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFja3MgOiBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIGF1ZGlvIHRyYWNrIChpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cylcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXVkaW9UcmFja1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgOiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2VsZWN0cyBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoYXVkaW9UcmFja0lkKSB7XG4gICAgICB2YXIgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuXG4gICAgICBpZiAoYXVkaW9UcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgICAgYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjayA9IGF1ZGlvVHJhY2tJZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0XG4gICAgICogQHR5cGUge01lZGlhUGxheWxpc3RbXX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN1YnRpdGxlVHJhY2tzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFja3MgOiBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIHN1YnRpdGxlIHRyYWNrIChpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cylcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3VidGl0bGVUcmFja1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgOiAtMTtcbiAgICB9LFxuICAgIHNldDpcbiAgICAvKipcbiAgICAgKiBzZWxlY3QgYW4gc3VidGl0bGUgdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0c1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KHN1YnRpdGxlVHJhY2tJZCkge1xuICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcblxuICAgICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICAgIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgPSBzdWJ0aXRsZVRyYWNrSWQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWVkaWFcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tZWRpYTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3VidGl0bGVEaXNwbGF5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVEaXNwbGF5IDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZS9kaXNhYmxlIHN1YnRpdGxlIGRpc3BsYXkgcmVuZGVyaW5nXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuXG4gICAgICBpZiAoc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVEaXNwbGF5ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCBtb2RlIGZvciBMb3ctTGF0ZW5jeSBITFMgbG9hZGluZ1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibG93TGF0ZW5jeU1vZGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlL2Rpc2FibGUgTG93LUxhdGVuY3kgSExTIHBhcnQgcGxheWxpc3QgYW5kIHNlZ21lbnQgbG9hZGluZywgYW5kIHN0YXJ0IGxpdmUgc3RyZWFtcyBhdCBwbGF5bGlzdCBQQVJULUhPTEQtQkFDSyByYXRoZXIgdGhhbiBIT0xELUJBQ0suXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG1vZGUpIHtcbiAgICAgIHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlID0gbW9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcG9zaXRpb24gKGluIHNlY29uZHMpIG9mIGxpdmUgc3luYyBwb2ludCAoaWUgZWRnZSBvZiBsaXZlIHBvc2l0aW9uIG1pbnVzIHNhZmV0eSBkZWxheSBkZWZpbmVkIGJ5IGBgYGhscy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbmBgYClcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGl2ZVN5bmNQb3NpdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubGl2ZVN5bmNQb3NpdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZXN0aW1hdGVkIHBvc2l0aW9uIChpbiBzZWNvbmRzKSBvZiBsaXZlIGVkZ2UgKGllIGVkZ2Ugb2YgbGl2ZSBwbGF5bGlzdCBwbHVzIHRpbWUgc3luYyBwbGF5bGlzdCBhZHZhbmNlZClcbiAgICAgKiByZXR1cm5zIDAgYmVmb3JlIGZpcnN0IHBsYXlsaXN0IGlzIGxvYWRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsYXRlbmN5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5sYXRlbmN5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gdGhlIGVkZ2UgYmVmb3JlIHRoZSBwbGF5ZXIgc2Vla3MgZm9yd2FyZCB0byBgYGBobHMubGl2ZVN5bmNQb3NpdGlvbmBgYFxuICAgICAqIGNvbmZpZ3VyZWQgdXNpbmcgYGBgbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50YGBgIChtdWx0aXBsZSBvZiB0YXJnZXQgZHVyYXRpb24pIG9yIGBgYGxpdmVNYXhMYXRlbmN5RHVyYXRpb25gYGBcbiAgICAgKiByZXR1cm5zIDAgYmVmb3JlIGZpcnN0IHBsYXlsaXN0IGlzIGxvYWRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXhMYXRlbmN5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5tYXhMYXRlbmN5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0YXJnZXQgZGlzdGFuY2UgZnJvbSB0aGUgZWRnZSBhcyBjYWxjdWxhdGVkIGJ5IHRoZSBsYXRlbmN5IGNvbnRyb2xsZXJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidGFyZ2V0TGF0ZW5jeVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIudGFyZ2V0TGF0ZW5jeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIGVkZ2Ugb2YgdGhlIGN1cnJlbnQgbGl2ZSBwbGF5bGlzdCBpcyBhZHZhbmNpbmcgb3IgMSBpZiB0aGVyZSBpcyBub25lXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyaWZ0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5kcmlmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0IHRvIHRydWUgd2hlbiBzdGFydExvYWQgaXMgY2FsbGVkIGJlZm9yZSBNQU5JRkVTVF9QQVJTRUQgZXZlbnRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZvcmNlU3RhcnRMb2FkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmZvcmNlU3RhcnRMb2FkO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInZlcnNpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBcIjEuMi4wXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIkV2ZW50c1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bXCJFdmVudHNcIl07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIkVycm9yVHlwZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wiRXJyb3JUeXBlc1wiXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiRXJyb3JEZXRhaWxzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1tcIkVycm9yRGV0YWlsc1wiXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiRGVmYXVsdENvbmZpZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFIbHMuZGVmYXVsdENvbmZpZykge1xuICAgICAgICByZXR1cm4gX2NvbmZpZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcImhsc0RlZmF1bHRDb25maWdcIl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBIbHMuZGVmYXVsdENvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHR5cGUge0hsc0NvbmZpZ31cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoZGVmYXVsdENvbmZpZykge1xuICAgICAgSGxzLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIbHM7XG59KCk7XG5cbkhscy5kZWZhdWx0Q29uZmlnID0gdm9pZCAwO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2lzLXN1cHBvcnRlZC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaXMtc3VwcG9ydGVkLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBpc1N1cHBvcnRlZCwgY2hhbmdlVHlwZVN1cHBvcnRlZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpc1N1cHBvcnRlZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzU3VwcG9ydGVkOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjaGFuZ2VUeXBlU3VwcG9ydGVkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2hhbmdlVHlwZVN1cHBvcnRlZDsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21lZGlhc291cmNlX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIudHNcIik7XG5cblxuZnVuY3Rpb24gZ2V0U291cmNlQnVmZmVyKCkge1xuICByZXR1cm4gc2VsZi5Tb3VyY2VCdWZmZXIgfHwgc2VsZi5XZWJLaXRTb3VyY2VCdWZmZXI7XG59XG5cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICB2YXIgbWVkaWFTb3VyY2UgPSBPYmplY3QoX3V0aWxzX21lZGlhc291cmNlX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZ2V0TWVkaWFTb3VyY2VcIl0pKCk7XG5cbiAgaWYgKCFtZWRpYVNvdXJjZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBzb3VyY2VCdWZmZXIgPSBnZXRTb3VyY2VCdWZmZXIoKTtcbiAgdmFyIGlzVHlwZVN1cHBvcnRlZCA9IG1lZGlhU291cmNlICYmIHR5cGVvZiBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQgPT09ICdmdW5jdGlvbicgJiYgbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJFMDFFLG1wNGEuNDAuMlwiJyk7IC8vIGlmIFNvdXJjZUJ1ZmZlciBpcyBleHBvc2VkIGVuc3VyZSBpdHMgQVBJIGlzIHZhbGlkXG4gIC8vIHNhZmFyaSBhbmQgb2xkIHZlcnNpb24gb2YgQ2hyb21lIGRvZSBub3QgZXhwb3NlIFNvdXJjZUJ1ZmZlciBnbG9iYWxseSBzbyBjaGVja2luZyBTb3VyY2VCdWZmZXIucHJvdG90eXBlIGlzIGltcG9zc2libGVcblxuICB2YXIgc291cmNlQnVmZmVyVmFsaWRBUEkgPSAhc291cmNlQnVmZmVyIHx8IHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUgJiYgdHlwZW9mIHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUuYXBwZW5kQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzb3VyY2VCdWZmZXIucHJvdG90eXBlLnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuICEhaXNUeXBlU3VwcG9ydGVkICYmICEhc291cmNlQnVmZmVyVmFsaWRBUEk7XG59XG5mdW5jdGlvbiBjaGFuZ2VUeXBlU3VwcG9ydGVkKCkge1xuICB2YXIgX3NvdXJjZUJ1ZmZlciRwcm90b3R5O1xuXG4gIHZhciBzb3VyY2VCdWZmZXIgPSBnZXRTb3VyY2VCdWZmZXIoKTtcbiAgcmV0dXJuIHR5cGVvZiAoc291cmNlQnVmZmVyID09PSBudWxsIHx8IHNvdXJjZUJ1ZmZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2VCdWZmZXIkcHJvdG90eSA9IHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUpID09PSBudWxsIHx8IF9zb3VyY2VCdWZmZXIkcHJvdG90eSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZUJ1ZmZlciRwcm90b3R5LmNoYW5nZVR5cGUpID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sb2FkZXIvZGF0ZS1yYW5nZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9sb2FkZXIvZGF0ZS1yYW5nZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBEYXRlUmFuZ2VBdHRyaWJ1dGUsIERhdGVSYW5nZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJEYXRlUmFuZ2VBdHRyaWJ1dGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBEYXRlUmFuZ2VBdHRyaWJ1dGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkRhdGVSYW5nZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERhdGVSYW5nZTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYXR0ci1saXN0ICovIFwiLi9zcmMvdXRpbHMvYXR0ci1saXN0LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcblxuXG5cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuXG5cbnZhciBEYXRlUmFuZ2VBdHRyaWJ1dGU7XG5cbihmdW5jdGlvbiAoRGF0ZVJhbmdlQXR0cmlidXRlKSB7XG4gIERhdGVSYW5nZUF0dHJpYnV0ZVtcIklEXCJdID0gXCJJRFwiO1xuICBEYXRlUmFuZ2VBdHRyaWJ1dGVbXCJDTEFTU1wiXSA9IFwiQ0xBU1NcIjtcbiAgRGF0ZVJhbmdlQXR0cmlidXRlW1wiU1RBUlRfREFURVwiXSA9IFwiU1RBUlQtREFURVwiO1xuICBEYXRlUmFuZ2VBdHRyaWJ1dGVbXCJEVVJBVElPTlwiXSA9IFwiRFVSQVRJT05cIjtcbiAgRGF0ZVJhbmdlQXR0cmlidXRlW1wiRU5EX0RBVEVcIl0gPSBcIkVORC1EQVRFXCI7XG4gIERhdGVSYW5nZUF0dHJpYnV0ZVtcIkVORF9PTl9ORVhUXCJdID0gXCJFTkQtT04tTkVYVFwiO1xuICBEYXRlUmFuZ2VBdHRyaWJ1dGVbXCJQTEFOTkVEX0RVUkFUSU9OXCJdID0gXCJQTEFOTkVELURVUkFUSU9OXCI7XG4gIERhdGVSYW5nZUF0dHJpYnV0ZVtcIlNDVEUzNV9PVVRcIl0gPSBcIlNDVEUzNS1PVVRcIjtcbiAgRGF0ZVJhbmdlQXR0cmlidXRlW1wiU0NURTM1X0lOXCJdID0gXCJTQ1RFMzUtSU5cIjtcbn0pKERhdGVSYW5nZUF0dHJpYnV0ZSB8fCAoRGF0ZVJhbmdlQXR0cmlidXRlID0ge30pKTtcblxudmFyIERhdGVSYW5nZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGVSYW5nZShkYXRlUmFuZ2VBdHRyLCBkYXRlUmFuZ2VXaXRoU2FtZUlkKSB7XG4gICAgdGhpcy5hdHRyID0gdm9pZCAwO1xuICAgIHRoaXMuX3N0YXJ0RGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9lbmREYXRlID0gdm9pZCAwO1xuICAgIHRoaXMuX2JhZFZhbHVlRm9yU2FtZUlkID0gdm9pZCAwO1xuXG4gICAgaWYgKGRhdGVSYW5nZVdpdGhTYW1lSWQpIHtcbiAgICAgIHZhciBwcmV2aW91c0F0dHIgPSBkYXRlUmFuZ2VXaXRoU2FtZUlkLmF0dHI7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcmV2aW91c0F0dHIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRlUmFuZ2VBdHRyLCBrZXkpICYmIGRhdGVSYW5nZUF0dHJba2V5XSAhPT0gcHJldmlvdXNBdHRyW2tleV0pIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybihcIkRBVEVSQU5HRSB0YWcgYXR0cmlidXRlOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgZG9lcyBub3QgbWF0Y2ggZm9yIHRhZ3Mgd2l0aCBJRDogXFxcIlwiICsgZGF0ZVJhbmdlQXR0ci5JRCArIFwiXFxcIlwiKTtcbiAgICAgICAgICB0aGlzLl9iYWRWYWx1ZUZvclNhbWVJZCA9IGtleTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBNZXJnZSBEYXRlUmFuZ2UgdGFncyB3aXRoIHRoZSBzYW1lIElEXG5cblxuICAgICAgZGF0ZVJhbmdlQXR0ciA9IF9leHRlbmRzKG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJBdHRyTGlzdFwiXSh7fSksIHByZXZpb3VzQXR0ciwgZGF0ZVJhbmdlQXR0cik7XG4gICAgfVxuXG4gICAgdGhpcy5hdHRyID0gZGF0ZVJhbmdlQXR0cjtcbiAgICB0aGlzLl9zdGFydERhdGUgPSBuZXcgRGF0ZShkYXRlUmFuZ2VBdHRyW0RhdGVSYW5nZUF0dHJpYnV0ZS5TVEFSVF9EQVRFXSk7XG5cbiAgICBpZiAoRGF0ZVJhbmdlQXR0cmlidXRlLkVORF9EQVRFIGluIHRoaXMuYXR0cikge1xuICAgICAgdmFyIGVuZERhdGUgPSBuZXcgRGF0ZSh0aGlzLmF0dHJbRGF0ZVJhbmdlQXR0cmlidXRlLkVORF9EQVRFXSk7XG5cbiAgICAgIGlmIChPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGVuZERhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICB0aGlzLl9lbmREYXRlID0gZW5kRGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGF0ZVJhbmdlLCBbe1xuICAgIGtleTogXCJpZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0ci5JRDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xhc3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIuQ0xBU1M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0RGF0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0RGF0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kRGF0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHRoaXMuX2VuZERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZERhdGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb247XG5cbiAgICAgIGlmIChkdXJhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fc3RhcnREYXRlLmdldFRpbWUoKSArIGR1cmF0aW9uICogMTAwMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkdXJhdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKERhdGVSYW5nZUF0dHJpYnV0ZS5EVVJBVElPTiBpbiB0aGlzLmF0dHIpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5hdHRyLmRlY2ltYWxGbG9hdGluZ1BvaW50KERhdGVSYW5nZUF0dHJpYnV0ZS5EVVJBVElPTik7XG5cbiAgICAgICAgaWYgKE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoZHVyYXRpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIGR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2VuZERhdGUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9lbmREYXRlLmdldFRpbWUoKSAtIHRoaXMuX3N0YXJ0RGF0ZS5nZXRUaW1lKCkpIC8gMTAwMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBsYW5uZWREdXJhdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKERhdGVSYW5nZUF0dHJpYnV0ZS5QTEFOTkVEX0RVUkFUSU9OIGluIHRoaXMuYXR0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyLmRlY2ltYWxGbG9hdGluZ1BvaW50KERhdGVSYW5nZUF0dHJpYnV0ZS5QTEFOTkVEX0RVUkFUSU9OKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZE9uTmV4dFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0ci5ib29sKERhdGVSYW5nZUF0dHJpYnV0ZS5FTkRfT05fTkVYVCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVmFsaWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuaWQgJiYgIXRoaXMuX2JhZFZhbHVlRm9yU2FtZUlkICYmIE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkodGhpcy5zdGFydERhdGUuZ2V0VGltZSgpKSAmJiAodGhpcy5kdXJhdGlvbiA9PT0gbnVsbCB8fCB0aGlzLmR1cmF0aW9uID49IDApICYmICghdGhpcy5lbmRPbk5leHQgfHwgISF0aGlzLmNsYXNzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGF0ZVJhbmdlO1xufSgpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sb2FkZXIvZnJhZ21lbnQtbG9hZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL2ZyYWdtZW50LWxvYWRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQsIExvYWRFcnJvciAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRnJhZ21lbnRMb2FkZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkxvYWRFcnJvclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExvYWRFcnJvcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuXG5cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdC5iaW5kKCk7IH0gZWxzZSB7IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgdmFyIGEgPSBbbnVsbF07IGEucHVzaC5hcHBseShhLCBhcmdzKTsgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpOyB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTsgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7IHJldHVybiBpbnN0YW5jZTsgfTsgfSByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxudmFyIE1JTl9DSFVOS19TSVpFID0gTWF0aC5wb3coMiwgMTcpOyAvLyAxMjhrYlxuXG52YXIgRnJhZ21lbnRMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGcmFnbWVudExvYWRlcihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5wYXJ0TG9hZFRpbWVvdXQgPSAtMTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBGcmFnbWVudExvYWRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgIC8vIEFib3J0IHRoZSBsb2FkZXIgZm9yIGN1cnJlbnQgZnJhZ21lbnQuIE9ubHkgb25lIG1heSBsb2FkIGF0IGFueSBnaXZlbiB0aW1lXG4gICAgICB0aGlzLmxvYWRlci5hYm9ydCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ubG9hZCA9IGZ1bmN0aW9uIGxvYWQoZnJhZywgX29uUHJvZ3Jlc3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHVybCA9IGZyYWcudXJsO1xuXG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5ORVRXT1JLX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19MT0FEX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzOiBudWxsXG4gICAgICB9LCBcIkZyYWdtZW50IGRvZXMgbm90IGhhdmUgYSBcIiArICh1cmwgPyAncGFydCBsaXN0JyA6ICd1cmwnKSkpO1xuICAgIH1cblxuICAgIHRoaXMuYWJvcnQoKTtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgdmFyIEZyYWdtZW50SUxvYWRlciA9IGNvbmZpZy5mTG9hZGVyO1xuICAgIHZhciBEZWZhdWx0SUxvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmIChfdGhpcy5sb2FkZXIpIHtcbiAgICAgICAgX3RoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxvYWRlciA9IF90aGlzLmxvYWRlciA9IGZyYWcubG9hZGVyID0gRnJhZ21lbnRJTG9hZGVyID8gbmV3IEZyYWdtZW50SUxvYWRlcihjb25maWcpIDogbmV3IERlZmF1bHRJTG9hZGVyKGNvbmZpZyk7XG4gICAgICB2YXIgbG9hZGVyQ29udGV4dCA9IGNyZWF0ZUxvYWRlckNvbnRleHQoZnJhZyk7XG4gICAgICB2YXIgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICB0aW1lb3V0OiBjb25maWcuZnJhZ0xvYWRpbmdUaW1lT3V0LFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0LFxuICAgICAgICBoaWdoV2F0ZXJNYXJrOiBmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnID8gSW5maW5pdHkgOiBNSU5fQ0hVTktfU0laRVxuICAgICAgfTsgLy8gQXNzaWduIGZyYWcgc3RhdHMgdG8gdGhlIGxvYWRlcidzIHN0YXRzIHJlZmVyZW5jZVxuXG4gICAgICBmcmFnLnN0YXRzID0gbG9hZGVyLnN0YXRzO1xuICAgICAgbG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCB7XG4gICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gb25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBfdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuXG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBfdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuXG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLkZSQUdfTE9BRF9FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWJvcnQ6IGZ1bmN0aW9uIG9uQWJvcnQoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgX3RoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcblxuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5JTlRFUk5BTF9BQk9SVEVELFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UaW1lb3V0OiBmdW5jdGlvbiBvblRpbWVvdXQocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgX3RoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcblxuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5GUkFHX0xPQURfVElNRU9VVCxcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvZ3Jlc3M6IGZ1bmN0aW9uIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGRhdGEsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgaWYgKF9vblByb2dyZXNzKSB7XG4gICAgICAgICAgICBfb25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IGRhdGEsXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ubG9hZFBhcnQgPSBmdW5jdGlvbiBsb2FkUGFydChmcmFnLCBwYXJ0LCBvblByb2dyZXNzKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB0aGlzLmFib3J0KCk7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIHZhciBGcmFnbWVudElMb2FkZXIgPSBjb25maWcuZkxvYWRlcjtcbiAgICB2YXIgRGVmYXVsdElMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoX3RoaXMyLmxvYWRlcikge1xuICAgICAgICBfdGhpczIubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxvYWRlciA9IF90aGlzMi5sb2FkZXIgPSBmcmFnLmxvYWRlciA9IEZyYWdtZW50SUxvYWRlciA/IG5ldyBGcmFnbWVudElMb2FkZXIoY29uZmlnKSA6IG5ldyBEZWZhdWx0SUxvYWRlcihjb25maWcpO1xuICAgICAgdmFyIGxvYWRlckNvbnRleHQgPSBjcmVhdGVMb2FkZXJDb250ZXh0KGZyYWcsIHBhcnQpO1xuICAgICAgdmFyIGxvYWRlckNvbmZpZyA9IHtcbiAgICAgICAgdGltZW91dDogY29uZmlnLmZyYWdMb2FkaW5nVGltZU91dCxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCxcbiAgICAgICAgaGlnaFdhdGVyTWFyazogTUlOX0NIVU5LX1NJWkVcbiAgICAgIH07IC8vIEFzc2lnbiBwYXJ0IHN0YXRzIHRvIHRoZSBsb2FkZXIncyBzdGF0cyByZWZlcmVuY2VcblxuICAgICAgcGFydC5zdGF0cyA9IGxvYWRlci5zdGF0cztcbiAgICAgIGxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywge1xuICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIG9uU3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgX3RoaXMyLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG5cbiAgICAgICAgICBfdGhpczIudXBkYXRlU3RhdHNGcm9tUGFydChmcmFnLCBwYXJ0KTtcblxuICAgICAgICAgIHZhciBwYXJ0TG9hZGVkRGF0YSA9IHtcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgICAgcGF5bG9hZDogcmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgIH07XG4gICAgICAgICAgb25Qcm9ncmVzcyhwYXJ0TG9hZGVkRGF0YSk7XG4gICAgICAgICAgcmVzb2x2ZShwYXJ0TG9hZGVkRGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgX3RoaXMyLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG5cbiAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19MT0FEX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWJvcnQ6IGZ1bmN0aW9uIG9uQWJvcnQoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgZnJhZy5zdGF0cy5hYm9ydGVkID0gcGFydC5zdGF0cy5hYm9ydGVkO1xuXG4gICAgICAgICAgX3RoaXMyLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG5cbiAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uSU5URVJOQUxfQUJPUlRFRCxcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBvblRpbWVvdXQ6IGZ1bmN0aW9uIG9uVGltZW91dChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBfdGhpczIucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcblxuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5GUkFHX0xPQURfVElNRU9VVCxcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8udXBkYXRlU3RhdHNGcm9tUGFydCA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXRzRnJvbVBhcnQoZnJhZywgcGFydCkge1xuICAgIHZhciBmcmFnU3RhdHMgPSBmcmFnLnN0YXRzO1xuICAgIHZhciBwYXJ0U3RhdHMgPSBwYXJ0LnN0YXRzO1xuICAgIHZhciBwYXJ0VG90YWwgPSBwYXJ0U3RhdHMudG90YWw7XG4gICAgZnJhZ1N0YXRzLmxvYWRlZCArPSBwYXJ0U3RhdHMubG9hZGVkO1xuXG4gICAgaWYgKHBhcnRUb3RhbCkge1xuICAgICAgdmFyIGVzdFRvdGFsUGFydHMgPSBNYXRoLnJvdW5kKGZyYWcuZHVyYXRpb24gLyBwYXJ0LmR1cmF0aW9uKTtcbiAgICAgIHZhciBlc3RMb2FkZWRQYXJ0cyA9IE1hdGgubWluKE1hdGgucm91bmQoZnJhZ1N0YXRzLmxvYWRlZCAvIHBhcnRUb3RhbCksIGVzdFRvdGFsUGFydHMpO1xuICAgICAgdmFyIGVzdFJlbWFpbmluZ1BhcnRzID0gZXN0VG90YWxQYXJ0cyAtIGVzdExvYWRlZFBhcnRzO1xuICAgICAgdmFyIGVzdFJlbWFpbmluZ0J5dGVzID0gZXN0UmVtYWluaW5nUGFydHMgKiBNYXRoLnJvdW5kKGZyYWdTdGF0cy5sb2FkZWQgLyBlc3RMb2FkZWRQYXJ0cyk7XG4gICAgICBmcmFnU3RhdHMudG90YWwgPSBmcmFnU3RhdHMubG9hZGVkICsgZXN0UmVtYWluaW5nQnl0ZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWdTdGF0cy50b3RhbCA9IE1hdGgubWF4KGZyYWdTdGF0cy5sb2FkZWQsIGZyYWdTdGF0cy50b3RhbCk7XG4gICAgfVxuXG4gICAgdmFyIGZyYWdMb2FkaW5nID0gZnJhZ1N0YXRzLmxvYWRpbmc7XG4gICAgdmFyIHBhcnRMb2FkaW5nID0gcGFydFN0YXRzLmxvYWRpbmc7XG5cbiAgICBpZiAoZnJhZ0xvYWRpbmcuc3RhcnQpIHtcbiAgICAgIC8vIGFkZCB0byBmcmFnbWVudCBsb2FkZXIgbGF0ZW5jeVxuICAgICAgZnJhZ0xvYWRpbmcuZmlyc3QgKz0gcGFydExvYWRpbmcuZmlyc3QgLSBwYXJ0TG9hZGluZy5zdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ0xvYWRpbmcuc3RhcnQgPSBwYXJ0TG9hZGluZy5zdGFydDtcbiAgICAgIGZyYWdMb2FkaW5nLmZpcnN0ID0gcGFydExvYWRpbmcuZmlyc3Q7XG4gICAgfVxuXG4gICAgZnJhZ0xvYWRpbmcuZW5kID0gcGFydExvYWRpbmcuZW5kO1xuICB9O1xuXG4gIF9wcm90by5yZXNldExvYWRlciA9IGZ1bmN0aW9uIHJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcikge1xuICAgIGZyYWcubG9hZGVyID0gbnVsbDtcblxuICAgIGlmICh0aGlzLmxvYWRlciA9PT0gbG9hZGVyKSB7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnBhcnRMb2FkVGltZW91dCk7XG4gICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgfVxuXG4gICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgfTtcblxuICByZXR1cm4gRnJhZ21lbnRMb2FkZXI7XG59KCk7XG5cblxuXG5mdW5jdGlvbiBjcmVhdGVMb2FkZXJDb250ZXh0KGZyYWcsIHBhcnQpIHtcbiAgaWYgKHBhcnQgPT09IHZvaWQgMCkge1xuICAgIHBhcnQgPSBudWxsO1xuICB9XG5cbiAgdmFyIHNlZ21lbnQgPSBwYXJ0IHx8IGZyYWc7XG4gIHZhciBsb2FkZXJDb250ZXh0ID0ge1xuICAgIGZyYWc6IGZyYWcsXG4gICAgcGFydDogcGFydCxcbiAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsXG4gICAgdXJsOiBzZWdtZW50LnVybCxcbiAgICBoZWFkZXJzOiB7fSxcbiAgICByYW5nZVN0YXJ0OiAwLFxuICAgIHJhbmdlRW5kOiAwXG4gIH07XG4gIHZhciBzdGFydCA9IHNlZ21lbnQuYnl0ZVJhbmdlU3RhcnRPZmZzZXQ7XG4gIHZhciBlbmQgPSBzZWdtZW50LmJ5dGVSYW5nZUVuZE9mZnNldDtcblxuICBpZiAoT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShzdGFydCkgJiYgT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShlbmQpKSB7XG4gICAgbG9hZGVyQ29udGV4dC5yYW5nZVN0YXJ0ID0gc3RhcnQ7XG4gICAgbG9hZGVyQ29udGV4dC5yYW5nZUVuZCA9IGVuZDtcbiAgfVxuXG4gIHJldHVybiBsb2FkZXJDb250ZXh0O1xufVxuXG52YXIgTG9hZEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzTG9vc2UoTG9hZEVycm9yLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIExvYWRFcnJvcihkYXRhKSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJhbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcGFyYW1zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpczMgPSBfRXJyb3IuY2FsbC5hcHBseShfRXJyb3IsIFt0aGlzXS5jb25jYXQocGFyYW1zKSkgfHwgdGhpcztcbiAgICBfdGhpczMuZGF0YSA9IHZvaWQgMDtcbiAgICBfdGhpczMuZGF0YSA9IGRhdGE7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIHJldHVybiBMb2FkRXJyb3I7XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sb2FkZXIvZnJhZ21lbnQudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xvYWRlci9mcmFnbWVudC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogRWxlbWVudGFyeVN0cmVhbVR5cGVzLCBCYXNlU2VnbWVudCwgRnJhZ21lbnQsIFBhcnQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiRWxlbWVudGFyeVN0cmVhbVR5cGVzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRWxlbWVudGFyeVN0cmVhbVR5cGVzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJCYXNlU2VnbWVudFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEJhc2VTZWdtZW50OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJGcmFnbWVudFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEZyYWdtZW50OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJQYXJ0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUGFydDsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdXJsX3Rvb2xraXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHVybC10b29sa2l0ICovIFwiLi9ub2RlX21vZHVsZXMvdXJsLXRvb2xraXQvc3JjL3VybC10b29sa2l0LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odXJsX3Rvb2xraXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sZXZlbF9rZXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGV2ZWwta2V5ICovIFwiLi9zcmMvbG9hZGVyL2xldmVsLWtleS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZF9zdGF0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2FkLXN0YXRzICovIFwiLi9zcmMvbG9hZGVyL2xvYWQtc3RhdHMudHNcIik7XG5cblxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cblxuXG5cbnZhciBFbGVtZW50YXJ5U3RyZWFtVHlwZXM7XG5cbihmdW5jdGlvbiAoRWxlbWVudGFyeVN0cmVhbVR5cGVzKSB7XG4gIEVsZW1lbnRhcnlTdHJlYW1UeXBlc1tcIkFVRElPXCJdID0gXCJhdWRpb1wiO1xuICBFbGVtZW50YXJ5U3RyZWFtVHlwZXNbXCJWSURFT1wiXSA9IFwidmlkZW9cIjtcbiAgRWxlbWVudGFyeVN0cmVhbVR5cGVzW1wiQVVESU9WSURFT1wiXSA9IFwiYXVkaW92aWRlb1wiO1xufSkoRWxlbWVudGFyeVN0cmVhbVR5cGVzIHx8IChFbGVtZW50YXJ5U3RyZWFtVHlwZXMgPSB7fSkpO1xuXG52YXIgQmFzZVNlZ21lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBiYXNldXJsIGlzIHRoZSBVUkwgdG8gdGhlIHBsYXlsaXN0XG4gIC8vIHJlbHVybCBpcyB0aGUgcG9ydGlvbiBvZiB0aGUgVVJMIHRoYXQgY29tZXMgZnJvbSBpbnNpZGUgdGhlIHBsYXlsaXN0LlxuICAvLyBIb2xkcyB0aGUgdHlwZXMgb2YgZGF0YSB0aGlzIGZyYWdtZW50IHN1cHBvcnRzXG4gIGZ1bmN0aW9uIEJhc2VTZWdtZW50KGJhc2V1cmwpIHtcbiAgICB2YXIgX3RoaXMkZWxlbWVudGFyeVN0cmVhO1xuXG4gICAgdGhpcy5fYnl0ZVJhbmdlID0gbnVsbDtcbiAgICB0aGlzLl91cmwgPSBudWxsO1xuICAgIHRoaXMuYmFzZXVybCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlbHVybCA9IHZvaWQgMDtcbiAgICB0aGlzLmVsZW1lbnRhcnlTdHJlYW1zID0gKF90aGlzJGVsZW1lbnRhcnlTdHJlYSA9IHt9LCBfdGhpcyRlbGVtZW50YXJ5U3RyZWFbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IG51bGwsIF90aGlzJGVsZW1lbnRhcnlTdHJlYVtFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9dID0gbnVsbCwgX3RoaXMkZWxlbWVudGFyeVN0cmVhW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT1ZJREVPXSA9IG51bGwsIF90aGlzJGVsZW1lbnRhcnlTdHJlYSk7XG4gICAgdGhpcy5iYXNldXJsID0gYmFzZXVybDtcbiAgfSAvLyBzZXRCeXRlUmFuZ2UgY29udmVydHMgYSBFWFQtWC1CWVRFUkFOR0UgYXR0cmlidXRlIGludG8gYSB0d28gZWxlbWVudCBhcnJheVxuXG5cbiAgdmFyIF9wcm90byA9IEJhc2VTZWdtZW50LnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0Qnl0ZVJhbmdlID0gZnVuY3Rpb24gc2V0Qnl0ZVJhbmdlKHZhbHVlLCBwcmV2aW91cykge1xuICAgIHZhciBwYXJhbXMgPSB2YWx1ZS5zcGxpdCgnQCcsIDIpO1xuICAgIHZhciBieXRlUmFuZ2UgPSBbXTtcblxuICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBieXRlUmFuZ2VbMF0gPSBwcmV2aW91cyA/IHByZXZpb3VzLmJ5dGVSYW5nZUVuZE9mZnNldCA6IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ5dGVSYW5nZVswXSA9IHBhcnNlSW50KHBhcmFtc1sxXSk7XG4gICAgfVxuXG4gICAgYnl0ZVJhbmdlWzFdID0gcGFyc2VJbnQocGFyYW1zWzBdKSArIGJ5dGVSYW5nZVswXTtcbiAgICB0aGlzLl9ieXRlUmFuZ2UgPSBieXRlUmFuZ2U7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKEJhc2VTZWdtZW50LCBbe1xuICAgIGtleTogXCJieXRlUmFuZ2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghdGhpcy5fYnl0ZVJhbmdlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2J5dGVSYW5nZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnl0ZVJhbmdlU3RhcnRPZmZzZXRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVswXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnl0ZVJhbmdlRW5kT2Zmc2V0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVybFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLl91cmwgJiYgdGhpcy5iYXNldXJsICYmIHRoaXMucmVsdXJsKSB7XG4gICAgICAgIHRoaXMuX3VybCA9IE9iamVjdCh1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiYnVpbGRBYnNvbHV0ZVVSTFwiXSkodGhpcy5iYXNldXJsLCB0aGlzLnJlbHVybCwge1xuICAgICAgICAgIGFsd2F5c05vcm1hbGl6ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3VybCB8fCAnJztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl91cmwgPSB2YWx1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZVNlZ21lbnQ7XG59KCk7XG52YXIgRnJhZ21lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlU2VnbWVudCkge1xuICBfaW5oZXJpdHNMb29zZShGcmFnbWVudCwgX0Jhc2VTZWdtZW50KTtcblxuICAvLyBFWFRJTkYgaGFzIHRvIGJlIHByZXNlbnQgZm9yIGEgbTN1OCB0byBiZSBjb25zaWRlcmVkIHZhbGlkXG4gIC8vIHNuIG5vdGF0ZXMgdGhlIHNlcXVlbmNlIG51bWJlciBmb3IgYSBzZWdtZW50LCBhbmQgaWYgc2V0IHRvIGEgc3RyaW5nIGNhbiBiZSAnaW5pdFNlZ21lbnQnXG4gIC8vIGxldmVsa2V5IGlzIHRoZSBFWFQtWC1LRVkgdGhhdCBhcHBsaWVzIHRvIHRoaXMgc2VnbWVudCBmb3IgZGVjcnlwdGlvblxuICAvLyBjb3JlIGRpZmZlcmVuY2UgZnJvbSB0aGUgcHJpdmF0ZSBmaWVsZCBfZGVjcnlwdGRhdGEgaXMgdGhlIGxhY2sgb2YgdGhlIGluaXRpYWxpemVkIElWXG4gIC8vIF9kZWNyeXB0ZGF0YSB3aWxsIHNldCB0aGUgSVYgZm9yIHRoaXMgc2VnbWVudCBiYXNlZCBvbiB0aGUgc2VnbWVudCBudW1iZXIgaW4gdGhlIGZyYWdtZW50XG4gIC8vIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZnJhZ21lbnQgdHlwZVxuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgbG9hZGVyLiBTZXQgd2hpbGUgdGhlIGZyYWdtZW50IGlzIGxvYWRpbmcsIGFuZCByZW1vdmVkIGFmdGVyd2FyZHMuIFVzZWQgdG8gYWJvcnQgZnJhZ21lbnQgbG9hZGluZ1xuICAvLyBUaGUgbGV2ZWwvdHJhY2sgaW5kZXggdG8gd2hpY2ggdGhlIGZyYWdtZW50IGJlbG9uZ3NcbiAgLy8gVGhlIGNvbnRpbnVpdHkgY291bnRlciBvZiB0aGUgZnJhZ21lbnRcbiAgLy8gVGhlIHN0YXJ0aW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAvLyBUaGUgZW5kaW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAvLyBUaGUgbGF0ZXN0IFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChQVFMpIGFwcGVuZGVkIHRvIHRoZSBidWZmZXIuXG4gIC8vIFRoZSBzdGFydGluZyBEZWNvZGUgVGltZSBTdGFtcCAoRFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgLy8gVGhlIGVuZGluZyBEZWNvZGUgVGltZSBTdGFtcCAoRFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgLy8gVGhlIHN0YXJ0IHRpbWUgb2YgdGhlIGZyYWdtZW50LCBhcyBsaXN0ZWQgaW4gdGhlIG1hbmlmZXN0LiBVcGRhdGVkIGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAvLyBTZXQgYnkgYHVwZGF0ZUZyYWdQVFNEVFNgIGluIGxldmVsLWhlbHBlclxuICAvLyBUaGUgbWF4aW11bSBzdGFydGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoYXVkaW8vdmlkZW8gUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgLy8gVGhlIG1pbmltdW0gZW5kaW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChhdWRpby92aWRlbyBQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAvLyBMb2FkL3BhcnNlIHRpbWluZyBpbmZvcm1hdGlvblxuICAvLyBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzZWdtZW50IHdhcyBkb3dubG9hZGVkIGluIG9yZGVyIHRvIHRlc3QgYml0cmF0ZSwgYW5kIHdhcyBub3QgYnVmZmVyZWRcbiAgLy8gI0VYVElORiAgc2VnbWVudCB0aXRsZVxuICAvLyBUaGUgTWVkaWEgSW5pdGlhbGl6YXRpb24gU2VjdGlvbiBmb3IgdGhpcyBzZWdtZW50XG4gIGZ1bmN0aW9uIEZyYWdtZW50KHR5cGUsIGJhc2V1cmwpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlU2VnbWVudC5jYWxsKHRoaXMsIGJhc2V1cmwpIHx8IHRoaXM7XG4gICAgX3RoaXMuX2RlY3J5cHRkYXRhID0gbnVsbDtcbiAgICBfdGhpcy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgIF90aGlzLnByb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgX3RoaXMudGFnTGlzdCA9IFtdO1xuICAgIF90aGlzLmR1cmF0aW9uID0gMDtcbiAgICBfdGhpcy5zbiA9IDA7XG4gICAgX3RoaXMubGV2ZWxrZXkgPSB2b2lkIDA7XG4gICAgX3RoaXMudHlwZSA9IHZvaWQgMDtcbiAgICBfdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIF90aGlzLmxldmVsID0gLTE7XG4gICAgX3RoaXMuY2MgPSAwO1xuICAgIF90aGlzLnN0YXJ0UFRTID0gdm9pZCAwO1xuICAgIF90aGlzLmVuZFBUUyA9IHZvaWQgMDtcbiAgICBfdGhpcy5hcHBlbmRlZFBUUyA9IHZvaWQgMDtcbiAgICBfdGhpcy5zdGFydERUUyA9IHZvaWQgMDtcbiAgICBfdGhpcy5lbmREVFMgPSB2b2lkIDA7XG4gICAgX3RoaXMuc3RhcnQgPSAwO1xuICAgIF90aGlzLmRlbHRhUFRTID0gdm9pZCAwO1xuICAgIF90aGlzLm1heFN0YXJ0UFRTID0gdm9pZCAwO1xuICAgIF90aGlzLm1pbkVuZFBUUyA9IHZvaWQgMDtcbiAgICBfdGhpcy5zdGF0cyA9IG5ldyBfbG9hZF9zdGF0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiTG9hZFN0YXRzXCJdKCk7XG4gICAgX3RoaXMudXJsSWQgPSAwO1xuICAgIF90aGlzLmRhdGEgPSB2b2lkIDA7XG4gICAgX3RoaXMuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICBfdGhpcy50aXRsZSA9IG51bGw7XG4gICAgX3RoaXMuaW5pdFNlZ21lbnQgPSBudWxsO1xuICAgIF90aGlzLnR5cGUgPSB0eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gRnJhZ21lbnQucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBVdGlsaXR5IG1ldGhvZCBmb3IgcGFyc2VMZXZlbFBsYXlsaXN0IHRvIGNyZWF0ZSBhbiBpbml0aWFsaXphdGlvbiB2ZWN0b3IgZm9yIGEgZ2l2ZW4gc2VnbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudE51bWJlciAtIHNlZ21lbnQgbnVtYmVyIHRvIGdlbmVyYXRlIElWIHdpdGhcbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAqL1xuICBfcHJvdG8yLmNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yID0gZnVuY3Rpb24gY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3Ioc2VnbWVudE51bWJlcikge1xuICAgIHZhciB1aW50OFZpZXcgPSBuZXcgVWludDhBcnJheSgxNik7XG5cbiAgICBmb3IgKHZhciBpID0gMTI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICB1aW50OFZpZXdbaV0gPSBzZWdtZW50TnVtYmVyID4+IDggKiAoMTUgLSBpKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVpbnQ4VmlldztcbiAgfVxuICAvKipcbiAgICogVXRpbGl0eSBtZXRob2QgZm9yIHBhcnNlTGV2ZWxQbGF5bGlzdCB0byBnZXQgYSBmcmFnbWVudCdzIGRlY3J5cHRpb24gZGF0YSBmcm9tIHRoZSBjdXJyZW50bHkgcGFyc2VkIGVuY3J5cHRpb24ga2V5IGRhdGFcbiAgICogQHBhcmFtIGxldmVsa2V5IC0gYSBwbGF5bGlzdCdzIGVuY3J5cHRpb24gaW5mb1xuICAgKiBAcGFyYW0gc2VnbWVudE51bWJlciAtIHRoZSBmcmFnbWVudCdzIHNlZ21lbnQgbnVtYmVyXG4gICAqIEByZXR1cm5zIHtMZXZlbEtleX0gLSBhbiBvYmplY3QgdG8gYmUgYXBwbGllZCBhcyBhIGZyYWdtZW50J3MgZGVjcnlwdGRhdGFcbiAgICovXG4gIDtcblxuICBfcHJvdG8yLnNldERlY3J5cHREYXRhRnJvbUxldmVsS2V5ID0gZnVuY3Rpb24gc2V0RGVjcnlwdERhdGFGcm9tTGV2ZWxLZXkobGV2ZWxrZXksIHNlZ21lbnROdW1iZXIpIHtcbiAgICB2YXIgZGVjcnlwdGRhdGEgPSBsZXZlbGtleTtcblxuICAgIGlmICgobGV2ZWxrZXkgPT09IG51bGwgfHwgbGV2ZWxrZXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxldmVsa2V5Lm1ldGhvZCkgPT09ICdBRVMtMTI4JyAmJiBsZXZlbGtleS51cmkgJiYgIWxldmVsa2V5Lml2KSB7XG4gICAgICBkZWNyeXB0ZGF0YSA9IF9sZXZlbF9rZXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkxldmVsS2V5XCJdLmZyb21VUkkobGV2ZWxrZXkudXJpKTtcbiAgICAgIGRlY3J5cHRkYXRhLm1ldGhvZCA9IGxldmVsa2V5Lm1ldGhvZDtcbiAgICAgIGRlY3J5cHRkYXRhLml2ID0gdGhpcy5jcmVhdGVJbml0aWFsaXphdGlvblZlY3RvcihzZWdtZW50TnVtYmVyKTtcbiAgICAgIGRlY3J5cHRkYXRhLmtleUZvcm1hdCA9ICdpZGVudGl0eSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY3J5cHRkYXRhO1xuICB9O1xuXG4gIF9wcm90bzIuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8gPSBmdW5jdGlvbiBzZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyh0eXBlLCBzdGFydFBUUywgZW5kUFRTLCBzdGFydERUUywgZW5kRFRTLCBwYXJ0aWFsKSB7XG4gICAgaWYgKHBhcnRpYWwgPT09IHZvaWQgMCkge1xuICAgICAgcGFydGlhbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50YXJ5U3RyZWFtcyA9IHRoaXMuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgdmFyIGluZm8gPSBlbGVtZW50YXJ5U3RyZWFtc1t0eXBlXTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgZWxlbWVudGFyeVN0cmVhbXNbdHlwZV0gPSB7XG4gICAgICAgIHN0YXJ0UFRTOiBzdGFydFBUUyxcbiAgICAgICAgZW5kUFRTOiBlbmRQVFMsXG4gICAgICAgIHN0YXJ0RFRTOiBzdGFydERUUyxcbiAgICAgICAgZW5kRFRTOiBlbmREVFMsXG4gICAgICAgIHBhcnRpYWw6IHBhcnRpYWxcbiAgICAgIH07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5mby5zdGFydFBUUyA9IE1hdGgubWluKGluZm8uc3RhcnRQVFMsIHN0YXJ0UFRTKTtcbiAgICBpbmZvLmVuZFBUUyA9IE1hdGgubWF4KGluZm8uZW5kUFRTLCBlbmRQVFMpO1xuICAgIGluZm8uc3RhcnREVFMgPSBNYXRoLm1pbihpbmZvLnN0YXJ0RFRTLCBzdGFydERUUyk7XG4gICAgaW5mby5lbmREVFMgPSBNYXRoLm1heChpbmZvLmVuZERUUywgZW5kRFRTKTtcbiAgfTtcblxuICBfcHJvdG8yLmNsZWFyRWxlbWVudGFyeVN0cmVhbUluZm8gPSBmdW5jdGlvbiBjbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCkge1xuICAgIHZhciBlbGVtZW50YXJ5U3RyZWFtcyA9IHRoaXMuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IG51bGw7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXSA9IG51bGw7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPVklERU9dID0gbnVsbDtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoRnJhZ21lbnQsIFt7XG4gICAga2V5OiBcImRlY3J5cHRkYXRhXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMubGV2ZWxrZXkgJiYgIXRoaXMuX2RlY3J5cHRkYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2RlY3J5cHRkYXRhICYmIHRoaXMubGV2ZWxrZXkpIHtcbiAgICAgICAgdmFyIHNuID0gdGhpcy5zbjtcblxuICAgICAgICBpZiAodHlwZW9mIHNuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIC8vIFdlIGFyZSBmZXRjaGluZyBkZWNyeXB0aW9uIGRhdGEgZm9yIGEgaW5pdGlhbGl6YXRpb24gc2VnbWVudFxuICAgICAgICAgIC8vIElmIHRoZSBzZWdtZW50IHdhcyBlbmNyeXB0ZWQgd2l0aCBBRVMtMTI4XG4gICAgICAgICAgLy8gSXQgbXVzdCBoYXZlIGFuIElWIGRlZmluZWQuIFdlIGNhbm5vdCBzdWJzdGl0dXRlIHRoZSBTZWdtZW50IE51bWJlciBpbi5cbiAgICAgICAgICBpZiAodGhpcy5sZXZlbGtleSAmJiB0aGlzLmxldmVsa2V5Lm1ldGhvZCA9PT0gJ0FFUy0xMjgnICYmICF0aGlzLmxldmVsa2V5Lml2KSB7XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybihcIm1pc3NpbmcgSVYgZm9yIGluaXRpYWxpemF0aW9uIHNlZ21lbnQgd2l0aCBtZXRob2Q9XFxcIlwiICsgdGhpcy5sZXZlbGtleS5tZXRob2QgKyBcIlxcXCIgLSBjb21wbGlhbmNlIGlzc3VlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKlxuICAgICAgICAgIEJlIGNvbnZlcnRlZCB0byBhIE51bWJlci5cbiAgICAgICAgICAnaW5pdFNlZ21lbnQnIHdpbGwgYmVjb21lIE5hTi5cbiAgICAgICAgICBOYU4sIHdoaWNoIHdoZW4gY29udmVydGVkIHRocm91Z2ggVG9JbnQzMigpIC0+ICswLlxuICAgICAgICAgIC0tLVxuICAgICAgICAgIEV4cGxpY2l0bHkgc2V0IHNuIHRvIHJlc3VsdGluZyB2YWx1ZSBmcm9tIGltcGxpY2l0IGNvbnZlcnNpb25zICdpbml0U2VnbWVudCcgdmFsdWVzIGZvciBJViBnZW5lcmF0aW9uLlxuICAgICAgICAgICovXG5cblxuICAgICAgICAgIHNuID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RlY3J5cHRkYXRhID0gdGhpcy5zZXREZWNyeXB0RGF0YUZyb21MZXZlbEtleSh0aGlzLmxldmVsa2V5LCBzbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9kZWNyeXB0ZGF0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFByb2dyYW1EYXRlVGltZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHRoaXMucHJvZ3JhbURhdGVUaW1lID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIU9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkodGhpcy5wcm9ncmFtRGF0ZVRpbWUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHVyYXRpb24gPSAhT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKSh0aGlzLmR1cmF0aW9uKSA/IDAgOiB0aGlzLmR1cmF0aW9uO1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3JhbURhdGVUaW1lICsgZHVyYXRpb24gKiAxMDAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmNyeXB0ZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfdGhpcyRkZWNyeXB0ZGF0YTtcblxuICAgICAgLy8gQXQgdGhlIG0zdTgtcGFyc2VyIGxldmVsIHdlIG5lZWQgdG8gYWRkIHN1cHBvcnQgZm9yIG1hbmlmZXN0IHNpZ25hbGxlZCBrZXlmb3JtYXRzXG4gICAgICAvLyB3aGVuIHdlIHdhbnQgdGhlIGZyYWdtZW50IHRvIHN0YXJ0IHJlcG9ydGluZyB0aGF0IGl0IGlzIGVuY3J5cHRlZC5cbiAgICAgIC8vIEN1cnJlbnRseSwga2V5Rm9ybWF0IHdpbGwgb25seSBiZSBzZXQgZm9yIGlkZW50aXR5IGtleXNcbiAgICAgIGlmICgoX3RoaXMkZGVjcnlwdGRhdGEgPSB0aGlzLmRlY3J5cHRkYXRhKSAhPT0gbnVsbCAmJiBfdGhpcyRkZWNyeXB0ZGF0YSAhPT0gdm9pZCAwICYmIF90aGlzJGRlY3J5cHRkYXRhLmtleUZvcm1hdCAmJiB0aGlzLmRlY3J5cHRkYXRhLnVyaSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGcmFnbWVudDtcbn0oQmFzZVNlZ21lbnQpO1xudmFyIFBhcnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlU2VnbWVudDIpIHtcbiAgX2luaGVyaXRzTG9vc2UoUGFydCwgX0Jhc2VTZWdtZW50Mik7XG5cbiAgZnVuY3Rpb24gUGFydChwYXJ0QXR0cnMsIGZyYWcsIGJhc2V1cmwsIGluZGV4LCBwcmV2aW91cykge1xuICAgIHZhciBfdGhpczI7XG5cbiAgICBfdGhpczIgPSBfQmFzZVNlZ21lbnQyLmNhbGwodGhpcywgYmFzZXVybCkgfHwgdGhpcztcbiAgICBfdGhpczIuZnJhZ09mZnNldCA9IDA7XG4gICAgX3RoaXMyLmR1cmF0aW9uID0gMDtcbiAgICBfdGhpczIuZ2FwID0gZmFsc2U7XG4gICAgX3RoaXMyLmluZGVwZW5kZW50ID0gZmFsc2U7XG4gICAgX3RoaXMyLnJlbHVybCA9IHZvaWQgMDtcbiAgICBfdGhpczIuZnJhZ21lbnQgPSB2b2lkIDA7XG4gICAgX3RoaXMyLmluZGV4ID0gdm9pZCAwO1xuICAgIF90aGlzMi5zdGF0cyA9IG5ldyBfbG9hZF9zdGF0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiTG9hZFN0YXRzXCJdKCk7XG4gICAgX3RoaXMyLmR1cmF0aW9uID0gcGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdEVVJBVElPTicpO1xuICAgIF90aGlzMi5nYXAgPSBwYXJ0QXR0cnMuYm9vbCgnR0FQJyk7XG4gICAgX3RoaXMyLmluZGVwZW5kZW50ID0gcGFydEF0dHJzLmJvb2woJ0lOREVQRU5ERU5UJyk7XG4gICAgX3RoaXMyLnJlbHVybCA9IHBhcnRBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdVUkknKTtcbiAgICBfdGhpczIuZnJhZ21lbnQgPSBmcmFnO1xuICAgIF90aGlzMi5pbmRleCA9IGluZGV4O1xuICAgIHZhciBieXRlUmFuZ2UgPSBwYXJ0QXR0cnMuZW51bWVyYXRlZFN0cmluZygnQllURVJBTkdFJyk7XG5cbiAgICBpZiAoYnl0ZVJhbmdlKSB7XG4gICAgICBfdGhpczIuc2V0Qnl0ZVJhbmdlKGJ5dGVSYW5nZSwgcHJldmlvdXMpO1xuICAgIH1cblxuICAgIGlmIChwcmV2aW91cykge1xuICAgICAgX3RoaXMyLmZyYWdPZmZzZXQgPSBwcmV2aW91cy5mcmFnT2Zmc2V0ICsgcHJldmlvdXMuZHVyYXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQYXJ0LCBbe1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnQuc3RhcnQgKyB0aGlzLmZyYWdPZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2FkZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBlbGVtZW50YXJ5U3RyZWFtcyA9IHRoaXMuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgICByZXR1cm4gISEoZWxlbWVudGFyeVN0cmVhbXMuYXVkaW8gfHwgZWxlbWVudGFyeVN0cmVhbXMudmlkZW8gfHwgZWxlbWVudGFyeVN0cmVhbXMuYXVkaW92aWRlbyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhcnQ7XG59KEJhc2VTZWdtZW50KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbG9hZGVyL2tleS1sb2FkZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL2tleS1sb2FkZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gS2V5TG9hZGVyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qXG4gKiBEZWNyeXB0IGtleSBMb2FkZXJcbiAqL1xuXG5cblxuXG52YXIgS2V5TG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gS2V5TG9hZGVyKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICAgIHRoaXMuZGVjcnlwdGtleSA9IG51bGw7XG4gICAgdGhpcy5kZWNyeXB0dXJsID0gbnVsbDtcbiAgICB0aGlzLmhscyA9IGhscztcblxuICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gS2V5TG9hZGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX3JlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5LRVlfTE9BRElORywgdGhpcy5vbktleUxvYWRpbmcsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5fdW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uS0VZX0xPQURJTkcsIHRoaXMub25LZXlMb2FkaW5nKTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuXG4gICAgZm9yICh2YXIgbG9hZGVyTmFtZSBpbiB0aGlzLmxvYWRlcnMpIHtcbiAgICAgIHZhciBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbbG9hZGVyTmFtZV07XG5cbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgfTtcblxuICBfcHJvdG8ub25LZXlMb2FkaW5nID0gZnVuY3Rpb24gb25LZXlMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgdmFyIHR5cGUgPSBmcmFnLnR5cGU7XG4gICAgdmFyIGxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXTtcblxuICAgIGlmICghZnJhZy5kZWNyeXB0ZGF0YSkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLndhcm4oJ01pc3NpbmcgZGVjcnlwdGlvbiBkYXRhIG9uIGZyYWdtZW50IGluIG9uS2V5TG9hZGluZycpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gTG9hZCB0aGUga2V5IGlmIHRoZSB1cmkgaXMgZGlmZmVyZW50IGZyb20gcHJldmlvdXMgb25lLCBvciBpZiB0aGUgZGVjcnlwdCBrZXkgaGFzIG5vdCB5ZXQgYmVlbiByZXRyaWV2ZWRcblxuXG4gICAgdmFyIHVyaSA9IGZyYWcuZGVjcnlwdGRhdGEudXJpO1xuXG4gICAgaWYgKHVyaSAhPT0gdGhpcy5kZWNyeXB0dXJsIHx8IHRoaXMuZGVjcnlwdGtleSA9PT0gbnVsbCkge1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcblxuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybihcImFib3J0IHByZXZpb3VzIGtleSBsb2FkZXIgZm9yIHR5cGU6XCIgKyB0eXBlKTtcbiAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdXJpKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKCdrZXkgdXJpIGlzIGZhbHN5Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIExvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgICB2YXIgZnJhZ0xvYWRlciA9IGZyYWcubG9hZGVyID0gdGhpcy5sb2FkZXJzW3R5cGVdID0gbmV3IExvYWRlcihjb25maWcpO1xuICAgICAgdGhpcy5kZWNyeXB0dXJsID0gdXJpO1xuICAgICAgdGhpcy5kZWNyeXB0a2V5ID0gbnVsbDtcbiAgICAgIHZhciBsb2FkZXJDb250ZXh0ID0ge1xuICAgICAgICB1cmw6IHVyaSxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInXG4gICAgICB9OyAvLyBtYXhSZXRyeSBpcyAwIHNvIHRoYXQgaW5zdGVhZCBvZiByZXRyeWluZyB0aGUgc2FtZSBrZXkgb24gdGhlIHNhbWUgdmFyaWFudCBtdWx0aXBsZSB0aW1lcyxcbiAgICAgIC8vIGtleS1sb2FkZXIgd2lsbCB0cmlnZ2VyIGFuIGVycm9yIGFuZCByZWx5IG9uIHN0cmVhbS1jb250cm9sbGVyIHRvIGhhbmRsZSByZXRyeSBsb2dpYy5cbiAgICAgIC8vIHRoaXMgd2lsbCBhbHNvIGFsaWduIHJldHJ5IGxvZ2ljIHdpdGggZnJhZ21lbnQtbG9hZGVyXG5cbiAgICAgIHZhciBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgIHRpbWVvdXQ6IGNvbmZpZy5mcmFnTG9hZGluZ1RpbWVPdXQsXG4gICAgICAgIG1heFJldHJ5OiAwLFxuICAgICAgICByZXRyeURlbGF5OiBjb25maWcuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LFxuICAgICAgICBtYXhSZXRyeURlbGF5OiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQsXG4gICAgICAgIGhpZ2hXYXRlck1hcms6IDBcbiAgICAgIH07XG4gICAgICB2YXIgbG9hZGVyQ2FsbGJhY2tzID0ge1xuICAgICAgICBvblN1Y2Nlc3M6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSxcbiAgICAgICAgb25FcnJvcjogdGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSxcbiAgICAgICAgb25UaW1lb3V0OiB0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcylcbiAgICAgIH07XG4gICAgICBmcmFnTG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kZWNyeXB0a2V5KSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIGtleSBpZiBpdCdzIGFscmVhZHkgYmVlbiBsb2FkZWRcbiAgICAgIGZyYWcuZGVjcnlwdGRhdGEua2V5ID0gdGhpcy5kZWNyeXB0a2V5O1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uS0VZX0xPQURFRCwge1xuICAgICAgICBmcmFnOiBmcmFnXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRzdWNjZXNzID0gZnVuY3Rpb24gbG9hZHN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0KSB7XG4gICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWc7XG5cbiAgICBpZiAoIWZyYWcuZGVjcnlwdGRhdGEpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcignYWZ0ZXIga2V5IGxvYWQsIGRlY3J5cHRkYXRhIHVuc2V0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kZWNyeXB0a2V5ID0gZnJhZy5kZWNyeXB0ZGF0YS5rZXkgPSBuZXcgVWludDhBcnJheShyZXNwb25zZS5kYXRhKTsgLy8gZGV0YWNoIGZyYWdtZW50IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcblxuICAgIGZyYWcubG9hZGVyID0gbnVsbDtcbiAgICBkZWxldGUgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV07XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uS0VZX0xPQURFRCwge1xuICAgICAgZnJhZzogZnJhZ1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5sb2FkZXJyb3IgPSBmdW5jdGlvbiBsb2FkZXJyb3IocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgICB2YXIgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICB2YXIgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG5cbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV07XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uTkVUV09SS19FUlJPUixcbiAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfTE9BRF9FUlJPUixcbiAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgIGZyYWc6IGZyYWcsXG4gICAgICByZXNwb25zZTogcmVzcG9uc2VcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ubG9hZHRpbWVvdXQgPSBmdW5jdGlvbiBsb2FkdGltZW91dChzdGF0cywgY29udGV4dCkge1xuICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgIHZhciBsb2FkZXIgPSBmcmFnLmxvYWRlcjtcblxuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5ORVRXT1JLX0VSUk9SLFxuICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9MT0FEX1RJTUVPVVQsXG4gICAgICBmYXRhbDogZmFsc2UsXG4gICAgICBmcmFnOiBmcmFnXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEtleUxvYWRlcjtcbn0oKTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9sZXZlbC1kZXRhaWxzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xvYWRlci9sZXZlbC1kZXRhaWxzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IExldmVsRGV0YWlscyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJMZXZlbERldGFpbHNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBMZXZlbERldGFpbHM7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuXG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIERFRkFVTFRfVEFSR0VUX0RVUkFUSU9OID0gMTA7XG52YXIgTGV2ZWxEZXRhaWxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gTWFuaWZlc3QgcmVsb2FkIHN5bmNocm9uaXphdGlvblxuICBmdW5jdGlvbiBMZXZlbERldGFpbHMoYmFzZVVybCkge1xuICAgIHRoaXMuUFRTS25vd24gPSBmYWxzZTtcbiAgICB0aGlzLmFsaWduZWRTbGlkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5lbmRDQyA9IDA7XG4gICAgdGhpcy5lbmRTTiA9IDA7XG4gICAgdGhpcy5mcmFnbWVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFnbWVudEhpbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJ0TGlzdCA9IG51bGw7XG4gICAgdGhpcy5kYXRlUmFuZ2VzID0gdm9pZCAwO1xuICAgIHRoaXMubGl2ZSA9IHRydWU7XG4gICAgdGhpcy5hZ2VIZWFkZXIgPSAwO1xuICAgIHRoaXMuYWR2YW5jZWREYXRlVGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLnVwZGF0ZWQgPSB0cnVlO1xuICAgIHRoaXMuYWR2YW5jZWQgPSB0cnVlO1xuICAgIHRoaXMuYXZhaWxhYmlsaXR5RGVsYXkgPSB2b2lkIDA7XG4gICAgdGhpcy5taXNzZXMgPSAwO1xuICAgIHRoaXMubmVlZFNpZHhSYW5nZXMgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0Q0MgPSAwO1xuICAgIHRoaXMuc3RhcnRTTiA9IDA7XG4gICAgdGhpcy5zdGFydFRpbWVPZmZzZXQgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0ZHVyYXRpb24gPSAwO1xuICAgIHRoaXMudG90YWxkdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50eXBlID0gbnVsbDtcbiAgICB0aGlzLnVybCA9IHZvaWQgMDtcbiAgICB0aGlzLm0zdTggPSAnJztcbiAgICB0aGlzLnZlcnNpb24gPSBudWxsO1xuICAgIHRoaXMuY2FuQmxvY2tSZWxvYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblNraXBVbnRpbCA9IDA7XG4gICAgdGhpcy5jYW5Ta2lwRGF0ZVJhbmdlcyA9IGZhbHNlO1xuICAgIHRoaXMuc2tpcHBlZFNlZ21lbnRzID0gMDtcbiAgICB0aGlzLnJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJ0SG9sZEJhY2sgPSAwO1xuICAgIHRoaXMuaG9sZEJhY2sgPSAwO1xuICAgIHRoaXMucGFydFRhcmdldCA9IDA7XG4gICAgdGhpcy5wcmVsb2FkSGludCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlbmRpdGlvblJlcG9ydHMgPSB2b2lkIDA7XG4gICAgdGhpcy50dW5lSW5Hb2FsID0gMDtcbiAgICB0aGlzLmRlbHRhVXBkYXRlRmFpbGVkID0gdm9pZCAwO1xuICAgIHRoaXMuZHJpZnRTdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuZHJpZnRFbmRUaW1lID0gMDtcbiAgICB0aGlzLmRyaWZ0U3RhcnQgPSAwO1xuICAgIHRoaXMuZHJpZnRFbmQgPSAwO1xuICAgIHRoaXMuZnJhZ21lbnRzID0gW107XG4gICAgdGhpcy5kYXRlUmFuZ2VzID0ge307XG4gICAgdGhpcy51cmwgPSBiYXNlVXJsO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IExldmVsRGV0YWlscy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbG9hZGVkID0gZnVuY3Rpb24gcmVsb2FkZWQocHJldmlvdXMpIHtcbiAgICBpZiAoIXByZXZpb3VzKSB7XG4gICAgICB0aGlzLmFkdmFuY2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlZCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhcnRTbkRpZmYgPSB0aGlzLmxhc3RQYXJ0U24gLSBwcmV2aW91cy5sYXN0UGFydFNuO1xuICAgIHZhciBwYXJ0SW5kZXhEaWZmID0gdGhpcy5sYXN0UGFydEluZGV4IC0gcHJldmlvdXMubGFzdFBhcnRJbmRleDtcbiAgICB0aGlzLnVwZGF0ZWQgPSB0aGlzLmVuZFNOICE9PSBwcmV2aW91cy5lbmRTTiB8fCAhIXBhcnRJbmRleERpZmYgfHwgISFwYXJ0U25EaWZmO1xuICAgIHRoaXMuYWR2YW5jZWQgPSB0aGlzLmVuZFNOID4gcHJldmlvdXMuZW5kU04gfHwgcGFydFNuRGlmZiA+IDAgfHwgcGFydFNuRGlmZiA9PT0gMCAmJiBwYXJ0SW5kZXhEaWZmID4gMDtcblxuICAgIGlmICh0aGlzLnVwZGF0ZWQgfHwgdGhpcy5hZHZhbmNlZCkge1xuICAgICAgdGhpcy5taXNzZXMgPSBNYXRoLmZsb29yKHByZXZpb3VzLm1pc3NlcyAqIDAuNik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWlzc2VzID0gcHJldmlvdXMubWlzc2VzICsgMTtcbiAgICB9XG5cbiAgICB0aGlzLmF2YWlsYWJpbGl0eURlbGF5ID0gcHJldmlvdXMuYXZhaWxhYmlsaXR5RGVsYXk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKExldmVsRGV0YWlscywgW3tcbiAgICBrZXk6IFwiaGFzUHJvZ3JhbURhdGVUaW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKHRoaXMuZnJhZ21lbnRzW3RoaXMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdLnByb2dyYW1EYXRlVGltZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGV2ZWxUYXJnZXREdXJhdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXZlcmFnZXRhcmdldGR1cmF0aW9uIHx8IHRoaXMudGFyZ2V0ZHVyYXRpb24gfHwgREVGQVVMVF9UQVJHRVRfRFVSQVRJT047XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyaWZ0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcnVuVGltZSA9IHRoaXMuZHJpZnRFbmRUaW1lIC0gdGhpcy5kcmlmdFN0YXJ0VGltZTtcblxuICAgICAgaWYgKHJ1blRpbWUgPiAwKSB7XG4gICAgICAgIHZhciBydW5EdXJhdGlvbiA9IHRoaXMuZHJpZnRFbmQgLSB0aGlzLmRyaWZ0U3RhcnQ7XG4gICAgICAgIHJldHVybiBydW5EdXJhdGlvbiAqIDEwMDAgLyBydW5UaW1lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWRnZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFydEVuZCB8fCB0aGlzLmZyYWdtZW50RW5kO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJ0RW5kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMkcGFydExpc3Q7XG5cbiAgICAgIGlmICgoX3RoaXMkcGFydExpc3QgPSB0aGlzLnBhcnRMaXN0KSAhPT0gbnVsbCAmJiBfdGhpcyRwYXJ0TGlzdCAhPT0gdm9pZCAwICYmIF90aGlzJHBhcnRMaXN0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0TGlzdFt0aGlzLnBhcnRMaXN0Lmxlbmd0aCAtIDFdLmVuZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRFbmQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyYWdtZW50RW5kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMkZnJhZ21lbnRzO1xuXG4gICAgICBpZiAoKF90aGlzJGZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzKSAhPT0gbnVsbCAmJiBfdGhpcyRmcmFnbWVudHMgIT09IHZvaWQgMCAmJiBfdGhpcyRmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdtZW50cy5sZW5ndGggLSAxXS5lbmQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZ2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLmFkdmFuY2VkRGF0ZVRpbWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KERhdGUubm93KCkgLSB0aGlzLmFkdmFuY2VkRGF0ZVRpbWUsIDApIC8gMTAwMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxhc3RQYXJ0SW5kZXhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfdGhpcyRwYXJ0TGlzdDI7XG5cbiAgICAgIGlmICgoX3RoaXMkcGFydExpc3QyID0gdGhpcy5wYXJ0TGlzdCkgIT09IG51bGwgJiYgX3RoaXMkcGFydExpc3QyICE9PSB2b2lkIDAgJiYgX3RoaXMkcGFydExpc3QyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0TGlzdFt0aGlzLnBhcnRMaXN0Lmxlbmd0aCAtIDFdLmluZGV4O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxhc3RQYXJ0U25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfdGhpcyRwYXJ0TGlzdDM7XG5cbiAgICAgIGlmICgoX3RoaXMkcGFydExpc3QzID0gdGhpcy5wYXJ0TGlzdCkgIT09IG51bGwgJiYgX3RoaXMkcGFydExpc3QzICE9PSB2b2lkIDAgJiYgX3RoaXMkcGFydExpc3QzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0TGlzdFt0aGlzLnBhcnRMaXN0Lmxlbmd0aCAtIDFdLmZyYWdtZW50LnNuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lbmRTTjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGV2ZWxEZXRhaWxzO1xufSgpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sb2FkZXIvbGV2ZWwta2V5LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL2xldmVsLWtleS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IExldmVsS2V5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkxldmVsS2V5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTGV2ZWxLZXk7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB1cmwtdG9vbGtpdCAqLyBcIi4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cbnZhciBMZXZlbEtleSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIExldmVsS2V5LmZyb21VUkwgPSBmdW5jdGlvbiBmcm9tVVJMKGJhc2VVcmwsIHJlbGF0aXZlVXJsKSB7XG4gICAgcmV0dXJuIG5ldyBMZXZlbEtleShiYXNlVXJsLCByZWxhdGl2ZVVybCk7XG4gIH07XG5cbiAgTGV2ZWxLZXkuZnJvbVVSSSA9IGZ1bmN0aW9uIGZyb21VUkkodXJpKSB7XG4gICAgcmV0dXJuIG5ldyBMZXZlbEtleSh1cmkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIExldmVsS2V5KGFic29sdXRlT3JCYXNlVVJJLCByZWxhdGl2ZVVSTCkge1xuICAgIHRoaXMuX3VyaSA9IG51bGw7XG4gICAgdGhpcy5tZXRob2QgPSBudWxsO1xuICAgIHRoaXMua2V5Rm9ybWF0ID0gbnVsbDtcbiAgICB0aGlzLmtleUZvcm1hdFZlcnNpb25zID0gbnVsbDtcbiAgICB0aGlzLmtleUlEID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgdGhpcy5pdiA9IG51bGw7XG5cbiAgICBpZiAocmVsYXRpdmVVUkwpIHtcbiAgICAgIHRoaXMuX3VyaSA9IE9iamVjdCh1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiYnVpbGRBYnNvbHV0ZVVSTFwiXSkoYWJzb2x1dGVPckJhc2VVUkksIHJlbGF0aXZlVVJMLCB7XG4gICAgICAgIGFsd2F5c05vcm1hbGl6ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VyaSA9IGFic29sdXRlT3JCYXNlVVJJO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMZXZlbEtleSwgW3tcbiAgICBrZXk6IFwidXJpXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMZXZlbEtleTtcbn0oKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbG9hZGVyL2xvYWQtc3RhdHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL2xvYWQtc3RhdHMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogTG9hZFN0YXRzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkxvYWRTdGF0c1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExvYWRTdGF0czsgfSk7XG52YXIgTG9hZFN0YXRzID0gZnVuY3Rpb24gTG9hZFN0YXRzKCkge1xuICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgdGhpcy5sb2FkZWQgPSAwO1xuICB0aGlzLnJldHJ5ID0gMDtcbiAgdGhpcy50b3RhbCA9IDA7XG4gIHRoaXMuY2h1bmtDb3VudCA9IDA7XG4gIHRoaXMuYndFc3RpbWF0ZSA9IDA7XG4gIHRoaXMubG9hZGluZyA9IHtcbiAgICBzdGFydDogMCxcbiAgICBmaXJzdDogMCxcbiAgICBlbmQ6IDBcbiAgfTtcbiAgdGhpcy5wYXJzaW5nID0ge1xuICAgIHN0YXJ0OiAwLFxuICAgIGVuZDogMFxuICB9O1xuICB0aGlzLmJ1ZmZlcmluZyA9IHtcbiAgICBzdGFydDogMCxcbiAgICBmaXJzdDogMCxcbiAgICBlbmQ6IDBcbiAgfTtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9tM3U4LXBhcnNlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL20zdTgtcGFyc2VyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBNM1U4UGFyc2VyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdXJsLXRvb2xraXQgKi8gXCIuL25vZGVfbW9kdWxlcy91cmwtdG9vbGtpdC9zcmMvdXJsLXRvb2xraXQuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdXJsX3Rvb2xraXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGF0ZV9yYW5nZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kYXRlLXJhbmdlICovIFwiLi9zcmMvbG9hZGVyL2RhdGUtcmFuZ2UudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZyYWdtZW50ICovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sZXZlbF9kZXRhaWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xldmVsLWRldGFpbHMgKi8gXCIuL3NyYy9sb2FkZXIvbGV2ZWwtZGV0YWlscy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbGV2ZWxfa2V5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xldmVsLWtleSAqLyBcIi4vc3JjL2xvYWRlci9sZXZlbC1rZXkudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYXR0ci1saXN0ICovIFwiLi9zcmMvdXRpbHMvYXR0ci1saXN0LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY29kZWNzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9jb2RlY3MgKi8gXCIuL3NyYy91dGlscy9jb2RlY3MudHNcIik7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vLyBodHRwczovL3JlZ2V4MTAxLmNvbSBpcyB5b3VyIGZyaWVuZFxudmFyIE1BU1RFUl9QTEFZTElTVF9SRUdFWCA9IC8jRVhULVgtU1RSRUFNLUlORjooW15cXHJcXG5dKikoPzpbXFxyXFxuXSg/OiNbXlxcclxcbl0qKT8pKihbXlxcclxcbl0rKXwjRVhULVgtU0VTU0lPTi1EQVRBOihbXlxcclxcbl0qKVtcXHJcXG5dKy9nO1xudmFyIE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCA9IC8jRVhULVgtTUVESUE6KC4qKS9nO1xudmFyIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QgPSBuZXcgUmVnRXhwKFsvI0VYVElORjpcXHMqKFxcZCooPzpcXC5cXGQrKT8pKD86LCguKilcXHMrKT8vLnNvdXJjZSwgLy8gZHVyYXRpb24gKCNFWFRJTkY6PGR1cmF0aW9uPiw8dGl0bGU+KSwgZ3JvdXAgMSA9PiBkdXJhdGlvbiwgZ3JvdXAgMiA9PiB0aXRsZVxuLyg/ISMpICooXFxTW1xcUyBdKikvLnNvdXJjZSwgLy8gc2VnbWVudCBVUkksIGdyb3VwIDMgPT4gdGhlIFVSSSAobm90ZSBuZXdsaW5lIGlzIG5vdCBlYXRlbilcbi8jRVhULVgtQllURVJBTkdFOiooLispLy5zb3VyY2UsIC8vIG5leHQgc2VnbWVudCdzIGJ5dGVyYW5nZSwgZ3JvdXAgNCA9PiByYW5nZSBzcGVjICh4QHkpXG4vI0VYVC1YLVBST0dSQU0tREFURS1USU1FOiguKykvLnNvdXJjZSwgLy8gbmV4dCBzZWdtZW50J3MgcHJvZ3JhbSBkYXRlL3RpbWUgZ3JvdXAgNSA9PiB0aGUgZGF0ZXRpbWUgc3BlY1xuLyMuKi8uc291cmNlIC8vIEFsbCBvdGhlciBub24tc2VnbWVudCBvcmllbnRlZCB0YWdzIHdpbGwgbWF0Y2ggd2l0aCBhbGwgZ3JvdXBzIGVtcHR5XG5dLmpvaW4oJ3wnKSwgJ2cnKTtcbnZhciBMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XID0gbmV3IFJlZ0V4cChbLyMoRVhUTTNVKS8uc291cmNlLCAvI0VYVC1YLShEQVRFUkFOR0V8S0VZfE1BUHxQQVJUfFBBUlQtSU5GfFBMQVlMSVNULVRZUEV8UFJFTE9BRC1ISU5UfFJFTkRJVElPTi1SRVBPUlR8U0VSVkVSLUNPTlRST0x8U0tJUHxTVEFSVCk6KC4rKS8uc291cmNlLCAvI0VYVC1YLShCSVRSQVRFfERJU0NPTlRJTlVJVFktU0VRVUVOQ0V8TUVESUEtU0VRVUVOQ0V8VEFSR0VURFVSQVRJT058VkVSU0lPTik6ICooXFxkKykvLnNvdXJjZSwgLyNFWFQtWC0oRElTQ09OVElOVUlUWXxFTkRMSVNUfEdBUCkvLnNvdXJjZSwgLygjKShbXjpdKik6KC4qKS8uc291cmNlLCAvKCMpKC4qKSg/Oi4qKVxccj9cXG4/Ly5zb3VyY2VdLmpvaW4oJ3wnKSk7XG52YXIgTVA0X1JFR0VYX1NVRkZJWCA9IC9cXC4obXA0fG00c3xtNHZ8bTRhKSQvaTtcblxuZnVuY3Rpb24gaXNNUDRVcmwodXJsKSB7XG4gIHZhciBfVVJMVG9vbGtpdCRwYXJzZVVSTCQsIF9VUkxUb29sa2l0JHBhcnNlVVJMO1xuXG4gIHJldHVybiBNUDRfUkVHRVhfU1VGRklYLnRlc3QoKF9VUkxUb29sa2l0JHBhcnNlVVJMJCA9IChfVVJMVG9vbGtpdCRwYXJzZVVSTCA9IHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJwYXJzZVVSTFwiXSh1cmwpKSA9PT0gbnVsbCB8fCBfVVJMVG9vbGtpdCRwYXJzZVVSTCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX1VSTFRvb2xraXQkcGFyc2VVUkwucGF0aCkgIT0gbnVsbCA/IF9VUkxUb29sa2l0JHBhcnNlVVJMJCA6ICcnKTtcbn1cblxudmFyIE0zVThQYXJzZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNM1U4UGFyc2VyKCkge31cblxuICBNM1U4UGFyc2VyLmZpbmRHcm91cCA9IGZ1bmN0aW9uIGZpbmRHcm91cChncm91cHMsIG1lZGlhR3JvdXBJZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBncm91cHNbaV07XG5cbiAgICAgIGlmIChncm91cC5pZCA9PT0gbWVkaWFHcm91cElkKSB7XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgTTNVOFBhcnNlci5jb252ZXJ0QVZDMVRvQVZDT1RJID0gZnVuY3Rpb24gY29udmVydEFWQzFUb0FWQ09USShjb2RlYykge1xuICAgIC8vIENvbnZlcnQgYXZjMSBjb2RlYyBzdHJpbmcgZnJvbSBSRkMtNDI4MSB0byBSRkMtNjM4MSBmb3IgTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkXG4gICAgdmFyIGF2Y2RhdGEgPSBjb2RlYy5zcGxpdCgnLicpO1xuXG4gICAgaWYgKGF2Y2RhdGEubGVuZ3RoID4gMikge1xuICAgICAgdmFyIHJlc3VsdCA9IGF2Y2RhdGEuc2hpZnQoKSArICcuJztcbiAgICAgIHJlc3VsdCArPSBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgIHJlc3VsdCArPSAoJzAwMCcgKyBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29kZWM7XG4gIH07XG5cbiAgTTNVOFBhcnNlci5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSh1cmwsIGJhc2VVcmwpIHtcbiAgICByZXR1cm4gdXJsX3Rvb2xraXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImJ1aWxkQWJzb2x1dGVVUkxcIl0oYmFzZVVybCwgdXJsLCB7XG4gICAgICBhbHdheXNOb3JtYWxpemU6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3QgPSBmdW5jdGlvbiBwYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgYmFzZXVybCkge1xuICAgIHZhciBsZXZlbHMgPSBbXTtcbiAgICB2YXIgc2Vzc2lvbkRhdGEgPSB7fTtcbiAgICB2YXIgaGFzU2Vzc2lvbkRhdGEgPSBmYWxzZTtcbiAgICBNQVNURVJfUExBWUxJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfUkVHRVguZXhlYyhzdHJpbmcpKSAhPSBudWxsKSB7XG4gICAgICBpZiAocmVzdWx0WzFdKSB7XG4gICAgICAgIC8vICcjRVhULVgtU1RSRUFNLUlORicgaXMgZm91bmQsIHBhcnNlIGxldmVsIHRhZyAgaW4gZ3JvdXAgMVxuICAgICAgICB2YXIgYXR0cnMgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiQXR0ckxpc3RcIl0ocmVzdWx0WzFdKTtcbiAgICAgICAgdmFyIGxldmVsID0ge1xuICAgICAgICAgIGF0dHJzOiBhdHRycyxcbiAgICAgICAgICBiaXRyYXRlOiBhdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKSB8fCBhdHRycy5kZWNpbWFsSW50ZWdlcignQkFORFdJRFRIJyksXG4gICAgICAgICAgbmFtZTogYXR0cnMuTkFNRSxcbiAgICAgICAgICB1cmw6IE0zVThQYXJzZXIucmVzb2x2ZShyZXN1bHRbMl0sIGJhc2V1cmwpXG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gYXR0cnMuZGVjaW1hbFJlc29sdXRpb24oJ1JFU09MVVRJT04nKTtcblxuICAgICAgICBpZiAocmVzb2x1dGlvbikge1xuICAgICAgICAgIGxldmVsLndpZHRoID0gcmVzb2x1dGlvbi53aWR0aDtcbiAgICAgICAgICBsZXZlbC5oZWlnaHQgPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldENvZGVjcygoYXR0cnMuQ09ERUNTIHx8ICcnKS5zcGxpdCgvWyAsXSsvKS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfSksIGxldmVsKTtcblxuICAgICAgICBpZiAobGV2ZWwudmlkZW9Db2RlYyAmJiBsZXZlbC52aWRlb0NvZGVjLmluZGV4T2YoJ2F2YzEnKSAhPT0gLTEpIHtcbiAgICAgICAgICBsZXZlbC52aWRlb0NvZGVjID0gTTNVOFBhcnNlci5jb252ZXJ0QVZDMVRvQVZDT1RJKGxldmVsLnZpZGVvQ29kZWMpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbM10pIHtcbiAgICAgICAgLy8gJyNFWFQtWC1TRVNTSU9OLURBVEEnIGlzIGZvdW5kLCBwYXJzZSBzZXNzaW9uIGRhdGEgaW4gZ3JvdXAgM1xuICAgICAgICB2YXIgc2Vzc2lvbkF0dHJzID0gbmV3IF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIkF0dHJMaXN0XCJdKHJlc3VsdFszXSk7XG5cbiAgICAgICAgaWYgKHNlc3Npb25BdHRyc1snREFUQS1JRCddKSB7XG4gICAgICAgICAgaGFzU2Vzc2lvbkRhdGEgPSB0cnVlO1xuICAgICAgICAgIHNlc3Npb25EYXRhW3Nlc3Npb25BdHRyc1snREFUQS1JRCddXSA9IHNlc3Npb25BdHRycztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsZXZlbHM6IGxldmVscyxcbiAgICAgIHNlc3Npb25EYXRhOiBoYXNTZXNzaW9uRGF0YSA/IHNlc3Npb25EYXRhIDogbnVsbFxuICAgIH07XG4gIH07XG5cbiAgTTNVOFBhcnNlci5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEgPSBmdW5jdGlvbiBwYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCBiYXNldXJsLCB0eXBlLCBncm91cHMpIHtcbiAgICBpZiAoZ3JvdXBzID09PSB2b2lkIDApIHtcbiAgICAgIGdyb3VwcyA9IFtdO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIG1lZGlhcyA9IFtdO1xuICAgIHZhciBpZCA9IDA7XG4gICAgTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmxhc3RJbmRleCA9IDA7XG5cbiAgICB3aGlsZSAoKHJlc3VsdCA9IE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWC5leGVjKHN0cmluZykpICE9PSBudWxsKSB7XG4gICAgICB2YXIgYXR0cnMgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiQXR0ckxpc3RcIl0ocmVzdWx0WzFdKTtcblxuICAgICAgaWYgKGF0dHJzLlRZUEUgPT09IHR5cGUpIHtcbiAgICAgICAgdmFyIG1lZGlhID0ge1xuICAgICAgICAgIGF0dHJzOiBhdHRycyxcbiAgICAgICAgICBiaXRyYXRlOiAwLFxuICAgICAgICAgIGlkOiBpZCsrLFxuICAgICAgICAgIGdyb3VwSWQ6IGF0dHJzWydHUk9VUC1JRCddLFxuICAgICAgICAgIGluc3RyZWFtSWQ6IGF0dHJzWydJTlNUUkVBTS1JRCddLFxuICAgICAgICAgIG5hbWU6IGF0dHJzLk5BTUUgfHwgYXR0cnMuTEFOR1VBR0UgfHwgJycsXG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBkZWZhdWx0OiBhdHRycy5ib29sKCdERUZBVUxUJyksXG4gICAgICAgICAgYXV0b3NlbGVjdDogYXR0cnMuYm9vbCgnQVVUT1NFTEVDVCcpLFxuICAgICAgICAgIGZvcmNlZDogYXR0cnMuYm9vbCgnRk9SQ0VEJyksXG4gICAgICAgICAgbGFuZzogYXR0cnMuTEFOR1VBR0UsXG4gICAgICAgICAgdXJsOiBhdHRycy5VUkkgPyBNM1U4UGFyc2VyLnJlc29sdmUoYXR0cnMuVVJJLCBiYXNldXJsKSA6ICcnXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYXVkaW8gb3IgdGV4dCBncm91cHMgc2lnbmFsbGVkIGluIHRoZSBtYW5pZmVzdCwgbGV0J3MgbG9vayBmb3IgYSBtYXRjaGluZyBjb2RlYyBzdHJpbmcgZm9yIHRoaXMgdHJhY2tcbiAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBmaW5kIHRoZSB0cmFjayBzaWduYWxsZWQsIGxldHMgdXNlIHRoZSBmaXJzdCBhdWRpbyBncm91cHMgY29kZWMgd2UgaGF2ZVxuICAgICAgICAgIC8vIEFjdGluZyBhcyBhIGJlc3QgZ3Vlc3NcbiAgICAgICAgICB2YXIgZ3JvdXBDb2RlYyA9IE0zVThQYXJzZXIuZmluZEdyb3VwKGdyb3VwcywgbWVkaWEuZ3JvdXBJZCkgfHwgZ3JvdXBzWzBdO1xuICAgICAgICAgIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cENvZGVjLCAnYXVkaW9Db2RlYycpO1xuICAgICAgICAgIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cENvZGVjLCAndGV4dENvZGVjJyk7XG4gICAgICAgIH1cblxuICAgICAgICBtZWRpYXMucHVzaChtZWRpYSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lZGlhcztcbiAgfTtcblxuICBNM1U4UGFyc2VyLnBhcnNlTGV2ZWxQbGF5bGlzdCA9IGZ1bmN0aW9uIHBhcnNlTGV2ZWxQbGF5bGlzdChzdHJpbmcsIGJhc2V1cmwsIGlkLCB0eXBlLCBsZXZlbFVybElkKSB7XG4gICAgdmFyIGxldmVsID0gbmV3IF9sZXZlbF9kZXRhaWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJMZXZlbERldGFpbHNcIl0oYmFzZXVybCk7XG4gICAgdmFyIGZyYWdtZW50cyA9IGxldmVsLmZyYWdtZW50czsgLy8gVGhlIG1vc3QgcmVjZW50IGluaXQgc2VnbWVudCBzZWVuIChhcHBsaWVzIHRvIGFsbCBzdWJzZXF1ZW50IHNlZ21lbnRzKVxuXG4gICAgdmFyIGN1cnJlbnRJbml0U2VnbWVudCA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRTTiA9IDA7XG4gICAgdmFyIGN1cnJlbnRQYXJ0ID0gMDtcbiAgICB2YXIgdG90YWxkdXJhdGlvbiA9IDA7XG4gICAgdmFyIGRpc2NvbnRpbnVpdHlDb3VudGVyID0gMDtcbiAgICB2YXIgcHJldkZyYWcgPSBudWxsO1xuICAgIHZhciBmcmFnID0gbmV3IF9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRnJhZ21lbnRcIl0odHlwZSwgYmFzZXVybCk7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGV2ZWxrZXk7XG4gICAgdmFyIGZpcnN0UGR0SW5kZXggPSAtMTtcbiAgICB2YXIgY3JlYXRlTmV4dEZyYWcgPSBmYWxzZTtcbiAgICBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmxhc3RJbmRleCA9IDA7XG4gICAgbGV2ZWwubTN1OCA9IHN0cmluZztcblxuICAgIHdoaWxlICgocmVzdWx0ID0gTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVC5leGVjKHN0cmluZykpICE9PSBudWxsKSB7XG4gICAgICBpZiAoY3JlYXRlTmV4dEZyYWcpIHtcbiAgICAgICAgY3JlYXRlTmV4dEZyYWcgPSBmYWxzZTtcbiAgICAgICAgZnJhZyA9IG5ldyBfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkZyYWdtZW50XCJdKHR5cGUsIGJhc2V1cmwpOyAvLyBzZXR1cCB0aGUgbmV4dCBmcmFnbWVudCBmb3IgcGFydCBsb2FkaW5nXG5cbiAgICAgICAgZnJhZy5zdGFydCA9IHRvdGFsZHVyYXRpb247XG4gICAgICAgIGZyYWcuc24gPSBjdXJyZW50U047XG4gICAgICAgIGZyYWcuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuXG4gICAgICAgIGlmIChjdXJyZW50SW5pdFNlZ21lbnQpIHtcbiAgICAgICAgICBmcmFnLmluaXRTZWdtZW50ID0gY3VycmVudEluaXRTZWdtZW50O1xuICAgICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZTtcbiAgICAgICAgICBjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZHVyYXRpb24gPSByZXN1bHRbMV07XG5cbiAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAvLyBJTkZcbiAgICAgICAgZnJhZy5kdXJhdGlvbiA9IHBhcnNlRmxvYXQoZHVyYXRpb24pOyAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG5cbiAgICAgICAgdmFyIHRpdGxlID0gKCcgJyArIHJlc3VsdFsyXSkuc2xpY2UoMSk7XG4gICAgICAgIGZyYWcudGl0bGUgPSB0aXRsZSB8fCBudWxsO1xuICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaCh0aXRsZSA/IFsnSU5GJywgZHVyYXRpb24sIHRpdGxlXSA6IFsnSU5GJywgZHVyYXRpb25dKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzNdKSB7XG4gICAgICAgIC8vIHVybFxuICAgICAgICBpZiAoT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShmcmFnLmR1cmF0aW9uKSkge1xuICAgICAgICAgIGZyYWcuc3RhcnQgPSB0b3RhbGR1cmF0aW9uO1xuXG4gICAgICAgICAgaWYgKGxldmVsa2V5KSB7XG4gICAgICAgICAgICBmcmFnLmxldmVsa2V5ID0gbGV2ZWxrZXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnJhZy5zbiA9IGN1cnJlbnRTTjtcbiAgICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgICAgZnJhZy5jYyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgICAgICAgIGZyYWcudXJsSWQgPSBsZXZlbFVybElkO1xuICAgICAgICAgIGZyYWdtZW50cy5wdXNoKGZyYWcpOyAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG5cbiAgICAgICAgICBmcmFnLnJlbHVybCA9ICgnICcgKyByZXN1bHRbM10pLnNsaWNlKDEpO1xuICAgICAgICAgIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZyk7XG4gICAgICAgICAgcHJldkZyYWcgPSBmcmFnO1xuICAgICAgICAgIHRvdGFsZHVyYXRpb24gKz0gZnJhZy5kdXJhdGlvbjtcbiAgICAgICAgICBjdXJyZW50U04rKztcbiAgICAgICAgICBjdXJyZW50UGFydCA9IDA7XG4gICAgICAgICAgY3JlYXRlTmV4dEZyYWcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFs0XSkge1xuICAgICAgICAvLyBYLUJZVEVSQU5HRVxuICAgICAgICB2YXIgZGF0YSA9ICgnICcgKyByZXN1bHRbNF0pLnNsaWNlKDEpO1xuXG4gICAgICAgIGlmIChwcmV2RnJhZykge1xuICAgICAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKGRhdGEsIHByZXZGcmFnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnLnNldEJ5dGVSYW5nZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbNV0pIHtcbiAgICAgICAgLy8gUFJPR1JBTS1EQVRFLVRJTUVcbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9ICgnICcgKyByZXN1bHRbNV0pLnNsaWNlKDEpO1xuICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ1BST0dSQU0tREFURS1USU1FJywgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWVdKTtcblxuICAgICAgICBpZiAoZmlyc3RQZHRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBmaXJzdFBkdEluZGV4ID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdLm1hdGNoKExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cpO1xuXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wibG9nZ2VyXCJdLndhcm4oJ05vIG1hdGNoZXMgb24gc2xvdyByZWdleCBtYXRjaCBmb3IgbGV2ZWwgcGxheWxpc3QhJyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuXG5cbiAgICAgICAgdmFyIHRhZyA9ICgnICcgKyByZXN1bHRbaV0pLnNsaWNlKDEpO1xuICAgICAgICB2YXIgdmFsdWUxID0gKCcgJyArIHJlc3VsdFtpICsgMV0pLnNsaWNlKDEpO1xuICAgICAgICB2YXIgdmFsdWUyID0gcmVzdWx0W2kgKyAyXSA/ICgnICcgKyByZXN1bHRbaSArIDJdKS5zbGljZSgxKSA6ICcnO1xuXG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgY2FzZSAnUExBWUxJU1QtVFlQRSc6XG4gICAgICAgICAgICBsZXZlbC50eXBlID0gdmFsdWUxLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ01FRElBLVNFUVVFTkNFJzpcbiAgICAgICAgICAgIGN1cnJlbnRTTiA9IGxldmVsLnN0YXJ0U04gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTS0lQJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHNraXBBdHRycyA9IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJBdHRyTGlzdFwiXSh2YWx1ZTEpO1xuICAgICAgICAgICAgICB2YXIgc2tpcHBlZFNlZ21lbnRzID0gc2tpcEF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdTS0lQUEVELVNFR01FTlRTJyk7XG5cbiAgICAgICAgICAgICAgaWYgKE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoc2tpcHBlZFNlZ21lbnRzKSkge1xuICAgICAgICAgICAgICAgIGxldmVsLnNraXBwZWRTZWdtZW50cyA9IHNraXBwZWRTZWdtZW50czsgLy8gVGhpcyB3aWxsIHJlc3VsdCBpbiBmcmFnbWVudHNbXSBjb250YWluaW5nIHVuZGVmaW5lZCB2YWx1ZXMsIHdoaWNoIHdlIHdpbGwgZmlsbCBpbiB3aXRoIGBtZXJnZURldGFpbHNgXG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IHNraXBwZWRTZWdtZW50czsgX2ktLTspIHtcbiAgICAgICAgICAgICAgICAgIGZyYWdtZW50cy51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1cnJlbnRTTiArPSBza2lwcGVkU2VnbWVudHM7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IHNraXBBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdSRUNFTlRMWS1SRU1PVkVELURBVEVSQU5HRVMnKTtcblxuICAgICAgICAgICAgICBpZiAocmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcykge1xuICAgICAgICAgICAgICAgIGxldmVsLnJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMgPSByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzLnNwbGl0KCdcXHQnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnVEFSR0VURFVSQVRJT04nOlxuICAgICAgICAgICAgbGV2ZWwudGFyZ2V0ZHVyYXRpb24gPSBwYXJzZUZsb2F0KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1ZFUlNJT04nOlxuICAgICAgICAgICAgbGV2ZWwudmVyc2lvbiA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0VYVE0zVSc6XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0VORExJU1QnOlxuICAgICAgICAgICAgbGV2ZWwubGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIGlmICh2YWx1ZTEgfHwgdmFsdWUyKSB7XG4gICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHZhbHVlMiA/IFt2YWx1ZTEsIHZhbHVlMl0gOiBbdmFsdWUxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRElTQ09OVElOVUlUWSc6XG4gICAgICAgICAgICBkaXNjb250aW51aXR5Q291bnRlcisrO1xuICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydESVMnXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0dBUCc6XG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbdGFnXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0JJVFJBVEUnOlxuICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goW3RhZywgdmFsdWUxXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0RBVEVSQU5HRSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBkYXRlUmFuZ2VBdHRyID0gbmV3IF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIkF0dHJMaXN0XCJdKHZhbHVlMSk7XG4gICAgICAgICAgICAgIHZhciBkYXRlUmFuZ2UgPSBuZXcgX2RhdGVfcmFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkRhdGVSYW5nZVwiXShkYXRlUmFuZ2VBdHRyLCBsZXZlbC5kYXRlUmFuZ2VzW2RhdGVSYW5nZUF0dHIuSURdKTtcblxuICAgICAgICAgICAgICBpZiAoZGF0ZVJhbmdlLmlzVmFsaWQgfHwgbGV2ZWwuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwuZGF0ZVJhbmdlc1tkYXRlUmFuZ2UuaWRdID0gZGF0ZVJhbmdlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImxvZ2dlclwiXS53YXJuKFwiSWdub3JpbmcgaW52YWxpZCBEQVRFUkFOR0UgdGFnOiBcXFwiXCIgKyB2YWx1ZTEgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgIH0gLy8gQWRkIHRvIGZyYWdtZW50IHRhZyBsaXN0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoPCB2MS4yLjApXG5cblxuICAgICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0VYVC1YLURBVEVSQU5HRScsIHZhbHVlMV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ0RJU0NPTlRJTlVJVFktU0VRVUVOQ0UnOlxuICAgICAgICAgICAgZGlzY29udGludWl0eUNvdW50ZXIgPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdLRVknOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgX2tleUF0dHJzJGVudW1lcmF0ZWRTO1xuXG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM4MjE2I3NlY3Rpb24tNC4zLjIuNFxuICAgICAgICAgICAgICB2YXIga2V5QXR0cnMgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiQXR0ckxpc3RcIl0odmFsdWUxKTtcbiAgICAgICAgICAgICAgdmFyIGRlY3J5cHRtZXRob2QgPSBrZXlBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdNRVRIT0QnKTtcbiAgICAgICAgICAgICAgdmFyIGRlY3J5cHR1cmkgPSBrZXlBdHRycy5VUkk7XG4gICAgICAgICAgICAgIHZhciBkZWNyeXB0aXYgPSBrZXlBdHRycy5oZXhhZGVjaW1hbEludGVnZXIoJ0lWJyk7XG4gICAgICAgICAgICAgIHZhciBkZWNyeXB0a2V5Zm9ybWF0dmVyc2lvbnMgPSBrZXlBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdLRVlGT1JNQVRWRVJTSU9OUycpO1xuICAgICAgICAgICAgICB2YXIgZGVjcnlwdGtleWlkID0ga2V5QXR0cnMuZW51bWVyYXRlZFN0cmluZygnS0VZSUQnKTsgLy8gRnJvbSBSRkM6IFRoaXMgYXR0cmlidXRlIGlzIE9QVElPTkFMOyBpdHMgYWJzZW5jZSBpbmRpY2F0ZXMgYW4gaW1wbGljaXQgdmFsdWUgb2YgXCJpZGVudGl0eVwiLlxuXG4gICAgICAgICAgICAgIHZhciBkZWNyeXB0a2V5Zm9ybWF0ID0gKF9rZXlBdHRycyRlbnVtZXJhdGVkUyA9IGtleUF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ0tFWUZPUk1BVCcpKSAhPSBudWxsID8gX2tleUF0dHJzJGVudW1lcmF0ZWRTIDogJ2lkZW50aXR5JztcbiAgICAgICAgICAgICAgdmFyIHVuc3VwcG9ydGVkS25vd25LZXlmb3JtYXRzSW5NYW5pZmVzdCA9IFsnY29tLmFwcGxlLnN0cmVhbWluZ2tleWRlbGl2ZXJ5JywgJ2NvbS5taWNyb3NvZnQucGxheXJlYWR5JywgJ3Vybjp1dWlkOmVkZWY4YmE5LTc5ZDYtNGFjZS1hM2M4LTI3ZGNkNTFkMjFlZCcsIC8vIHdpZGV2aW5lICh2MilcbiAgICAgICAgICAgICAgJ2NvbS53aWRldmluZScgLy8gZWFybGllciB3aWRldmluZSAodjEpXG4gICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgaWYgKHVuc3VwcG9ydGVkS25vd25LZXlmb3JtYXRzSW5NYW5pZmVzdC5pbmRleE9mKGRlY3J5cHRrZXlmb3JtYXQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJsb2dnZXJcIl0ud2FybihcIktleWZvcm1hdCBcIiArIGRlY3J5cHRrZXlmb3JtYXQgKyBcIiBpcyBub3Qgc3VwcG9ydGVkIGZyb20gdGhlIG1hbmlmZXN0XCIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlY3J5cHRrZXlmb3JtYXQgIT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgc3VwcG9zZWQgdG8gc2tpcCBrZXlzIHdlIGRvbid0IHVuZGVyc3RhbmQuXG4gICAgICAgICAgICAgICAgLy8gQXMgd2UgY3VycmVudGx5IG9ubHkgb2ZmaWNpYWxseSBzdXBwb3J0IGlkZW50aXR5IGtleXNcbiAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBtYW5pZmVzdCB3ZSBzaG91bGRuJ3Qgc2F2ZSBhbnkgb3RoZXIga2V5LlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9IC8vIFRPRE86IG11bHRpcGxlIGtleXMgY2FuIGJlIGRlZmluZWQgb24gYSBmcmFnbWVudCwgYW5kIHdlIG5lZWQgdG8gc3VwcG9ydCB0aGlzXG4gICAgICAgICAgICAgIC8vIGZvciBjbGllbnRzIHRoYXQgc3VwcG9ydCBib3RoIHBsYXlyZWFkeSBhbmQgd2lkZXZpbmVcblxuXG4gICAgICAgICAgICAgIGlmIChkZWNyeXB0bWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogbmVlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGxldmVsIGtleSBpcyBhY3R1YWxseSBhIHJlbGF0aXZlIFVSTFxuICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzbid0LCB0aGVuIHdlIHNob3VsZCBpbnN0ZWFkIGNvbnN0cnVjdCB0aGUgTGV2ZWxLZXkgdXNpbmcgZnJvbVVSSS5cbiAgICAgICAgICAgICAgICBsZXZlbGtleSA9IF9sZXZlbF9rZXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkxldmVsS2V5XCJdLmZyb21VUkwoYmFzZXVybCwgZGVjcnlwdHVyaSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVjcnlwdHVyaSAmJiBbJ0FFUy0xMjgnLCAnU0FNUExFLUFFUycsICdTQU1QTEUtQUVTLUNFTkMnXS5pbmRleE9mKGRlY3J5cHRtZXRob2QpID49IDApIHtcbiAgICAgICAgICAgICAgICAgIGxldmVsa2V5Lm1ldGhvZCA9IGRlY3J5cHRtZXRob2Q7XG4gICAgICAgICAgICAgICAgICBsZXZlbGtleS5rZXlGb3JtYXQgPSBkZWNyeXB0a2V5Zm9ybWF0O1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZGVjcnlwdGtleWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsa2V5LmtleUlEID0gZGVjcnlwdGtleWlkO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsa2V5LmtleUZvcm1hdFZlcnNpb25zID0gZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zO1xuICAgICAgICAgICAgICAgICAgfSAvLyBJbml0aWFsaXphdGlvbiBWZWN0b3IgKElWKVxuXG5cbiAgICAgICAgICAgICAgICAgIGxldmVsa2V5Lml2ID0gZGVjcnlwdGl2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnU1RBUlQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgc3RhcnRBdHRycyA9IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJBdHRyTGlzdFwiXSh2YWx1ZTEpO1xuICAgICAgICAgICAgICB2YXIgc3RhcnRUaW1lT2Zmc2V0ID0gc3RhcnRBdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnVElNRS1PRkZTRVQnKTsgLy8gVElNRS1PRkZTRVQgY2FuIGJlIDBcblxuICAgICAgICAgICAgICBpZiAoT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShzdGFydFRpbWVPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwuc3RhcnRUaW1lT2Zmc2V0ID0gc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdNQVAnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgbWFwQXR0cnMgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiQXR0ckxpc3RcIl0odmFsdWUxKTtcblxuICAgICAgICAgICAgICBpZiAoZnJhZy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIEluaXRpYWwgc2VnbWVudCB0YWcgaXMgYWZ0ZXIgc2VnbWVudCBkdXJhdGlvbiB0YWcuXG4gICAgICAgICAgICAgICAgLy8gICAjRVhUSU5GOiA2LjBcbiAgICAgICAgICAgICAgICAvLyAgICNFWFQtWC1NQVA6VVJJPVwiaW5pdC5tcDRcbiAgICAgICAgICAgICAgICB2YXIgaW5pdCA9IG5ldyBfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkZyYWdtZW50XCJdKHR5cGUsIGJhc2V1cmwpO1xuICAgICAgICAgICAgICAgIHNldEluaXRTZWdtZW50KGluaXQsIG1hcEF0dHJzLCBpZCwgbGV2ZWxrZXkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgZnJhZy5pbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudDtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lICYmICFmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICAgICAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsIHNlZ21lbnQgdGFnIGlzIGJlZm9yZSBzZWdtZW50IGR1cmF0aW9uIHRhZ1xuICAgICAgICAgICAgICAgIHNldEluaXRTZWdtZW50KGZyYWcsIG1hcEF0dHJzLCBpZCwgbGV2ZWxrZXkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IGZyYWc7XG4gICAgICAgICAgICAgICAgY3JlYXRlTmV4dEZyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdTRVJWRVItQ09OVFJPTCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBzZXJ2ZXJDb250cm9sQXR0cnMgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiQXR0ckxpc3RcIl0odmFsdWUxKTtcbiAgICAgICAgICAgICAgbGV2ZWwuY2FuQmxvY2tSZWxvYWQgPSBzZXJ2ZXJDb250cm9sQXR0cnMuYm9vbCgnQ0FOLUJMT0NLLVJFTE9BRCcpO1xuICAgICAgICAgICAgICBsZXZlbC5jYW5Ta2lwVW50aWwgPSBzZXJ2ZXJDb250cm9sQXR0cnMub3B0aW9uYWxGbG9hdCgnQ0FOLVNLSVAtVU5USUwnLCAwKTtcbiAgICAgICAgICAgICAgbGV2ZWwuY2FuU2tpcERhdGVSYW5nZXMgPSBsZXZlbC5jYW5Ta2lwVW50aWwgPiAwICYmIHNlcnZlckNvbnRyb2xBdHRycy5ib29sKCdDQU4tU0tJUC1EQVRFUkFOR0VTJyk7XG4gICAgICAgICAgICAgIGxldmVsLnBhcnRIb2xkQmFjayA9IHNlcnZlckNvbnRyb2xBdHRycy5vcHRpb25hbEZsb2F0KCdQQVJULUhPTEQtQkFDSycsIDApO1xuICAgICAgICAgICAgICBsZXZlbC5ob2xkQmFjayA9IHNlcnZlckNvbnRyb2xBdHRycy5vcHRpb25hbEZsb2F0KCdIT0xELUJBQ0snLCAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdQQVJULUlORic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0SW5mQXR0cnMgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiQXR0ckxpc3RcIl0odmFsdWUxKTtcbiAgICAgICAgICAgICAgbGV2ZWwucGFydFRhcmdldCA9IHBhcnRJbmZBdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnUEFSVC1UQVJHRVQnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdQQVJUJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBhcnRMaXN0ID0gbGV2ZWwucGFydExpc3Q7XG5cbiAgICAgICAgICAgICAgaWYgKCFwYXJ0TGlzdCkge1xuICAgICAgICAgICAgICAgIHBhcnRMaXN0ID0gbGV2ZWwucGFydExpc3QgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBwcmV2aW91c0ZyYWdtZW50UGFydCA9IGN1cnJlbnRQYXJ0ID4gMCA/IHBhcnRMaXN0W3BhcnRMaXN0Lmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBjdXJyZW50UGFydCsrO1xuICAgICAgICAgICAgICB2YXIgcGFydCA9IG5ldyBfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIlBhcnRcIl0obmV3IF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIkF0dHJMaXN0XCJdKHZhbHVlMSksIGZyYWcsIGJhc2V1cmwsIGluZGV4LCBwcmV2aW91c0ZyYWdtZW50UGFydCk7XG4gICAgICAgICAgICAgIHBhcnRMaXN0LnB1c2gocGFydCk7XG4gICAgICAgICAgICAgIGZyYWcuZHVyYXRpb24gKz0gcGFydC5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdQUkVMT0FELUhJTlQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcHJlbG9hZEhpbnRBdHRycyA9IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJBdHRyTGlzdFwiXSh2YWx1ZTEpO1xuICAgICAgICAgICAgICBsZXZlbC5wcmVsb2FkSGludCA9IHByZWxvYWRIaW50QXR0cnM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnUkVORElUSU9OLVJFUE9SVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciByZW5kaXRpb25SZXBvcnRBdHRycyA9IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJBdHRyTGlzdFwiXSh2YWx1ZTEpO1xuICAgICAgICAgICAgICBsZXZlbC5yZW5kaXRpb25SZXBvcnRzID0gbGV2ZWwucmVuZGl0aW9uUmVwb3J0cyB8fCBbXTtcbiAgICAgICAgICAgICAgbGV2ZWwucmVuZGl0aW9uUmVwb3J0cy5wdXNoKHJlbmRpdGlvblJlcG9ydEF0dHJzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wibG9nZ2VyXCJdLndhcm4oXCJsaW5lIHBhcnNlZCBidXQgbm90IGhhbmRsZWQ6IFwiICsgcmVzdWx0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZGcmFnICYmICFwcmV2RnJhZy5yZWx1cmwpIHtcbiAgICAgIGZyYWdtZW50cy5wb3AoKTtcbiAgICAgIHRvdGFsZHVyYXRpb24gLT0gcHJldkZyYWcuZHVyYXRpb247XG5cbiAgICAgIGlmIChsZXZlbC5wYXJ0TGlzdCkge1xuICAgICAgICBsZXZlbC5mcmFnbWVudEhpbnQgPSBwcmV2RnJhZztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxldmVsLnBhcnRMaXN0KSB7XG4gICAgICBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcpO1xuICAgICAgZnJhZy5jYyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgICAgbGV2ZWwuZnJhZ21lbnRIaW50ID0gZnJhZztcbiAgICB9XG5cbiAgICB2YXIgZnJhZ21lbnRMZW5ndGggPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgIHZhciBmaXJzdEZyYWdtZW50ID0gZnJhZ21lbnRzWzBdO1xuICAgIHZhciBsYXN0RnJhZ21lbnQgPSBmcmFnbWVudHNbZnJhZ21lbnRMZW5ndGggLSAxXTtcbiAgICB0b3RhbGR1cmF0aW9uICs9IGxldmVsLnNraXBwZWRTZWdtZW50cyAqIGxldmVsLnRhcmdldGR1cmF0aW9uO1xuXG4gICAgaWYgKHRvdGFsZHVyYXRpb24gPiAwICYmIGZyYWdtZW50TGVuZ3RoICYmIGxhc3RGcmFnbWVudCkge1xuICAgICAgbGV2ZWwuYXZlcmFnZXRhcmdldGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbiAvIGZyYWdtZW50TGVuZ3RoO1xuICAgICAgdmFyIGxhc3RTbiA9IGxhc3RGcmFnbWVudC5zbjtcbiAgICAgIGxldmVsLmVuZFNOID0gbGFzdFNuICE9PSAnaW5pdFNlZ21lbnQnID8gbGFzdFNuIDogMDtcblxuICAgICAgaWYgKGZpcnN0RnJhZ21lbnQpIHtcbiAgICAgICAgbGV2ZWwuc3RhcnRDQyA9IGZpcnN0RnJhZ21lbnQuY2M7XG5cbiAgICAgICAgaWYgKCFmaXJzdEZyYWdtZW50LmluaXRTZWdtZW50KSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBhIGJpdCBsdXJreSBidXQgSExTIHJlYWxseSBoYXMgbm8gb3RoZXIgd2F5IHRvIHRlbGwgdXNcbiAgICAgICAgICAvLyBpZiB0aGUgZnJhZ21lbnRzIGFyZSBUUyBvciBNUDQsIGV4Y2VwdCBpZiB3ZSBkb3dubG9hZCB0aGVtIDovXG4gICAgICAgICAgLy8gYnV0IHRoaXMgaXMgdG8gYmUgYWJsZSB0byBoYW5kbGUgU0lEWC5cbiAgICAgICAgICBpZiAobGV2ZWwuZnJhZ21lbnRzLmV2ZXJ5KGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhZy5yZWx1cmwgJiYgaXNNUDRVcmwoZnJhZy5yZWx1cmwpO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJsb2dnZXJcIl0ud2FybignTVA0IGZyYWdtZW50cyBmb3VuZCBidXQgbm8gaW5pdCBzZWdtZW50IChwcm9iYWJseSBubyBNQVAsIGluY29tcGxldGUgTTNVOCksIHRyeWluZyB0byBmZXRjaCBTSURYJyk7XG4gICAgICAgICAgICBmcmFnID0gbmV3IF9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRnJhZ21lbnRcIl0odHlwZSwgYmFzZXVybCk7XG4gICAgICAgICAgICBmcmFnLnJlbHVybCA9IGxhc3RGcmFnbWVudC5yZWx1cmw7XG4gICAgICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgICAgICBmcmFnLnNuID0gJ2luaXRTZWdtZW50JztcbiAgICAgICAgICAgIGZpcnN0RnJhZ21lbnQuaW5pdFNlZ21lbnQgPSBmcmFnO1xuICAgICAgICAgICAgbGV2ZWwubmVlZFNpZHhSYW5nZXMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXZlbC5lbmRTTiA9IDA7XG4gICAgICBsZXZlbC5zdGFydENDID0gMDtcbiAgICB9XG5cbiAgICBpZiAobGV2ZWwuZnJhZ21lbnRIaW50KSB7XG4gICAgICB0b3RhbGR1cmF0aW9uICs9IGxldmVsLmZyYWdtZW50SGludC5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICBsZXZlbC50b3RhbGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbjtcbiAgICBsZXZlbC5lbmRDQyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgIC8qKlxuICAgICAqIEJhY2tmaWxsIGFueSBtaXNzaW5nIFBEVCB2YWx1ZXNcbiAgICAgKiBcIklmIHRoZSBmaXJzdCBFWFQtWC1QUk9HUkFNLURBVEUtVElNRSB0YWcgaW4gYSBQbGF5bGlzdCBhcHBlYXJzIGFmdGVyXG4gICAgICogb25lIG9yIG1vcmUgTWVkaWEgU2VnbWVudCBVUklzLCB0aGUgY2xpZW50IFNIT1VMRCBleHRyYXBvbGF0ZVxuICAgICAqIGJhY2t3YXJkIGZyb20gdGhhdCB0YWcgKHVzaW5nIEVYVElORiBkdXJhdGlvbnMgYW5kL29yIG1lZGlhXG4gICAgICogdGltZXN0YW1wcykgdG8gYXNzb2NpYXRlIGRhdGVzIHdpdGggdGhvc2Ugc2VnbWVudHMuXCJcbiAgICAgKiBXZSBoYXZlIGFscmVhZHkgZXh0cmFwb2xhdGVkIGZvcndhcmQsIGJ1dCBhbGwgZnJhZ21lbnRzIHVwIHRvIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBQRFQgZG8gbm90IGhhdmUgdGhlaXIgUERUc1xuICAgICAqIGNvbXB1dGVkLlxuICAgICAqL1xuXG4gICAgaWYgKGZpcnN0UGR0SW5kZXggPiAwKSB7XG4gICAgICBiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMoZnJhZ21lbnRzLCBmaXJzdFBkdEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGV2ZWw7XG4gIH07XG5cbiAgcmV0dXJuIE0zVThQYXJzZXI7XG59KCk7XG5cblxuXG5mdW5jdGlvbiBzZXRDb2RlY3MoY29kZWNzLCBsZXZlbCkge1xuICBbJ3ZpZGVvJywgJ2F1ZGlvJywgJ3RleHQnXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGZpbHRlcmVkID0gY29kZWNzLmZpbHRlcihmdW5jdGlvbiAoY29kZWMpIHtcbiAgICAgIHJldHVybiBPYmplY3QoX3V0aWxzX2NvZGVjc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wiaXNDb2RlY1R5cGVcIl0pKGNvZGVjLCB0eXBlKTtcbiAgICB9KTtcblxuICAgIGlmIChmaWx0ZXJlZC5sZW5ndGgpIHtcbiAgICAgIHZhciBwcmVmZXJyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgICAgIHJldHVybiBjb2RlYy5sYXN0SW5kZXhPZignYXZjMScsIDApID09PSAwIHx8IGNvZGVjLmxhc3RJbmRleE9mKCdtcDRhJywgMCkgPT09IDA7XG4gICAgICB9KTtcbiAgICAgIGxldmVsW3R5cGUgKyBcIkNvZGVjXCJdID0gcHJlZmVycmVkLmxlbmd0aCA+IDAgPyBwcmVmZXJyZWRbMF0gOiBmaWx0ZXJlZFswXTsgLy8gcmVtb3ZlIGZyb20gbGlzdFxuXG4gICAgICBjb2RlY3MgPSBjb2RlY3MuZmlsdGVyKGZ1bmN0aW9uIChjb2RlYykge1xuICAgICAgICByZXR1cm4gZmlsdGVyZWQuaW5kZXhPZihjb2RlYykgPT09IC0xO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgbGV2ZWwudW5rbm93bkNvZGVjcyA9IGNvZGVjcztcbn1cblxuZnVuY3Rpb24gYXNzaWduQ29kZWMobWVkaWEsIGdyb3VwSXRlbSwgY29kZWNQcm9wZXJ0eSkge1xuICB2YXIgY29kZWNWYWx1ZSA9IGdyb3VwSXRlbVtjb2RlY1Byb3BlcnR5XTtcblxuICBpZiAoY29kZWNWYWx1ZSkge1xuICAgIG1lZGlhW2NvZGVjUHJvcGVydHldID0gY29kZWNWYWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMoZnJhZ21lbnRzLCBmaXJzdFBkdEluZGV4KSB7XG4gIHZhciBmcmFnUHJldiA9IGZyYWdtZW50c1tmaXJzdFBkdEluZGV4XTtcblxuICBmb3IgKHZhciBpID0gZmlyc3RQZHRJbmRleDsgaS0tOykge1xuICAgIHZhciBmcmFnID0gZnJhZ21lbnRzW2ldOyAvLyBFeGl0IG9uIGRlbHRhLXBsYXlsaXN0IHNraXBwZWQgc2VnbWVudHNcblxuICAgIGlmICghZnJhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gZnJhZ1ByZXYucHJvZ3JhbURhdGVUaW1lIC0gZnJhZy5kdXJhdGlvbiAqIDEwMDA7XG4gICAgZnJhZ1ByZXYgPSBmcmFnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZykge1xuICBpZiAoZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IERhdGUucGFyc2UoZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpO1xuICB9IGVsc2UgaWYgKHByZXZGcmFnICE9PSBudWxsICYmIHByZXZGcmFnICE9PSB2b2lkIDAgJiYgcHJldkZyYWcucHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBwcmV2RnJhZy5lbmRQcm9ncmFtRGF0ZVRpbWU7XG4gIH1cblxuICBpZiAoIU9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoZnJhZy5wcm9ncmFtRGF0ZVRpbWUpKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRJbml0U2VnbWVudChmcmFnLCBtYXBBdHRycywgaWQsIGxldmVsa2V5KSB7XG4gIGZyYWcucmVsdXJsID0gbWFwQXR0cnMuVVJJO1xuXG4gIGlmIChtYXBBdHRycy5CWVRFUkFOR0UpIHtcbiAgICBmcmFnLnNldEJ5dGVSYW5nZShtYXBBdHRycy5CWVRFUkFOR0UpO1xuICB9XG5cbiAgZnJhZy5sZXZlbCA9IGlkO1xuICBmcmFnLnNuID0gJ2luaXRTZWdtZW50JztcblxuICBpZiAobGV2ZWxrZXkpIHtcbiAgICBmcmFnLmxldmVsa2V5ID0gbGV2ZWxrZXk7XG4gIH1cblxuICBmcmFnLmluaXRTZWdtZW50ID0gbnVsbDtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbG9hZGVyL3BsYXlsaXN0LWxvYWRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xvYWRlci9wbGF5bGlzdC1sb2FkZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL21wNC10b29scyAqLyBcIi4vc3JjL3V0aWxzL21wNC10b29scy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbTN1OF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbTN1OC1wYXJzZXIgKi8gXCIuL3NyYy9sb2FkZXIvbTN1OC1wYXJzZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvbG9hZGVyICovIFwiLi9zcmMvdHlwZXMvbG9hZGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2F0dHItbGlzdCAqLyBcIi4vc3JjL3V0aWxzL2F0dHItbGlzdC50c1wiKTtcblxuXG5cbi8qKlxuICogUGxheWxpc3RMb2FkZXIgLSBkZWxlZ2F0ZSBmb3IgbWVkaWEgbWFuaWZlc3QvcGxheWxpc3QgbG9hZGluZyB0YXNrcy4gVGFrZXMgY2FyZSBvZiBwYXJzaW5nIG1lZGlhIHRvIGludGVybmFsIGRhdGEtbW9kZWxzLlxuICpcbiAqIE9uY2UgbG9hZGVkLCBkaXNwYXRjaGVzIGV2ZW50cyB3aXRoIHBhcnNlZCBkYXRhLW1vZGVscyBvZiBtYW5pZmVzdC9sZXZlbHMvYXVkaW8vc3VidGl0bGUgdHJhY2tzLlxuICpcbiAqIFVzZXMgbG9hZGVyKHMpIHNldCBpbiBjb25maWcgdG8gZG8gYWN0dWFsIGludGVybmFsIGxvYWRpbmcgb2YgcmVzb3VyY2UgdGFza3MuXG4gKlxuICogQG1vZHVsZVxuICpcbiAqL1xuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIG1hcENvbnRleHRUb0xldmVsVHlwZShjb250ZXh0KSB7XG4gIHZhciB0eXBlID0gY29udGV4dC50eXBlO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5BVURJT19UUkFDSzpcbiAgICAgIHJldHVybiBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5BVURJTztcblxuICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgIHJldHVybiBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5TVUJUSVRMRTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uTUFJTjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCkge1xuICB2YXIgdXJsID0gcmVzcG9uc2UudXJsOyAvLyByZXNwb25zZVVSTCBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMgKGl0IGlzIHVzZWQgdG8gZGV0ZWN0IFVSTCByZWRpcmVjdGlvbilcbiAgLy8gZGF0YS11cmkgbW9kZSBhbHNvIG5vdCBzdXBwb3J0ZWQgKGJ1dCBubyBuZWVkIHRvIGRldGVjdCByZWRpcmVjdGlvbilcblxuICBpZiAodXJsID09PSB1bmRlZmluZWQgfHwgdXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAvLyBmYWxsYmFjayB0byBpbml0aWFsIFVSTFxuICAgIHVybCA9IGNvbnRleHQudXJsO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cblxudmFyIFBsYXlsaXN0TG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGxheWxpc3RMb2FkZXIoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2FkZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUGxheWxpc3RMb2FkZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19MT0FESU5HLCB0aGlzLm9uQXVkaW9UcmFja0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tfTE9BRElORywgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX0xPQURJTkcsIHRoaXMub25BdWRpb1RyYWNrTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tfTE9BRElORywgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBkZWZhdWx0cyBvciBjb25maWd1cmVkIGxvYWRlci10eXBlIG92ZXJsb2FkcyAocExvYWRlciBhbmQgbG9hZGVyIGNvbmZpZyBwYXJhbXMpXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNyZWF0ZUludGVybmFsTG9hZGVyID0gZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxMb2FkZXIoY29udGV4dCkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgdmFyIFBMb2FkZXIgPSBjb25maWcucExvYWRlcjtcbiAgICB2YXIgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICB2YXIgSW50ZXJuYWxMb2FkZXIgPSBQTG9hZGVyIHx8IExvYWRlcjtcbiAgICB2YXIgbG9hZGVyID0gbmV3IEludGVybmFsTG9hZGVyKGNvbmZpZyk7XG4gICAgY29udGV4dC5sb2FkZXIgPSBsb2FkZXI7XG4gICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSBsb2FkZXI7XG4gICAgcmV0dXJuIGxvYWRlcjtcbiAgfTtcblxuICBfcHJvdG8uZ2V0SW50ZXJuYWxMb2FkZXIgPSBmdW5jdGlvbiBnZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdO1xuICB9O1xuXG4gIF9wcm90by5yZXNldEludGVybmFsTG9hZGVyID0gZnVuY3Rpb24gcmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0VHlwZSkge1xuICAgIGlmICh0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdKSB7XG4gICAgICBkZWxldGUgdGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYGRlc3Ryb3lgIG9uIGFsbCBpbnRlcm5hbCBsb2FkZXIgaW5zdGFuY2VzIG1hcHBlZCAob25lIHBlciBjb250ZXh0IHR5cGUpXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlc3Ryb3lJbnRlcm5hbExvYWRlcnMgPSBmdW5jdGlvbiBkZXN0cm95SW50ZXJuYWxMb2FkZXJzKCkge1xuICAgIGZvciAodmFyIGNvbnRleHRUeXBlIGluIHRoaXMubG9hZGVycykge1xuICAgICAgdmFyIGxvYWRlciA9IHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV07XG5cbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHRUeXBlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuZGVzdHJveUludGVybmFsTG9hZGVycygpO1xuICB9O1xuXG4gIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIHVybCA9IGRhdGEudXJsO1xuICAgIHRoaXMubG9hZCh7XG4gICAgICBpZDogbnVsbCxcbiAgICAgIGdyb3VwSWQ6IG51bGwsXG4gICAgICBsZXZlbDogMCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgdHlwZTogX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5NQU5JRkVTVCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBudWxsXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTGV2ZWxMb2FkaW5nID0gZnVuY3Rpb24gb25MZXZlbExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgaWQgPSBkYXRhLmlkLFxuICAgICAgICBsZXZlbCA9IGRhdGEubGV2ZWwsXG4gICAgICAgIHVybCA9IGRhdGEudXJsLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcztcbiAgICB0aGlzLmxvYWQoe1xuICAgICAgaWQ6IGlkLFxuICAgICAgZ3JvdXBJZDogbnVsbCxcbiAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgdHlwZTogX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5MRVZFTCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ub25BdWRpb1RyYWNrTG9hZGluZyA9IGZ1bmN0aW9uIG9uQXVkaW9UcmFja0xvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgaWQgPSBkYXRhLmlkLFxuICAgICAgICBncm91cElkID0gZGF0YS5ncm91cElkLFxuICAgICAgICB1cmwgPSBkYXRhLnVybCxcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzID0gZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXM7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGdyb3VwSWQ6IGdyb3VwSWQsXG4gICAgICBsZXZlbDogbnVsbCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgdHlwZTogX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5BVURJT19UUkFDSyxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ub25TdWJ0aXRsZVRyYWNrTG9hZGluZyA9IGZ1bmN0aW9uIG9uU3VidGl0bGVUcmFja0xvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgaWQgPSBkYXRhLmlkLFxuICAgICAgICBncm91cElkID0gZGF0YS5ncm91cElkLFxuICAgICAgICB1cmwgPSBkYXRhLnVybCxcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzID0gZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXM7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGdyb3VwSWQ6IGdyb3VwSWQsXG4gICAgICBsZXZlbDogbnVsbCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgdHlwZTogX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5TVUJUSVRMRV9UUkFDSyxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ubG9hZCA9IGZ1bmN0aW9uIGxvYWQoY29udGV4dCkge1xuICAgIHZhciBfY29udGV4dCRkZWxpdmVyeURpcmU7XG5cbiAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnOyAvLyBsb2dnZXIuZGVidWcoYFtwbGF5bGlzdC1sb2FkZXJdOiBMb2FkaW5nIHBsYXlsaXN0IG9mIHR5cGUgJHtjb250ZXh0LnR5cGV9LCBsZXZlbDogJHtjb250ZXh0LmxldmVsfSwgaWQ6ICR7Y29udGV4dC5pZH1gKTtcbiAgICAvLyBDaGVjayBpZiBhIGxvYWRlciBmb3IgdGhpcyBjb250ZXh0IGFscmVhZHkgZXhpc3RzXG5cbiAgICB2YXIgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcblxuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIHZhciBsb2FkZXJDb250ZXh0ID0gbG9hZGVyLmNvbnRleHQ7XG5cbiAgICAgIGlmIChsb2FkZXJDb250ZXh0ICYmIGxvYWRlckNvbnRleHQudXJsID09PSBjb250ZXh0LnVybCkge1xuICAgICAgICAvLyBzYW1lIFVSTCBjYW4ndCBvdmVybGFwXG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS50cmFjZSgnW3BsYXlsaXN0LWxvYWRlcl06IHBsYXlsaXN0IHJlcXVlc3Qgb25nb2luZycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS5sb2coXCJbcGxheWxpc3QtbG9hZGVyXTogYWJvcnRpbmcgcHJldmlvdXMgbG9hZGVyIGZvciB0eXBlOiBcIiArIGNvbnRleHQudHlwZSk7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICB2YXIgbWF4UmV0cnk7XG4gICAgdmFyIHRpbWVvdXQ7XG4gICAgdmFyIHJldHJ5RGVsYXk7XG4gICAgdmFyIG1heFJldHJ5RGVsYXk7IC8vIGFwcGx5IGRpZmZlcmVudCBjb25maWdzIGZvciByZXRyaWVzIGRlcGVuZGluZyBvblxuICAgIC8vIGNvbnRleHQgKG1hbmlmZXN0LCBsZXZlbCwgYXVkaW8vc3VicyBwbGF5bGlzdClcblxuICAgIHN3aXRjaCAoY29udGV4dC50eXBlKSB7XG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uTUFOSUZFU1Q6XG4gICAgICAgIG1heFJldHJ5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ01heFJldHJ5O1xuICAgICAgICB0aW1lb3V0ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ7XG4gICAgICAgIHJldHJ5RGVsYXkgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTtcbiAgICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uTEVWRUw6XG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uQVVESU9fVFJBQ0s6XG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uU1VCVElUTEVfVFJBQ0s6XG4gICAgICAgIC8vIE1hbmFnZSByZXRyaWVzIGluIExldmVsL1RyYWNrIENvbnRyb2xsZXJcbiAgICAgICAgbWF4UmV0cnkgPSAwO1xuICAgICAgICB0aW1lb3V0ID0gY29uZmlnLmxldmVsTG9hZGluZ1RpbWVPdXQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBtYXhSZXRyeSA9IGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeTtcbiAgICAgICAgdGltZW91dCA9IGNvbmZpZy5sZXZlbExvYWRpbmdUaW1lT3V0O1xuICAgICAgICByZXRyeURlbGF5ID0gY29uZmlnLmxldmVsTG9hZGluZ1JldHJ5RGVsYXk7XG4gICAgICAgIG1heFJldHJ5RGVsYXkgPSBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0O1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBsb2FkZXIgPSB0aGlzLmNyZWF0ZUludGVybmFsTG9hZGVyKGNvbnRleHQpOyAvLyBPdmVycmlkZSBsZXZlbC90cmFjayB0aW1lb3V0IGZvciBMTC1ITFMgcmVxdWVzdHNcbiAgICAvLyAodGhlIGRlZmF1bHQgb2YgMTAwMDBtcyBpcyBjb3VudGVyIHByb2R1Y3RpdmUgdG8gYmxvY2tpbmcgcGxheWxpc3QgcmVsb2FkIHJlcXVlc3RzKVxuXG4gICAgaWYgKChfY29udGV4dCRkZWxpdmVyeURpcmUgPSBjb250ZXh0LmRlbGl2ZXJ5RGlyZWN0aXZlcykgIT09IG51bGwgJiYgX2NvbnRleHQkZGVsaXZlcnlEaXJlICE9PSB2b2lkIDAgJiYgX2NvbnRleHQkZGVsaXZlcnlEaXJlLnBhcnQpIHtcbiAgICAgIHZhciBsZXZlbERldGFpbHM7XG5cbiAgICAgIGlmIChjb250ZXh0LnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uTEVWRUwgJiYgY29udGV4dC5sZXZlbCAhPT0gbnVsbCkge1xuICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmhscy5sZXZlbHNbY29udGV4dC5sZXZlbF0uZGV0YWlscztcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dC50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLkFVRElPX1RSQUNLICYmIGNvbnRleHQuaWQgIT09IG51bGwpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5obHMuYXVkaW9UcmFja3NbY29udGV4dC5pZF0uZGV0YWlscztcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dC50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLlNVQlRJVExFX1RSQUNLICYmIGNvbnRleHQuaWQgIT09IG51bGwpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5obHMuc3VidGl0bGVUcmFja3NbY29udGV4dC5pZF0uZGV0YWlscztcbiAgICAgIH1cblxuICAgICAgaWYgKGxldmVsRGV0YWlscykge1xuICAgICAgICB2YXIgcGFydFRhcmdldCA9IGxldmVsRGV0YWlscy5wYXJ0VGFyZ2V0O1xuICAgICAgICB2YXIgdGFyZ2V0RHVyYXRpb24gPSBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG5cbiAgICAgICAgaWYgKHBhcnRUYXJnZXQgJiYgdGFyZ2V0RHVyYXRpb24pIHtcbiAgICAgICAgICB0aW1lb3V0ID0gTWF0aC5taW4oTWF0aC5tYXgocGFydFRhcmdldCAqIDMsIHRhcmdldER1cmF0aW9uICogMC44KSAqIDEwMDAsIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvYWRlckNvbmZpZyA9IHtcbiAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICBtYXhSZXRyeTogbWF4UmV0cnksXG4gICAgICByZXRyeURlbGF5OiByZXRyeURlbGF5LFxuICAgICAgbWF4UmV0cnlEZWxheTogbWF4UmV0cnlEZWxheSxcbiAgICAgIGhpZ2hXYXRlck1hcms6IDBcbiAgICB9O1xuICAgIHZhciBsb2FkZXJDYWxsYmFja3MgPSB7XG4gICAgICBvblN1Y2Nlc3M6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSxcbiAgICAgIG9uRXJyb3I6IHRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblRpbWVvdXQ6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKVxuICAgIH07IC8vIGxvZ2dlci5kZWJ1ZyhgW3BsYXlsaXN0LWxvYWRlcl06IENhbGxpbmcgaW50ZXJuYWwgbG9hZGVyIGRlbGVnYXRlIGZvciBVUkw6ICR7Y29udGV4dC51cmx9YCk7XG5cbiAgICBsb2FkZXIubG9hZChjb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRzdWNjZXNzID0gZnVuY3Rpb24gbG9hZHN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgIGlmIChuZXR3b3JrRGV0YWlscyA9PT0gdm9pZCAwKSB7XG4gICAgICBuZXR3b3JrRGV0YWlscyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQuaXNTaWR4UmVxdWVzdCkge1xuICAgICAgdGhpcy5oYW5kbGVTaWR4UmVxdWVzdChyZXNwb25zZSwgY29udGV4dCk7XG4gICAgICB0aGlzLmhhbmRsZVBsYXlsaXN0TG9hZGVkKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0LnR5cGUpO1xuICAgIHZhciBzdHJpbmcgPSByZXNwb25zZS5kYXRhOyAvLyBWYWxpZGF0ZSBpZiBpdCBpcyBhbiBNM1U4IGF0IGFsbFxuXG4gICAgaWYgKHN0cmluZy5pbmRleE9mKCcjRVhUTTNVJykgIT09IDApIHtcbiAgICAgIHRoaXMuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsICdubyBFWFRNM1UgZGVsaW1pdGVyJywgbmV0d29ya0RldGFpbHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0YXRzLnBhcnNpbmcuc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTsgLy8gQ2hlY2sgaWYgY2h1bmstbGlzdCBvciBtYXN0ZXIuIGhhbmRsZSBlbXB0eSBjaHVuayBsaXN0IGNhc2UgKGZpcnN0IEVYVElORiBub3Qgc2lnbmFsZWQsIGJ1dCBUQVJHRVREVVJBVElPTiBwcmVzZW50KVxuXG4gICAgaWYgKHN0cmluZy5pbmRleE9mKCcjRVhUSU5GOicpID4gMCB8fCBzdHJpbmcuaW5kZXhPZignI0VYVC1YLVRBUkdFVERVUkFUSU9OOicpID4gMCkge1xuICAgICAgdGhpcy5oYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYW5kbGVNYXN0ZXJQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRlcnJvciA9IGZ1bmN0aW9uIGxvYWRlcnJvcihyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICBpZiAobmV0d29ya0RldGFpbHMgPT09IHZvaWQgMCkge1xuICAgICAgbmV0d29ya0RldGFpbHMgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlTmV0d29ya0Vycm9yKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBmYWxzZSwgcmVzcG9uc2UpO1xuICB9O1xuXG4gIF9wcm90by5sb2FkdGltZW91dCA9IGZ1bmN0aW9uIGxvYWR0aW1lb3V0KHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgIGlmIChuZXR3b3JrRGV0YWlscyA9PT0gdm9pZCAwKSB7XG4gICAgICBuZXR3b3JrRGV0YWlscyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5oYW5kbGVOZXR3b3JrRXJyb3IoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHRydWUpO1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVNYXN0ZXJQbGF5bGlzdCA9IGZ1bmN0aW9uIGhhbmRsZU1hc3RlclBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgdmFyIHN0cmluZyA9IHJlc3BvbnNlLmRhdGE7XG4gICAgdmFyIHVybCA9IGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcblxuICAgIHZhciBfTTNVOFBhcnNlciRwYXJzZU1hc3QgPSBfbTN1OF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0ucGFyc2VNYXN0ZXJQbGF5bGlzdChzdHJpbmcsIHVybCksXG4gICAgICAgIGxldmVscyA9IF9NM1U4UGFyc2VyJHBhcnNlTWFzdC5sZXZlbHMsXG4gICAgICAgIHNlc3Npb25EYXRhID0gX00zVThQYXJzZXIkcGFyc2VNYXN0LnNlc3Npb25EYXRhO1xuXG4gICAgaWYgKCFsZXZlbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCAnbm8gbGV2ZWwgZm91bmQgaW4gbWFuaWZlc3QnLCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBtdWx0aSBsZXZlbCBwbGF5bGlzdCwgcGFyc2UgbGV2ZWwgaW5mb1xuXG5cbiAgICB2YXIgYXVkaW9Hcm91cHMgPSBsZXZlbHMubWFwKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGxldmVsLmF0dHJzLkFVRElPLFxuICAgICAgICBhdWRpb0NvZGVjOiBsZXZlbC5hdWRpb0NvZGVjXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHZhciBzdWJ0aXRsZUdyb3VwcyA9IGxldmVscy5tYXAoZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogbGV2ZWwuYXR0cnMuU1VCVElUTEVTLFxuICAgICAgICB0ZXh0Q29kZWM6IGxldmVsLnRleHRDb2RlY1xuICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgYXVkaW9UcmFja3MgPSBfbTN1OF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0ucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCAnQVVESU8nLCBhdWRpb0dyb3Vwcyk7XG4gICAgdmFyIHN1YnRpdGxlcyA9IF9tM3U4X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXS5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCB1cmwsICdTVUJUSVRMRVMnLCBzdWJ0aXRsZUdyb3Vwcyk7XG4gICAgdmFyIGNhcHRpb25zID0gX20zdThfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdLnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIHVybCwgJ0NMT1NFRC1DQVBUSU9OUycpO1xuXG4gICAgaWYgKGF1ZGlvVHJhY2tzLmxlbmd0aCkge1xuICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSBmb3VuZCBhbiBhdWRpbyB0cmFjayBlbWJlZGRlZCBpbiBtYWluIHBsYXlsaXN0IChhdWRpbyB0cmFjayB3aXRob3V0IFVSSSBhdHRyaWJ1dGUpXG4gICAgICB2YXIgZW1iZWRkZWRBdWRpb0ZvdW5kID0gYXVkaW9UcmFja3Muc29tZShmdW5jdGlvbiAoYXVkaW9UcmFjaykge1xuICAgICAgICByZXR1cm4gIWF1ZGlvVHJhY2sudXJsO1xuICAgICAgfSk7IC8vIGlmIG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIGRlZmluZWQsIGJ1dCBhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLFxuICAgICAgLy8gd2UgbmVlZCB0byBzaWduYWwgdGhpcyBtYWluIGF1ZGlvIHRyYWNrIHRoaXMgY291bGQgaGFwcGVuIHdpdGggcGxheWxpc3RzIHdpdGhcbiAgICAgIC8vIGFsdCBhdWRpbyByZW5kaXRpb24gaW4gd2hpY2ggcXVhbGl0eSBsZXZlbHMgKG1haW4pXG4gICAgICAvLyBjb250YWlucyBib3RoIGF1ZGlvK3ZpZGVvLiBidXQgd2l0aCBtaXhlZCBhdWRpbyB0cmFjayBub3Qgc2lnbmFsZWRcblxuICAgICAgaWYgKCFlbWJlZGRlZEF1ZGlvRm91bmQgJiYgbGV2ZWxzWzBdLmF1ZGlvQ29kZWMgJiYgIWxldmVsc1swXS5hdHRycy5BVURJTykge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ubG9nKCdbcGxheWxpc3QtbG9hZGVyXTogYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCwgYnV0IG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIHNpZ25hbGVkLCBjcmVhdGUgb25lJyk7XG4gICAgICAgIGF1ZGlvVHJhY2tzLnVuc2hpZnQoe1xuICAgICAgICAgIHR5cGU6ICdtYWluJyxcbiAgICAgICAgICBuYW1lOiAnbWFpbicsXG4gICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgYXV0b3NlbGVjdDogZmFsc2UsXG4gICAgICAgICAgZm9yY2VkOiBmYWxzZSxcbiAgICAgICAgICBpZDogLTEsXG4gICAgICAgICAgYXR0cnM6IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJBdHRyTGlzdFwiXSh7fSksXG4gICAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgICB1cmw6ICcnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgIGxldmVsczogbGV2ZWxzLFxuICAgICAgYXVkaW9UcmFja3M6IGF1ZGlvVHJhY2tzLFxuICAgICAgc3VidGl0bGVzOiBzdWJ0aXRsZXMsXG4gICAgICBjYXB0aW9uczogY2FwdGlvbnMsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgIHNlc3Npb25EYXRhOiBzZXNzaW9uRGF0YVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdCA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgdmFyIGlkID0gY29udGV4dC5pZCxcbiAgICAgICAgbGV2ZWwgPSBjb250ZXh0LmxldmVsLFxuICAgICAgICB0eXBlID0gY29udGV4dC50eXBlO1xuICAgIHZhciB1cmwgPSBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG4gICAgdmFyIGxldmVsVXJsSWQgPSBPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGlkKSA/IGlkIDogMDtcbiAgICB2YXIgbGV2ZWxJZCA9IE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkobGV2ZWwpID8gbGV2ZWwgOiBsZXZlbFVybElkO1xuICAgIHZhciBsZXZlbFR5cGUgPSBtYXBDb250ZXh0VG9MZXZlbFR5cGUoY29udGV4dCk7XG4gICAgdmFyIGxldmVsRGV0YWlscyA9IF9tM3U4X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXS5wYXJzZUxldmVsUGxheWxpc3QocmVzcG9uc2UuZGF0YSwgdXJsLCBsZXZlbElkLCBsZXZlbFR5cGUsIGxldmVsVXJsSWQpO1xuXG4gICAgaWYgKCFsZXZlbERldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yVHlwZXNcIl0uTkVUV09SS19FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLkxFVkVMX0VNUFRZX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICByZWFzb246ICdubyBmcmFnbWVudHMgZm91bmQgaW4gbGV2ZWwnLFxuICAgICAgICBsZXZlbDogdHlwZW9mIGNvbnRleHQubGV2ZWwgPT09ICdudW1iZXInID8gY29udGV4dC5sZXZlbCA6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBXZSBoYXZlIGRvbmUgb3VyIGZpcnN0IHJlcXVlc3QgKE1hbmlmZXN0LXR5cGUpIGFuZCByZWNlaXZlXG4gICAgLy8gbm90IGEgbWFzdGVyIHBsYXlsaXN0IGJ1dCBhIGNodW5rLWxpc3QgKHRyYWNrL2xldmVsKVxuICAgIC8vIFdlIGZpcmUgdGhlIG1hbmlmZXN0LWxvYWRlZCBldmVudCBhbnl3YXkgd2l0aCB0aGUgcGFyc2VkIGxldmVsLWRldGFpbHNcbiAgICAvLyBieSBjcmVhdGluZyBhIHNpbmdsZS1sZXZlbCBzdHJ1Y3R1cmUgZm9yIGl0LlxuXG5cbiAgICBpZiAodHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5NQU5JRkVTVCkge1xuICAgICAgdmFyIHNpbmdsZUxldmVsID0ge1xuICAgICAgICBhdHRyczogbmV3IF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIkF0dHJMaXN0XCJdKHt9KSxcbiAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgdXJsOiB1cmxcbiAgICAgIH07XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BREVELCB7XG4gICAgICAgIGxldmVsczogW3NpbmdsZUxldmVsXSxcbiAgICAgICAgYXVkaW9UcmFja3M6IFtdLFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgIHNlc3Npb25EYXRhOiBudWxsXG4gICAgICB9KTtcbiAgICB9IC8vIHNhdmUgcGFyc2luZyB0aW1lXG5cblxuICAgIHN0YXRzLnBhcnNpbmcuZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7IC8vIGluIGNhc2Ugd2UgbmVlZCBTSURYIHJhbmdlc1xuICAgIC8vIHJldHVybiBlYXJseSBhZnRlciBjYWxsaW5nIGxvYWQgZm9yXG4gICAgLy8gdGhlIFNJRFggYm94LlxuXG4gICAgaWYgKGxldmVsRGV0YWlscy5uZWVkU2lkeFJhbmdlcykge1xuICAgICAgdmFyIF9sZXZlbERldGFpbHMkZnJhZ21lbjtcblxuICAgICAgdmFyIHNpZHhVcmwgPSAoX2xldmVsRGV0YWlscyRmcmFnbWVuID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1swXS5pbml0U2VnbWVudCkgPT09IG51bGwgfHwgX2xldmVsRGV0YWlscyRmcmFnbWVuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGV2ZWxEZXRhaWxzJGZyYWdtZW4udXJsO1xuICAgICAgdGhpcy5sb2FkKHtcbiAgICAgICAgdXJsOiBzaWR4VXJsLFxuICAgICAgICBpc1NpZHhSZXF1ZXN0OiB0cnVlLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgIGxldmVsRGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIGdyb3VwSWQ6IG51bGwsXG4gICAgICAgIHJhbmdlU3RhcnQ6IDAsXG4gICAgICAgIHJhbmdlRW5kOiAyMDQ4LFxuICAgICAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogbnVsbFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBleHRlbmQgdGhlIGNvbnRleHQgd2l0aCB0aGUgbmV3IGxldmVsRGV0YWlscyBwcm9wZXJ0eVxuXG5cbiAgICBjb250ZXh0LmxldmVsRGV0YWlscyA9IGxldmVsRGV0YWlscztcbiAgICB0aGlzLmhhbmRsZVBsYXlsaXN0TG9hZGVkKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVTaWR4UmVxdWVzdCA9IGZ1bmN0aW9uIGhhbmRsZVNpZHhSZXF1ZXN0KHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgdmFyIHNpZHhJbmZvID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcInBhcnNlU2VnbWVudEluZGV4XCJdKShuZXcgVWludDhBcnJheShyZXNwb25zZS5kYXRhKSk7IC8vIGlmIHByb3ZpZGVkIGZyYWdtZW50IGRvZXMgbm90IGNvbnRhaW4gc2lkeCwgZWFybHkgcmV0dXJuXG5cbiAgICBpZiAoIXNpZHhJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNpZHhSZWZlcmVuY2VzID0gc2lkeEluZm8ucmVmZXJlbmNlcztcbiAgICB2YXIgbGV2ZWxEZXRhaWxzID0gY29udGV4dC5sZXZlbERldGFpbHM7XG4gICAgc2lkeFJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoc2VnbWVudFJlZiwgaW5kZXgpIHtcbiAgICAgIHZhciBzZWdSZWZJbmZvID0gc2VnbWVudFJlZi5pbmZvO1xuICAgICAgdmFyIGZyYWcgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2luZGV4XTtcblxuICAgICAgaWYgKGZyYWcuYnl0ZVJhbmdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmcmFnLnNldEJ5dGVSYW5nZShTdHJpbmcoMSArIHNlZ1JlZkluZm8uZW5kIC0gc2VnUmVmSW5mby5zdGFydCkgKyAnQCcgKyBTdHJpbmcoc2VnUmVmSW5mby5zdGFydCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZnJhZy5pbml0U2VnbWVudCkge1xuICAgICAgICBmcmFnLmluaXRTZWdtZW50LnNldEJ5dGVSYW5nZShTdHJpbmcoc2lkeEluZm8ubW9vdkVuZE9mZnNldCkgKyAnQDAnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihyZXNwb25zZSwgY29udGV4dCwgcmVhc29uLCBuZXR3b3JrRGV0YWlscykge1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvclR5cGVzXCJdLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uTUFOSUZFU1RfUEFSU0lOR19FUlJPUixcbiAgICAgIGZhdGFsOiBjb250ZXh0LnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uTUFOSUZFU1QsXG4gICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVOZXR3b3JrRXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVOZXR3b3JrRXJyb3IoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHRpbWVvdXQsIHJlc3BvbnNlKSB7XG4gICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkge1xuICAgICAgdGltZW91dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS53YXJuKFwiW3BsYXlsaXN0LWxvYWRlcl06IEEgbmV0d29yayBcIiArICh0aW1lb3V0ID8gJ3RpbWVvdXQnIDogJ2Vycm9yJykgKyBcIiBvY2N1cnJlZCB3aGlsZSBsb2FkaW5nIFwiICsgY29udGV4dC50eXBlICsgXCIgbGV2ZWw6IFwiICsgY29udGV4dC5sZXZlbCArIFwiIGlkOiBcIiArIGNvbnRleHQuaWQgKyBcIiBncm91cC1pZDogXFxcIlwiICsgY29udGV4dC5ncm91cElkICsgXCJcXFwiXCIpO1xuICAgIHZhciBkZXRhaWxzID0gX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLlVOS05PV047XG4gICAgdmFyIGZhdGFsID0gZmFsc2U7XG4gICAgdmFyIGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG5cbiAgICBzd2l0Y2ggKGNvbnRleHQudHlwZSkge1xuICAgICAgY2FzZSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLk1BTklGRVNUOlxuICAgICAgICBkZXRhaWxzID0gdGltZW91dCA/IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5NQU5JRkVTVF9MT0FEX1RJTUVPVVQgOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uTUFOSUZFU1RfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLkxFVkVMOlxuICAgICAgICBkZXRhaWxzID0gdGltZW91dCA/IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5MRVZFTF9MT0FEX1RJTUVPVVQgOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uTEVWRUxfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5BVURJT19UUkFDSzpcbiAgICAgICAgZGV0YWlscyA9IHRpbWVvdXQgPyBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUIDogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLkFVRElPX1RSQUNLX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uU1VCVElUTEVfVFJBQ0s6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0ID8gX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLlNVQlRJVExFX1RSQUNLX0xPQURfVElNRU9VVCA6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5TVUJUSVRMRV9MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dC50eXBlKTtcbiAgICB9XG5cbiAgICB2YXIgZXJyb3JEYXRhID0ge1xuICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JUeXBlc1wiXS5ORVRXT1JLX0VSUk9SLFxuICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgIGZhdGFsOiBmYXRhbCxcbiAgICAgIHVybDogY29udGV4dC51cmwsXG4gICAgICBsb2FkZXI6IGxvYWRlcixcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICB9O1xuXG4gICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICBlcnJvckRhdGEucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB9XG5cbiAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5FUlJPUiwgZXJyb3JEYXRhKTtcbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlUGxheWxpc3RMb2FkZWQgPSBmdW5jdGlvbiBoYW5kbGVQbGF5bGlzdExvYWRlZChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgdmFyIHR5cGUgPSBjb250ZXh0LnR5cGUsXG4gICAgICAgIGxldmVsID0gY29udGV4dC5sZXZlbCxcbiAgICAgICAgaWQgPSBjb250ZXh0LmlkLFxuICAgICAgICBncm91cElkID0gY29udGV4dC5ncm91cElkLFxuICAgICAgICBsb2FkZXIgPSBjb250ZXh0LmxvYWRlcixcbiAgICAgICAgbGV2ZWxEZXRhaWxzID0gY29udGV4dC5sZXZlbERldGFpbHMsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IGNvbnRleHQuZGVsaXZlcnlEaXJlY3RpdmVzO1xuXG4gICAgaWYgKCEobGV2ZWxEZXRhaWxzICE9PSBudWxsICYmIGxldmVsRGV0YWlscyAhPT0gdm9pZCAwICYmIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikpIHtcbiAgICAgIHRoaXMuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsICdpbnZhbGlkIHRhcmdldCBkdXJhdGlvbicsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWxvYWRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgaWYgKGxvYWRlci5nZXRDYWNoZUFnZSkge1xuICAgICAgICBsZXZlbERldGFpbHMuYWdlSGVhZGVyID0gbG9hZGVyLmdldENhY2hlQWdlKCkgfHwgMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFsb2FkZXIuZ2V0Q2FjaGVBZ2UgfHwgaXNOYU4obGV2ZWxEZXRhaWxzLmFnZUhlYWRlcikpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzLmFnZUhlYWRlciA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uTUFOSUZFU1Q6XG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uTEVWRUw6XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkxFVkVMX0xPQURFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICBsZXZlbDogbGV2ZWwgfHwgMCxcbiAgICAgICAgICBpZDogaWQgfHwgMCxcbiAgICAgICAgICBzdGF0czogc3RhdHMsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLkFVRElPX1RSQUNLOlxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19MT0FERUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCB8fCAnJyxcbiAgICAgICAgICBzdGF0czogc3RhdHMsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLlNVQlRJVExFX1RSQUNLOlxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCB8fCAnJyxcbiAgICAgICAgICBzdGF0czogc3RhdHMsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBsYXlsaXN0TG9hZGVyO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFBsYXlsaXN0TG9hZGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3BvbHlmaWxscy9udW1iZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBpc0Zpbml0ZU51bWJlciwgTUFYX1NBRkVfSU5URUdFUiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpc0Zpbml0ZU51bWJlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzRmluaXRlTnVtYmVyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJNQVhfU0FGRV9JTlRFR0VSXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTUFYX1NBRkVfSU5URUdFUjsgfSk7XG52YXIgaXNGaW5pdGVOdW1iZXIgPSBOdW1iZXIuaXNGaW5pdGUgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKTtcbn07XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3JlbXV4L2FhYy1oZWxwZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9yZW11eC9hYWMtaGVscGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qKlxuICogIEFBQyBoZWxwZXJcbiAqL1xudmFyIEFBQyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFBQygpIHt9XG5cbiAgQUFDLmdldFNpbGVudEZyYW1lID0gZnVuY3Rpb24gZ2V0U2lsZW50RnJhbWUoY29kZWMsIGNoYW5uZWxDb3VudCkge1xuICAgIHN3aXRjaCAoY29kZWMpIHtcbiAgICAgIGNhc2UgJ21wNGEuNDAuMic6XG4gICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjMsIDB4ODBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MjEsIDB4MDAsIDB4NDksIDB4OTAsIDB4MDIsIDB4MTksIDB4MDAsIDB4MjMsIDB4ODBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4OGVdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODAsIDB4MmMsIDB4ODAsIDB4MDgsIDB4MDIsIDB4MzhdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MzhdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDYpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MDAsIDB4YjIsIDB4MDAsIDB4MjAsIDB4MDgsIDB4ZTBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gaGFuZGxlIEhFLUFBQyBiZWxvdyAobXA0YS40MC41IC8gbXA0YS40MC4yOSlcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NGUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgxYywgMHg2LCAweGYxLCAweGMxLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NWUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDk1LCAweDAsIDB4NiwgMHhmMSwgMHhhMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XG4gICAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MHwwfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NWUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDk1LCAweDAsIDB4NiwgMHhmMSwgMHhhMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHJldHVybiBBQUM7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQUFDKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcmVtdXgvbXA0LWdlbmVyYXRvci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3JlbXV4L21wNC1nZW5lcmF0b3IudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyoqXG4gKiBHZW5lcmF0ZSBNUDQgQm94XG4gKi9cbnZhciBVSU5UMzJfTUFYID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcblxudmFyIE1QNCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1QNCgpIHt9XG5cbiAgTVA0LmluaXQgPSBmdW5jdGlvbiBpbml0KCkge1xuICAgIE1QNC50eXBlcyA9IHtcbiAgICAgIGF2YzE6IFtdLFxuICAgICAgLy8gY29kaW5nbmFtZVxuICAgICAgYXZjQzogW10sXG4gICAgICBidHJ0OiBbXSxcbiAgICAgIGRpbmY6IFtdLFxuICAgICAgZHJlZjogW10sXG4gICAgICBlc2RzOiBbXSxcbiAgICAgIGZ0eXA6IFtdLFxuICAgICAgaGRscjogW10sXG4gICAgICBtZGF0OiBbXSxcbiAgICAgIG1kaGQ6IFtdLFxuICAgICAgbWRpYTogW10sXG4gICAgICBtZmhkOiBbXSxcbiAgICAgIG1pbmY6IFtdLFxuICAgICAgbW9vZjogW10sXG4gICAgICBtb292OiBbXSxcbiAgICAgIG1wNGE6IFtdLFxuICAgICAgJy5tcDMnOiBbXSxcbiAgICAgIG12ZXg6IFtdLFxuICAgICAgbXZoZDogW10sXG4gICAgICBwYXNwOiBbXSxcbiAgICAgIHNkdHA6IFtdLFxuICAgICAgc3RibDogW10sXG4gICAgICBzdGNvOiBbXSxcbiAgICAgIHN0c2M6IFtdLFxuICAgICAgc3RzZDogW10sXG4gICAgICBzdHN6OiBbXSxcbiAgICAgIHN0dHM6IFtdLFxuICAgICAgdGZkdDogW10sXG4gICAgICB0ZmhkOiBbXSxcbiAgICAgIHRyYWY6IFtdLFxuICAgICAgdHJhazogW10sXG4gICAgICB0cnVuOiBbXSxcbiAgICAgIHRyZXg6IFtdLFxuICAgICAgdGtoZDogW10sXG4gICAgICB2bWhkOiBbXSxcbiAgICAgIHNtaGQ6IFtdXG4gICAgfTtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSBpbiBNUDQudHlwZXMpIHtcbiAgICAgIGlmIChNUDQudHlwZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgTVA0LnR5cGVzW2ldID0gW2kuY2hhckNvZGVBdCgwKSwgaS5jaGFyQ29kZUF0KDEpLCBpLmNoYXJDb2RlQXQoMiksIGkuY2hhckNvZGVBdCgzKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHZpZGVvSGRsciA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgMHg3NiwgMHg2OSwgMHg2NCwgMHg2NSwgLy8gaGFuZGxlcl90eXBlOiAndmlkZSdcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDU2LCAweDY5LCAweDY0LCAweDY1LCAweDZmLCAweDQ4LCAweDYxLCAweDZlLCAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdWaWRlb0hhbmRsZXInXG4gICAgXSk7XG4gICAgdmFyIGF1ZGlvSGRsciA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgMHg3MywgMHg2ZiwgMHg3NSwgMHg2ZSwgLy8gaGFuZGxlcl90eXBlOiAnc291bidcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDUzLCAweDZmLCAweDc1LCAweDZlLCAweDY0LCAweDQ4LCAweDYxLCAweDZlLCAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdTb3VuZEhhbmRsZXInXG4gICAgXSk7XG4gICAgTVA0LkhETFJfVFlQRVMgPSB7XG4gICAgICB2aWRlbzogdmlkZW9IZGxyLFxuICAgICAgYXVkaW86IGF1ZGlvSGRsclxuICAgIH07XG4gICAgdmFyIGRyZWYgPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyBlbnRyeV9jb3VudFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MGMsIC8vIGVudHJ5X3NpemVcbiAgICAweDc1LCAweDcyLCAweDZjLCAweDIwLCAvLyAndXJsJyB0eXBlXG4gICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMSAvLyBlbnRyeV9mbGFnc1xuICAgIF0pO1xuICAgIHZhciBzdGNvID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnRcbiAgICBdKTtcbiAgICBNUDQuU1RUUyA9IE1QNC5TVFNDID0gTVA0LlNUQ08gPSBzdGNvO1xuICAgIE1QNC5TVFNaID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHNhbXBsZV9zaXplXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBzYW1wbGVfY291bnRcbiAgICBdKTtcbiAgICBNUDQuVk1IRCA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAvLyBncmFwaGljc21vZGVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIG9wY29sb3JcbiAgICBdKTtcbiAgICBNUDQuU01IRCA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAvLyBiYWxhbmNlXG4gICAgMHgwMCwgMHgwMCAvLyByZXNlcnZlZFxuICAgIF0pO1xuICAgIE1QNC5TVFNEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMV0pOyAvLyBlbnRyeV9jb3VudFxuXG4gICAgdmFyIG1ham9yQnJhbmQgPSBuZXcgVWludDhBcnJheShbMTA1LCAxMTUsIDExMSwgMTA5XSk7IC8vIGlzb21cblxuICAgIHZhciBhdmMxQnJhbmQgPSBuZXcgVWludDhBcnJheShbOTcsIDExOCwgOTksIDQ5XSk7IC8vIGF2YzFcblxuICAgIHZhciBtaW5vclZlcnNpb24gPSBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMV0pO1xuICAgIE1QNC5GVFlQID0gTVA0LmJveChNUDQudHlwZXMuZnR5cCwgbWFqb3JCcmFuZCwgbWlub3JWZXJzaW9uLCBtYWpvckJyYW5kLCBhdmMxQnJhbmQpO1xuICAgIE1QNC5ESU5GID0gTVA0LmJveChNUDQudHlwZXMuZGluZiwgTVA0LmJveChNUDQudHlwZXMuZHJlZiwgZHJlZikpO1xuICB9O1xuXG4gIE1QNC5ib3ggPSBmdW5jdGlvbiBib3godHlwZSkge1xuICAgIHZhciBzaXplID0gODtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXlsb2FkID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHBheWxvYWRbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBpID0gcGF5bG9hZC5sZW5ndGg7XG4gICAgdmFyIGxlbiA9IGk7IC8vIGNhbGN1bGF0ZSB0aGUgdG90YWwgc2l6ZSB3ZSBuZWVkIHRvIGFsbG9jYXRlXG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgcmVzdWx0WzBdID0gc2l6ZSA+PiAyNCAmIDB4ZmY7XG4gICAgcmVzdWx0WzFdID0gc2l6ZSA+PiAxNiAmIDB4ZmY7XG4gICAgcmVzdWx0WzJdID0gc2l6ZSA+PiA4ICYgMHhmZjtcbiAgICByZXN1bHRbM10gPSBzaXplICYgMHhmZjtcbiAgICByZXN1bHQuc2V0KHR5cGUsIDQpOyAvLyBjb3B5IHRoZSBwYXlsb2FkIGludG8gdGhlIHJlc3VsdFxuXG4gICAgZm9yIChpID0gMCwgc2l6ZSA9IDg7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gY29weSBwYXlsb2FkW2ldIGFycmF5IEAgb2Zmc2V0IHNpemVcbiAgICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIE1QNC5oZGxyID0gZnVuY3Rpb24gaGRscih0eXBlKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmhkbHIsIE1QNC5IRExSX1RZUEVTW3R5cGVdKTtcbiAgfTtcblxuICBNUDQubWRhdCA9IGZ1bmN0aW9uIG1kYXQoZGF0YSkge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGF0LCBkYXRhKTtcbiAgfTtcblxuICBNUDQubWRoZCA9IGZ1bmN0aW9uIG1kaGQodGltZXNjYWxlLCBkdXJhdGlvbikge1xuICAgIGR1cmF0aW9uICo9IHRpbWVzY2FsZTtcbiAgICB2YXIgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgdmFyIGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGhkLCBuZXcgVWludDhBcnJheShbMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICB0aW1lc2NhbGUgPj4gMjQgJiAweGZmLCB0aW1lc2NhbGUgPj4gMTYgJiAweGZmLCB0aW1lc2NhbGUgPj4gOCAmIDB4ZmYsIHRpbWVzY2FsZSAmIDB4ZmYsIC8vIHRpbWVzY2FsZVxuICAgIHVwcGVyV29yZER1cmF0aW9uID4+IDI0LCB1cHBlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDI0LCBsb3dlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiAmIDB4ZmYsIDB4NTUsIDB4YzQsIC8vICd1bmQnIGxhbmd1YWdlICh1bmRldGVybWluZWQpXG4gICAgMHgwMCwgMHgwMF0pKTtcbiAgfTtcblxuICBNUDQubWRpYSA9IGZ1bmN0aW9uIG1kaWEodHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRpYSwgTVA0Lm1kaGQodHJhY2sudGltZXNjYWxlLCB0cmFjay5kdXJhdGlvbiksIE1QNC5oZGxyKHRyYWNrLnR5cGUpLCBNUDQubWluZih0cmFjaykpO1xuICB9O1xuXG4gIE1QNC5tZmhkID0gZnVuY3Rpb24gbWZoZChzZXF1ZW5jZU51bWJlcikge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZmhkLCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICBzZXF1ZW5jZU51bWJlciA+PiAyNCwgc2VxdWVuY2VOdW1iZXIgPj4gMTYgJiAweGZmLCBzZXF1ZW5jZU51bWJlciA+PiA4ICYgMHhmZiwgc2VxdWVuY2VOdW1iZXIgJiAweGZmIC8vIHNlcXVlbmNlX251bWJlclxuICAgIF0pKTtcbiAgfTtcblxuICBNUDQubWluZiA9IGZ1bmN0aW9uIG1pbmYodHJhY2spIHtcbiAgICBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnNtaGQsIE1QNC5TTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5taW5mLCBNUDQuYm94KE1QNC50eXBlcy52bWhkLCBNUDQuVk1IRCksIE1QNC5ESU5GLCBNUDQuc3RibCh0cmFjaykpO1xuICAgIH1cbiAgfTtcblxuICBNUDQubW9vZiA9IGZ1bmN0aW9uIG1vb2Yoc24sIGJhc2VNZWRpYURlY29kZVRpbWUsIHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1vb2YsIE1QNC5tZmhkKHNuKSwgTVA0LnRyYWYodHJhY2ssIGJhc2VNZWRpYURlY29kZVRpbWUpKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHRyYWNrcy4uLiAob3B0aW9uYWwpIHthcnJheX0gdGhlIHRyYWNrcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtb3ZpZVxuICAgKi9cbiAgO1xuXG4gIE1QNC5tb292ID0gZnVuY3Rpb24gbW9vdih0cmFja3MpIHtcbiAgICB2YXIgaSA9IHRyYWNrcy5sZW5ndGg7XG4gICAgdmFyIGJveGVzID0gW107XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBib3hlc1tpXSA9IE1QNC50cmFrKHRyYWNrc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1QNC5ib3guYXBwbHkobnVsbCwgW01QNC50eXBlcy5tb292LCBNUDQubXZoZCh0cmFja3NbMF0udGltZXNjYWxlLCB0cmFja3NbMF0uZHVyYXRpb24pXS5jb25jYXQoYm94ZXMpLmNvbmNhdChNUDQubXZleCh0cmFja3MpKSk7XG4gIH07XG5cbiAgTVA0Lm12ZXggPSBmdW5jdGlvbiBtdmV4KHRyYWNrcykge1xuICAgIHZhciBpID0gdHJhY2tzLmxlbmd0aDtcbiAgICB2YXIgYm94ZXMgPSBbXTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGJveGVzW2ldID0gTVA0LnRyZXgodHJhY2tzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm12ZXhdLmNvbmNhdChib3hlcykpO1xuICB9O1xuXG4gIE1QNC5tdmhkID0gZnVuY3Rpb24gbXZoZCh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xuICAgIHZhciB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICB2YXIgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDEsIC8vIHZlcnNpb24gMVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMiwgLy8gY3JlYXRpb25fdGltZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgdGltZXNjYWxlID4+IDI0ICYgMHhmZiwgdGltZXNjYWxlID4+IDE2ICYgMHhmZiwgdGltZXNjYWxlID4+IDggJiAweGZmLCB0aW1lc2NhbGUgJiAweGZmLCAvLyB0aW1lc2NhbGVcbiAgICB1cHBlcldvcmREdXJhdGlvbiA+PiAyNCwgdXBwZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiAyNCwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gJiAweGZmLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAvLyAxLjAgcmF0ZVxuICAgIDB4MDEsIDB4MDAsIC8vIDEuMCB2b2x1bWVcbiAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDQwLCAweDAwLCAweDAwLCAweDAwLCAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAweGZmLCAweGZmLCAweGZmLCAweGZmIC8vIG5leHRfdHJhY2tfSURcbiAgICBdKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXZoZCwgYnl0ZXMpO1xuICB9O1xuXG4gIE1QNC5zZHRwID0gZnVuY3Rpb24gc2R0cCh0cmFjaykge1xuICAgIHZhciBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXTtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheSg0ICsgc2FtcGxlcy5sZW5ndGgpO1xuICAgIHZhciBpO1xuICAgIHZhciBmbGFnczsgLy8gbGVhdmUgdGhlIGZ1bGwgYm94IGhlYWRlciAoNCBieXRlcykgYWxsIHplcm9cbiAgICAvLyB3cml0ZSB0aGUgc2FtcGxlIHRhYmxlXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZmxhZ3MgPSBzYW1wbGVzW2ldLmZsYWdzO1xuICAgICAgYnl0ZXNbaSArIDRdID0gZmxhZ3MuZGVwZW5kc09uIDw8IDQgfCBmbGFncy5pc0RlcGVuZGVkT24gPDwgMiB8IGZsYWdzLmhhc1JlZHVuZGFuY3k7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnNkdHAsIGJ5dGVzKTtcbiAgfTtcblxuICBNUDQuc3RibCA9IGZ1bmN0aW9uIHN0YmwodHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RibCwgTVA0LnN0c2QodHJhY2spLCBNUDQuYm94KE1QNC50eXBlcy5zdHRzLCBNUDQuU1RUUyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c2MsIE1QNC5TVFNDKSwgTVA0LmJveChNUDQudHlwZXMuc3RzeiwgTVA0LlNUU1opLCBNUDQuYm94KE1QNC50eXBlcy5zdGNvLCBNUDQuU1RDTykpO1xuICB9O1xuXG4gIE1QNC5hdmMxID0gZnVuY3Rpb24gYXZjMSh0cmFjaykge1xuICAgIHZhciBzcHMgPSBbXTtcbiAgICB2YXIgcHBzID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGE7XG4gICAgdmFyIGxlbjsgLy8gYXNzZW1ibGUgdGhlIFNQU3NcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5zcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEgPSB0cmFjay5zcHNbaV07XG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBzcHMucHVzaChsZW4gPj4+IDggJiAweGZmKTtcbiAgICAgIHNwcy5wdXNoKGxlbiAmIDB4ZmYpOyAvLyBTUFNcblxuICAgICAgc3BzID0gc3BzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XG4gICAgfSAvLyBhc3NlbWJsZSB0aGUgUFBTc1xuXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2sucHBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhID0gdHJhY2sucHBzW2ldO1xuICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgcHBzLnB1c2gobGVuID4+PiA4ICYgMHhmZik7XG4gICAgICBwcHMucHVzaChsZW4gJiAweGZmKTtcbiAgICAgIHBwcyA9IHBwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xuICAgIH1cblxuICAgIHZhciBhdmNjID0gTVA0LmJveChNUDQudHlwZXMuYXZjQywgbmV3IFVpbnQ4QXJyYXkoWzB4MDEsIC8vIHZlcnNpb25cbiAgICBzcHNbM10sIC8vIHByb2ZpbGVcbiAgICBzcHNbNF0sIC8vIHByb2ZpbGUgY29tcGF0XG4gICAgc3BzWzVdLCAvLyBsZXZlbFxuICAgIDB4ZmMgfCAzLCAvLyBsZW5ndGhTaXplTWludXNPbmUsIGhhcmQtY29kZWQgdG8gNCBieXRlc1xuICAgIDB4ZTAgfCB0cmFjay5zcHMubGVuZ3RoIC8vIDNiaXQgcmVzZXJ2ZWQgKDExMSkgKyBudW1PZlNlcXVlbmNlUGFyYW1ldGVyU2V0c1xuICAgIF0uY29uY2F0KHNwcykuY29uY2F0KFt0cmFjay5wcHMubGVuZ3RoIC8vIG51bU9mUGljdHVyZVBhcmFtZXRlclNldHNcbiAgICBdKS5jb25jYXQocHBzKSkpOyAvLyBcIlBQU1wiXG5cbiAgICB2YXIgd2lkdGggPSB0cmFjay53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0O1xuICAgIHZhciBoU3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMF07XG4gICAgdmFyIHZTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1sxXTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuYXZjMSwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgIHdpZHRoID4+IDggJiAweGZmLCB3aWR0aCAmIDB4ZmYsIC8vIHdpZHRoXG4gICAgaGVpZ2h0ID4+IDggJiAweGZmLCBoZWlnaHQgJiAweGZmLCAvLyBoZWlnaHRcbiAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLCAvLyBob3JpenJlc29sdXRpb25cbiAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLCAvLyB2ZXJ0cmVzb2x1dGlvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSwgLy8gZnJhbWVfY291bnRcbiAgICAweDEyLCAweDY0LCAweDYxLCAweDY5LCAweDZjLCAvLyBkYWlseW1vdGlvbi9obHMuanNcbiAgICAweDc5LCAweDZkLCAweDZmLCAweDc0LCAweDY5LCAweDZmLCAweDZlLCAweDJmLCAweDY4LCAweDZjLCAweDczLCAweDJlLCAweDZhLCAweDczLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBjb21wcmVzc29ybmFtZVxuICAgIDB4MDAsIDB4MTgsIC8vIGRlcHRoID0gMjRcbiAgICAweDExLCAweDExXSksIC8vIHByZV9kZWZpbmVkID0gLTFcbiAgICBhdmNjLCBNUDQuYm94KE1QNC50eXBlcy5idHJ0LCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgxYywgMHg5YywgMHg4MCwgLy8gYnVmZmVyU2l6ZURCXG4gICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMCwgLy8gbWF4Qml0cmF0ZVxuICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzBdKSksIC8vIGF2Z0JpdHJhdGVcbiAgICBNUDQuYm94KE1QNC50eXBlcy5wYXNwLCBuZXcgVWludDhBcnJheShbaFNwYWNpbmcgPj4gMjQsIC8vIGhTcGFjaW5nXG4gICAgaFNwYWNpbmcgPj4gMTYgJiAweGZmLCBoU3BhY2luZyA+PiA4ICYgMHhmZiwgaFNwYWNpbmcgJiAweGZmLCB2U3BhY2luZyA+PiAyNCwgLy8gdlNwYWNpbmdcbiAgICB2U3BhY2luZyA+PiAxNiAmIDB4ZmYsIHZTcGFjaW5nID4+IDggJiAweGZmLCB2U3BhY2luZyAmIDB4ZmZdKSkpO1xuICB9O1xuXG4gIE1QNC5lc2RzID0gZnVuY3Rpb24gZXNkcyh0cmFjaykge1xuICAgIHZhciBjb25maWdsZW4gPSB0cmFjay5jb25maWcubGVuZ3RoO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAweDAzLCAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAweDE3ICsgY29uZmlnbGVuLCAvLyBsZW5ndGhcbiAgICAweDAwLCAweDAxLCAvLyBlc19pZFxuICAgIDB4MDAsIC8vIHN0cmVhbV9wcmlvcml0eVxuICAgIDB4MDQsIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgIDB4MGYgKyBjb25maWdsZW4sIC8vIGxlbmd0aFxuICAgIDB4NDAsIC8vIGNvZGVjIDogbXBlZzRfYXVkaW9cbiAgICAweDE1LCAvLyBzdHJlYW1fdHlwZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGJ1ZmZlcl9zaXplXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gbWF4Qml0cmF0ZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGF2Z0JpdHJhdGVcbiAgICAweDA1IC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgIF0uY29uY2F0KFtjb25maWdsZW5dKS5jb25jYXQodHJhY2suY29uZmlnKS5jb25jYXQoWzB4MDYsIDB4MDEsIDB4MDJdKSk7IC8vIEdBU3BlY2lmaWNDb25maWcpKTsgLy8gbGVuZ3RoICsgYXVkaW8gY29uZmlnIGRlc2NyaXB0b3JcbiAgfTtcblxuICBNUDQubXA0YSA9IGZ1bmN0aW9uIG1wNGEodHJhY2spIHtcbiAgICB2YXIgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGU7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1wNGEsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIHRyYWNrLmNoYW5uZWxDb3VudCwgLy8gY2hhbm5lbGNvdW50XG4gICAgMHgwMCwgMHgxMCwgLy8gc2FtcGxlU2l6ZToxNmJpdHNcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDJcbiAgICBzYW1wbGVyYXRlID4+IDggJiAweGZmLCBzYW1wbGVyYXRlICYgMHhmZiwgLy9cbiAgICAweDAwLCAweDAwXSksIE1QNC5ib3goTVA0LnR5cGVzLmVzZHMsIE1QNC5lc2RzKHRyYWNrKSkpO1xuICB9O1xuXG4gIE1QNC5tcDMgPSBmdW5jdGlvbiBtcDModHJhY2spIHtcbiAgICB2YXIgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGU7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzWycubXAzJ10sIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIHRyYWNrLmNoYW5uZWxDb3VudCwgLy8gY2hhbm5lbGNvdW50XG4gICAgMHgwMCwgMHgxMCwgLy8gc2FtcGxlU2l6ZToxNmJpdHNcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDJcbiAgICBzYW1wbGVyYXRlID4+IDggJiAweGZmLCBzYW1wbGVyYXRlICYgMHhmZiwgLy9cbiAgICAweDAwLCAweDAwXSkpO1xuICB9O1xuXG4gIE1QNC5zdHNkID0gZnVuY3Rpb24gc3RzZCh0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICBpZiAodHJhY2suc2VnbWVudENvZGVjID09PSAnbXAzJyAmJiB0cmFjay5jb2RlYyA9PT0gJ21wMycpIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQubXAzKHRyYWNrKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wNGEodHJhY2spKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQuYXZjMSh0cmFjaykpO1xuICAgIH1cbiAgfTtcblxuICBNUDQudGtoZCA9IGZ1bmN0aW9uIHRraGQodHJhY2spIHtcbiAgICB2YXIgaWQgPSB0cmFjay5pZDtcbiAgICB2YXIgZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiAqIHRyYWNrLnRpbWVzY2FsZTtcbiAgICB2YXIgd2lkdGggPSB0cmFjay53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0O1xuICAgIHZhciB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICB2YXIgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRraGQsIG5ldyBVaW50OEFycmF5KFsweDAxLCAvLyB2ZXJzaW9uIDFcbiAgICAweDAwLCAweDAwLCAweDA3LCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLCAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgIGlkID4+IDI0ICYgMHhmZiwgaWQgPj4gMTYgJiAweGZmLCBpZCA+PiA4ICYgMHhmZiwgaWQgJiAweGZmLCAvLyB0cmFja19JRFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgdXBwZXJXb3JkRHVyYXRpb24gPj4gMjQsIHVwcGVyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMjQsIGxvd2VyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uICYgMHhmZiwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAvLyBsYXllclxuICAgIDB4MDAsIDB4MDAsIC8vIGFsdGVybmF0ZV9ncm91cFxuICAgIDB4MDAsIDB4MDAsIC8vIG5vbi1hdWRpbyB0cmFjayB2b2x1bWVcbiAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcbiAgICB3aWR0aCA+PiA4ICYgMHhmZiwgd2lkdGggJiAweGZmLCAweDAwLCAweDAwLCAvLyB3aWR0aFxuICAgIGhlaWdodCA+PiA4ICYgMHhmZiwgaGVpZ2h0ICYgMHhmZiwgMHgwMCwgMHgwMCAvLyBoZWlnaHRcbiAgICBdKSk7XG4gIH07XG5cbiAgTVA0LnRyYWYgPSBmdW5jdGlvbiB0cmFmKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKSB7XG4gICAgdmFyIHNhbXBsZURlcGVuZGVuY3lUYWJsZSA9IE1QNC5zZHRwKHRyYWNrKTtcbiAgICB2YXIgaWQgPSB0cmFjay5pZDtcbiAgICB2YXIgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHZhciBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWYsIE1QNC5ib3goTVA0LnR5cGVzLnRmaGQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIGlkID4+IDI0LCBpZCA+PiAxNiAmIDB4ZmYsIGlkID4+IDggJiAweGZmLCBpZCAmIDB4ZmYgLy8gdHJhY2tfSURcbiAgICBdKSksIE1QNC5ib3goTVA0LnR5cGVzLnRmZHQsIG5ldyBVaW50OEFycmF5KFsweDAxLCAvLyB2ZXJzaW9uIDFcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMjQsIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYgJiAweGZmLCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDggJiAweGZmLCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhmZiwgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAyNCwgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNiAmIDB4ZmYsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gOCAmIDB4ZmYsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweGZmXSkpLCBNUDQudHJ1bih0cmFjaywgc2FtcGxlRGVwZW5kZW5jeVRhYmxlLmxlbmd0aCArIDE2ICsgLy8gdGZoZFxuICAgIDIwICsgLy8gdGZkdFxuICAgIDggKyAvLyB0cmFmIGhlYWRlclxuICAgIDE2ICsgLy8gbWZoZFxuICAgIDggKyAvLyBtb29mIGhlYWRlclxuICAgIDgpLCAvLyBtZGF0IGhlYWRlclxuICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhY2sgYm94LlxuICAgKiBAcGFyYW0gdHJhY2sge29iamVjdH0gYSB0cmFjayBkZWZpbml0aW9uXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IHRoZSB0cmFjayBib3hcbiAgICovXG4gIDtcblxuICBNUDQudHJhayA9IGZ1bmN0aW9uIHRyYWsodHJhY2spIHtcbiAgICB0cmFjay5kdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uIHx8IDB4ZmZmZmZmZmY7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWssIE1QNC50a2hkKHRyYWNrKSwgTVA0Lm1kaWEodHJhY2spKTtcbiAgfTtcblxuICBNUDQudHJleCA9IGZ1bmN0aW9uIHRyZXgodHJhY2spIHtcbiAgICB2YXIgaWQgPSB0cmFjay5pZDtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJleCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgaWQgPj4gMjQsIGlkID4+IDE2ICYgMHhmZiwgaWQgPj4gOCAmIDB4ZmYsIGlkICYgMHhmZiwgLy8gdHJhY2tfSURcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyBkZWZhdWx0X3NhbXBsZV9kZXNjcmlwdGlvbl9pbmRleFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfc2l6ZVxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDEgLy8gZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgICBdKSk7XG4gIH07XG5cbiAgTVA0LnRydW4gPSBmdW5jdGlvbiB0cnVuKHRyYWNrLCBvZmZzZXQpIHtcbiAgICB2YXIgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW107XG4gICAgdmFyIGxlbiA9IHNhbXBsZXMubGVuZ3RoO1xuICAgIHZhciBhcnJheWxlbiA9IDEyICsgMTYgKiBsZW47XG4gICAgdmFyIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlsZW4pO1xuICAgIHZhciBpO1xuICAgIHZhciBzYW1wbGU7XG4gICAgdmFyIGR1cmF0aW9uO1xuICAgIHZhciBzaXplO1xuICAgIHZhciBmbGFncztcbiAgICB2YXIgY3RzO1xuICAgIG9mZnNldCArPSA4ICsgYXJyYXlsZW47XG4gICAgYXJyYXkuc2V0KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDBmLCAweDAxLCAvLyBmbGFnc1xuICAgIGxlbiA+Pj4gMjQgJiAweGZmLCBsZW4gPj4+IDE2ICYgMHhmZiwgbGVuID4+PiA4ICYgMHhmZiwgbGVuICYgMHhmZiwgLy8gc2FtcGxlX2NvdW50XG4gICAgb2Zmc2V0ID4+PiAyNCAmIDB4ZmYsIG9mZnNldCA+Pj4gMTYgJiAweGZmLCBvZmZzZXQgPj4+IDggJiAweGZmLCBvZmZzZXQgJiAweGZmIC8vIGRhdGFfb2Zmc2V0XG4gICAgXSwgMCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNhbXBsZSA9IHNhbXBsZXNbaV07XG4gICAgICBkdXJhdGlvbiA9IHNhbXBsZS5kdXJhdGlvbjtcbiAgICAgIHNpemUgPSBzYW1wbGUuc2l6ZTtcbiAgICAgIGZsYWdzID0gc2FtcGxlLmZsYWdzO1xuICAgICAgY3RzID0gc2FtcGxlLmN0cztcbiAgICAgIGFycmF5LnNldChbZHVyYXRpb24gPj4+IDI0ICYgMHhmZiwgZHVyYXRpb24gPj4+IDE2ICYgMHhmZiwgZHVyYXRpb24gPj4+IDggJiAweGZmLCBkdXJhdGlvbiAmIDB4ZmYsIC8vIHNhbXBsZV9kdXJhdGlvblxuICAgICAgc2l6ZSA+Pj4gMjQgJiAweGZmLCBzaXplID4+PiAxNiAmIDB4ZmYsIHNpemUgPj4+IDggJiAweGZmLCBzaXplICYgMHhmZiwgLy8gc2FtcGxlX3NpemVcbiAgICAgIGZsYWdzLmlzTGVhZGluZyA8PCAyIHwgZmxhZ3MuZGVwZW5kc09uLCBmbGFncy5pc0RlcGVuZGVkT24gPDwgNiB8IGZsYWdzLmhhc1JlZHVuZGFuY3kgPDwgNCB8IGZsYWdzLnBhZGRpbmdWYWx1ZSA8PCAxIHwgZmxhZ3MuaXNOb25TeW5jLCBmbGFncy5kZWdyYWRQcmlvICYgMHhmMCA8PCA4LCBmbGFncy5kZWdyYWRQcmlvICYgMHgwZiwgLy8gc2FtcGxlX2ZsYWdzXG4gICAgICBjdHMgPj4+IDI0ICYgMHhmZiwgY3RzID4+PiAxNiAmIDB4ZmYsIGN0cyA+Pj4gOCAmIDB4ZmYsIGN0cyAmIDB4ZmYgLy8gc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgICBdLCAxMiArIDE2ICogaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRydW4sIGFycmF5KTtcbiAgfTtcblxuICBNUDQuaW5pdFNlZ21lbnQgPSBmdW5jdGlvbiBpbml0U2VnbWVudCh0cmFja3MpIHtcbiAgICBpZiAoIU1QNC50eXBlcykge1xuICAgICAgTVA0LmluaXQoKTtcbiAgICB9XG5cbiAgICB2YXIgbW92aWUgPSBNUDQubW9vdih0cmFja3MpO1xuICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShNUDQuRlRZUC5ieXRlTGVuZ3RoICsgbW92aWUuYnl0ZUxlbmd0aCk7XG4gICAgcmVzdWx0LnNldChNUDQuRlRZUCk7XG4gICAgcmVzdWx0LnNldChtb3ZpZSwgTVA0LkZUWVAuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gTVA0O1xufSgpO1xuXG5NUDQudHlwZXMgPSB2b2lkIDA7XG5NUDQuSERMUl9UWVBFUyA9IHZvaWQgMDtcbk1QNC5TVFRTID0gdm9pZCAwO1xuTVA0LlNUU0MgPSB2b2lkIDA7XG5NUDQuU1RDTyA9IHZvaWQgMDtcbk1QNC5TVFNaID0gdm9pZCAwO1xuTVA0LlZNSEQgPSB2b2lkIDA7XG5NUDQuU01IRCA9IHZvaWQgMDtcbk1QNC5TVFNEID0gdm9pZCAwO1xuTVA0LkZUWVAgPSB2b2lkIDA7XG5NUDQuRElORiA9IHZvaWQgMDtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoTVA0KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcmVtdXgvbXA0LXJlbXV4ZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcmVtdXgvbXA0LXJlbXV4ZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCwgbm9ybWFsaXplUHRzLCBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcywgZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIE1QNFJlbXV4ZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm5vcm1hbGl6ZVB0c1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG5vcm1hbGl6ZVB0czsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZmx1c2hUZXh0VHJhY2tNZXRhZGF0YUN1ZVNhbXBsZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmbHVzaFRleHRUcmFja1VzZXJkYXRhQ3VlU2FtcGxlczsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2FhY19oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWFjLWhlbHBlciAqLyBcIi4vc3JjL3JlbXV4L2FhYy1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21wNF9nZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbXA0LWdlbmVyYXRvciAqLyBcIi4vc3JjL3JlbXV4L21wNC1nZW5lcmF0b3IudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvbG9hZGVyICovIFwiLi9zcmMvdHlwZXMvbG9hZGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc190aW1lc2NhbGVfY29udmVyc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24gKi8gXCIuL3NyYy91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbi50c1wiKTtcblxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuXG5cblxuXG5cblxuXG52YXIgTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiA9IDEwICogMTAwMDsgLy8gMTAgc2Vjb25kc1xuXG52YXIgQUFDX1NBTVBMRVNfUEVSX0ZSQU1FID0gMTAyNDtcbnZhciBNUEVHX0FVRElPX1NBTVBMRV9QRVJfRlJBTUUgPSAxMTUyO1xudmFyIGNocm9tZVZlcnNpb24gPSBudWxsO1xudmFyIHNhZmFyaVdlYmtpdFZlcnNpb24gPSBudWxsO1xudmFyIHJlcXVpcmVzUG9zaXRpdmVEdHMgPSBmYWxzZTtcblxudmFyIE1QNFJlbXV4ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNUDRSZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQsIHZlbmRvcikge1xuICAgIGlmICh2ZW5kb3IgPT09IHZvaWQgMCkge1xuICAgICAgdmVuZG9yID0gJyc7XG4gICAgfVxuXG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2luaXRQVFMgPSB2b2lkIDA7XG4gICAgdGhpcy5faW5pdERUUyA9IHZvaWQgMDtcbiAgICB0aGlzLm5leHRBdmNEdHMgPSBudWxsO1xuICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gbnVsbDtcbiAgICB0aGlzLnZpZGVvU2FtcGxlRHVyYXRpb24gPSBudWxsO1xuICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICB0aGlzLmlzVmlkZW9Db250aWd1b3VzID0gZmFsc2U7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGNocm9tZVZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xuICAgICAgdmFyIHJlc3VsdCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspL2kpO1xuICAgICAgY2hyb21lVmVyc2lvbiA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgIH1cblxuICAgIGlmIChzYWZhcmlXZWJraXRWZXJzaW9uID09PSBudWxsKSB7XG4gICAgICB2YXIgX3Jlc3VsdCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQrKS9pKTtcblxuICAgICAgc2FmYXJpV2Via2l0VmVyc2lvbiA9IF9yZXN1bHQgPyBwYXJzZUludChfcmVzdWx0WzFdKSA6IDA7XG4gICAgfVxuXG4gICAgcmVxdWlyZXNQb3NpdGl2ZUR0cyA9ICEoISFjaHJvbWVWZXJzaW9uICYmIGNocm9tZVZlcnNpb24gPj0gNzUgfHwgISFzYWZhcmlXZWJraXRWZXJzaW9uICYmIHNhZmFyaVdlYmtpdFZlcnNpb24gPj0gNjAwKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBNUDRSZW11eGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fTtcblxuICBfcHJvdG8ucmVzZXRUaW1lU3RhbXAgPSBmdW5jdGlvbiByZXNldFRpbWVTdGFtcChkZWZhdWx0VGltZVN0YW1wKSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLmxvZygnW21wNC1yZW11eGVyXTogaW5pdFBUUyAmIGluaXREVFMgcmVzZXQnKTtcbiAgICB0aGlzLl9pbml0UFRTID0gdGhpcy5faW5pdERUUyA9IGRlZmF1bHRUaW1lU3RhbXA7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0TmV4dFRpbWVzdGFtcCA9IGZ1bmN0aW9uIHJlc2V0TmV4dFRpbWVzdGFtcCgpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ubG9nKCdbbXA0LXJlbXV4ZXJdOiByZXNldCBuZXh0IHRpbWVzdGFtcCcpO1xuICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS5sb2coJ1ttcDQtcmVtdXhlcl06IElTR2VuZXJhdGVkIGZsYWcgcmVzZXQnKTtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmdldFZpZGVvU3RhcnRQdHMgPSBmdW5jdGlvbiBnZXRWaWRlb1N0YXJ0UHRzKHZpZGVvU2FtcGxlcykge1xuICAgIHZhciByb2xsb3ZlckRldGVjdGVkID0gZmFsc2U7XG4gICAgdmFyIHN0YXJ0UFRTID0gdmlkZW9TYW1wbGVzLnJlZHVjZShmdW5jdGlvbiAobWluUFRTLCBzYW1wbGUpIHtcbiAgICAgIHZhciBkZWx0YSA9IHNhbXBsZS5wdHMgLSBtaW5QVFM7XG5cbiAgICAgIGlmIChkZWx0YSA8IC00Mjk0OTY3Mjk2KSB7XG4gICAgICAgIC8vIDJeMzIsIHNlZSBQVFNOb3JtYWxpemUgZm9yIHJlYXNvbmluZywgYnV0IHdlJ3JlIGhpdHRpbmcgYSByb2xsb3ZlciBoZXJlLCBhbmQgd2UgZG9uJ3Qgd2FudCB0aGF0IHRvIGltcGFjdCB0aGUgdGltZU9mZnNldCBjYWxjdWxhdGlvblxuICAgICAgICByb2xsb3ZlckRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVB0cyhtaW5QVFMsIHNhbXBsZS5wdHMpO1xuICAgICAgfSBlbHNlIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgcmV0dXJuIG1pblBUUztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzYW1wbGUucHRzO1xuICAgICAgfVxuICAgIH0sIHZpZGVvU2FtcGxlc1swXS5wdHMpO1xuXG4gICAgaWYgKHJvbGxvdmVyRGV0ZWN0ZWQpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS5kZWJ1ZygnUFRTIHJvbGxvdmVyIGRldGVjdGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXJ0UFRTO1xuICB9O1xuXG4gIF9wcm90by5yZW11eCA9IGZ1bmN0aW9uIHJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgZmx1c2gsIHBsYXlsaXN0VHlwZSkge1xuICAgIHZhciB2aWRlbztcbiAgICB2YXIgYXVkaW87XG4gICAgdmFyIGluaXRTZWdtZW50O1xuICAgIHZhciB0ZXh0O1xuICAgIHZhciBpZDM7XG4gICAgdmFyIGluZGVwZW5kZW50O1xuICAgIHZhciBhdWRpb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIHZhciB2aWRlb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0OyAvLyBJZiB3ZSdyZSByZW11eGluZyBhdWRpbyBhbmQgdmlkZW8gcHJvZ3Jlc3NpdmVseSwgd2FpdCB1bnRpbCB3ZSd2ZSByZWNlaXZlZCBlbm91Z2ggc2FtcGxlcyBmb3IgZWFjaCB0cmFjayBiZWZvcmUgcHJvY2VlZGluZy5cbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gc3luY2hyb25pemUgdGhlIGF1ZGlvIGFuZCB2aWRlbyBzdHJlYW1zLiBXZSBrbm93IGlmIHRoZSBjdXJyZW50IHNlZ21lbnQgd2lsbCBoYXZlIHNhbXBsZXMgaWYgdGhlIFwicGlkXCJcbiAgICAvLyBwYXJhbWV0ZXIgaXMgZ3JlYXRlciB0aGFuIC0xLiBUaGUgcGlkIGlzIHNldCB3aGVuIHRoZSBQTVQgaXMgcGFyc2VkLCB3aGljaCBjb250YWlucyB0aGUgdHJhY2tzIGxpc3QuXG4gICAgLy8gSG93ZXZlciwgaWYgdGhlIGluaXRTZWdtZW50IGhhcyBhbHJlYWR5IGJlZW4gZ2VuZXJhdGVkLCBvciB3ZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgYSBzZWdtZW50IChmbHVzaCksXG4gICAgLy8gdGhlbiB3ZSBjYW4gcmVtdXggb25lIHRyYWNrIHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIG90aGVyLlxuXG4gICAgdmFyIGhhc0F1ZGlvID0gYXVkaW9UcmFjay5waWQgPiAtMTtcbiAgICB2YXIgaGFzVmlkZW8gPSB2aWRlb1RyYWNrLnBpZCA+IC0xO1xuICAgIHZhciBsZW5ndGggPSB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoO1xuICAgIHZhciBlbm91Z2hBdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoID4gMDtcbiAgICB2YXIgZW5vdWdoVmlkZW9TYW1wbGVzID0gZmx1c2ggJiYgbGVuZ3RoID4gMCB8fCBsZW5ndGggPiAxO1xuICAgIHZhciBjYW5SZW11eEF2YyA9ICghaGFzQXVkaW8gfHwgZW5vdWdoQXVkaW9TYW1wbGVzKSAmJiAoIWhhc1ZpZGVvIHx8IGVub3VnaFZpZGVvU2FtcGxlcykgfHwgdGhpcy5JU0dlbmVyYXRlZCB8fCBmbHVzaDtcblxuICAgIGlmIChjYW5SZW11eEF2Yykge1xuICAgICAgaWYgKCF0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNWaWRlb0NvbnRpZ3VvdXMgPSB0aGlzLmlzVmlkZW9Db250aWd1b3VzO1xuICAgICAgdmFyIGZpcnN0S2V5RnJhbWVJbmRleCA9IC0xO1xuICAgICAgdmFyIGZpcnN0S2V5RnJhbWVQVFM7XG5cbiAgICAgIGlmIChlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgZmlyc3RLZXlGcmFtZUluZGV4ID0gZmluZEtleWZyYW1lSW5kZXgodmlkZW9UcmFjay5zYW1wbGVzKTtcblxuICAgICAgICBpZiAoIWlzVmlkZW9Db250aWd1b3VzICYmIHRoaXMuY29uZmlnLmZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgICBpbmRlcGVuZGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoZmlyc3RLZXlGcmFtZUluZGV4ID4gMCkge1xuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLndhcm4oXCJbbXA0LXJlbXV4ZXJdOiBEcm9wcGVkIFwiICsgZmlyc3RLZXlGcmFtZUluZGV4ICsgXCIgb3V0IG9mIFwiICsgbGVuZ3RoICsgXCIgdmlkZW8gc2FtcGxlcyBkdWUgdG8gYSBtaXNzaW5nIGtleWZyYW1lXCIpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0UFRTID0gdGhpcy5nZXRWaWRlb1N0YXJ0UHRzKHZpZGVvVHJhY2suc2FtcGxlcyk7XG4gICAgICAgICAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSB2aWRlb1RyYWNrLnNhbXBsZXMuc2xpY2UoZmlyc3RLZXlGcmFtZUluZGV4KTtcbiAgICAgICAgICAgIHZpZGVvVHJhY2suZHJvcHBlZCArPSBmaXJzdEtleUZyYW1lSW5kZXg7XG4gICAgICAgICAgICB2aWRlb1RpbWVPZmZzZXQgKz0gKHZpZGVvVHJhY2suc2FtcGxlc1swXS5wdHMgLSBzdGFydFBUUykgLyB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICAgICAgZmlyc3RLZXlGcmFtZVBUUyA9IHZpZGVvVGltZU9mZnNldDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpcnN0S2V5RnJhbWVJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS53YXJuKFwiW21wNC1yZW11eGVyXTogTm8ga2V5ZnJhbWUgZm91bmQgb3V0IG9mIFwiICsgbGVuZ3RoICsgXCIgdmlkZW8gc2FtcGxlc1wiKTtcbiAgICAgICAgICAgIGluZGVwZW5kZW50ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAgIGlmIChlbm91Z2hBdWRpb1NhbXBsZXMgJiYgZW5vdWdoVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgLy8gdGltZU9mZnNldCBpcyBleHBlY3RlZCB0byBiZSB0aGUgb2Zmc2V0IG9mIHRoZSBmaXJzdCB0aW1lc3RhbXAgb2YgdGhpcyBmcmFnbWVudCAoZmlyc3QgRFRTKVxuICAgICAgICAgIC8vIGlmIGZpcnN0IGF1ZGlvIERUUyBpcyBub3QgYWxpZ25lZCB3aXRoIGZpcnN0IHZpZGVvIERUUyB0aGVuIHdlIG5lZWQgdG8gdGFrZSB0aGF0IGludG8gYWNjb3VudFxuICAgICAgICAgIC8vIHdoZW4gcHJvdmlkaW5nIHRpbWVPZmZzZXQgdG8gcmVtdXhBdWRpbyAvIHJlbXV4VmlkZW8uIGlmIHdlIGRvbid0IGRvIHRoYXQsIHRoZXJlIG1pZ2h0IGJlIGEgcGVybWFuZW50IC8gc21hbGxcbiAgICAgICAgICAvLyBkcmlmdCBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbyBzdHJlYW1zXG4gICAgICAgICAgdmFyIF9zdGFydFBUUyA9IHRoaXMuZ2V0VmlkZW9TdGFydFB0cyh2aWRlb1RyYWNrLnNhbXBsZXMpO1xuXG4gICAgICAgICAgdmFyIHRzRGVsdGEgPSBub3JtYWxpemVQdHMoYXVkaW9UcmFjay5zYW1wbGVzWzBdLnB0cywgX3N0YXJ0UFRTKSAtIF9zdGFydFBUUztcblxuICAgICAgICAgIHZhciBhdWRpb3ZpZGVvVGltZXN0YW1wRGVsdGEgPSB0c0RlbHRhIC8gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgICBhdWRpb1RpbWVPZmZzZXQgKz0gTWF0aC5tYXgoMCwgYXVkaW92aWRlb1RpbWVzdGFtcERlbHRhKTtcbiAgICAgICAgICB2aWRlb1RpbWVPZmZzZXQgKz0gTWF0aC5tYXgoMCwgLWF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSk7XG4gICAgICAgIH0gLy8gUHVycG9zZWZ1bGx5IHJlbXV4aW5nIGF1ZGlvIGJlZm9yZSB2aWRlbywgc28gdGhhdCByZW11eFZpZGVvIGNhbiB1c2UgbmV4dEF1ZGlvUHRzLCB3aGljaCBpcyBjYWxjdWxhdGVkIGluIHJlbXV4QXVkaW8uXG5cblxuICAgICAgICBpZiAoZW5vdWdoQXVkaW9TYW1wbGVzKSB7XG4gICAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IGF1ZGlvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cbiAgICAgICAgICBpZiAoIWF1ZGlvVHJhY2suc2FtcGxlcmF0ZSkge1xuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLndhcm4oJ1ttcDQtcmVtdXhlcl06IHJlZ2VuZXJhdGUgSW5pdFNlZ21lbnQgYXMgYXVkaW8gZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF1ZGlvID0gdGhpcy5yZW11eEF1ZGlvKGF1ZGlvVHJhY2ssIGF1ZGlvVGltZU9mZnNldCwgdGhpcy5pc0F1ZGlvQ29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCBoYXNWaWRlbyB8fCBlbm91Z2hWaWRlb1NhbXBsZXMgfHwgcGxheWxpc3RUeXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5BVURJTyA/IHZpZGVvVGltZU9mZnNldCA6IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBpZiAoZW5vdWdoVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgICB2YXIgYXVkaW9UcmFja0xlbmd0aCA9IGF1ZGlvID8gYXVkaW8uZW5kUFRTIC0gYXVkaW8uc3RhcnRQVFMgOiAwOyAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgdmlkZW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxuXG4gICAgICAgICAgICBpZiAoIXZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGUpIHtcbiAgICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLndhcm4oJ1ttcDQtcmVtdXhlcl06IHJlZ2VuZXJhdGUgSW5pdFNlZ21lbnQgYXMgdmlkZW8gZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgICAgaW5pdFNlZ21lbnQgPSB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZpZGVvID0gdGhpcy5yZW11eFZpZGVvKHZpZGVvVHJhY2ssIHZpZGVvVGltZU9mZnNldCwgaXNWaWRlb0NvbnRpZ3VvdXMsIGF1ZGlvVHJhY2tMZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICB2aWRlbyA9IHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLCB2aWRlb1RpbWVPZmZzZXQsIGlzVmlkZW9Db250aWd1b3VzLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2aWRlbykge1xuICAgICAgICAgIHZpZGVvLmZpcnN0S2V5RnJhbWUgPSBmaXJzdEtleUZyYW1lSW5kZXg7XG4gICAgICAgICAgdmlkZW8uaW5kZXBlbmRlbnQgPSBmaXJzdEtleUZyYW1lSW5kZXggIT09IC0xO1xuICAgICAgICAgIHZpZGVvLmZpcnN0S2V5RnJhbWVQVFMgPSBmaXJzdEtleUZyYW1lUFRTO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBBbGxvdyBJRDMgYW5kIHRleHQgdG8gcmVtdXgsIGV2ZW4gaWYgbW9yZSBhdWRpby92aWRlbyBzYW1wbGVzIGFyZSByZXF1aXJlZFxuXG5cbiAgICBpZiAodGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgaWYgKGlkM1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGlkMyA9IGZsdXNoVGV4dFRyYWNrTWV0YWRhdGFDdWVTYW1wbGVzKGlkM1RyYWNrLCB0aW1lT2Zmc2V0LCB0aGlzLl9pbml0UFRTLCB0aGlzLl9pbml0RFRTKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICB0ZXh0ID0gZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXModGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCB0aGlzLl9pbml0UFRTKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW86IGF1ZGlvLFxuICAgICAgdmlkZW86IHZpZGVvLFxuICAgICAgaW5pdFNlZ21lbnQ6IGluaXRTZWdtZW50LFxuICAgICAgaW5kZXBlbmRlbnQ6IGluZGVwZW5kZW50LFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIGlkMzogaWQzXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZ2VuZXJhdGVJUyA9IGZ1bmN0aW9uIGdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCkge1xuICAgIHZhciBhdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXM7XG4gICAgdmFyIHZpZGVvU2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcztcbiAgICB2YXIgdHlwZVN1cHBvcnRlZCA9IHRoaXMudHlwZVN1cHBvcnRlZDtcbiAgICB2YXIgdHJhY2tzID0ge307XG4gICAgdmFyIGNvbXB1dGVQVFNEVFMgPSAhT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKSh0aGlzLl9pbml0UFRTKTtcbiAgICB2YXIgY29udGFpbmVyID0gJ2F1ZGlvL21wNCc7XG4gICAgdmFyIGluaXRQVFM7XG4gICAgdmFyIGluaXREVFM7XG4gICAgdmFyIHRpbWVzY2FsZTtcblxuICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICBpbml0UFRTID0gaW5pdERUUyA9IEluZmluaXR5O1xuICAgIH1cblxuICAgIGlmIChhdWRpb1RyYWNrLmNvbmZpZyAmJiBhdWRpb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAvLyBsZXQncyB1c2UgYXVkaW8gc2FtcGxpbmcgcmF0ZSBhcyBNUDQgdGltZSBzY2FsZS5cbiAgICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IHRoZXJlIGlzIGEgaW50ZWdlciBuYiBvZiBhdWRpbyBmcmFtZXMgcGVyIGF1ZGlvIHNhbXBsZSAoMTAyNCBmb3IgQUFDKVxuICAgICAgLy8gdXNpbmcgYXVkaW8gc2FtcGxpbmcgcmF0ZSBoZXJlIGhlbHBzIGhhdmluZyBhbiBpbnRlZ2VyIE1QNCBmcmFtZSBkdXJhdGlvblxuICAgICAgLy8gdGhpcyBhdm9pZHMgcG90ZW50aWFsIHJvdW5kaW5nIGlzc3VlIGFuZCBBViBzeW5jIGlzc3VlXG4gICAgICBhdWRpb1RyYWNrLnRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suc2FtcGxlcmF0ZTtcblxuICAgICAgc3dpdGNoIChhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYykge1xuICAgICAgICBjYXNlICdtcDMnOlxuICAgICAgICAgIGlmICh0eXBlU3VwcG9ydGVkLm1wZWcpIHtcbiAgICAgICAgICAgIC8vIENocm9tZSBhbmQgU2FmYXJpXG4gICAgICAgICAgICBjb250YWluZXIgPSAnYXVkaW8vbXBlZyc7XG4gICAgICAgICAgICBhdWRpb1RyYWNrLmNvZGVjID0gJyc7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlU3VwcG9ydGVkLm1wMykge1xuICAgICAgICAgICAgLy8gRmlyZWZveFxuICAgICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICdtcDMnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0cmFja3MuYXVkaW8gPSB7XG4gICAgICAgIGlkOiAnYXVkaW8nLFxuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgY29kZWM6IGF1ZGlvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50OiBhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ21wMycgJiYgdHlwZVN1cHBvcnRlZC5tcGVnID8gbmV3IFVpbnQ4QXJyYXkoMCkgOiBfbXA0X2dlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5pbml0U2VnbWVudChbYXVkaW9UcmFja10pLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGNoYW5uZWxDb3VudDogYXVkaW9UcmFjay5jaGFubmVsQ291bnRcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgdGltZXNjYWxlID0gYXVkaW9UcmFjay5pbnB1dFRpbWVTY2FsZTsgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIHRoaXMgZGVtdXhpbmcgY29udGV4dC4gZm9yIGF1ZGlvLCBQVFMgPSBEVFNcblxuICAgICAgICBpbml0UFRTID0gaW5pdERUUyA9IGF1ZGlvU2FtcGxlc1swXS5wdHMgLSBNYXRoLnJvdW5kKHRpbWVzY2FsZSAqIHRpbWVPZmZzZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2aWRlb1RyYWNrLnNwcyAmJiB2aWRlb1RyYWNrLnBwcyAmJiB2aWRlb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAvLyBsZXQncyB1c2UgaW5wdXQgdGltZSBzY2FsZSBhcyBNUDQgdmlkZW8gdGltZXNjYWxlXG4gICAgICAvLyB3ZSB1c2UgaW5wdXQgdGltZSBzY2FsZSBzdHJhaWdodCBhd2F5IHRvIGF2b2lkIHJvdW5kaW5nIGlzc3VlcyBvbiBmcmFtZSBkdXJhdGlvbiAvIGN0cyBjb21wdXRhdGlvblxuICAgICAgdmlkZW9UcmFjay50aW1lc2NhbGUgPSB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICBpZDogJ21haW4nLFxuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICBjb2RlYzogdmlkZW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IF9tcDRfZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLmluaXRTZWdtZW50KFt2aWRlb1RyYWNrXSksXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgd2lkdGg6IHZpZGVvVHJhY2sud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB2aWRlb1RyYWNrLmhlaWdodFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICB0aW1lc2NhbGUgPSB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICB2YXIgc3RhcnRQVFMgPSB0aGlzLmdldFZpZGVvU3RhcnRQdHModmlkZW9TYW1wbGVzKTtcbiAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gTWF0aC5yb3VuZCh0aW1lc2NhbGUgKiB0aW1lT2Zmc2V0KTtcbiAgICAgICAgaW5pdERUUyA9IE1hdGgubWluKGluaXREVFMsIG5vcm1hbGl6ZVB0cyh2aWRlb1NhbXBsZXNbMF0uZHRzLCBzdGFydFBUUykgLSBzdGFydE9mZnNldCk7XG4gICAgICAgIGluaXRQVFMgPSBNYXRoLm1pbihpbml0UFRTLCBzdGFydFBUUyAtIHN0YXJ0T2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmtleXModHJhY2tzKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICB0aGlzLl9pbml0UFRTID0gaW5pdFBUUztcbiAgICAgICAgdGhpcy5faW5pdERUUyA9IGluaXREVFM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyYWNrczogdHJhY2tzLFxuICAgICAgICBpbml0UFRTOiBpbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGU6IHRpbWVzY2FsZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbXV4VmlkZW8gPSBmdW5jdGlvbiByZW11eFZpZGVvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhdWRpb1RyYWNrTGVuZ3RoKSB7XG4gICAgdmFyIHRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIHZhciBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgIHZhciBvdXRwdXRTYW1wbGVzID0gW107XG4gICAgdmFyIG5iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7XG4gICAgdmFyIGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIHZhciBuZXh0QXZjRHRzID0gdGhpcy5uZXh0QXZjRHRzO1xuICAgIHZhciBvZmZzZXQgPSA4O1xuICAgIHZhciBtcDRTYW1wbGVEdXJhdGlvbiA9IHRoaXMudmlkZW9TYW1wbGVEdXJhdGlvbjtcbiAgICB2YXIgZmlyc3REVFM7XG4gICAgdmFyIGxhc3REVFM7XG4gICAgdmFyIG1pblBUUyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB2YXIgbWF4UFRTID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIHZhciBwdHNEdHNTaGlmdCA9IDA7XG4gICAgdmFyIHNvcnRTYW1wbGVzID0gZmFsc2U7IC8vIGlmIHBhcnNlZCBmcmFnbWVudCBpcyBjb250aWd1b3VzIHdpdGggbGFzdCBvbmUsIGxldCdzIHVzZSBsYXN0IERUUyB2YWx1ZSBhcyByZWZlcmVuY2VcblxuICAgIGlmICghY29udGlndW91cyB8fCBuZXh0QXZjRHRzID09PSBudWxsKSB7XG4gICAgICB2YXIgcHRzID0gdGltZU9mZnNldCAqIHRpbWVTY2FsZTtcbiAgICAgIHZhciBjdHMgPSBpbnB1dFNhbXBsZXNbMF0ucHRzIC0gbm9ybWFsaXplUHRzKGlucHV0U2FtcGxlc1swXS5kdHMsIGlucHV0U2FtcGxlc1swXS5wdHMpOyAvLyBpZiBub3QgY29udGlndW91cywgbGV0J3MgdXNlIHRhcmdldCB0aW1lT2Zmc2V0XG5cbiAgICAgIG5leHRBdmNEdHMgPSBwdHMgLSBjdHM7XG4gICAgfSAvLyBQVFMgaXMgY29kZWQgb24gMzNiaXRzLCBhbmQgY2FuIGxvb3AgZnJvbSAtMl4zMiB0byAyXjMyXG4gICAgLy8gUFRTTm9ybWFsaXplIHdpbGwgbWFrZSBQVFMvRFRTIHZhbHVlIG1vbm90b25pYywgd2UgdXNlIGxhc3Qga25vd24gRFRTIHZhbHVlIGFzIHJlZmVyZW5jZSB2YWx1ZVxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICB2YXIgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzIC0gaW5pdFBUUywgbmV4dEF2Y0R0cyk7XG4gICAgICBzYW1wbGUuZHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5kdHMgLSBpbml0UFRTLCBuZXh0QXZjRHRzKTtcblxuICAgICAgaWYgKHNhbXBsZS5kdHMgPiBzYW1wbGUucHRzKSB7XG4gICAgICAgIHZhciBQVFNfRFRTX1NISUZUX1RPTEVSQU5DRV85MEtIWiA9IDkwMDAwICogMC4yO1xuICAgICAgICBwdHNEdHNTaGlmdCA9IE1hdGgubWF4KE1hdGgubWluKHB0c0R0c1NoaWZ0LCBzYW1wbGUucHRzIC0gc2FtcGxlLmR0cyksIC0xICogUFRTX0RUU19TSElGVF9UT0xFUkFOQ0VfOTBLSFopO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2FtcGxlLmR0cyA8IGlucHV0U2FtcGxlc1tpID4gMCA/IGkgLSAxIDogaV0uZHRzKSB7XG4gICAgICAgIHNvcnRTYW1wbGVzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIHNvcnQgdmlkZW8gc2FtcGxlcyBieSBEVFMgdGhlbiBQVFMgdGhlbiBkZW11eCBpZCBvcmRlclxuXG5cbiAgICBpZiAoc29ydFNhbXBsZXMpIHtcbiAgICAgIGlucHV0U2FtcGxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBkZWx0YWR0cyA9IGEuZHRzIC0gYi5kdHM7XG4gICAgICAgIHZhciBkZWx0YXB0cyA9IGEucHRzIC0gYi5wdHM7XG4gICAgICAgIHJldHVybiBkZWx0YWR0cyB8fCBkZWx0YXB0cztcbiAgICAgIH0pO1xuICAgIH0gLy8gR2V0IGZpcnN0L2xhc3QgRFRTXG5cblxuICAgIGZpcnN0RFRTID0gaW5wdXRTYW1wbGVzWzBdLmR0cztcbiAgICBsYXN0RFRTID0gaW5wdXRTYW1wbGVzW2lucHV0U2FtcGxlcy5sZW5ndGggLSAxXS5kdHM7IC8vIG9uIFNhZmFyaSBsZXQncyBzaWduYWwgdGhlIHNhbWUgc2FtcGxlIGR1cmF0aW9uIGZvciBhbGwgc2FtcGxlc1xuICAgIC8vIHNhbXBsZSBkdXJhdGlvbiAoYXMgZXhwZWN0ZWQgYnkgdHJ1biBNUDQgYm94ZXMpLCBzaG91bGQgYmUgdGhlIGRlbHRhIGJldHdlZW4gc2FtcGxlIERUU1xuICAgIC8vIHNldCB0aGlzIGNvbnN0YW50IGR1cmF0aW9uIGFzIGJlaW5nIHRoZSBhdmcgZGVsdGEgYmV0d2VlbiBjb25zZWN1dGl2ZSBEVFMuXG5cbiAgICB2YXIgaW5wdXREdXJhdGlvbiA9IGxhc3REVFMgLSBmaXJzdERUUztcbiAgICB2YXIgYXZlcmFnZVNhbXBsZUR1cmF0aW9uID0gaW5wdXREdXJhdGlvbiA/IE1hdGgucm91bmQoaW5wdXREdXJhdGlvbiAvIChuYlNhbXBsZXMgLSAxKSkgOiBtcDRTYW1wbGVEdXJhdGlvbiB8fCB0cmFjay5pbnB1dFRpbWVTY2FsZSAvIDMwOyAvLyBoYW5kbGUgYnJva2VuIHN0cmVhbXMgd2l0aCBQVFMgPCBEVFMsIHRvbGVyYW5jZSB1cCAwLjIgc2Vjb25kc1xuXG4gICAgaWYgKHB0c0R0c1NoaWZ0IDwgMCkge1xuICAgICAgaWYgKHB0c0R0c1NoaWZ0IDwgYXZlcmFnZVNhbXBsZUR1cmF0aW9uICogLTIpIHtcbiAgICAgICAgLy8gRml4IGZvciBcIkNOTiBzcGVjaWFsIHJlcG9ydCwgd2l0aCBDQ1wiIGluIHRlc3Qtc3RyZWFtcyAoaW5jbHVkaW5nIFNhZmFyaSBicm93c2VyKVxuICAgICAgICAvLyBXaXRoIGxhcmdlIFBUUyA8IERUUyBlcnJvcnMgc3VjaCBhcyB0aGlzLCB3ZSB3YW50IHRvIGNvcnJlY3QgQ1RTIHdoaWxlIG1haW50YWluaW5nIGluY3JlYXNpbmcgRFRTIHZhbHVlc1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ud2FybihcIlBUUyA8IERUUyBkZXRlY3RlZCBpbiB2aWRlbyBzYW1wbGVzLCBvZmZzZXR0aW5nIERUUyBmcm9tIFBUUyBieSBcIiArIE9iamVjdChfdXRpbHNfdGltZXNjYWxlX2NvbnZlcnNpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcInRvTXNGcm9tTXBlZ1RzQ2xvY2tcIl0pKC1hdmVyYWdlU2FtcGxlRHVyYXRpb24sIHRydWUpICsgXCIgbXNcIik7XG4gICAgICAgIHZhciBsYXN0RHRzID0gcHRzRHRzU2hpZnQ7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5iU2FtcGxlczsgX2krKykge1xuICAgICAgICAgIGlucHV0U2FtcGxlc1tfaV0uZHRzID0gbGFzdER0cyA9IE1hdGgubWF4KGxhc3REdHMsIGlucHV0U2FtcGxlc1tfaV0ucHRzIC0gYXZlcmFnZVNhbXBsZUR1cmF0aW9uKTtcbiAgICAgICAgICBpbnB1dFNhbXBsZXNbX2ldLnB0cyA9IE1hdGgubWF4KGxhc3REdHMsIGlucHV0U2FtcGxlc1tfaV0ucHRzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRml4IGZvciBcIkN1c3RvbSBJViB3aXRoIGJhZCBQVFMgRFRTXCIgaW4gdGVzdC1zdHJlYW1zXG4gICAgICAgIC8vIFdpdGggc21hbGxlciBQVFMgPCBEVFMgZXJyb3JzIHdlIGNhbiBzaW1wbHkgbW92ZSBhbGwgRFRTIGJhY2suIFRoaXMgaW5jcmVhc2VzIENUUyB3aXRob3V0IGNhdXNpbmcgYnVmZmVyIGdhcHMgb3IgZGVjb2RlIGVycm9ycyBpbiBTYWZhcmlcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLndhcm4oXCJQVFMgPCBEVFMgZGV0ZWN0ZWQgaW4gdmlkZW8gc2FtcGxlcywgc2hpZnRpbmcgRFRTIGJ5IFwiICsgT2JqZWN0KF91dGlsc190aW1lc2NhbGVfY29udmVyc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1widG9Nc0Zyb21NcGVnVHNDbG9ja1wiXSkocHRzRHRzU2hpZnQsIHRydWUpICsgXCIgbXMgdG8gb3ZlcmNvbWUgdGhpcyBpc3N1ZVwiKTtcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBuYlNhbXBsZXM7IF9pMisrKSB7XG4gICAgICAgICAgaW5wdXRTYW1wbGVzW19pMl0uZHRzID0gaW5wdXRTYW1wbGVzW19pMl0uZHRzICsgcHRzRHRzU2hpZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZmlyc3REVFMgPSBpbnB1dFNhbXBsZXNbMF0uZHRzO1xuICAgIH0gLy8gaWYgZnJhZ21lbnQgYXJlIGNvbnRpZ3VvdXMsIGRldGVjdCBob2xlL292ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzXG5cblxuICAgIGlmIChjb250aWd1b3VzKSB7XG4gICAgICAvLyBjaGVjayB0aW1lc3RhbXAgY29udGludWl0eSBhY3Jvc3MgY29uc2VjdXRpdmUgZnJhZ21lbnRzICh0aGlzIGlzIHRvIHJlbW92ZSBpbnRlci1mcmFnbWVudCBnYXAvaG9sZSlcbiAgICAgIHZhciBkZWx0YSA9IGZpcnN0RFRTIC0gbmV4dEF2Y0R0cztcbiAgICAgIHZhciBmb3VuZEhvbGUgPSBkZWx0YSA+IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgIHZhciBmb3VuZE92ZXJsYXAgPSBkZWx0YSA8IC0xO1xuXG4gICAgICBpZiAoZm91bmRIb2xlIHx8IGZvdW5kT3ZlcmxhcCkge1xuICAgICAgICBpZiAoZm91bmRIb2xlKSB7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLndhcm4oXCJBVkM6IFwiICsgT2JqZWN0KF91dGlsc190aW1lc2NhbGVfY29udmVyc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1widG9Nc0Zyb21NcGVnVHNDbG9ja1wiXSkoZGVsdGEsIHRydWUpICsgXCIgbXMgKFwiICsgZGVsdGEgKyBcImR0cykgaG9sZSBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCwgZmlsbGluZyBpdFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ud2FybihcIkFWQzogXCIgKyBPYmplY3QoX3V0aWxzX3RpbWVzY2FsZV9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJ0b01zRnJvbU1wZWdUc0Nsb2NrXCJdKSgtZGVsdGEsIHRydWUpICsgXCIgbXMgKFwiICsgZGVsdGEgKyBcImR0cykgb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmaXJzdERUUyA9IG5leHRBdmNEdHM7XG4gICAgICAgIHZhciBmaXJzdFBUUyA9IGlucHV0U2FtcGxlc1swXS5wdHMgLSBkZWx0YTtcbiAgICAgICAgaW5wdXRTYW1wbGVzWzBdLmR0cyA9IGZpcnN0RFRTO1xuICAgICAgICBpbnB1dFNhbXBsZXNbMF0ucHRzID0gZmlyc3RQVFM7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS5sb2coXCJWaWRlbzogRmlyc3QgUFRTL0RUUyBhZGp1c3RlZDogXCIgKyBPYmplY3QoX3V0aWxzX3RpbWVzY2FsZV9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJ0b01zRnJvbU1wZWdUc0Nsb2NrXCJdKShmaXJzdFBUUywgdHJ1ZSkgKyBcIi9cIiArIE9iamVjdChfdXRpbHNfdGltZXNjYWxlX2NvbnZlcnNpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcInRvTXNGcm9tTXBlZ1RzQ2xvY2tcIl0pKGZpcnN0RFRTLCB0cnVlKSArIFwiLCBkZWx0YTogXCIgKyBPYmplY3QoX3V0aWxzX3RpbWVzY2FsZV9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJ0b01zRnJvbU1wZWdUc0Nsb2NrXCJdKShkZWx0YSwgdHJ1ZSkgKyBcIiBtc1wiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVxdWlyZXNQb3NpdGl2ZUR0cykge1xuICAgICAgZmlyc3REVFMgPSBNYXRoLm1heCgwLCBmaXJzdERUUyk7XG4gICAgfVxuXG4gICAgdmFyIG5iTmFsdSA9IDA7XG4gICAgdmFyIG5hbHVMZW4gPSAwO1xuXG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbmJTYW1wbGVzOyBfaTMrKykge1xuICAgICAgLy8gY29tcHV0ZSB0b3RhbC9hdmMgc2FtcGxlIGxlbmd0aCBhbmQgbmIgb2YgTkFMIHVuaXRzXG4gICAgICB2YXIgX3NhbXBsZSA9IGlucHV0U2FtcGxlc1tfaTNdO1xuICAgICAgdmFyIHVuaXRzID0gX3NhbXBsZS51bml0cztcbiAgICAgIHZhciBuYlVuaXRzID0gdW5pdHMubGVuZ3RoO1xuICAgICAgdmFyIHNhbXBsZUxlbiA9IDA7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmJVbml0czsgaisrKSB7XG4gICAgICAgIHNhbXBsZUxlbiArPSB1bml0c1tqXS5kYXRhLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgbmFsdUxlbiArPSBzYW1wbGVMZW47XG4gICAgICBuYk5hbHUgKz0gbmJVbml0cztcbiAgICAgIF9zYW1wbGUubGVuZ3RoID0gc2FtcGxlTGVuOyAvLyBub3JtYWxpemUgUFRTL0RUU1xuICAgICAgLy8gZW5zdXJlIHNhbXBsZSBtb25vdG9uaWMgRFRTXG5cbiAgICAgIF9zYW1wbGUuZHRzID0gTWF0aC5tYXgoX3NhbXBsZS5kdHMsIGZpcnN0RFRTKTsgLy8gZW5zdXJlIHRoYXQgY29tcHV0ZWQgdmFsdWUgaXMgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHNhbXBsZSBEVFNcblxuICAgICAgX3NhbXBsZS5wdHMgPSBNYXRoLm1heChfc2FtcGxlLnB0cywgX3NhbXBsZS5kdHMsIDApO1xuICAgICAgbWluUFRTID0gTWF0aC5taW4oX3NhbXBsZS5wdHMsIG1pblBUUyk7XG4gICAgICBtYXhQVFMgPSBNYXRoLm1heChfc2FtcGxlLnB0cywgbWF4UFRTKTtcbiAgICB9XG5cbiAgICBsYXN0RFRTID0gaW5wdXRTYW1wbGVzW25iU2FtcGxlcyAtIDFdLmR0cztcbiAgICAvKiBjb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1wZGF0IHR5cGUpICovXG5cbiAgICB2YXIgbWRhdFNpemUgPSBuYWx1TGVuICsgNCAqIG5iTmFsdSArIDg7XG4gICAgdmFyIG1kYXQ7XG5cbiAgICB0cnkge1xuICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uRVJST1IsIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJFcnJvclR5cGVzXCJdLk1VWF9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiRXJyb3JEZXRhaWxzXCJdLlJFTVVYX0FMTE9DX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGJ5dGVzOiBtZGF0U2l6ZSxcbiAgICAgICAgcmVhc29uOiBcImZhaWwgYWxsb2NhdGluZyB2aWRlbyBtZGF0IFwiICsgbWRhdFNpemVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcbiAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgbWRhdC5zZXQoX21wNF9nZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0udHlwZXMubWRhdCwgNCk7XG4gICAgdmFyIHN0cmV0Y2hlZExhc3RGcmFtZSA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbmJTYW1wbGVzOyBfaTQrKykge1xuICAgICAgdmFyIGF2Y1NhbXBsZSA9IGlucHV0U2FtcGxlc1tfaTRdO1xuICAgICAgdmFyIGF2Y1NhbXBsZVVuaXRzID0gYXZjU2FtcGxlLnVuaXRzO1xuICAgICAgdmFyIG1wNFNhbXBsZUxlbmd0aCA9IDA7IC8vIGNvbnZlcnQgTkFMVSBiaXRzdHJlYW0gdG8gTVA0IGZvcm1hdCAocHJlcGVuZCBOQUxVIHdpdGggc2l6ZSBmaWVsZClcblxuICAgICAgZm9yICh2YXIgX2ogPSAwLCBfbmJVbml0cyA9IGF2Y1NhbXBsZVVuaXRzLmxlbmd0aDsgX2ogPCBfbmJVbml0czsgX2orKykge1xuICAgICAgICB2YXIgdW5pdCA9IGF2Y1NhbXBsZVVuaXRzW19qXTtcbiAgICAgICAgdmFyIHVuaXREYXRhID0gdW5pdC5kYXRhO1xuICAgICAgICB2YXIgdW5pdERhdGFMZW4gPSB1bml0LmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCB1bml0RGF0YUxlbik7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBtZGF0LnNldCh1bml0RGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IHVuaXREYXRhTGVuO1xuICAgICAgICBtcDRTYW1wbGVMZW5ndGggKz0gNCArIHVuaXREYXRhTGVuO1xuICAgICAgfSAvLyBleHBlY3RlZCBzYW1wbGUgZHVyYXRpb24gaXMgdGhlIERlY29kaW5nIFRpbWVzdGFtcCBkaWZmIG9mIGNvbnNlY3V0aXZlIHNhbXBsZXNcblxuXG4gICAgICBpZiAoX2k0IDwgbmJTYW1wbGVzIC0gMSkge1xuICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGlucHV0U2FtcGxlc1tfaTQgKyAxXS5kdHMgLSBhdmNTYW1wbGUuZHRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICB2YXIgbGFzdEZyYW1lRHVyYXRpb24gPSBfaTQgPiAwID8gYXZjU2FtcGxlLmR0cyAtIGlucHV0U2FtcGxlc1tfaTQgLSAxXS5kdHMgOiBhdmVyYWdlU2FtcGxlRHVyYXRpb247XG5cbiAgICAgICAgaWYgKGNvbmZpZy5zdHJldGNoU2hvcnRWaWRlb1RyYWNrICYmIHRoaXMubmV4dEF1ZGlvUHRzICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gSW4gc29tZSBjYXNlcywgYSBzZWdtZW50J3MgYXVkaW8gdHJhY2sgZHVyYXRpb24gbWF5IGV4Y2VlZCB0aGUgdmlkZW8gdHJhY2sgZHVyYXRpb24uXG4gICAgICAgICAgLy8gU2luY2Ugd2UndmUgYWxyZWFkeSByZW11eGVkIGF1ZGlvLCBhbmQgd2Uga25vdyBob3cgbG9uZyB0aGUgYXVkaW8gdHJhY2sgaXMsIHdlIGxvb2sgdG9cbiAgICAgICAgICAvLyBzZWUgaWYgdGhlIGRlbHRhIHRvIHRoZSBuZXh0IHNlZ21lbnQgaXMgbG9uZ2VyIHRoYW4gbWF4QnVmZmVySG9sZS5cbiAgICAgICAgICAvLyBJZiBzbywgcGxheWJhY2sgd291bGQgcG90ZW50aWFsbHkgZ2V0IHN0dWNrLCBzbyB3ZSBhcnRpZmljaWFsbHkgaW5mbGF0ZVxuICAgICAgICAgIC8vIHRoZSBkdXJhdGlvbiBvZiB0aGUgbGFzdCBmcmFtZSB0byBtaW5pbWl6ZSBhbnkgcG90ZW50aWFsIGdhcCBiZXR3ZWVuIHNlZ21lbnRzLlxuICAgICAgICAgIHZhciBnYXBUb2xlcmFuY2UgPSBNYXRoLmZsb29yKGNvbmZpZy5tYXhCdWZmZXJIb2xlICogdGltZVNjYWxlKTtcbiAgICAgICAgICB2YXIgZGVsdGFUb0ZyYW1lRW5kID0gKGF1ZGlvVHJhY2tMZW5ndGggPyBtaW5QVFMgKyBhdWRpb1RyYWNrTGVuZ3RoICogdGltZVNjYWxlIDogdGhpcy5uZXh0QXVkaW9QdHMpIC0gYXZjU2FtcGxlLnB0cztcblxuICAgICAgICAgIGlmIChkZWx0YVRvRnJhbWVFbmQgPiBnYXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIC8vIFdlIHN1YnRyYWN0IGxhc3RGcmFtZUR1cmF0aW9uIGZyb20gZGVsdGFUb0ZyYW1lRW5kIHRvIHRyeSB0byBwcmV2ZW50IGFueSB2aWRlb1xuICAgICAgICAgICAgLy8gZnJhbWUgb3ZlcmxhcC4gbWF4QnVmZmVySG9sZSBzaG91bGQgYmUgPj4gbGFzdEZyYW1lRHVyYXRpb24gYW55d2F5LlxuICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBkZWx0YVRvRnJhbWVFbmQgLSBsYXN0RnJhbWVEdXJhdGlvbjtcblxuICAgICAgICAgICAgaWYgKG1wNFNhbXBsZUR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyZXRjaGVkTGFzdEZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLmxvZyhcIlttcDQtcmVtdXhlcl06IEl0IGlzIGFwcHJveGltYXRlbHkgXCIgKyBkZWx0YVRvRnJhbWVFbmQgLyA5MCArIFwiIG1zIHRvIHRoZSBuZXh0IHNlZ21lbnQ7IHVzaW5nIGR1cmF0aW9uIFwiICsgbXA0U2FtcGxlRHVyYXRpb24gLyA5MCArIFwiIG1zIGZvciB0aGUgbGFzdCB2aWRlbyBmcmFtZS5cIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgucm91bmQoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpO1xuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG5ldyBNcDRTYW1wbGUoYXZjU2FtcGxlLmtleSwgbXA0U2FtcGxlRHVyYXRpb24sIG1wNFNhbXBsZUxlbmd0aCwgY29tcG9zaXRpb25UaW1lT2Zmc2V0KSk7XG4gICAgfVxuXG4gICAgaWYgKG91dHB1dFNhbXBsZXMubGVuZ3RoICYmIGNocm9tZVZlcnNpb24gJiYgY2hyb21lVmVyc2lvbiA8IDcwKSB7XG4gICAgICAvLyBDaHJvbWUgd29ya2Fyb3VuZCwgbWFyayBmaXJzdCBzYW1wbGUgYXMgYmVpbmcgYSBSYW5kb20gQWNjZXNzIFBvaW50IChrZXlmcmFtZSkgdG8gYXZvaWQgc291cmNlYnVmZmVyIGFwcGVuZCBpc3N1ZVxuICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTQxMlxuICAgICAgdmFyIGZsYWdzID0gb3V0cHV0U2FtcGxlc1swXS5mbGFncztcbiAgICAgIGZsYWdzLmRlcGVuZHNPbiA9IDI7XG4gICAgICBmbGFncy5pc05vblN5bmMgPSAwO1xuICAgIH1cblxuICAgIGNvbnNvbGUuYXNzZXJ0KG1wNFNhbXBsZUR1cmF0aW9uICE9PSBudWxsLCAnbXA0U2FtcGxlRHVyYXRpb24gbXVzdCBiZSBjb21wdXRlZCcpOyAvLyBuZXh0IEFWQyBzYW1wbGUgRFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBEVFMgKyBsYXN0IHNhbXBsZSBkdXJhdGlvbiAoaW4gUEVTIHRpbWVzY2FsZSlcblxuICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gc3RyZXRjaGVkTGFzdEZyYW1lIHx8ICFtcDRTYW1wbGVEdXJhdGlvbiA/IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbiA6IG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgIHRoaXMubmV4dEF2Y0R0cyA9IG5leHRBdmNEdHMgPSBsYXN0RFRTICsgbXA0U2FtcGxlRHVyYXRpb247XG4gICAgdGhpcy52aWRlb1NhbXBsZUR1cmF0aW9uID0gbXA0U2FtcGxlRHVyYXRpb247XG4gICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IHRydWU7XG4gICAgdmFyIG1vb2YgPSBfbXA0X2dlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0RFRTLCBfZXh0ZW5kcyh7fSwgdHJhY2ssIHtcbiAgICAgIHNhbXBsZXM6IG91dHB1dFNhbXBsZXNcbiAgICB9KSk7XG4gICAgdmFyIHR5cGUgPSAndmlkZW8nO1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICBkYXRhMjogbWRhdCxcbiAgICAgIHN0YXJ0UFRTOiBtaW5QVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmRQVFM6IChtYXhQVFMgKyBtcDRTYW1wbGVEdXJhdGlvbikgLyB0aW1lU2NhbGUsXG4gICAgICBzdGFydERUUzogZmlyc3REVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmREVFM6IG5leHRBdmNEdHMgLyB0aW1lU2NhbGUsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgaGFzQXVkaW86IGZhbHNlLFxuICAgICAgaGFzVmlkZW86IHRydWUsXG4gICAgICBuYjogb3V0cHV0U2FtcGxlcy5sZW5ndGgsXG4gICAgICBkcm9wcGVkOiB0cmFjay5kcm9wcGVkXG4gICAgfTtcbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgdHJhY2suZHJvcHBlZCA9IDA7XG4gICAgY29uc29sZS5hc3NlcnQobWRhdC5sZW5ndGgsICdNREFUIGxlbmd0aCBtdXN0IG5vdCBiZSB6ZXJvJyk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgX3Byb3RvLnJlbXV4QXVkaW8gPSBmdW5jdGlvbiByZW11eEF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHZpZGVvVGltZU9mZnNldCkge1xuICAgIHZhciBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIHZhciBtcDR0aW1lU2NhbGUgPSB0cmFjay5zYW1wbGVyYXRlID8gdHJhY2suc2FtcGxlcmF0ZSA6IGlucHV0VGltZVNjYWxlO1xuICAgIHZhciBzY2FsZUZhY3RvciA9IGlucHV0VGltZVNjYWxlIC8gbXA0dGltZVNjYWxlO1xuICAgIHZhciBtcDRTYW1wbGVEdXJhdGlvbiA9IHRyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ2FhYycgPyBBQUNfU0FNUExFU19QRVJfRlJBTUUgOiBNUEVHX0FVRElPX1NBTVBMRV9QRVJfRlJBTUU7XG4gICAgdmFyIGlucHV0U2FtcGxlRHVyYXRpb24gPSBtcDRTYW1wbGVEdXJhdGlvbiAqIHNjYWxlRmFjdG9yO1xuICAgIHZhciBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICB2YXIgcmF3TVBFRyA9IHRyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ21wMycgJiYgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWc7XG4gICAgdmFyIG91dHB1dFNhbXBsZXMgPSBbXTtcbiAgICB2YXIgYWxpZ25lZFdpdGhWaWRlbyA9IHZpZGVvVGltZU9mZnNldCAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgIHZhciBvZmZzZXQgPSByYXdNUEVHID8gMCA6IDg7XG4gICAgdmFyIG5leHRBdWRpb1B0cyA9IHRoaXMubmV4dEF1ZGlvUHRzIHx8IC0xOyAvLyB3aW5kb3cuYXVkaW9TYW1wbGVzID8gd2luZG93LmF1ZGlvU2FtcGxlcy5wdXNoKGlucHV0U2FtcGxlcy5tYXAocyA9PiBzLnB0cykpIDogKHdpbmRvdy5hdWRpb1NhbXBsZXMgPSBbaW5wdXRTYW1wbGVzLm1hcChzID0+IHMucHRzKV0pO1xuICAgIC8vIGZvciBhdWRpbyBzYW1wbGVzLCBhbHNvIGNvbnNpZGVyIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcyBiZWluZyBjb250aWd1b3VzIChldmVuIGlmIGEgbGV2ZWwgc3dpdGNoIG9jY3VycyksXG4gICAgLy8gZm9yIHNha2Ugb2YgY2xhcml0eTpcbiAgICAvLyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXJlIGZyYWdzIHdpdGhcbiAgICAvLyAgLSBsZXNzIHRoYW4gMTAwbXMgZ2FwcyBiZXR3ZWVuIG5ldyB0aW1lIG9mZnNldCAoaWYgYWNjdXJhdGUpIGFuZCBuZXh0IGV4cGVjdGVkIFBUUyBPUlxuICAgIC8vICAtIGxlc3MgdGhhbiAyMCBhdWRpbyBmcmFtZXMgZGlzdGFuY2VcbiAgICAvLyBjb250aWd1b3VzIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGZyb20gc2FtZSBxdWFsaXR5IGxldmVsIChzYW1lIGxldmVsLCBuZXcgU04gPSBvbGQgU04gKyAxKVxuICAgIC8vIHRoaXMgaGVscHMgZW5zdXJpbmcgYXVkaW8gY29udGludWl0eVxuICAgIC8vIGFuZCB0aGlzIGFsc28gYXZvaWRzIGF1ZGlvIGdsaXRjaGVzL2N1dCB3aGVuIHN3aXRjaGluZyBxdWFsaXR5LCBvciByZXBvcnRpbmcgd3JvbmcgZHVyYXRpb24gb24gZmlyc3QgYXVkaW8gZnJhbWVcblxuICAgIHZhciB0aW1lT2Zmc2V0TXBlZ1RTID0gdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlO1xuICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSBjb250aWd1b3VzID0gY29udGlndW91cyB8fCBpbnB1dFNhbXBsZXMubGVuZ3RoICYmIG5leHRBdWRpb1B0cyA+IDAgJiYgKGFjY3VyYXRlVGltZU9mZnNldCAmJiBNYXRoLmFicyh0aW1lT2Zmc2V0TXBlZ1RTIC0gbmV4dEF1ZGlvUHRzKSA8IDkwMDAgfHwgTWF0aC5hYnMobm9ybWFsaXplUHRzKGlucHV0U2FtcGxlc1swXS5wdHMgLSBpbml0UFRTLCB0aW1lT2Zmc2V0TXBlZ1RTKSAtIG5leHRBdWRpb1B0cykgPCAyMCAqIGlucHV0U2FtcGxlRHVyYXRpb24pOyAvLyBjb21wdXRlIG5vcm1hbGl6ZWQgUFRTXG5cbiAgICBpbnB1dFNhbXBsZXMuZm9yRWFjaChmdW5jdGlvbiAoc2FtcGxlKSB7XG4gICAgICBzYW1wbGUucHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5wdHMgLSBpbml0UFRTLCB0aW1lT2Zmc2V0TXBlZ1RTKTtcbiAgICB9KTtcblxuICAgIGlmICghY29udGlndW91cyB8fCBuZXh0QXVkaW9QdHMgPCAwKSB7XG4gICAgICAvLyBmaWx0ZXIgb3V0IHNhbXBsZSB3aXRoIG5lZ2F0aXZlIFBUUyB0aGF0IGFyZSBub3QgcGxheWFibGUgYW55d2F5XG4gICAgICAvLyBpZiB3ZSBkb24ndCByZW1vdmUgdGhlc2UgbmVnYXRpdmUgc2FtcGxlcywgdGhleSB3aWxsIHNoaWZ0IGFsbCBhdWRpbyBzYW1wbGVzIGZvcndhcmQuXG4gICAgICAvLyBsZWFkaW5nIHRvIGF1ZGlvIG92ZXJsYXAgYmV0d2VlbiBjdXJyZW50IC8gbmV4dCBmcmFnbWVudFxuICAgICAgaW5wdXRTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmZpbHRlcihmdW5jdGlvbiAoc2FtcGxlKSB7XG4gICAgICAgIHJldHVybiBzYW1wbGUucHRzID49IDA7XG4gICAgICB9KTsgLy8gaW4gY2FzZSBhbGwgc2FtcGxlcyBoYXZlIG5lZ2F0aXZlIFBUUywgYW5kIGhhdmUgYmVlbiBmaWx0ZXJlZCBvdXQsIHJldHVybiBub3dcblxuICAgICAgaWYgKCFpbnB1dFNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHZpZGVvVGltZU9mZnNldCA9PT0gMCkge1xuICAgICAgICAvLyBTZXQgdGhlIHN0YXJ0IHRvIDAgdG8gbWF0Y2ggdmlkZW8gc28gdGhhdCBzdGFydCBnYXBzIGxhcmdlciB0aGFuIGlucHV0U2FtcGxlRHVyYXRpb24gYXJlIGZpbGxlZCB3aXRoIHNpbGVuY2VcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmICFhbGlnbmVkV2l0aFZpZGVvKSB7XG4gICAgICAgIC8vIFdoZW4gbm90IHNlZWtpbmcsIG5vdCBsaXZlLCBhbmQgTGV2ZWxEZXRhaWxzLlBUU0tub3duLCB1c2UgZnJhZ21lbnQgc3RhcnQgYXMgcHJlZGljdGVkIG5leHQgYXVkaW8gUFRTXG4gICAgICAgIG5leHRBdWRpb1B0cyA9IE1hdGgubWF4KDAsIHRpbWVPZmZzZXRNcGVnVFMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgZnJhZ3MgYXJlIG5vdCBjb250aWd1b3VzIGFuZCBpZiB3ZSBjYW50IHRydXN0IHRpbWUgb2Zmc2V0LCBsZXQncyB1c2UgZmlyc3Qgc2FtcGxlIFBUUyBhcyBuZXh0IGF1ZGlvIFBUU1xuICAgICAgICBuZXh0QXVkaW9QdHMgPSBpbnB1dFNhbXBsZXNbMF0ucHRzO1xuICAgICAgfVxuICAgIH0gLy8gSWYgdGhlIGF1ZGlvIHRyYWNrIGlzIG1pc3Npbmcgc2FtcGxlcywgdGhlIGZyYW1lcyBzZWVtIHRvIGdldCBcImxlZnQtc2hpZnRlZFwiIHdpdGhpbiB0aGVcbiAgICAvLyByZXN1bHRpbmcgbXA0IHNlZ21lbnQsIGNhdXNpbmcgc3luYyBpc3N1ZXMgYW5kIGxlYXZpbmcgZ2FwcyBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBzZWdtZW50LlxuICAgIC8vIEluIGFuIGVmZm9ydCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmcsIHdlIGluamVjdCBmcmFtZXMgaGVyZSB3aGVyZSB0aGVyZSBhcmUgZ2Fwcy5cbiAgICAvLyBXaGVuIHBvc3NpYmxlLCB3ZSBpbmplY3QgYSBzaWxlbnQgZnJhbWU7IHdoZW4gdGhhdCdzIG5vdCBwb3NzaWJsZSwgd2UgZHVwbGljYXRlIHRoZSBsYXN0XG4gICAgLy8gZnJhbWUuXG5cblxuICAgIGlmICh0cmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICB2YXIgbWF4QXVkaW9GcmFtZXNEcmlmdCA9IHRoaXMuY29uZmlnLm1heEF1ZGlvRnJhbWVzRHJpZnQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBuZXh0UHRzID0gbmV4dEF1ZGlvUHRzOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEZpcnN0LCBsZXQncyBzZWUgaG93IGZhciBvZmYgdGhpcyBmcmFtZSBpcyBmcm9tIHdoZXJlIHdlIGV4cGVjdCBpdCB0byBiZVxuICAgICAgICB2YXIgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgICB2YXIgcHRzID0gc2FtcGxlLnB0cztcbiAgICAgICAgdmFyIGRlbHRhID0gcHRzIC0gbmV4dFB0cztcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gTWF0aC5hYnMoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpOyAvLyBXaGVuIHJlbXV4aW5nIHdpdGggdmlkZW8sIGlmIHdlJ3JlIG92ZXJsYXBwaW5nIGJ5IG1vcmUgdGhhbiBhIGR1cmF0aW9uLCBkcm9wIHRoaXMgc2FtcGxlIHRvIHN0YXkgaW4gc3luY1xuXG4gICAgICAgIGlmIChkZWx0YSA8PSAtbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24gJiYgYWxpZ25lZFdpdGhWaWRlbykge1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ud2FybihcIkF1ZGlvIGZyYW1lIEAgXCIgKyAocHRzIC8gaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoMykgKyBcInMgb3ZlcmxhcHMgbmV4dEF1ZGlvUHRzIGJ5IFwiICsgTWF0aC5yb3VuZCgxMDAwICogZGVsdGEgLyBpbnB1dFRpbWVTY2FsZSkgKyBcIiBtcy5cIik7XG4gICAgICAgICAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG5leHRBdWRpb1B0cyA9IG5leHRQdHMgPSBwdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYnJhY2Utc3R5bGVcbiAgICAgICAgLy8gSW5zZXJ0IG1pc3NpbmcgZnJhbWVzIGlmOlxuICAgICAgICAvLyAxOiBXZSdyZSBtb3JlIHRoYW4gbWF4QXVkaW9GcmFtZXNEcmlmdCBmcmFtZSBhd2F5XG4gICAgICAgIC8vIDI6IE5vdCBtb3JlIHRoYW4gTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiBhd2F5XG4gICAgICAgIC8vIDM6IGN1cnJlbnRUaW1lIChha2EgbmV4dFB0c05vcm0pIGlzIG5vdCAwXG4gICAgICAgIC8vIDQ6IHJlbXV4aW5nIHdpdGggdmlkZW8gKHZpZGVvVGltZU9mZnNldCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA+PSBtYXhBdWRpb0ZyYW1lc0RyaWZ0ICogaW5wdXRTYW1wbGVEdXJhdGlvbiAmJiBkdXJhdGlvbiA8IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gJiYgYWxpZ25lZFdpdGhWaWRlbykge1xuICAgICAgICAgIHZhciBtaXNzaW5nID0gTWF0aC5yb3VuZChkZWx0YSAvIGlucHV0U2FtcGxlRHVyYXRpb24pOyAvLyBBZGp1c3QgbmV4dFB0cyBzbyB0aGF0IHNpbGVudCBzYW1wbGVzIGFyZSBhbGlnbmVkIHdpdGggbWVkaWEgcHRzLiBUaGlzIHdpbGwgcHJldmVudCBtZWRpYSBzYW1wbGVzIGZyb21cbiAgICAgICAgICAvLyBsYXRlciBiZWluZyBzaGlmdGVkIGlmIG5leHRQdHMgaXMgYmFzZWQgb24gdGltZU9mZnNldCBhbmQgZGVsdGEgaXMgbm90IGEgbXVsdGlwbGUgb2YgaW5wdXRTYW1wbGVEdXJhdGlvbi5cblxuICAgICAgICAgIG5leHRQdHMgPSBwdHMgLSBtaXNzaW5nICogaW5wdXRTYW1wbGVEdXJhdGlvbjtcblxuICAgICAgICAgIGlmIChuZXh0UHRzIDwgMCkge1xuICAgICAgICAgICAgbWlzc2luZy0tO1xuICAgICAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG5leHRBdWRpb1B0cyA9IG5leHRQdHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLndhcm4oXCJbbXA0LXJlbXV4ZXJdOiBJbmplY3RpbmcgXCIgKyBtaXNzaW5nICsgXCIgYXVkaW8gZnJhbWUgQCBcIiArIChuZXh0UHRzIC8gaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoMykgKyBcInMgZHVlIHRvIFwiICsgTWF0aC5yb3VuZCgxMDAwICogZGVsdGEgLyBpbnB1dFRpbWVTY2FsZSkgKyBcIiBtcyBnYXAuXCIpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtaXNzaW5nOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBuZXdTdGFtcCA9IE1hdGgubWF4KG5leHRQdHMsIDApO1xuICAgICAgICAgICAgdmFyIGZpbGxGcmFtZSA9IF9hYWNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG5cbiAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS5sb2coJ1ttcDQtcmVtdXhlcl06IFVuYWJsZSB0byBnZXQgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYzsgZHVwbGljYXRpbmcgbGFzdCBmcmFtZSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBzYW1wbGUudW5pdC5zdWJhcnJheSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnB1dFNhbXBsZXMuc3BsaWNlKGksIDAsIHtcbiAgICAgICAgICAgICAgdW5pdDogZmlsbEZyYW1lLFxuICAgICAgICAgICAgICBwdHM6IG5ld1N0YW1wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzYW1wbGUucHRzID0gbmV4dFB0cztcbiAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaXJzdFBUUyA9IG51bGw7XG4gICAgdmFyIGxhc3RQVFMgPSBudWxsO1xuICAgIHZhciBtZGF0O1xuICAgIHZhciBtZGF0U2l6ZSA9IDA7XG4gICAgdmFyIHNhbXBsZUxlbmd0aCA9IGlucHV0U2FtcGxlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoc2FtcGxlTGVuZ3RoLS0pIHtcbiAgICAgIG1kYXRTaXplICs9IGlucHV0U2FtcGxlc1tzYW1wbGVMZW5ndGhdLnVuaXQuYnl0ZUxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfajIgPSAwLCBfbmJTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmxlbmd0aDsgX2oyIDwgX25iU2FtcGxlczsgX2oyKyspIHtcbiAgICAgIHZhciBhdWRpb1NhbXBsZSA9IGlucHV0U2FtcGxlc1tfajJdO1xuICAgICAgdmFyIHVuaXQgPSBhdWRpb1NhbXBsZS51bml0O1xuICAgICAgdmFyIF9wdHMgPSBhdWRpb1NhbXBsZS5wdHM7XG5cbiAgICAgIGlmIChsYXN0UFRTICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSBzYW1wbGUsIHNldCB0aGUgZHVyYXRpb24gb2YgdGhlIHNhbXBsZSB0byB0aGUgXCJyZWFsXCIgZHVyYXRpb247IHRoZSBQVFMgZGlmZiB3aXRoXG4gICAgICAgIC8vIHRoZSBwcmV2aW91cyBzYW1wbGVcbiAgICAgICAgdmFyIHByZXZTYW1wbGUgPSBvdXRwdXRTYW1wbGVzW19qMiAtIDFdO1xuICAgICAgICBwcmV2U2FtcGxlLmR1cmF0aW9uID0gTWF0aC5yb3VuZCgoX3B0cyAtIGxhc3RQVFMpIC8gc2NhbGVGYWN0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbnRpZ3VvdXMgJiYgdHJhY2suc2VnbWVudENvZGVjID09PSAnYWFjJykge1xuICAgICAgICAgIC8vIHNldCBQVFMvRFRTIHRvIGV4cGVjdGVkIFBUUy9EVFNcbiAgICAgICAgICBfcHRzID0gbmV4dEF1ZGlvUHRzO1xuICAgICAgICB9IC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiBvdXIgYXVkaW9TYW1wbGVzXG5cblxuICAgICAgICBmaXJzdFBUUyA9IF9wdHM7XG5cbiAgICAgICAgaWYgKG1kYXRTaXplID4gMCkge1xuICAgICAgICAgIC8qIGNvbmNhdGVuYXRlIHRoZSBhdWRpbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgICAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbWRhdCB0eXBlKSAqL1xuICAgICAgICAgIG1kYXRTaXplICs9IG9mZnNldDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZGF0ID0gbmV3IFVpbnQ4QXJyYXkobWRhdFNpemUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5FUlJPUiwgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkVycm9yVHlwZXNcIl0uTVVYX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJFcnJvckRldGFpbHNcIl0uUkVNVVhfQUxMT0NfRVJST1IsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgYnl0ZXM6IG1kYXRTaXplLFxuICAgICAgICAgICAgICByZWFzb246IFwiZmFpbCBhbGxvY2F0aW5nIGF1ZGlvIG1kYXQgXCIgKyBtZGF0U2l6ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFyYXdNUEVHKSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgICAgICAgICBtZGF0LnNldChfbXA0X2dlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS50eXBlcy5tZGF0LCA0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gYXVkaW8gc2FtcGxlc1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZGF0LnNldCh1bml0LCBvZmZzZXQpO1xuICAgICAgdmFyIHVuaXRMZW4gPSB1bml0LmJ5dGVMZW5ndGg7XG4gICAgICBvZmZzZXQgKz0gdW5pdExlbjsgLy8gRGVmYXVsdCB0aGUgc2FtcGxlJ3MgZHVyYXRpb24gdG8gdGhlIGNvbXB1dGVkIG1wNFNhbXBsZUR1cmF0aW9uLCB3aGljaCB3aWxsIGVpdGhlciBiZSAxMDI0IGZvciBBQUMgb3IgMTE1MiBmb3IgTVBFR1xuICAgICAgLy8gSW4gdGhlIGNhc2UgdGhhdCB3ZSBoYXZlIDEgc2FtcGxlLCB0aGlzIHdpbGwgYmUgdGhlIGR1cmF0aW9uLiBJZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgc2FtcGxlLCB0aGUgZHVyYXRpb25cbiAgICAgIC8vIGJlY29tZXMgdGhlIFBUUyBkaWZmIHdpdGggdGhlIHByZXZpb3VzIHNhbXBsZVxuXG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobmV3IE1wNFNhbXBsZSh0cnVlLCBtcDRTYW1wbGVEdXJhdGlvbiwgdW5pdExlbiwgMCkpO1xuICAgICAgbGFzdFBUUyA9IF9wdHM7XG4gICAgfSAvLyBXZSBjb3VsZCBlbmQgdXAgd2l0aCBubyBhdWRpbyBzYW1wbGVzIGlmIGFsbCBpbnB1dCBzYW1wbGVzIHdlcmUgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJldmlvdXNseSByZW11eGVkIG9uZXNcblxuXG4gICAgdmFyIG5iU2FtcGxlcyA9IG91dHB1dFNhbXBsZXMubGVuZ3RoO1xuXG4gICAgaWYgKCFuYlNhbXBsZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRoZSBuZXh0IGF1ZGlvIHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGR1cmF0aW9uXG5cblxuICAgIHZhciBsYXN0U2FtcGxlID0gb3V0cHV0U2FtcGxlc1tvdXRwdXRTYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gbmV4dEF1ZGlvUHRzID0gbGFzdFBUUyArIHNjYWxlRmFjdG9yICogbGFzdFNhbXBsZS5kdXJhdGlvbjsgLy8gU2V0IHRoZSB0cmFjayBzYW1wbGVzIGZyb20gaW5wdXRTYW1wbGVzIHRvIG91dHB1dFNhbXBsZXMgYmVmb3JlIHJlbXV4aW5nXG5cbiAgICB2YXIgbW9vZiA9IHJhd01QRUcgPyBuZXcgVWludDhBcnJheSgwKSA6IF9tcDRfZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3RQVFMgLyBzY2FsZUZhY3RvciwgX2V4dGVuZHMoe30sIHRyYWNrLCB7XG4gICAgICBzYW1wbGVzOiBvdXRwdXRTYW1wbGVzXG4gICAgfSkpOyAvLyBDbGVhciB0aGUgdHJhY2sgc2FtcGxlcy4gVGhpcyBhbHNvIGNsZWFycyB0aGUgc2FtcGxlcyBhcnJheSBpbiB0aGUgZGVtdXhlciwgc2luY2UgdGhlIHJlZmVyZW5jZSBpcyBzaGFyZWRcblxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICB2YXIgc3RhcnQgPSBmaXJzdFBUUyAvIGlucHV0VGltZVNjYWxlO1xuICAgIHZhciBlbmQgPSBuZXh0QXVkaW9QdHMgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICB2YXIgdHlwZSA9ICdhdWRpbyc7XG4gICAgdmFyIGF1ZGlvRGF0YSA9IHtcbiAgICAgIGRhdGExOiBtb29mLFxuICAgICAgZGF0YTI6IG1kYXQsXG4gICAgICBzdGFydFBUUzogc3RhcnQsXG4gICAgICBlbmRQVFM6IGVuZCxcbiAgICAgIHN0YXJ0RFRTOiBzdGFydCxcbiAgICAgIGVuZERUUzogZW5kLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGhhc0F1ZGlvOiB0cnVlLFxuICAgICAgaGFzVmlkZW86IGZhbHNlLFxuICAgICAgbmI6IG5iU2FtcGxlc1xuICAgIH07XG4gICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyA9IHRydWU7XG4gICAgY29uc29sZS5hc3NlcnQobWRhdC5sZW5ndGgsICdNREFUIGxlbmd0aCBtdXN0IG5vdCBiZSB6ZXJvJyk7XG4gICAgcmV0dXJuIGF1ZGlvRGF0YTtcbiAgfTtcblxuICBfcHJvdG8ucmVtdXhFbXB0eUF1ZGlvID0gZnVuY3Rpb24gcmVtdXhFbXB0eUF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCB2aWRlb0RhdGEpIHtcbiAgICB2YXIgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICB2YXIgbXA0dGltZVNjYWxlID0gdHJhY2suc2FtcGxlcmF0ZSA/IHRyYWNrLnNhbXBsZXJhdGUgOiBpbnB1dFRpbWVTY2FsZTtcbiAgICB2YXIgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZTtcbiAgICB2YXIgbmV4dEF1ZGlvUHRzID0gdGhpcy5uZXh0QXVkaW9QdHM7IC8vIHN5bmMgd2l0aCB2aWRlbydzIHRpbWVzdGFtcFxuXG4gICAgdmFyIHN0YXJ0RFRTID0gKG5leHRBdWRpb1B0cyAhPT0gbnVsbCA/IG5leHRBdWRpb1B0cyA6IHZpZGVvRGF0YS5zdGFydERUUyAqIGlucHV0VGltZVNjYWxlKSArIHRoaXMuX2luaXREVFM7XG4gICAgdmFyIGVuZERUUyA9IHZpZGVvRGF0YS5lbmREVFMgKiBpbnB1dFRpbWVTY2FsZSArIHRoaXMuX2luaXREVFM7IC8vIG9uZSBzYW1wbGUncyBkdXJhdGlvbiB2YWx1ZVxuXG4gICAgdmFyIGZyYW1lRHVyYXRpb24gPSBzY2FsZUZhY3RvciAqIEFBQ19TQU1QTEVTX1BFUl9GUkFNRTsgLy8gc2FtcGxlcyBjb3VudCBvZiB0aGlzIHNlZ21lbnQncyBkdXJhdGlvblxuXG4gICAgdmFyIG5iU2FtcGxlcyA9IE1hdGguY2VpbCgoZW5kRFRTIC0gc3RhcnREVFMpIC8gZnJhbWVEdXJhdGlvbik7IC8vIHNpbGVudCBmcmFtZVxuXG4gICAgdmFyIHNpbGVudEZyYW1lID0gX2FhY19oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0uZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ud2FybignW21wNC1yZW11eGVyXTogcmVtdXggZW1wdHkgQXVkaW8nKTsgLy8gQ2FuJ3QgcmVtdXggaWYgd2UgY2FuJ3QgZ2VuZXJhdGUgYSBzaWxlbnQgZnJhbWUuLi5cblxuICAgIGlmICghc2lsZW50RnJhbWUpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS50cmFjZSgnW21wNC1yZW11eGVyXTogVW5hYmxlIHRvIHJlbXV4RW1wdHlBdWRpbyBzaW5jZSB3ZSB3ZXJlIHVuYWJsZSB0byBnZXQgYSBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNhbXBsZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIHZhciBzdGFtcCA9IHN0YXJ0RFRTICsgaSAqIGZyYW1lRHVyYXRpb247XG4gICAgICBzYW1wbGVzLnB1c2goe1xuICAgICAgICB1bml0OiBzaWxlbnRGcmFtZSxcbiAgICAgICAgcHRzOiBzdGFtcCxcbiAgICAgICAgZHRzOiBzdGFtcFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJhY2suc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgcmV0dXJuIHRoaXMucmVtdXhBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgZmFsc2UpO1xuICB9O1xuXG4gIHJldHVybiBNUDRSZW11eGVyO1xufSgpO1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVB0cyh2YWx1ZSwgcmVmZXJlbmNlKSB7XG4gIHZhciBvZmZzZXQ7XG5cbiAgaWYgKHJlZmVyZW5jZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChyZWZlcmVuY2UgPCB2YWx1ZSkge1xuICAgIC8vIC0gMl4zM1xuICAgIG9mZnNldCA9IC04NTg5OTM0NTkyO1xuICB9IGVsc2Uge1xuICAgIC8vICsgMl4zM1xuICAgIG9mZnNldCA9IDg1ODk5MzQ1OTI7XG4gIH1cbiAgLyogUFRTIGlzIDMzYml0IChmcm9tIDAgdG8gMl4zMyAtMSlcbiAgICBpZiBkaWZmIGJldHdlZW4gdmFsdWUgYW5kIHJlZmVyZW5jZSBpcyBiaWdnZXIgdGhhbiBoYWxmIG9mIHRoZSBhbXBsaXR1ZGUgKDJeMzIpIHRoZW4gaXQgbWVhbnMgdGhhdFxuICAgIFBUUyBsb29waW5nIG9jY3VyZWQuIGZpbGwgdGhlIGdhcCAqL1xuXG5cbiAgd2hpbGUgKE1hdGguYWJzKHZhbHVlIC0gcmVmZXJlbmNlKSA+IDQyOTQ5NjcyOTYpIHtcbiAgICB2YWx1ZSArPSBvZmZzZXQ7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGZpbmRLZXlmcmFtZUluZGV4KHNhbXBsZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHNhbXBsZXNbaV0ua2V5KSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGZsdXNoVGV4dFRyYWNrTWV0YWRhdGFDdWVTYW1wbGVzKHRyYWNrLCB0aW1lT2Zmc2V0LCBpbml0UFRTLCBpbml0RFRTKSB7XG4gIHZhciBsZW5ndGggPSB0cmFjay5zYW1wbGVzLmxlbmd0aDtcblxuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuXG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICB2YXIgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07IC8vIHNldHRpbmcgaWQzIHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG5cbiAgICBzYW1wbGUucHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5wdHMgLSBpbml0UFRTLCB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGUpIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgc2FtcGxlLmR0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUuZHRzIC0gaW5pdERUUywgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlKSAvIGlucHV0VGltZVNjYWxlO1xuICB9XG5cbiAgdmFyIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICB0cmFjay5zYW1wbGVzID0gW107XG4gIHJldHVybiB7XG4gICAgc2FtcGxlczogc2FtcGxlc1xuICB9O1xufVxuZnVuY3Rpb24gZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXModHJhY2ssIHRpbWVPZmZzZXQsIGluaXRQVFMpIHtcbiAgdmFyIGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoO1xuXG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG5cbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIHZhciBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTsgLy8gc2V0dGluZyB0ZXh0IHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG5cbiAgICBzYW1wbGUucHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5wdHMgLSBpbml0UFRTLCB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGUpIC8gaW5wdXRUaW1lU2NhbGU7XG4gIH1cblxuICB0cmFjay5zYW1wbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5wdHMgLSBiLnB0cztcbiAgfSk7XG4gIHZhciBzYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICByZXR1cm4ge1xuICAgIHNhbXBsZXM6IHNhbXBsZXNcbiAgfTtcbn1cblxudmFyIE1wNFNhbXBsZSA9IGZ1bmN0aW9uIE1wNFNhbXBsZShpc0tleWZyYW1lLCBkdXJhdGlvbiwgc2l6ZSwgY3RzKSB7XG4gIHRoaXMuc2l6ZSA9IHZvaWQgMDtcbiAgdGhpcy5kdXJhdGlvbiA9IHZvaWQgMDtcbiAgdGhpcy5jdHMgPSB2b2lkIDA7XG4gIHRoaXMuZmxhZ3MgPSB2b2lkIDA7XG4gIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgdGhpcy5zaXplID0gc2l6ZTtcbiAgdGhpcy5jdHMgPSBjdHM7XG4gIHRoaXMuZmxhZ3MgPSBuZXcgTXA0U2FtcGxlRmxhZ3MoaXNLZXlmcmFtZSk7XG59O1xuXG52YXIgTXA0U2FtcGxlRmxhZ3MgPSBmdW5jdGlvbiBNcDRTYW1wbGVGbGFncyhpc0tleWZyYW1lKSB7XG4gIHRoaXMuaXNMZWFkaW5nID0gMDtcbiAgdGhpcy5pc0RlcGVuZGVkT24gPSAwO1xuICB0aGlzLmhhc1JlZHVuZGFuY3kgPSAwO1xuICB0aGlzLmRlZ3JhZFByaW8gPSAwO1xuICB0aGlzLmRlcGVuZHNPbiA9IDE7XG4gIHRoaXMuaXNOb25TeW5jID0gMTtcbiAgdGhpcy5kZXBlbmRzT24gPSBpc0tleWZyYW1lID8gMiA6IDE7XG4gIHRoaXMuaXNOb25TeW5jID0gaXNLZXlmcmFtZSA/IDAgOiAxO1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3JlbXV4L3Bhc3N0aHJvdWdoLXJlbXV4ZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tcDRfcmVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tcDQtcmVtdXhlciAqLyBcIi4vc3JjL3JlbXV4L21wNC1yZW11eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL21wNC10b29scyAqLyBcIi4vc3JjL3V0aWxzL21wNC10b29scy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2FkZXIvZnJhZ21lbnQgKi8gXCIuL3NyYy9sb2FkZXIvZnJhZ21lbnQudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuXG5cblxuXG5cblxuXG52YXIgUGFzc1Rocm91Z2hSZW11eGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGFzc1Rocm91Z2hSZW11eGVyKCkge1xuICAgIHRoaXMuZW1pdEluaXRTZWdtZW50ID0gZmFsc2U7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXREYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdFBUUyA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRUcmFja3MgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0RW5kRFRTID0gbnVsbDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQYXNzVGhyb3VnaFJlbXV4ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHt9O1xuXG4gIF9wcm90by5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uIHJlc2V0VGltZVN0YW1wKGRlZmF1bHRJbml0UFRTKSB7XG4gICAgdGhpcy5pbml0UFRTID0gZGVmYXVsdEluaXRQVFM7XG4gICAgdGhpcy5sYXN0RW5kRFRTID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXROZXh0VGltZXN0YW1wID0gZnVuY3Rpb24gcmVzZXROZXh0VGltZXN0YW1wKCkge1xuICAgIHRoaXMubGFzdEVuZERUUyA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjKSB7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xuICAgIHRoaXMuZ2VuZXJhdGVJbml0U2VnbWVudChpbml0U2VnbWVudCk7XG4gICAgdGhpcy5lbWl0SW5pdFNlZ21lbnQgPSB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5nZW5lcmF0ZUluaXRTZWdtZW50ID0gZnVuY3Rpb24gZ2VuZXJhdGVJbml0U2VnbWVudChpbml0U2VnbWVudCkge1xuICAgIHZhciBhdWRpb0NvZGVjID0gdGhpcy5hdWRpb0NvZGVjLFxuICAgICAgICB2aWRlb0NvZGVjID0gdGhpcy52aWRlb0NvZGVjO1xuXG4gICAgaWYgKCFpbml0U2VnbWVudCB8fCAhaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkge1xuICAgICAgdGhpcy5pbml0VHJhY2tzID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5pbml0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcInBhcnNlSW5pdFNlZ21lbnRcIl0pKGluaXRTZWdtZW50KTsgLy8gR2V0IGNvZGVjIGZyb20gaW5pdFNlZ21lbnQgb3IgZmFsbGJhY2sgdG8gZGVmYXVsdFxuXG4gICAgaWYgKCFhdWRpb0NvZGVjKSB7XG4gICAgICBhdWRpb0NvZGVjID0gZ2V0UGFyc2VkVHJhY2tDb2RlYyhpbml0RGF0YS5hdWRpbywgX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRWxlbWVudGFyeVN0cmVhbVR5cGVzXCJdLkFVRElPKTtcbiAgICB9XG5cbiAgICBpZiAoIXZpZGVvQ29kZWMpIHtcbiAgICAgIHZpZGVvQ29kZWMgPSBnZXRQYXJzZWRUcmFja0NvZGVjKGluaXREYXRhLnZpZGVvLCBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIl0uVklERU8pO1xuICAgIH1cblxuICAgIHZhciB0cmFja3MgPSB7fTtcblxuICAgIGlmIChpbml0RGF0YS5hdWRpbyAmJiBpbml0RGF0YS52aWRlbykge1xuICAgICAgdHJhY2tzLmF1ZGlvdmlkZW8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsXG4gICAgICAgIGNvZGVjOiBhdWRpb0NvZGVjICsgJywnICsgdmlkZW9Db2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IGluaXRTZWdtZW50LFxuICAgICAgICBpZDogJ21haW4nXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaW5pdERhdGEuYXVkaW8pIHtcbiAgICAgIHRyYWNrcy5hdWRpbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiAnYXVkaW8vbXA0JyxcbiAgICAgICAgY29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50OiBpbml0U2VnbWVudCxcbiAgICAgICAgaWQ6ICdhdWRpbydcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpbml0RGF0YS52aWRlbykge1xuICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICBjb2RlYzogdmlkZW9Db2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IGluaXRTZWdtZW50LFxuICAgICAgICBpZDogJ21haW4nXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJsb2dnZXJcIl0ud2FybignW3Bhc3N0aHJvdWdoLXJlbXV4ZXIudHNdOiBpbml0U2VnbWVudCBkb2VzIG5vdCBjb250YWluIG1vb3Ygb3IgdHJhayBib3hlcy4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRUcmFja3MgPSB0cmFja3M7XG4gIH07XG5cbiAgX3Byb3RvLnJlbXV4ID0gZnVuY3Rpb24gcmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCkge1xuICAgIHZhciBfdGhpcyRpbml0UFRTO1xuXG4gICAgdmFyIGluaXRQVFMgPSB0aGlzLmluaXRQVFMsXG4gICAgICAgIGxhc3RFbmREVFMgPSB0aGlzLmxhc3RFbmREVFM7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIGF1ZGlvOiB1bmRlZmluZWQsXG4gICAgICB2aWRlbzogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdGV4dFRyYWNrLFxuICAgICAgaWQzOiBpZDNUcmFjayxcbiAgICAgIGluaXRTZWdtZW50OiB1bmRlZmluZWRcbiAgICB9OyAvLyBJZiB3ZSBoYXZlbid0IHlldCBzZXQgYSBsYXN0RW5kRFRTLCBvciBpdCB3YXMgcmVzZXQsIHNldCBpdCB0byB0aGUgcHJvdmlkZWQgdGltZU9mZnNldC4gV2Ugd2FudCB0byB1c2UgdGhlXG4gICAgLy8gbGFzdEVuZERUUyBvdmVyIHRpbWVPZmZzZXQgd2hlbmV2ZXIgcG9zc2libGU7IGR1cmluZyBwcm9ncmVzc2l2ZSBwbGF5YmFjaywgdGhlIG1lZGlhIHNvdXJjZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAvLyB0aGUgbWVkaWEgZHVyYXRpb24gKHdoaWNoIGlzIHdoYXQgdGltZU9mZnNldCBpcyBwcm92aWRlZCBhcykgYmVmb3JlIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGUgbmV4dCBjaHVuay5cblxuICAgIGlmICghT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShsYXN0RW5kRFRTKSkge1xuICAgICAgbGFzdEVuZERUUyA9IHRoaXMubGFzdEVuZERUUyA9IHRpbWVPZmZzZXQgfHwgMDtcbiAgICB9IC8vIFRoZSBiaW5hcnkgc2VnbWVudCBkYXRhIGlzIGFkZGVkIHRvIHRoZSB2aWRlb1RyYWNrIGluIHRoZSBtcDRkZW11eGVyLiBXZSBkb24ndCBjaGVjayB0byBzZWUgaWYgdGhlIGRhdGEgaXMgb25seVxuICAgIC8vIGF1ZGlvIG9yIHZpZGVvIChvciBib3RoKTsgYWRkaW5nIGl0IHRvIHZpZGVvIHdhcyBhbiBhcmJpdHJhcnkgY2hvaWNlLlxuXG5cbiAgICB2YXIgZGF0YSA9IHZpZGVvVHJhY2suc2FtcGxlcztcblxuICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGluaXRTZWdtZW50ID0ge1xuICAgICAgaW5pdFBUUzogdW5kZWZpbmVkLFxuICAgICAgdGltZXNjYWxlOiAxXG4gICAgfTtcbiAgICB2YXIgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhO1xuXG4gICAgaWYgKCFpbml0RGF0YSB8fCAhaW5pdERhdGEubGVuZ3RoKSB7XG4gICAgICB0aGlzLmdlbmVyYXRlSW5pdFNlZ21lbnQoZGF0YSk7XG4gICAgICBpbml0RGF0YSA9IHRoaXMuaW5pdERhdGE7XG4gICAgfVxuXG4gICAgaWYgKCFpbml0RGF0YSB8fCAhaW5pdERhdGEubGVuZ3RoKSB7XG4gICAgICAvLyBXZSBjYW4ndCByZW11eCBpZiB0aGUgaW5pdFNlZ21lbnQgY291bGQgbm90IGJlIGdlbmVyYXRlZFxuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wibG9nZ2VyXCJdLndhcm4oJ1twYXNzdGhyb3VnaC1yZW11eGVyLnRzXTogRmFpbGVkIHRvIGdlbmVyYXRlIGluaXRTZWdtZW50LicpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbWl0SW5pdFNlZ21lbnQpIHtcbiAgICAgIGluaXRTZWdtZW50LnRyYWNrcyA9IHRoaXMuaW5pdFRyYWNrcztcbiAgICAgIHRoaXMuZW1pdEluaXRTZWdtZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGluaXRQVFMpKSB7XG4gICAgICB0aGlzLmluaXRQVFMgPSBpbml0U2VnbWVudC5pbml0UFRTID0gaW5pdFBUUyA9IGNvbXB1dGVJbml0UFRTKGluaXREYXRhLCBkYXRhLCBsYXN0RW5kRFRTKTtcbiAgICB9XG5cbiAgICB2YXIgZHVyYXRpb24gPSBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZ2V0RHVyYXRpb25cIl0pKGRhdGEsIGluaXREYXRhKTtcbiAgICB2YXIgc3RhcnREVFMgPSBsYXN0RW5kRFRTO1xuICAgIHZhciBlbmREVFMgPSBkdXJhdGlvbiArIHN0YXJ0RFRTO1xuICAgIE9iamVjdChfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJvZmZzZXRTdGFydERUU1wiXSkoaW5pdERhdGEsIGRhdGEsIGluaXRQVFMpO1xuXG4gICAgaWYgKGR1cmF0aW9uID4gMCkge1xuICAgICAgdGhpcy5sYXN0RW5kRFRTID0gZW5kRFRTO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJsb2dnZXJcIl0ud2FybignRHVyYXRpb24gcGFyc2VkIGZyb20gbXA0IHNob3VsZCBiZSBncmVhdGVyIHRoYW4gemVybycpO1xuICAgICAgdGhpcy5yZXNldE5leHRUaW1lc3RhbXAoKTtcbiAgICB9XG5cbiAgICB2YXIgaGFzQXVkaW8gPSAhIWluaXREYXRhLmF1ZGlvO1xuICAgIHZhciBoYXNWaWRlbyA9ICEhaW5pdERhdGEudmlkZW87XG4gICAgdmFyIHR5cGUgPSAnJztcblxuICAgIGlmIChoYXNBdWRpbykge1xuICAgICAgdHlwZSArPSAnYXVkaW8nO1xuICAgIH1cblxuICAgIGlmIChoYXNWaWRlbykge1xuICAgICAgdHlwZSArPSAndmlkZW8nO1xuICAgIH1cblxuICAgIHZhciB0cmFjayA9IHtcbiAgICAgIGRhdGExOiBkYXRhLFxuICAgICAgc3RhcnRQVFM6IHN0YXJ0RFRTLFxuICAgICAgc3RhcnREVFM6IHN0YXJ0RFRTLFxuICAgICAgZW5kUFRTOiBlbmREVFMsXG4gICAgICBlbmREVFM6IGVuZERUUyxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBoYXNBdWRpbzogaGFzQXVkaW8sXG4gICAgICBoYXNWaWRlbzogaGFzVmlkZW8sXG4gICAgICBuYjogMSxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICAgIHJlc3VsdC5hdWRpbyA9IHRyYWNrLnR5cGUgPT09ICdhdWRpbycgPyB0cmFjayA6IHVuZGVmaW5lZDtcbiAgICByZXN1bHQudmlkZW8gPSB0cmFjay50eXBlICE9PSAnYXVkaW8nID8gdHJhY2sgOiB1bmRlZmluZWQ7XG4gICAgcmVzdWx0LmluaXRTZWdtZW50ID0gaW5pdFNlZ21lbnQ7XG4gICAgdmFyIGluaXRQdHNOdW0gPSAoX3RoaXMkaW5pdFBUUyA9IHRoaXMuaW5pdFBUUykgIT0gbnVsbCA/IF90aGlzJGluaXRQVFMgOiAwO1xuICAgIHJlc3VsdC5pZDMgPSBPYmplY3QoX21wNF9yZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlc1wiXSkoaWQzVHJhY2ssIHRpbWVPZmZzZXQsIGluaXRQdHNOdW0sIGluaXRQdHNOdW0pO1xuXG4gICAgaWYgKHRleHRUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnRleHQgPSBPYmplY3QoX21wNF9yZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJmbHVzaFRleHRUcmFja1VzZXJkYXRhQ3VlU2FtcGxlc1wiXSkodGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBpbml0UHRzTnVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBQYXNzVGhyb3VnaFJlbXV4ZXI7XG59KCk7XG5cbnZhciBjb21wdXRlSW5pdFBUUyA9IGZ1bmN0aW9uIGNvbXB1dGVJbml0UFRTKGluaXREYXRhLCBkYXRhLCB0aW1lT2Zmc2V0KSB7XG4gIHJldHVybiBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZ2V0U3RhcnREVFNcIl0pKGluaXREYXRhLCBkYXRhKSAtIHRpbWVPZmZzZXQ7XG59O1xuXG5mdW5jdGlvbiBnZXRQYXJzZWRUcmFja0NvZGVjKHRyYWNrLCB0eXBlKSB7XG4gIHZhciBwYXJzZWRDb2RlYyA9IHRyYWNrID09PSBudWxsIHx8IHRyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFjay5jb2RlYztcblxuICBpZiAocGFyc2VkQ29kZWMgJiYgcGFyc2VkQ29kZWMubGVuZ3RoID4gNCkge1xuICAgIHJldHVybiBwYXJzZWRDb2RlYztcbiAgfSAvLyBTaW5jZSBtcDQtdG9vbHMgY2Fubm90IHBhcnNlIGZ1bGwgY29kZWMgc3RyaW5nIChzZWUgJ1RPRE86IFBhcnNlIGNvZGVjIGRldGFpbHMnLi4uIGluIG1wNC10b29scylcbiAgLy8gUHJvdmlkZSBkZWZhdWx0cyBiYXNlZCBvbiBjb2RlYyB0eXBlXG4gIC8vIFRoaXMgYWxsb3dzIGZvciBzb21lIHBsYXliYWNrIG9mIHNvbWUgZm1wNCBwbGF5bGlzdHMgd2l0aG91dCBDT0RFQ1MgZGVmaW5lZCBpbiBtYW5pZmVzdFxuXG5cbiAgaWYgKHBhcnNlZENvZGVjID09PSAnaHZjMScgfHwgcGFyc2VkQ29kZWMgPT09ICdoZXYxJykge1xuICAgIHJldHVybiAnaHZjMS4xLmMuTDEyMC45MCc7XG4gIH1cblxuICBpZiAocGFyc2VkQ29kZWMgPT09ICdhdjAxJykge1xuICAgIHJldHVybiAnYXYwMS4wLjA0TS4wOCc7XG4gIH1cblxuICBpZiAocGFyc2VkQ29kZWMgPT09ICdhdmMxJyB8fCB0eXBlID09PSBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIl0uVklERU8pIHtcbiAgICByZXR1cm4gJ2F2YzEuNDJlMDFlJztcbiAgfVxuXG4gIHJldHVybiAnbXA0YS40MC41Jztcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChQYXNzVGhyb3VnaFJlbXV4ZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90YXNrLWxvb3AudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3Rhc2stbG9vcC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVGFza0xvb3A7IH0pO1xuLyoqXG4gKiBTdWItY2xhc3Mgc3BlY2lhbGl6YXRpb24gb2YgRXZlbnRIYW5kbGVyIGJhc2UgY2xhc3MuXG4gKlxuICogVGFza0xvb3AgYWxsb3dzIHRvIHNjaGVkdWxlIGEgdGFzayBmdW5jdGlvbiBiZWluZyBjYWxsZWQgKG9wdGlvbm5hbHkgcmVwZWF0ZWRseSkgb24gdGhlIG1haW4gbG9vcCxcbiAqIHNjaGVkdWxlZCBhc3luY2hyb25lb3VzbHksIGF2b2lkaW5nIHJlY3Vyc2l2ZSBjYWxscyBpbiB0aGUgc2FtZSB0aWNrLlxuICpcbiAqIFRoZSB0YXNrIGl0c2VsZiBpcyBpbXBsZW1lbnRlZCBpbiBgZG9UaWNrYC4gSXQgY2FuIGJlIHJlcXVlc3RlZCBhbmQgY2FsbGVkIGZvciBzaW5nbGUgZXhlY3V0aW9uXG4gKiB1c2luZyB0aGUgYHRpY2tgIG1ldGhvZC5cbiAqXG4gKiBJdCB3aWxsIGJlIGFzc3VyZWQgdGhhdCB0aGUgdGFzayBleGVjdXRpb24gbWV0aG9kIChgdGlja2ApIG9ubHkgZ2V0cyBjYWxsZWQgb25jZSBwZXIgbWFpbiBsb29wIFwidGlja1wiLFxuICogbm8gbWF0dGVyIGhvdyBvZnRlbiBpdCBnZXRzIHJlcXVlc3RlZCBmb3IgZXhlY3V0aW9uLiBFeGVjdXRpb24gaW4gZnVydGhlciB0aWNrcyB3aWxsIGJlIHNjaGVkdWxlZCBhY2NvcmRpbmdseS5cbiAqXG4gKiBJZiBmdXJ0aGVyIGV4ZWN1dGlvbiByZXF1ZXN0cyBoYXZlIGFscmVhZHkgYmVlbiBzY2hlZHVsZWQgb24gdGhlIG5leHQgdGljaywgaXQgY2FuIGJlIGNoZWNrZWQgd2l0aCBgaGFzTmV4dFRpY2tgLFxuICogYW5kIGNhbmNlbGxlZCB3aXRoIGBjbGVhck5leHRUaWNrYC5cbiAqXG4gKiBUaGUgdGFzayBjYW4gYmUgc2NoZWR1bGVkIGFzIGFuIGludGVydmFsIHJlcGVhdGVkbHkgd2l0aCBhIHBlcmlvZCBhcyBwYXJhbWV0ZXIgKHNlZSBgc2V0SW50ZXJ2YWxgLCBgY2xlYXJJbnRlcnZhbGApLlxuICpcbiAqIFN1Yi1jbGFzc2VzIG5lZWQgdG8gaW1wbGVtZW50IHRoZSBgZG9UaWNrYCBtZXRob2Qgd2hpY2ggd2lsbCBlZmZlY3RpdmVseSBoYXZlIHRoZSB0YXNrIGV4ZWN1dGlvbiByb3V0aW5lLlxuICpcbiAqIEZ1cnRoZXIgZXhwbGFuYXRpb25zOlxuICpcbiAqIFRoZSBiYXNlY2xhc3MgaGFzIGEgYHRpY2tgIG1ldGhvZCB0aGF0IHdpbGwgc2NoZWR1bGUgdGhlIGRvVGljayBjYWxsLiBJdCBtYXkgYmUgY2FsbGVkIHN5bmNocm9uZW91c2x5XG4gKiBvbmx5IGZvciBhIHN0YWNrLWRlcHRoIG9mIG9uZS4gT24gcmUtZW50cmFudCBjYWxscywgc3ViLXNlcXVlbnQgY2FsbHMgYXJlIHNjaGVkdWxlZCBmb3IgbmV4dCBtYWluIGxvb3AgdGlja3MuXG4gKlxuICogV2hlbiB0aGUgdGFzayBleGVjdXRpb24gKGB0aWNrYCBtZXRob2QpIGlzIGNhbGxlZCBpbiByZS1lbnRyYW50IHdheSB0aGlzIGlzIGRldGVjdGVkIGFuZFxuICogd2UgYXJlIGxpbWl0aW5nIHRoZSB0YXNrIGV4ZWN1dGlvbiBwZXIgY2FsbCBzdGFjayB0byBleGFjdGx5IG9uZSwgYnV0IHNjaGVkdWxpbmcvcG9zdC1wb25pbmcgZnVydGhlclxuICogdGFzayBwcm9jZXNzaW5nIG9uIHRoZSBuZXh0IG1haW4gbG9vcCBpdGVyYXRpb24gKGFsc28ga25vd24gYXMgXCJuZXh0IHRpY2tcIiBpbiB0aGUgTm9kZS9KUyBydW50aW1lIGxpbmdvKS5cbiAqL1xudmFyIFRhc2tMb29wID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGFza0xvb3AoKSB7XG4gICAgdGhpcy5fYm91bmRUaWNrID0gdm9pZCAwO1xuICAgIHRoaXMuX3RpY2tUaW1lciA9IG51bGw7XG4gICAgdGhpcy5fdGlja0ludGVydmFsID0gbnVsbDtcbiAgICB0aGlzLl90aWNrQ2FsbENvdW50ID0gMDtcbiAgICB0aGlzLl9ib3VuZFRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUYXNrTG9vcC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWluZygpO1xuICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWVkKCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uSGFuZGxlckRlc3Ryb3lpbmcgPSBmdW5jdGlvbiBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIC8vIGNsZWFyIGFsbCB0aW1lcnMgYmVmb3JlIHVucmVnaXN0ZXJpbmcgZnJvbSBldmVudCBidXNcbiAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgfTtcblxuICBfcHJvdG8ub25IYW5kbGVyRGVzdHJveWVkID0gZnVuY3Rpb24gb25IYW5kbGVyRGVzdHJveWVkKCkge31cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5oYXNJbnRlcnZhbCA9IGZ1bmN0aW9uIGhhc0ludGVydmFsKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3RpY2tJbnRlcnZhbDtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmhhc05leHRUaWNrID0gZnVuY3Rpb24gaGFzTmV4dFRpY2soKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fdGlja1RpbWVyO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzIEludGVydmFsIHRpbWUgKG1zKVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIGludGVydmFsIGhhcyBiZWVuIHNjaGVkdWxlZCwgZmFsc2Ugd2hlbiBhbHJlYWR5IHNjaGVkdWxlZCAobm8gZWZmZWN0KVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uIHNldEludGVydmFsKG1pbGxpcykge1xuICAgIGlmICghdGhpcy5fdGlja0ludGVydmFsKSB7XG4gICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBzZWxmLnNldEludGVydmFsKHRoaXMuX2JvdW5kVGljaywgbWlsbGlzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgd2hlbiBpbnRlcnZhbCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcbiAgICovXG4gIDtcblxuICBfcHJvdG8uY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uIGNsZWFySW50ZXJ2YWwoKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tJbnRlcnZhbCkge1xuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMuX3RpY2tJbnRlcnZhbCk7XG4gICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIHRpbWVvdXQgd2FzIGNsZWFyZWQsIGZhbHNlIHdoZW4gbm9uZSB3YXMgc2V0IChubyBlZmZlY3QpXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNsZWFyTmV4dFRpY2sgPSBmdW5jdGlvbiBjbGVhck5leHRUaWNrKCkge1xuICAgIGlmICh0aGlzLl90aWNrVGltZXIpIHtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMuX3RpY2tUaW1lcik7XG4gICAgICB0aGlzLl90aWNrVGltZXIgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBXaWxsIGNhbGwgdGhlIHN1YmNsYXNzIGRvVGljayBpbXBsZW1lbnRhdGlvbiBpbiB0aGlzIG1haW4gbG9vcCB0aWNrXG4gICAqIG9yIGluIHRoZSBuZXh0IG9uZSAodmlhIHNldFRpbWVvdXQoLDApKSBpbiBjYXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkXG4gICAqIGluIHRoaXMgdGljayAoaW4gY2FzZSB0aGlzIGlzIGEgcmUtZW50cmFudCBjYWxsKS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udGljayA9IGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgdGhpcy5fdGlja0NhbGxDb3VudCsrO1xuXG4gICAgaWYgKHRoaXMuX3RpY2tDYWxsQ291bnQgPT09IDEpIHtcbiAgICAgIHRoaXMuZG9UaWNrKCk7IC8vIHJlLWVudHJhbnQgY2FsbCB0byB0aWNrIGZyb20gcHJldmlvdXMgZG9UaWNrIGNhbGwgc3RhY2tcbiAgICAgIC8vIC0+IHNjaGVkdWxlIGEgY2FsbCBvbiB0aGUgbmV4dCBtYWluIGxvb3AgaXRlcmF0aW9uIHRvIHByb2Nlc3MgdGhpcyB0YXNrIHByb2Nlc3NpbmcgcmVxdWVzdFxuXG4gICAgICBpZiAodGhpcy5fdGlja0NhbGxDb3VudCA+IDEpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIG9ubHkgb25lIHRpbWVyIGV4aXN0cyBhdCBhbnkgdGltZSBhdCBtYXhcbiAgICAgICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udGlja0ltbWVkaWF0ZSA9IGZ1bmN0aW9uIHRpY2tJbW1lZGlhdGUoKSB7XG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5fdGlja1RpbWVyID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMuX2JvdW5kVGljaywgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEZvciBzdWJjbGFzcyB0byBpbXBsZW1lbnQgdGFzayBsb2dpY1xuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZG9UaWNrID0gZnVuY3Rpb24gZG9UaWNrKCkge307XG5cbiAgcmV0dXJuIFRhc2tMb29wO1xufSgpO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHlwZXMvY21jZC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3R5cGVzL2NtY2QudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBDTUNEVmVyc2lvbiwgQ01DRE9iamVjdFR5cGUsIENNQ0RTdHJlYW1pbmdGb3JtYXQsIENNQ0RTdHJlYW1UeXBlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNNQ0RWZXJzaW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ01DRFZlcnNpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNNQ0RPYmplY3RUeXBlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ01DRE9iamVjdFR5cGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNNQ0RTdHJlYW1pbmdGb3JtYXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDTUNEU3RyZWFtaW5nRm9ybWF0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDTUNEU3RyZWFtVHlwZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENNQ0RTdHJlYW1UeXBlOyB9KTtcbi8qKlxuICogQ01DRCBzcGVjIHZlcnNpb25cbiAqL1xudmFyIENNQ0RWZXJzaW9uID0gMTtcbi8qKlxuICogQ01DRCBPYmplY3QgVHlwZVxuICovXG5cbnZhciBDTUNET2JqZWN0VHlwZTtcbi8qKlxuICogQ01DRCBTdHJlYW1pbmcgRm9ybWF0XG4gKi9cblxuKGZ1bmN0aW9uIChDTUNET2JqZWN0VHlwZSkge1xuICBDTUNET2JqZWN0VHlwZVtcIk1BTklGRVNUXCJdID0gXCJtXCI7XG4gIENNQ0RPYmplY3RUeXBlW1wiQVVESU9cIl0gPSBcImFcIjtcbiAgQ01DRE9iamVjdFR5cGVbXCJWSURFT1wiXSA9IFwidlwiO1xuICBDTUNET2JqZWN0VHlwZVtcIk1VWEVEXCJdID0gXCJhdlwiO1xuICBDTUNET2JqZWN0VHlwZVtcIklOSVRcIl0gPSBcImlcIjtcbiAgQ01DRE9iamVjdFR5cGVbXCJDQVBUSU9OXCJdID0gXCJjXCI7XG4gIENNQ0RPYmplY3RUeXBlW1wiVElNRURfVEVYVFwiXSA9IFwidHRcIjtcbiAgQ01DRE9iamVjdFR5cGVbXCJLRVlcIl0gPSBcImtcIjtcbiAgQ01DRE9iamVjdFR5cGVbXCJPVEhFUlwiXSA9IFwib1wiO1xufSkoQ01DRE9iamVjdFR5cGUgfHwgKENNQ0RPYmplY3RUeXBlID0ge30pKTtcblxudmFyIENNQ0RTdHJlYW1pbmdGb3JtYXQ7XG4vKipcbiAqIENNQ0QgU3RyZWFtaW5nIFR5cGVcbiAqL1xuXG4oZnVuY3Rpb24gKENNQ0RTdHJlYW1pbmdGb3JtYXQpIHtcbiAgQ01DRFN0cmVhbWluZ0Zvcm1hdFtcIkRBU0hcIl0gPSBcImRcIjtcbiAgQ01DRFN0cmVhbWluZ0Zvcm1hdFtcIkhMU1wiXSA9IFwiaFwiO1xuICBDTUNEU3RyZWFtaW5nRm9ybWF0W1wiU01PT1RIXCJdID0gXCJzXCI7XG4gIENNQ0RTdHJlYW1pbmdGb3JtYXRbXCJPVEhFUlwiXSA9IFwib1wiO1xufSkoQ01DRFN0cmVhbWluZ0Zvcm1hdCB8fCAoQ01DRFN0cmVhbWluZ0Zvcm1hdCA9IHt9KSk7XG5cbnZhciBDTUNEU3RyZWFtVHlwZTtcbi8qKlxuICogQ01DRCBIZWFkZXJzXG4gKi9cblxuKGZ1bmN0aW9uIChDTUNEU3RyZWFtVHlwZSkge1xuICBDTUNEU3RyZWFtVHlwZVtcIlZPRFwiXSA9IFwidlwiO1xuICBDTUNEU3RyZWFtVHlwZVtcIkxJVkVcIl0gPSBcImxcIjtcbn0pKENNQ0RTdHJlYW1UeXBlIHx8IChDTUNEU3RyZWFtVHlwZSA9IHt9KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3R5cGVzL2RlbXV4ZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90eXBlcy9kZW11eGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogTWV0YWRhdGFTY2hlbWEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiTWV0YWRhdGFTY2hlbWFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBNZXRhZGF0YVNjaGVtYTsgfSk7XG52YXIgTWV0YWRhdGFTY2hlbWE7XG5cbihmdW5jdGlvbiAoTWV0YWRhdGFTY2hlbWEpIHtcbiAgTWV0YWRhdGFTY2hlbWFbXCJhdWRpb0lkM1wiXSA9IFwib3JnLmlkM1wiO1xuICBNZXRhZGF0YVNjaGVtYVtcImRhdGVSYW5nZVwiXSA9IFwiY29tLmFwcGxlLnF1aWNrdGltZS5ITFNcIjtcbiAgTWV0YWRhdGFTY2hlbWFbXCJlbXNnXCJdID0gXCJodHRwczovL2FvbWVkaWEub3JnL2Vtc2cvSUQzXCI7XG59KShNZXRhZGF0YVNjaGVtYSB8fCAoTWV0YWRhdGFTY2hlbWEgPSB7fSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90eXBlcy9sZXZlbC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90eXBlcy9sZXZlbC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBIbHNTa2lwLCBnZXRTa2lwVmFsdWUsIEhsc1VybFBhcmFtZXRlcnMsIExldmVsICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkhsc1NraXBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBIbHNTa2lwOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRTa2lwVmFsdWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRTa2lwVmFsdWU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkhsc1VybFBhcmFtZXRlcnNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBIbHNVcmxQYXJhbWV0ZXJzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJMZXZlbFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExldmVsOyB9KTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIEhsc1NraXA7XG5cbihmdW5jdGlvbiAoSGxzU2tpcCkge1xuICBIbHNTa2lwW1wiTm9cIl0gPSBcIlwiO1xuICBIbHNTa2lwW1wiWWVzXCJdID0gXCJZRVNcIjtcbiAgSGxzU2tpcFtcInYyXCJdID0gXCJ2MlwiO1xufSkoSGxzU2tpcCB8fCAoSGxzU2tpcCA9IHt9KSk7XG5cbmZ1bmN0aW9uIGdldFNraXBWYWx1ZShkZXRhaWxzLCBtc24pIHtcbiAgdmFyIGNhblNraXBVbnRpbCA9IGRldGFpbHMuY2FuU2tpcFVudGlsLFxuICAgICAgY2FuU2tpcERhdGVSYW5nZXMgPSBkZXRhaWxzLmNhblNraXBEYXRlUmFuZ2VzLFxuICAgICAgZW5kU04gPSBkZXRhaWxzLmVuZFNOO1xuICB2YXIgc25DaGFuZ2VHb2FsID0gbXNuICE9PSB1bmRlZmluZWQgPyBtc24gLSBlbmRTTiA6IDA7XG5cbiAgaWYgKGNhblNraXBVbnRpbCAmJiBzbkNoYW5nZUdvYWwgPCBjYW5Ta2lwVW50aWwpIHtcbiAgICBpZiAoY2FuU2tpcERhdGVSYW5nZXMpIHtcbiAgICAgIHJldHVybiBIbHNTa2lwLnYyO1xuICAgIH1cblxuICAgIHJldHVybiBIbHNTa2lwLlllcztcbiAgfVxuXG4gIHJldHVybiBIbHNTa2lwLk5vO1xufVxudmFyIEhsc1VybFBhcmFtZXRlcnMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIbHNVcmxQYXJhbWV0ZXJzKG1zbiwgcGFydCwgc2tpcCkge1xuICAgIHRoaXMubXNuID0gdm9pZCAwO1xuICAgIHRoaXMucGFydCA9IHZvaWQgMDtcbiAgICB0aGlzLnNraXAgPSB2b2lkIDA7XG4gICAgdGhpcy5tc24gPSBtc247XG4gICAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgICB0aGlzLnNraXAgPSBza2lwO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEhsc1VybFBhcmFtZXRlcnMucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGREaXJlY3RpdmVzID0gZnVuY3Rpb24gYWRkRGlyZWN0aXZlcyh1cmkpIHtcbiAgICB2YXIgdXJsID0gbmV3IHNlbGYuVVJMKHVyaSk7XG5cbiAgICBpZiAodGhpcy5tc24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ19ITFNfbXNuJywgdGhpcy5tc24udG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19wYXJ0JywgdGhpcy5wYXJ0LnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNraXApIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3NraXAnLCB0aGlzLnNraXApO1xuICAgIH1cblxuICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbiAgfTtcblxuICByZXR1cm4gSGxzVXJsUGFyYW1ldGVycztcbn0oKTtcbnZhciBMZXZlbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExldmVsKGRhdGEpIHtcbiAgICB0aGlzLmF0dHJzID0gdm9pZCAwO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLmJpdHJhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2RlY1NldCA9IHZvaWQgMDtcbiAgICB0aGlzLmhlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy53aWR0aCA9IHZvaWQgMDtcbiAgICB0aGlzLnVua25vd25Db2RlY3MgPSB2b2lkIDA7XG4gICAgdGhpcy5hdWRpb0dyb3VwSWRzID0gdm9pZCAwO1xuICAgIHRoaXMuZGV0YWlscyA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50RXJyb3IgPSAwO1xuICAgIHRoaXMubG9hZEVycm9yID0gMDtcbiAgICB0aGlzLmxvYWRlZCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlYWxCaXRyYXRlID0gMDtcbiAgICB0aGlzLnRleHRHcm91cElkcyA9IHZvaWQgMDtcbiAgICB0aGlzLnVybCA9IHZvaWQgMDtcbiAgICB0aGlzLl91cmxJZCA9IDA7XG4gICAgdGhpcy51cmwgPSBbZGF0YS51cmxdO1xuICAgIHRoaXMuYXR0cnMgPSBkYXRhLmF0dHJzO1xuICAgIHRoaXMuYml0cmF0ZSA9IGRhdGEuYml0cmF0ZTtcblxuICAgIGlmIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIHRoaXMuZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB9XG5cbiAgICB0aGlzLmlkID0gZGF0YS5pZCB8fCAwO1xuICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcbiAgICB0aGlzLndpZHRoID0gZGF0YS53aWR0aCB8fCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gZGF0YS5oZWlnaHQgfHwgMDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBkYXRhLmF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gZGF0YS52aWRlb0NvZGVjO1xuICAgIHRoaXMudW5rbm93bkNvZGVjcyA9IGRhdGEudW5rbm93bkNvZGVjcztcbiAgICB0aGlzLmNvZGVjU2V0ID0gW2RhdGEudmlkZW9Db2RlYywgZGF0YS5hdWRpb0NvZGVjXS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH0pLmpvaW4oJywnKS5yZXBsYWNlKC9cXC5bXi4sXSsvZywgJycpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExldmVsLCBbe1xuICAgIGtleTogXCJtYXhCaXRyYXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5yZWFsQml0cmF0ZSwgdGhpcy5iaXRyYXRlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXJpXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy51cmxbdGhpcy5fdXJsSWRdIHx8ICcnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cmxJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VybElkO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IHZhbHVlICUgdGhpcy51cmwubGVuZ3RoO1xuXG4gICAgICBpZiAodGhpcy5fdXJsSWQgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdXJsSWQgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGV2ZWw7XG59KCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHlwZXMvbG9hZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBQbGF5bGlzdENvbnRleHRUeXBlLCBQbGF5bGlzdExldmVsVHlwZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJQbGF5bGlzdENvbnRleHRUeXBlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUGxheWxpc3RDb250ZXh0VHlwZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUGxheWxpc3RMZXZlbFR5cGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQbGF5bGlzdExldmVsVHlwZTsgfSk7XG52YXIgUGxheWxpc3RDb250ZXh0VHlwZTtcblxuKGZ1bmN0aW9uIChQbGF5bGlzdENvbnRleHRUeXBlKSB7XG4gIFBsYXlsaXN0Q29udGV4dFR5cGVbXCJNQU5JRkVTVFwiXSA9IFwibWFuaWZlc3RcIjtcbiAgUGxheWxpc3RDb250ZXh0VHlwZVtcIkxFVkVMXCJdID0gXCJsZXZlbFwiO1xuICBQbGF5bGlzdENvbnRleHRUeXBlW1wiQVVESU9fVFJBQ0tcIl0gPSBcImF1ZGlvVHJhY2tcIjtcbiAgUGxheWxpc3RDb250ZXh0VHlwZVtcIlNVQlRJVExFX1RSQUNLXCJdID0gXCJzdWJ0aXRsZVRyYWNrXCI7XG59KShQbGF5bGlzdENvbnRleHRUeXBlIHx8IChQbGF5bGlzdENvbnRleHRUeXBlID0ge30pKTtcblxudmFyIFBsYXlsaXN0TGV2ZWxUeXBlO1xuXG4oZnVuY3Rpb24gKFBsYXlsaXN0TGV2ZWxUeXBlKSB7XG4gIFBsYXlsaXN0TGV2ZWxUeXBlW1wiTUFJTlwiXSA9IFwibWFpblwiO1xuICBQbGF5bGlzdExldmVsVHlwZVtcIkFVRElPXCJdID0gXCJhdWRpb1wiO1xuICBQbGF5bGlzdExldmVsVHlwZVtcIlNVQlRJVExFXCJdID0gXCJzdWJ0aXRsZVwiO1xufSkoUGxheWxpc3RMZXZlbFR5cGUgfHwgKFBsYXlsaXN0TGV2ZWxUeXBlID0ge30pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHlwZXMvdHJhbnNtdXhlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3R5cGVzL3RyYW5zbXV4ZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBDaHVua01ldGFkYXRhICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNodW5rTWV0YWRhdGFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDaHVua01ldGFkYXRhOyB9KTtcbnZhciBDaHVua01ldGFkYXRhID0gZnVuY3Rpb24gQ2h1bmtNZXRhZGF0YShsZXZlbCwgc24sIGlkLCBzaXplLCBwYXJ0LCBwYXJ0aWFsKSB7XG4gIGlmIChzaXplID09PSB2b2lkIDApIHtcbiAgICBzaXplID0gMDtcbiAgfVxuXG4gIGlmIChwYXJ0ID09PSB2b2lkIDApIHtcbiAgICBwYXJ0ID0gLTE7XG4gIH1cblxuICBpZiAocGFydGlhbCA9PT0gdm9pZCAwKSB7XG4gICAgcGFydGlhbCA9IGZhbHNlO1xuICB9XG5cbiAgdGhpcy5sZXZlbCA9IHZvaWQgMDtcbiAgdGhpcy5zbiA9IHZvaWQgMDtcbiAgdGhpcy5wYXJ0ID0gdm9pZCAwO1xuICB0aGlzLmlkID0gdm9pZCAwO1xuICB0aGlzLnNpemUgPSB2b2lkIDA7XG4gIHRoaXMucGFydGlhbCA9IHZvaWQgMDtcbiAgdGhpcy50cmFuc211eGluZyA9IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCk7XG4gIHRoaXMuYnVmZmVyaW5nID0ge1xuICAgIGF1ZGlvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpLFxuICAgIHZpZGVvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpLFxuICAgIGF1ZGlvdmlkZW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKClcbiAgfTtcbiAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICB0aGlzLnNuID0gc247XG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5zaXplID0gc2l6ZTtcbiAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgdGhpcy5wYXJ0aWFsID0gcGFydGlhbDtcbn07XG5cbmZ1bmN0aW9uIGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiAwLFxuICAgIGV4ZWN1dGVTdGFydDogMCxcbiAgICBleGVjdXRlRW5kOiAwLFxuICAgIGVuZDogMFxuICB9O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9hdHRyLWxpc3QudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2F0dHItbGlzdC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogQXR0ckxpc3QgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQXR0ckxpc3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBBdHRyTGlzdDsgfSk7XG52YXIgREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYID0gL14oXFxkKyl4KFxcZCspJC87IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcblxudmFyIEFUVFJfTElTVF9SRUdFWCA9IC9cXHMqKC4rPylcXHMqPSgoPzpcXFwiLio/XFxcIil8Lio/KSg/Oix8JCkvZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5vbmdpbC9ub2RlLW0zdThwYXJzZS9ibG9iL21hc3Rlci9hdHRybGlzdC5qc1xuXG52YXIgQXR0ckxpc3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBdHRyTGlzdChhdHRycykge1xuICAgIGlmICh0eXBlb2YgYXR0cnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhdHRycyA9IEF0dHJMaXN0LnBhcnNlQXR0ckxpc3QoYXR0cnMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICB0aGlzW2F0dHJdID0gYXR0cnNbYXR0cl07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90byA9IEF0dHJMaXN0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVjaW1hbEludGVnZXIgPSBmdW5jdGlvbiBkZWNpbWFsSW50ZWdlcihhdHRyTmFtZSkge1xuICAgIHZhciBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxMCk7XG5cbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cblxuICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uaGV4YWRlY2ltYWxJbnRlZ2VyID0gZnVuY3Rpb24gaGV4YWRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lKSB7XG4gICAgaWYgKHRoaXNbYXR0ck5hbWVdKSB7XG4gICAgICB2YXIgc3RyaW5nVmFsdWUgPSAodGhpc1thdHRyTmFtZV0gfHwgJzB4Jykuc2xpY2UoMik7XG4gICAgICBzdHJpbmdWYWx1ZSA9IChzdHJpbmdWYWx1ZS5sZW5ndGggJiAxID8gJzAnIDogJycpICsgc3RyaW5nVmFsdWU7XG4gICAgICB2YXIgdmFsdWUgPSBuZXcgVWludDhBcnJheShzdHJpbmdWYWx1ZS5sZW5ndGggLyAyKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSBwYXJzZUludChzdHJpbmdWYWx1ZS5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaGV4YWRlY2ltYWxJbnRlZ2VyQXNOdW1iZXIgPSBmdW5jdGlvbiBoZXhhZGVjaW1hbEludGVnZXJBc051bWJlcihhdHRyTmFtZSkge1xuICAgIHZhciBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxNik7XG5cbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cblxuICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uZGVjaW1hbEZsb2F0aW5nUG9pbnQgPSBmdW5jdGlvbiBkZWNpbWFsRmxvYXRpbmdQb2ludChhdHRyTmFtZSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXNbYXR0ck5hbWVdKTtcbiAgfTtcblxuICBfcHJvdG8ub3B0aW9uYWxGbG9hdCA9IGZ1bmN0aW9uIG9wdGlvbmFsRmxvYXQoYXR0ck5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXNbYXR0ck5hbWVdO1xuICAgIHJldHVybiB2YWx1ZSA/IHBhcnNlRmxvYXQodmFsdWUpIDogZGVmYXVsdFZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5lbnVtZXJhdGVkU3RyaW5nID0gZnVuY3Rpb24gZW51bWVyYXRlZFN0cmluZyhhdHRyTmFtZSkge1xuICAgIHJldHVybiB0aGlzW2F0dHJOYW1lXTtcbiAgfTtcblxuICBfcHJvdG8uYm9vbCA9IGZ1bmN0aW9uIGJvb2woYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gdGhpc1thdHRyTmFtZV0gPT09ICdZRVMnO1xuICB9O1xuXG4gIF9wcm90by5kZWNpbWFsUmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGRlY2ltYWxSZXNvbHV0aW9uKGF0dHJOYW1lKSB7XG4gICAgdmFyIHJlcyA9IERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWC5leGVjKHRoaXNbYXR0ck5hbWVdKTtcblxuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBwYXJzZUludChyZXNbMV0sIDEwKSxcbiAgICAgIGhlaWdodDogcGFyc2VJbnQocmVzWzJdLCAxMClcbiAgICB9O1xuICB9O1xuXG4gIEF0dHJMaXN0LnBhcnNlQXR0ckxpc3QgPSBmdW5jdGlvbiBwYXJzZUF0dHJMaXN0KGlucHV0KSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIHZhciBhdHRycyA9IHt9O1xuICAgIHZhciBxdW90ZSA9ICdcIic7XG4gICAgQVRUUl9MSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG5cbiAgICB3aGlsZSAoKG1hdGNoID0gQVRUUl9MSVNUX1JFR0VYLmV4ZWMoaW5wdXQpKSAhPT0gbnVsbCkge1xuICAgICAgdmFyIHZhbHVlID0gbWF0Y2hbMl07XG5cbiAgICAgIGlmICh2YWx1ZS5pbmRleE9mKHF1b3RlKSA9PT0gMCAmJiB2YWx1ZS5sYXN0SW5kZXhPZihxdW90ZSkgPT09IHZhbHVlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxLCAtMSk7XG4gICAgICB9XG5cbiAgICAgIGF0dHJzW21hdGNoWzFdXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBhdHRycztcbiAgfTtcblxuICByZXR1cm4gQXR0ckxpc3Q7XG59KCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2JpbmFyeS1zZWFyY2gudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9iaW5hcnktc2VhcmNoLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbnZhciBCaW5hcnlTZWFyY2ggPSB7XG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3IgYW4gaXRlbSBpbiBhbiBhcnJheSB3aGljaCBtYXRjaGVzIGEgY2VydGFpbiBjb25kaXRpb24uXG4gICAqIFRoaXMgcmVxdWlyZXMgdGhlIGNvbmRpdGlvbiB0byBvbmx5IG1hdGNoIG9uZSBpdGVtIGluIHRoZSBhcnJheSxcbiAgICogYW5kIGZvciB0aGUgYXJyYXkgdG8gYmUgb3JkZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxUPn0gbGlzdCBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge0JpbmFyeVNlYXJjaENvbXBhcmlzb248VD59IGNvbXBhcmlzb25GblxuICAgKiAgICAgIENhbGxlZCBhbmQgcHJvdmlkZWQgYSBjYW5kaWRhdGUgaXRlbSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAqICAgICAgU2hvdWxkIHJldHVybjpcbiAgICogICAgICAgICAgPiAtMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGxvd2VyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAqICAgICAgICAgID4gMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGhpZ2hlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgKiAgICAgICAgICA+IDAgaWYgdGhlIGl0ZW0gaXMgdGhlIGl0ZW0geW91J3JlIGxvb2tpbmcgZm9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUIHwgbnVsbH0gVGhlIG9iamVjdCBpZiBpdCBpcyBmb3VuZCBvciBudWxsIG90aGVyd2lzZS5cbiAgICovXG4gIHNlYXJjaDogZnVuY3Rpb24gc2VhcmNoKGxpc3QsIGNvbXBhcmlzb25Gbikge1xuICAgIHZhciBtaW5JbmRleCA9IDA7XG4gICAgdmFyIG1heEluZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgIHZhciBjdXJyZW50SW5kZXggPSBudWxsO1xuICAgIHZhciBjdXJyZW50RWxlbWVudCA9IG51bGw7XG5cbiAgICB3aGlsZSAobWluSW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgIGN1cnJlbnRJbmRleCA9IChtaW5JbmRleCArIG1heEluZGV4KSAvIDIgfCAwO1xuICAgICAgY3VycmVudEVsZW1lbnQgPSBsaXN0W2N1cnJlbnRJbmRleF07XG4gICAgICB2YXIgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmlzb25GbihjdXJyZW50RWxlbWVudCk7XG5cbiAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xuICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICB9IGVsc2UgaWYgKGNvbXBhcmlzb25SZXN1bHQgPCAwKSB7XG4gICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQmluYXJ5U2VhcmNoKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvYnVmZmVyLWhlbHBlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBCdWZmZXJIZWxwZXIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQnVmZmVySGVscGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQnVmZmVySGVscGVyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qKlxuICogQG1vZHVsZSBCdWZmZXJIZWxwZXJcbiAqXG4gKiBQcm92aWRpbmcgbWV0aG9kcyBkZWFsaW5nIHdpdGggYnVmZmVyIGxlbmd0aCByZXRyaWV2YWwgZm9yIGV4YW1wbGUuXG4gKlxuICogSW4gZ2VuZXJhbCwgYSBoZWxwZXIgYXJvdW5kIEhUTUw1IE1lZGlhRWxlbWVudCBUaW1lUmFuZ2VzIGdhdGhlcmVkIGZyb20gYGJ1ZmZlcmVkYCBwcm9wZXJ0eS5cbiAqXG4gKiBBbHNvIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvYnVmZmVyZWRcbiAqL1xuXG52YXIgbm9vcEJ1ZmZlcmVkID0ge1xuICBsZW5ndGg6IDAsXG4gIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgZW5kOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG52YXIgQnVmZmVySGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVySGVscGVyKCkge31cblxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgYG1lZGlhYCdzIGJ1ZmZlcmVkIGluY2x1ZGUgYHBvc2l0aW9uYFxuICAgKiBAcGFyYW0ge0J1ZmZlcmFibGV9IG1lZGlhXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkID0gZnVuY3Rpb24gaXNCdWZmZXJlZChtZWRpYSwgcG9zaXRpb24pIHtcbiAgICB0cnkge1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHZhciBidWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBidWZmZXJlZC5zdGFydChpKSAmJiBwb3NpdGlvbiA8PSBidWZmZXJlZC5lbmQoaSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7Ly8gdGhpcyBpcyB0byBjYXRjaFxuICAgICAgLy8gSW52YWxpZFN0YXRlRXJyb3I6IEZhaWxlZCB0byByZWFkIHRoZSAnYnVmZmVyZWQnIHByb3BlcnR5IGZyb20gJ1NvdXJjZUJ1ZmZlcic6XG4gICAgICAvLyBUaGlzIFNvdXJjZUJ1ZmZlciBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhcmVudCBtZWRpYSBzb3VyY2VcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgQnVmZmVySGVscGVyLmJ1ZmZlckluZm8gPSBmdW5jdGlvbiBidWZmZXJJbmZvKG1lZGlhLCBwb3MsIG1heEhvbGVEdXJhdGlvbikge1xuICAgIHRyeSB7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgdmFyIHZidWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgICAgIHZhciBidWZmZXJlZCA9IFtdO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYnVmZmVyZWQucHVzaCh7XG4gICAgICAgICAgICBzdGFydDogdmJ1ZmZlcmVkLnN0YXJ0KGkpLFxuICAgICAgICAgICAgZW5kOiB2YnVmZmVyZWQuZW5kKGkpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJlZEluZm8oYnVmZmVyZWQsIHBvcywgbWF4SG9sZUR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikgey8vIHRoaXMgaXMgdG8gY2F0Y2hcbiAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxuICAgICAgLy8gVGhpcyBTb3VyY2VCdWZmZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgbWVkaWEgc291cmNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlbjogMCxcbiAgICAgIHN0YXJ0OiBwb3MsXG4gICAgICBlbmQ6IHBvcyxcbiAgICAgIG5leHRTdGFydDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfTtcblxuICBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvID0gZnVuY3Rpb24gYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLCBwb3MsIG1heEhvbGVEdXJhdGlvbikge1xuICAgIHBvcyA9IE1hdGgubWF4KDAsIHBvcyk7IC8vIHNvcnQgb24gYnVmZmVyLnN0YXJ0L3NtYWxsZXIgZW5kIChJRSBkb2VzIG5vdCBhbHdheXMgcmV0dXJuIHNvcnRlZCBidWZmZXJlZCByYW5nZSlcblxuICAgIGJ1ZmZlcmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBkaWZmID0gYS5zdGFydCAtIGIuc3RhcnQ7XG5cbiAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGIuZW5kIC0gYS5lbmQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGJ1ZmZlcmVkMiA9IFtdO1xuXG4gICAgaWYgKG1heEhvbGVEdXJhdGlvbikge1xuICAgICAgLy8gdGhlcmUgbWlnaHQgYmUgc29tZSBzbWFsbCBob2xlcyBiZXR3ZWVuIGJ1ZmZlciB0aW1lIHJhbmdlXG4gICAgICAvLyBjb25zaWRlciB0aGF0IGhvbGVzIHNtYWxsZXIgdGhhbiBtYXhIb2xlRHVyYXRpb24gYXJlIGlycmVsZXZhbnQgYW5kIGJ1aWxkIGFub3RoZXJcbiAgICAgIC8vIGJ1ZmZlciB0aW1lIHJhbmdlIHJlcHJlc2VudGF0aW9ucyB0aGF0IGRpc2NhcmRzIHRob3NlIGhvbGVzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBidWYybGVuID0gYnVmZmVyZWQyLmxlbmd0aDtcblxuICAgICAgICBpZiAoYnVmMmxlbikge1xuICAgICAgICAgIHZhciBidWYyZW5kID0gYnVmZmVyZWQyW2J1ZjJsZW4gLSAxXS5lbmQ7IC8vIGlmIHNtYWxsIGhvbGUgKHZhbHVlIGJldHdlZW4gMCBvciBtYXhIb2xlRHVyYXRpb24gKSBvciBvdmVybGFwcGluZyAobmVnYXRpdmUpXG5cbiAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uc3RhcnQgLSBidWYyZW5kIDwgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBtZXJnZSBvdmVybGFwcGluZyB0aW1lIHJhbmdlc1xuICAgICAgICAgICAgLy8gdXBkYXRlIGxhc3RSYW5nZS5lbmQgb25seSBpZiBzbWFsbGVyIHRoYW4gaXRlbS5lbmRcbiAgICAgICAgICAgIC8vIGUuZy4gIFsgMSwgMTVdIHdpdGggIFsgMiw4XSA9PiBbIDEsMTVdIChubyBuZWVkIHRvIG1vZGlmeSBsYXN0UmFuZ2UuZW5kKVxuICAgICAgICAgICAgLy8gd2hlcmVhcyBbIDEsIDhdIHdpdGggIFsgMiwxNV0gPT4gWyAxLDE1XSAoIGxhc3RSYW5nZSBzaG91bGQgc3dpdGNoIGZyb20gWzEsOF0gdG8gWzEsMTVdKVxuICAgICAgICAgICAgaWYgKGJ1ZmZlcmVkW2ldLmVuZCA+IGJ1ZjJlbmQpIHtcbiAgICAgICAgICAgICAgYnVmZmVyZWQyW2J1ZjJsZW4gLSAxXS5lbmQgPSBidWZmZXJlZFtpXS5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJpZyBob2xlXG4gICAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZpcnN0IHZhbHVlXG4gICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlcmVkMiA9IGJ1ZmZlcmVkO1xuICAgIH1cblxuICAgIHZhciBidWZmZXJMZW4gPSAwOyAvLyBidWZmZXJTdGFydE5leHQgY2FuIHBvc3NpYmx5IGJlIHVuZGVmaW5lZCBiYXNlZCBvbiB0aGUgY29uZGl0aW9uYWwgbG9naWMgYmVsb3dcblxuICAgIHZhciBidWZmZXJTdGFydE5leHQ7IC8vIGJ1ZmZlclN0YXJ0IGFuZCBidWZmZXJFbmQgYXJlIGJ1ZmZlciBib3VuZGFyaWVzIGFyb3VuZCBjdXJyZW50IHZpZGVvIHBvc2l0aW9uXG5cbiAgICB2YXIgYnVmZmVyU3RhcnQgPSBwb3M7XG4gICAgdmFyIGJ1ZmZlckVuZCA9IHBvcztcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBidWZmZXJlZDIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgc3RhcnQgPSBidWZmZXJlZDJbX2ldLnN0YXJ0O1xuICAgICAgdmFyIGVuZCA9IGJ1ZmZlcmVkMltfaV0uZW5kOyAvLyBsb2dnZXIubG9nKCdidWYgc3RhcnQvZW5kOicgKyBidWZmZXJlZC5zdGFydChpKSArICcvJyArIGJ1ZmZlcmVkLmVuZChpKSk7XG5cbiAgICAgIGlmIChwb3MgKyBtYXhIb2xlRHVyYXRpb24gPj0gc3RhcnQgJiYgcG9zIDwgZW5kKSB7XG4gICAgICAgIC8vIHBsYXkgcG9zaXRpb24gaXMgaW5zaWRlIHRoaXMgYnVmZmVyIFRpbWVSYW5nZSwgcmV0cmlldmUgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvbiBhbmQgYnVmZmVyIGxlbmd0aFxuICAgICAgICBidWZmZXJTdGFydCA9IHN0YXJ0O1xuICAgICAgICBidWZmZXJFbmQgPSBlbmQ7XG4gICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckVuZCAtIHBvcztcbiAgICAgIH0gZWxzZSBpZiAocG9zICsgbWF4SG9sZUR1cmF0aW9uIDwgc3RhcnQpIHtcbiAgICAgICAgYnVmZmVyU3RhcnROZXh0ID0gc3RhcnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsZW46IGJ1ZmZlckxlbixcbiAgICAgIHN0YXJ0OiBidWZmZXJTdGFydCB8fCAwLFxuICAgICAgZW5kOiBidWZmZXJFbmQgfHwgMCxcbiAgICAgIG5leHRTdGFydDogYnVmZmVyU3RhcnROZXh0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2FmZSBtZXRob2QgdG8gZ2V0IGJ1ZmZlcmVkIHByb3BlcnR5LlxuICAgKiBTb3VyY2VCdWZmZXIuYnVmZmVyZWQgbWF5IHRocm93IGlmIFNvdXJjZUJ1ZmZlciBpcyByZW1vdmVkIGZyb20gaXQncyBNZWRpYVNvdXJjZVxuICAgKi9cbiAgO1xuXG4gIEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZCA9IGZ1bmN0aW9uIGdldEJ1ZmZlcmVkKG1lZGlhKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtZWRpYS5idWZmZXJlZDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJsb2dnZXJcIl0ubG9nKCdmYWlsZWQgdG8gZ2V0IG1lZGlhLmJ1ZmZlcmVkJywgZSk7XG4gICAgICByZXR1cm4gbm9vcEJ1ZmZlcmVkO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQnVmZmVySGVscGVyO1xufSgpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9jZWEtNjA4LXBhcnNlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9jZWEtNjA4LXBhcnNlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBSb3csIENhcHRpb25TY3JlZW4sIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUm93XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUm93OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDYXB0aW9uU2NyZWVuXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ2FwdGlvblNjcmVlbjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuXG4vKipcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIHBvcnRlZCBmcm9tIHRoZSBkYXNoLmpzIHByb2plY3QgYXQ6XG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvYmxvYi9kZXZlbG9wbWVudC9leHRlcm5hbHMvY2VhNjA4LXBhcnNlci5qc1xuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2NvbW1pdC84MjY5YjI2YTc2MWUwODUzYmIyMWQ3ODc4MGVkOTQ1MTQ0ZWNkZDRkI2RpZmYtNzFiYzI5NWEyZDZiNmI3MDkzYTFkMzI5MGQ1M2E0YjJcbiAqXG4gKiBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IGFwcGVhcnMgYmVsb3c6XG4gKlxuICogVGhlIGNvcHlyaWdodCBpbiB0aGlzIHNvZnR3YXJlIGlzIGJlaW5nIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSBCU0QgTGljZW5zZSxcbiAqIGluY2x1ZGVkIGJlbG93LiBUaGlzIHNvZnR3YXJlIG1heSBiZSBzdWJqZWN0IHRvIG90aGVyIHRoaXJkIHBhcnR5IGFuZCBjb250cmlidXRvclxuICogcmlnaHRzLCBpbmNsdWRpbmcgcGF0ZW50IHJpZ2h0cywgYW5kIG5vIHN1Y2ggcmlnaHRzIGFyZSBncmFudGVkIHVuZGVyIHRoaXMgbGljZW5zZS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiwgREFTSCBJbmR1c3RyeSBGb3J1bS5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vclxuICogIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgMi4gTmVpdGhlciB0aGUgbmFtZSBvZiBEYXNoIEluZHVzdHJ5IEZvcnVtIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICogIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIEFTIElTIEFORCBBTllcbiAqICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELlxuICogIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsXG4gKiAgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVFxuICogIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbiAqICBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiAgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4vKipcbiAqICBFeGNlcHRpb25zIGZyb20gcmVndWxhciBBU0NJSS4gQ29kZVBvaW50cyBhcmUgbWFwcGVkIHRvIFVURi0xNiBjb2Rlc1xuICovXG5cbnZhciBzcGVjaWFsQ2VhNjA4Q2hhcnNDb2RlcyA9IHtcbiAgMHgyYTogMHhlMSxcbiAgLy8gbG93ZXJjYXNlIGEsIGFjdXRlIGFjY2VudFxuICAweDVjOiAweGU5LFxuICAvLyBsb3dlcmNhc2UgZSwgYWN1dGUgYWNjZW50XG4gIDB4NWU6IDB4ZWQsXG4gIC8vIGxvd2VyY2FzZSBpLCBhY3V0ZSBhY2NlbnRcbiAgMHg1ZjogMHhmMyxcbiAgLy8gbG93ZXJjYXNlIG8sIGFjdXRlIGFjY2VudFxuICAweDYwOiAweGZhLFxuICAvLyBsb3dlcmNhc2UgdSwgYWN1dGUgYWNjZW50XG4gIDB4N2I6IDB4ZTcsXG4gIC8vIGxvd2VyY2FzZSBjIHdpdGggY2VkaWxsYVxuICAweDdjOiAweGY3LFxuICAvLyBkaXZpc2lvbiBzeW1ib2xcbiAgMHg3ZDogMHhkMSxcbiAgLy8gdXBwZXJjYXNlIE4gdGlsZGVcbiAgMHg3ZTogMHhmMSxcbiAgLy8gbG93ZXJjYXNlIG4gdGlsZGVcbiAgMHg3ZjogMHgyNTg4LFxuICAvLyBGdWxsIGJsb2NrXG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDE2IEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMSBBTkQgTE9XIEJFVFdFRU4gMHgzMCBBTkQgMHgzRlxuICAvLyBUSElTIE1FQU5TIFRIQVQgXFx4NTAgTVVTVCBCRSBBRERFRCBUTyBUSEUgVkFMVUVTXG4gIDB4ODA6IDB4YWUsXG4gIC8vIFJlZ2lzdGVyZWQgc3ltYm9sIChSKVxuICAweDgxOiAweGIwLFxuICAvLyBkZWdyZWUgc2lnblxuICAweDgyOiAweGJkLFxuICAvLyAxLzIgc3ltYm9sXG4gIDB4ODM6IDB4YmYsXG4gIC8vIEludmVydGVkIChvcGVuKSBxdWVzdGlvbiBtYXJrXG4gIDB4ODQ6IDB4MjEyMixcbiAgLy8gVHJhZGVtYXJrIHN5bWJvbCAoVE0pXG4gIDB4ODU6IDB4YTIsXG4gIC8vIENlbnRzIHN5bWJvbFxuICAweDg2OiAweGEzLFxuICAvLyBQb3VuZHMgc3RlcmxpbmdcbiAgMHg4NzogMHgyNjZhLFxuICAvLyBNdXNpYyA4J3RoIG5vdGVcbiAgMHg4ODogMHhlMCxcbiAgLy8gbG93ZXJjYXNlIGEsIGdyYXZlIGFjY2VudFxuICAweDg5OiAweDIwLFxuICAvLyB0cmFuc3BhcmVudCBzcGFjZSAocmVndWxhcilcbiAgMHg4YTogMHhlOCxcbiAgLy8gbG93ZXJjYXNlIGUsIGdyYXZlIGFjY2VudFxuICAweDhiOiAweGUyLFxuICAvLyBsb3dlcmNhc2UgYSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4YzogMHhlYSxcbiAgLy8gbG93ZXJjYXNlIGUsIGNpcmN1bWZsZXggYWNjZW50XG4gIDB4OGQ6IDB4ZWUsXG4gIC8vIGxvd2VyY2FzZSBpLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhlOiAweGY0LFxuICAvLyBsb3dlcmNhc2UgbywgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4ZjogMHhmYixcbiAgLy8gbG93ZXJjYXNlIHUsIGNpcmN1bWZsZXggYWNjZW50XG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMiBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAweDkwOiAweGMxLFxuICAvLyBjYXBpdGFsIGxldHRlciBBIHdpdGggYWN1dGVcbiAgMHg5MTogMHhjOSxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGFjdXRlXG4gIDB4OTI6IDB4ZDMsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIE8gd2l0aCBhY3V0ZVxuICAweDkzOiAweGRhLFxuICAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggYWN1dGVcbiAgMHg5NDogMHhkYyxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGRpYXJlc2lzXG4gIDB4OTU6IDB4ZmMsXG4gIC8vIGxvd2VyY2FzZSBsZXR0ZXIgVSB3aXRoIGRpYWVyZXNpc1xuICAweDk2OiAweDIwMTgsXG4gIC8vIG9wZW5pbmcgc2luZ2xlIHF1b3RlXG4gIDB4OTc6IDB4YTEsXG4gIC8vIGludmVydGVkIGV4Y2xhbWF0aW9uIG1hcmtcbiAgMHg5ODogMHgyYSxcbiAgLy8gYXN0ZXJpc2tcbiAgMHg5OTogMHgyMDE5LFxuICAvLyBjbG9zaW5nIHNpbmdsZSBxdW90ZVxuICAweDlhOiAweDI1MDEsXG4gIC8vIGJveCBkcmF3aW5ncyBoZWF2eSBob3Jpem9udGFsXG4gIDB4OWI6IDB4YTksXG4gIC8vIGNvcHlyaWdodCBzaWduXG4gIDB4OWM6IDB4MjEyMCxcbiAgLy8gU2VydmljZSBtYXJrXG4gIDB4OWQ6IDB4MjAyMixcbiAgLy8gKHJvdW5kKSBidWxsZXRcbiAgMHg5ZTogMHgyMDFjLFxuICAvLyBMZWZ0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAweDlmOiAweDIwMWQsXG4gIC8vIFJpZ2h0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAweGEwOiAweGMwLFxuICAvLyB1cHBlcmNhc2UgQSwgZ3JhdmUgYWNjZW50XG4gIDB4YTE6IDB4YzIsXG4gIC8vIHVwcGVyY2FzZSBBLCBjaXJjdW1mbGV4XG4gIDB4YTI6IDB4YzcsXG4gIC8vIHVwcGVyY2FzZSBDIHdpdGggY2VkaWxsYVxuICAweGEzOiAweGM4LFxuICAvLyB1cHBlcmNhc2UgRSwgZ3JhdmUgYWNjZW50XG4gIDB4YTQ6IDB4Y2EsXG4gIC8vIHVwcGVyY2FzZSBFLCBjaXJjdW1mbGV4XG4gIDB4YTU6IDB4Y2IsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBkaWFyZXNpc1xuICAweGE2OiAweGViLFxuICAvLyBsb3dlcmNhc2UgbGV0dGVyIGUgd2l0aCBkaWFyZXNpc1xuICAweGE3OiAweGNlLFxuICAvLyB1cHBlcmNhc2UgSSwgY2lyY3VtZmxleFxuICAweGE4OiAweGNmLFxuICAvLyB1cHBlcmNhc2UgSSwgd2l0aCBkaWFyZXNpc1xuICAweGE5OiAweGVmLFxuICAvLyBsb3dlcmNhc2UgaSwgd2l0aCBkaWFyZXNpc1xuICAweGFhOiAweGQ0LFxuICAvLyB1cHBlcmNhc2UgTywgY2lyY3VtZmxleFxuICAweGFiOiAweGQ5LFxuICAvLyB1cHBlcmNhc2UgVSwgZ3JhdmUgYWNjZW50XG4gIDB4YWM6IDB4ZjksXG4gIC8vIGxvd2VyY2FzZSB1LCBncmF2ZSBhY2NlbnRcbiAgMHhhZDogMHhkYixcbiAgLy8gdXBwZXJjYXNlIFUsIGNpcmN1bWZsZXhcbiAgMHhhZTogMHhhYixcbiAgLy8gbGVmdC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgMHhhZjogMHhiYixcbiAgLy8gcmlnaHQtcG9pbnRpbmcgZG91YmxlIGFuZ2xlIHF1b3RhdGlvbiBtYXJrXG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMyBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAweGIwOiAweGMzLFxuICAvLyBVcHBlcmNhc2UgQSwgdGlsZGVcbiAgMHhiMTogMHhlMyxcbiAgLy8gTG93ZXJjYXNlIGEsIHRpbGRlXG4gIDB4YjI6IDB4Y2QsXG4gIC8vIFVwcGVyY2FzZSBJLCBhY3V0ZSBhY2NlbnRcbiAgMHhiMzogMHhjYyxcbiAgLy8gVXBwZXJjYXNlIEksIGdyYXZlIGFjY2VudFxuICAweGI0OiAweGVjLFxuICAvLyBMb3dlcmNhc2UgaSwgZ3JhdmUgYWNjZW50XG4gIDB4YjU6IDB4ZDIsXG4gIC8vIFVwcGVyY2FzZSBPLCBncmF2ZSBhY2NlbnRcbiAgMHhiNjogMHhmMixcbiAgLy8gTG93ZXJjYXNlIG8sIGdyYXZlIGFjY2VudFxuICAweGI3OiAweGQ1LFxuICAvLyBVcHBlcmNhc2UgTywgdGlsZGVcbiAgMHhiODogMHhmNSxcbiAgLy8gTG93ZXJjYXNlIG8sIHRpbGRlXG4gIDB4Yjk6IDB4N2IsXG4gIC8vIE9wZW4gY3VybHkgYnJhY2VcbiAgMHhiYTogMHg3ZCxcbiAgLy8gQ2xvc2luZyBjdXJseSBicmFjZVxuICAweGJiOiAweDVjLFxuICAvLyBCYWNrc2xhc2hcbiAgMHhiYzogMHg1ZSxcbiAgLy8gQ2FyZXRcbiAgMHhiZDogMHg1ZixcbiAgLy8gVW5kZXJzY29yZVxuICAweGJlOiAweDdjLFxuICAvLyBQaXBlICh2ZXJ0aWNhbCBsaW5lKVxuICAweGJmOiAweDIyM2MsXG4gIC8vIFRpbGRlIG9wZXJhdG9yXG4gIDB4YzA6IDB4YzQsXG4gIC8vIFVwcGVyY2FzZSBBLCB1bWxhdXRcbiAgMHhjMTogMHhlNCxcbiAgLy8gTG93ZXJjYXNlIEEsIHVtbGF1dFxuICAweGMyOiAweGQ2LFxuICAvLyBVcHBlcmNhc2UgTywgdW1sYXV0XG4gIDB4YzM6IDB4ZjYsXG4gIC8vIExvd2VyY2FzZSBvLCB1bWxhdXRcbiAgMHhjNDogMHhkZixcbiAgLy8gRXNzemV0dCAoc2hhcnAgUylcbiAgMHhjNTogMHhhNSxcbiAgLy8gWWVuIHN5bWJvbFxuICAweGM2OiAweGE0LFxuICAvLyBHZW5lcmljIGN1cnJlbmN5IHNpZ25cbiAgMHhjNzogMHgyNTAzLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdmVydGljYWxcbiAgMHhjODogMHhjNSxcbiAgLy8gVXBwZXJjYXNlIEEsIHJpbmdcbiAgMHhjOTogMHhlNSxcbiAgLy8gTG93ZXJjYXNlIEEsIHJpbmdcbiAgMHhjYTogMHhkOCxcbiAgLy8gVXBwZXJjYXNlIE8sIHN0cm9rZVxuICAweGNiOiAweGY4LFxuICAvLyBMb3dlcmNhc2Ugbywgc3Ryb2tcbiAgMHhjYzogMHgyNTBmLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgcmlnaHRcbiAgMHhjZDogMHgyNTEzLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgbGVmdFxuICAweGNlOiAweDI1MTcsXG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgcmlnaHRcbiAgMHhjZjogMHgyNTFiIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgbGVmdFxuXG59O1xuLyoqXG4gKiBVdGlsc1xuICovXG5cbnZhciBnZXRDaGFyRm9yQnl0ZSA9IGZ1bmN0aW9uIGdldENoYXJGb3JCeXRlKF9ieXRlKSB7XG4gIHZhciBjaGFyQ29kZSA9IF9ieXRlO1xuXG4gIGlmIChzcGVjaWFsQ2VhNjA4Q2hhcnNDb2Rlcy5oYXNPd25Qcm9wZXJ0eShfYnl0ZSkpIHtcbiAgICBjaGFyQ29kZSA9IHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzW19ieXRlXTtcbiAgfVxuXG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn07XG5cbnZhciBOUl9ST1dTID0gMTU7XG52YXIgTlJfQ09MUyA9IDEwMDsgLy8gVGFibGVzIHRvIGxvb2sgdXAgcm93IGZyb20gUEFDIGRhdGFcblxudmFyIHJvd3NMb3dDaDEgPSB7XG4gIDB4MTE6IDEsXG4gIDB4MTI6IDMsXG4gIDB4MTU6IDUsXG4gIDB4MTY6IDcsXG4gIDB4MTc6IDksXG4gIDB4MTA6IDExLFxuICAweDEzOiAxMixcbiAgMHgxNDogMTRcbn07XG52YXIgcm93c0hpZ2hDaDEgPSB7XG4gIDB4MTE6IDIsXG4gIDB4MTI6IDQsXG4gIDB4MTU6IDYsXG4gIDB4MTY6IDgsXG4gIDB4MTc6IDEwLFxuICAweDEzOiAxMyxcbiAgMHgxNDogMTVcbn07XG52YXIgcm93c0xvd0NoMiA9IHtcbiAgMHgxOTogMSxcbiAgMHgxYTogMyxcbiAgMHgxZDogNSxcbiAgMHgxZTogNyxcbiAgMHgxZjogOSxcbiAgMHgxODogMTEsXG4gIDB4MWI6IDEyLFxuICAweDFjOiAxNFxufTtcbnZhciByb3dzSGlnaENoMiA9IHtcbiAgMHgxOTogMixcbiAgMHgxYTogNCxcbiAgMHgxZDogNixcbiAgMHgxZTogOCxcbiAgMHgxZjogMTAsXG4gIDB4MWI6IDEzLFxuICAweDFjOiAxNVxufTtcbnZhciBiYWNrZ3JvdW5kQ29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ2JsYWNrJywgJ3RyYW5zcGFyZW50J107XG52YXIgVmVyYm9zZUxldmVsO1xuXG4oZnVuY3Rpb24gKFZlcmJvc2VMZXZlbCkge1xuICBWZXJib3NlTGV2ZWxbVmVyYm9zZUxldmVsW1wiRVJST1JcIl0gPSAwXSA9IFwiRVJST1JcIjtcbiAgVmVyYm9zZUxldmVsW1ZlcmJvc2VMZXZlbFtcIlRFWFRcIl0gPSAxXSA9IFwiVEVYVFwiO1xuICBWZXJib3NlTGV2ZWxbVmVyYm9zZUxldmVsW1wiV0FSTklOR1wiXSA9IDJdID0gXCJXQVJOSU5HXCI7XG4gIFZlcmJvc2VMZXZlbFtWZXJib3NlTGV2ZWxbXCJJTkZPXCJdID0gMl0gPSBcIklORk9cIjtcbiAgVmVyYm9zZUxldmVsW1ZlcmJvc2VMZXZlbFtcIkRFQlVHXCJdID0gM10gPSBcIkRFQlVHXCI7XG4gIFZlcmJvc2VMZXZlbFtWZXJib3NlTGV2ZWxbXCJEQVRBXCJdID0gM10gPSBcIkRBVEFcIjtcbn0pKFZlcmJvc2VMZXZlbCB8fCAoVmVyYm9zZUxldmVsID0ge30pKTtcblxudmFyIENhcHRpb25zTG9nZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2FwdGlvbnNMb2dnZXIoKSB7XG4gICAgdGhpcy50aW1lID0gbnVsbDtcbiAgICB0aGlzLnZlcmJvc2VMZXZlbCA9IFZlcmJvc2VMZXZlbC5FUlJPUjtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDYXB0aW9uc0xvZ2dlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmxvZyA9IGZ1bmN0aW9uIGxvZyhzZXZlcml0eSwgbXNnKSB7XG4gICAgaWYgKHRoaXMudmVyYm9zZUxldmVsID49IHNldmVyaXR5KSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJsb2dnZXJcIl0ubG9nKHRoaXMudGltZSArIFwiIFtcIiArIHNldmVyaXR5ICsgXCJdIFwiICsgbXNnKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENhcHRpb25zTG9nZ2VyO1xufSgpO1xuXG52YXIgbnVtQXJyYXlUb0hleEFycmF5ID0gZnVuY3Rpb24gbnVtQXJyYXlUb0hleEFycmF5KG51bUFycmF5KSB7XG4gIHZhciBoZXhBcnJheSA9IFtdO1xuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgbnVtQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICBoZXhBcnJheS5wdXNoKG51bUFycmF5W2pdLnRvU3RyaW5nKDE2KSk7XG4gIH1cblxuICByZXR1cm4gaGV4QXJyYXk7XG59O1xuXG52YXIgUGVuU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQZW5TdGF0ZShmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gdm9pZCAwO1xuICAgIHRoaXMudW5kZXJsaW5lID0gdm9pZCAwO1xuICAgIHRoaXMuaXRhbGljcyA9IHZvaWQgMDtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB2b2lkIDA7XG4gICAgdGhpcy5mbGFzaCA9IHZvaWQgMDtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kIHx8ICd3aGl0ZSc7XG4gICAgdGhpcy51bmRlcmxpbmUgPSB1bmRlcmxpbmUgfHwgZmFsc2U7XG4gICAgdGhpcy5pdGFsaWNzID0gaXRhbGljcyB8fCBmYWxzZTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kIHx8ICdibGFjayc7XG4gICAgdGhpcy5mbGFzaCA9IGZsYXNoIHx8IGZhbHNlO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBQZW5TdGF0ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgdGhpcy51bmRlcmxpbmUgPSBmYWxzZTtcbiAgICB0aGlzLml0YWxpY3MgPSBmYWxzZTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSAnYmxhY2snO1xuICAgIHRoaXMuZmxhc2ggPSBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8yLnNldFN0eWxlcyA9IGZ1bmN0aW9uIHNldFN0eWxlcyhzdHlsZXMpIHtcbiAgICB2YXIgYXR0cmlicyA9IFsnZm9yZWdyb3VuZCcsICd1bmRlcmxpbmUnLCAnaXRhbGljcycsICdiYWNrZ3JvdW5kJywgJ2ZsYXNoJ107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdHlsZSA9IGF0dHJpYnNbaV07XG5cbiAgICAgIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgIHRoaXNbc3R5bGVdID0gc3R5bGVzW3N0eWxlXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvMi5pc0RlZmF1bHQgPSBmdW5jdGlvbiBpc0RlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yZWdyb3VuZCA9PT0gJ3doaXRlJyAmJiAhdGhpcy51bmRlcmxpbmUgJiYgIXRoaXMuaXRhbGljcyAmJiB0aGlzLmJhY2tncm91bmQgPT09ICdibGFjaycgJiYgIXRoaXMuZmxhc2g7XG4gIH07XG5cbiAgX3Byb3RvMi5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JlZ3JvdW5kID09PSBvdGhlci5mb3JlZ3JvdW5kICYmIHRoaXMudW5kZXJsaW5lID09PSBvdGhlci51bmRlcmxpbmUgJiYgdGhpcy5pdGFsaWNzID09PSBvdGhlci5pdGFsaWNzICYmIHRoaXMuYmFja2dyb3VuZCA9PT0gb3RoZXIuYmFja2dyb3VuZCAmJiB0aGlzLmZsYXNoID09PSBvdGhlci5mbGFzaDtcbiAgfTtcblxuICBfcHJvdG8yLmNvcHkgPSBmdW5jdGlvbiBjb3B5KG5ld1BlblN0YXRlKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gbmV3UGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICB0aGlzLnVuZGVybGluZSA9IG5ld1BlblN0YXRlLnVuZGVybGluZTtcbiAgICB0aGlzLml0YWxpY3MgPSBuZXdQZW5TdGF0ZS5pdGFsaWNzO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ld1BlblN0YXRlLmJhY2tncm91bmQ7XG4gICAgdGhpcy5mbGFzaCA9IG5ld1BlblN0YXRlLmZsYXNoO1xuICB9O1xuXG4gIF9wcm90bzIudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ2NvbG9yPScgKyB0aGlzLmZvcmVncm91bmQgKyAnLCB1bmRlcmxpbmU9JyArIHRoaXMudW5kZXJsaW5lICsgJywgaXRhbGljcz0nICsgdGhpcy5pdGFsaWNzICsgJywgYmFja2dyb3VuZD0nICsgdGhpcy5iYWNrZ3JvdW5kICsgJywgZmxhc2g9JyArIHRoaXMuZmxhc2g7XG4gIH07XG5cbiAgcmV0dXJuIFBlblN0YXRlO1xufSgpO1xuLyoqXG4gKiBVbmljb2RlIGNoYXJhY3RlciB3aXRoIHN0eWxpbmcgYW5kIGJhY2tncm91bmQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBTdHlsZWRVbmljb2RlQ2hhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0eWxlZFVuaWNvZGVDaGFyKHVjaGFyLCBmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKSB7XG4gICAgdGhpcy51Y2hhciA9IHZvaWQgMDtcbiAgICB0aGlzLnBlblN0YXRlID0gdm9pZCAwO1xuICAgIHRoaXMudWNoYXIgPSB1Y2hhciB8fCAnICc7IC8vIHVuaWNvZGUgY2hhcmFjdGVyXG5cbiAgICB0aGlzLnBlblN0YXRlID0gbmV3IFBlblN0YXRlKGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpO1xuICB9XG5cbiAgdmFyIF9wcm90bzMgPSBTdHlsZWRVbmljb2RlQ2hhci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMy5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMudWNoYXIgPSAnICc7XG4gICAgdGhpcy5wZW5TdGF0ZS5yZXNldCgpO1xuICB9O1xuXG4gIF9wcm90bzMuc2V0Q2hhciA9IGZ1bmN0aW9uIHNldENoYXIodWNoYXIsIG5ld1BlblN0YXRlKSB7XG4gICAgdGhpcy51Y2hhciA9IHVjaGFyO1xuICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdQZW5TdGF0ZSk7XG4gIH07XG5cbiAgX3Byb3RvMy5zZXRQZW5TdGF0ZSA9IGZ1bmN0aW9uIHNldFBlblN0YXRlKG5ld1BlblN0YXRlKSB7XG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgfTtcblxuICBfcHJvdG8zLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnVjaGFyID09PSBvdGhlci51Y2hhciAmJiB0aGlzLnBlblN0YXRlLmVxdWFscyhvdGhlci5wZW5TdGF0ZSk7XG4gIH07XG5cbiAgX3Byb3RvMy5jb3B5ID0gZnVuY3Rpb24gY29weShuZXdDaGFyKSB7XG4gICAgdGhpcy51Y2hhciA9IG5ld0NoYXIudWNoYXI7XG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld0NoYXIucGVuU3RhdGUpO1xuICB9O1xuXG4gIF9wcm90bzMuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudWNoYXIgPT09ICcgJyAmJiB0aGlzLnBlblN0YXRlLmlzRGVmYXVsdCgpO1xuICB9O1xuXG4gIHJldHVybiBTdHlsZWRVbmljb2RlQ2hhcjtcbn0oKTtcbi8qKlxuICogQ0VBLTYwOCByb3cgY29uc2lzdGluZyBvZiBOUl9DT0xTIGluc3RhbmNlcyBvZiBTdHlsZWRVbmljb2RlQ2hhci5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIFJvdyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJvdyhsb2dnZXIpIHtcbiAgICB0aGlzLmNoYXJzID0gdm9pZCAwO1xuICAgIHRoaXMucG9zID0gdm9pZCAwO1xuICAgIHRoaXMuY3VyclBlblN0YXRlID0gdm9pZCAwO1xuICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdm9pZCAwO1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIHRoaXMuY2hhcnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICB0aGlzLmNoYXJzLnB1c2gobmV3IFN0eWxlZFVuaWNvZGVDaGFyKCkpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmN1cnJQZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZSgpO1xuICB9XG5cbiAgdmFyIF9wcm90bzQgPSBSb3cucHJvdG90eXBlO1xuXG4gIF9wcm90bzQuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgdmFyIGVxdWFsID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uZXF1YWxzKG90aGVyLmNoYXJzW2ldKSkge1xuICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXF1YWw7XG4gIH07XG5cbiAgX3Byb3RvNC5jb3B5ID0gZnVuY3Rpb24gY29weShvdGhlcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICB0aGlzLmNoYXJzW2ldLmNvcHkob3RoZXIuY2hhcnNbaV0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG80LmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgIHZhciBlbXB0eSA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLmNoYXJzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cbiAgLyoqXG4gICAqICBTZXQgdGhlIGN1cnNvciB0byBhIHZhbGlkIGNvbHVtbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG80LnNldEN1cnNvciA9IGZ1bmN0aW9uIHNldEN1cnNvcihhYnNQb3MpIHtcbiAgICBpZiAodGhpcy5wb3MgIT09IGFic1Bvcykge1xuICAgICAgdGhpcy5wb3MgPSBhYnNQb3M7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucG9zIDwgMCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5ERUJVRywgJ05lZ2F0aXZlIGN1cnNvciBwb3NpdGlvbiAnICsgdGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wb3MgPiBOUl9DT0xTKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLkRFQlVHLCAnVG9vIGxhcmdlIGN1cnNvciBwb3NpdGlvbiAnICsgdGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MgPSBOUl9DT0xTO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTW92ZSB0aGUgY3Vyc29yIHJlbGF0aXZlIHRvIGN1cnJlbnQgcG9zaXRpb24uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvNC5tb3ZlQ3Vyc29yID0gZnVuY3Rpb24gbW92ZUN1cnNvcihyZWxQb3MpIHtcbiAgICB2YXIgbmV3UG9zID0gdGhpcy5wb3MgKyByZWxQb3M7XG5cbiAgICBpZiAocmVsUG9zID4gMSkge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMucG9zICsgMTsgaSA8IG5ld1BvcyArIDE7IGkrKykge1xuICAgICAgICB0aGlzLmNoYXJzW2ldLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldEN1cnNvcihuZXdQb3MpO1xuICB9XG4gIC8qKlxuICAgKiBCYWNrc3BhY2UsIG1vdmUgb25lIHN0ZXAgYmFjayBhbmQgY2xlYXIgY2hhcmFjdGVyLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzQuYmFja1NwYWNlID0gZnVuY3Rpb24gYmFja1NwYWNlKCkge1xuICAgIHRoaXMubW92ZUN1cnNvcigtMSk7XG4gICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcignICcsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgfTtcblxuICBfcHJvdG80Lmluc2VydENoYXIgPSBmdW5jdGlvbiBpbnNlcnRDaGFyKF9ieXRlMikge1xuICAgIGlmIChfYnl0ZTIgPj0gMHg5MCkge1xuICAgICAgLy8gRXh0ZW5kZWQgY2hhclxuICAgICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICB9XG5cbiAgICB2YXIgX2NoYXIgPSBnZXRDaGFyRm9yQnl0ZShfYnl0ZTIpO1xuXG4gICAgaWYgKHRoaXMucG9zID49IE5SX0NPTFMpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuRVJST1IsICdDYW5ub3QgaW5zZXJ0ICcgKyBfYnl0ZTIudG9TdHJpbmcoMTYpICsgJyAoJyArIF9jaGFyICsgJykgYXQgcG9zaXRpb24gJyArIHRoaXMucG9zICsgJy4gU2tpcHBpbmcgaXQhJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcihfY2hhciwgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgIHRoaXMubW92ZUN1cnNvcigxKTtcbiAgfTtcblxuICBfcHJvdG80LmNsZWFyRnJvbVBvcyA9IGZ1bmN0aW9uIGNsZWFyRnJvbVBvcyhzdGFydFBvcykge1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gc3RhcnRQb3M7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIHRoaXMuY2hhcnNbaV0ucmVzZXQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvNC5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuY2xlYXJGcm9tUG9zKDApO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmN1cnJQZW5TdGF0ZS5yZXNldCgpO1xuICB9O1xuXG4gIF9wcm90bzQuY2xlYXJUb0VuZE9mUm93ID0gZnVuY3Rpb24gY2xlYXJUb0VuZE9mUm93KCkge1xuICAgIHRoaXMuY2xlYXJGcm9tUG9zKHRoaXMucG9zKTtcbiAgfTtcblxuICBfcHJvdG80LmdldFRleHRTdHJpbmcgPSBmdW5jdGlvbiBnZXRUZXh0U3RyaW5nKCkge1xuICAgIHZhciBjaGFycyA9IFtdO1xuICAgIHZhciBlbXB0eSA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgdmFyIF9jaGFyMiA9IHRoaXMuY2hhcnNbaV0udWNoYXI7XG5cbiAgICAgIGlmIChfY2hhcjIgIT09ICcgJykge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjaGFycy5wdXNoKF9jaGFyMik7XG4gICAgfVxuXG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvNC5zZXRQZW5TdHlsZXMgPSBmdW5jdGlvbiBzZXRQZW5TdHlsZXMoc3R5bGVzKSB7XG4gICAgdGhpcy5jdXJyUGVuU3RhdGUuc2V0U3R5bGVzKHN0eWxlcyk7XG4gICAgdmFyIGN1cnJDaGFyID0gdGhpcy5jaGFyc1t0aGlzLnBvc107XG4gICAgY3VyckNoYXIuc2V0UGVuU3RhdGUodGhpcy5jdXJyUGVuU3RhdGUpO1xuICB9O1xuXG4gIHJldHVybiBSb3c7XG59KCk7XG4vKipcbiAqIEtlZXAgYSBDRUEtNjA4IHNjcmVlbiBvZiAzMngxNSBzdHlsZWQgY2hhcmFjdGVyc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIENhcHRpb25TY3JlZW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYXB0aW9uU2NyZWVuKGxvZ2dlcikge1xuICAgIHRoaXMucm93cyA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJSb3cgPSB2b2lkIDA7XG4gICAgdGhpcy5uclJvbGxVcFJvd3MgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gdm9pZCAwO1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIHRoaXMucm93cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHRoaXMucm93cy5wdXNoKG5ldyBSb3cobG9nZ2VyKSk7XG4gICAgfSAvLyBOb3RlIHRoYXQgd2UgdXNlIHplcm8tYmFzZWQgbnVtYmVyaW5nICgwLTE0KVxuXG5cbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcbiAgICB0aGlzLm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gbnVsbDtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICB2YXIgX3Byb3RvNSA9IENhcHRpb25TY3JlZW4ucHJvdG90eXBlO1xuXG4gIF9wcm90bzUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gIH07XG5cbiAgX3Byb3RvNS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICB2YXIgZXF1YWwgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5yb3dzW2ldLmVxdWFscyhvdGhlci5yb3dzW2ldKSkge1xuICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXF1YWw7XG4gIH07XG5cbiAgX3Byb3RvNS5jb3B5ID0gZnVuY3Rpb24gY29weShvdGhlcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICB0aGlzLnJvd3NbaV0uY29weShvdGhlci5yb3dzW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvNS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICB2YXIgZW1wdHkgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5yb3dzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZW1wdHk7XG4gIH07XG5cbiAgX3Byb3RvNS5iYWNrU3BhY2UgPSBmdW5jdGlvbiBiYWNrU3BhY2UoKSB7XG4gICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5iYWNrU3BhY2UoKTtcbiAgfTtcblxuICBfcHJvdG81LmNsZWFyVG9FbmRPZlJvdyA9IGZ1bmN0aW9uIGNsZWFyVG9FbmRPZlJvdygpIHtcbiAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LmNsZWFyVG9FbmRPZlJvdygpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgYSBjaGFyYWN0ZXIgKHdpdGhvdXQgc3R5bGluZykgaW4gdGhlIGN1cnJlbnQgcm93LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzUuaW5zZXJ0Q2hhciA9IGZ1bmN0aW9uIGluc2VydENoYXIoX2NoYXIzKSB7XG4gICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5pbnNlcnRDaGFyKF9jaGFyMyk7XG4gIH07XG5cbiAgX3Byb3RvNS5zZXRQZW4gPSBmdW5jdGlvbiBzZXRQZW4oc3R5bGVzKSB7XG4gICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5zZXRQZW5TdHlsZXMoc3R5bGVzKTtcbiAgfTtcblxuICBfcHJvdG81Lm1vdmVDdXJzb3IgPSBmdW5jdGlvbiBtb3ZlQ3Vyc29yKHJlbFBvcykge1xuICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cubW92ZUN1cnNvcihyZWxQb3MpO1xuICB9O1xuXG4gIF9wcm90bzUuc2V0Q3Vyc29yID0gZnVuY3Rpb24gc2V0Q3Vyc29yKGFic1Bvcykge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ3NldEN1cnNvcjogJyArIGFic1Bvcyk7XG4gICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5zZXRDdXJzb3IoYWJzUG9zKTtcbiAgfTtcblxuICBfcHJvdG81LnNldFBBQyA9IGZ1bmN0aW9uIHNldFBBQyhwYWNEYXRhKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAncGFjRGF0YSA9ICcgKyBKU09OLnN0cmluZ2lmeShwYWNEYXRhKSk7XG4gICAgdmFyIG5ld1JvdyA9IHBhY0RhdGEucm93IC0gMTtcblxuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiBuZXdSb3cgPCB0aGlzLm5yUm9sbFVwUm93cyAtIDEpIHtcbiAgICAgIG5ld1JvdyA9IHRoaXMubnJSb2xsVXBSb3dzIC0gMTtcbiAgICB9IC8vIE1ha2Ugc3VyZSB0aGlzIG9ubHkgYWZmZWN0cyBSb2xsLXVwIENhcHRpb25zIGJ5IGNoZWNraW5nIHRoaXMubnJSb2xsVXBSb3dzXG5cblxuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiB0aGlzLmN1cnJSb3cgIT09IG5ld1Jvdykge1xuICAgICAgLy8gY2xlYXIgYWxsIHJvd3MgZmlyc3RcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xuICAgICAgfSAvLyBDb3B5IHRoaXMubnJSb2xsVXBSb3dzIHJvd3MgZnJvbSBsYXN0T3V0cHV0U2NyZWVuIGFuZCBwbGFjZSBpdCBpbiB0aGUgbmV3Um93IGxvY2F0aW9uXG4gICAgICAvLyB0b3BSb3dJbmRleCAtIHRoZSBzdGFydCBvZiByb3dzIHRvIGNvcHkgKGluY2x1c2l2ZSBpbmRleClcblxuXG4gICAgICB2YXIgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gdGhpcy5uclJvbGxVcFJvd3M7IC8vIFdlIG9ubHkgY29weSBpZiB0aGUgbGFzdCBwb3NpdGlvbiB3YXMgYWxyZWFkeSBzaG93bi5cbiAgICAgIC8vIFdlIHVzZSB0aGUgY3VlU3RhcnRUaW1lIHZhbHVlIHRvIGNoZWNrIHRoaXMuXG5cbiAgICAgIHZhciBsYXN0T3V0cHV0U2NyZWVuID0gdGhpcy5sYXN0T3V0cHV0U2NyZWVuO1xuXG4gICAgICBpZiAobGFzdE91dHB1dFNjcmVlbikge1xuICAgICAgICB2YXIgcHJldkxpbmVUaW1lID0gbGFzdE91dHB1dFNjcmVlbi5yb3dzW3RvcFJvd0luZGV4XS5jdWVTdGFydFRpbWU7XG4gICAgICAgIHZhciB0aW1lID0gdGhpcy5sb2dnZXIudGltZTtcblxuICAgICAgICBpZiAocHJldkxpbmVUaW1lICYmIHRpbWUgIT09IG51bGwgJiYgcHJldkxpbmVUaW1lIDwgdGltZSkge1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLm5yUm9sbFVwUm93czsgX2krKykge1xuICAgICAgICAgICAgdGhpcy5yb3dzW25ld1JvdyAtIHRoaXMubnJSb2xsVXBSb3dzICsgX2kgKyAxXS5jb3B5KGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleCArIF9pXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyUm93ID0gbmV3Um93O1xuICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcblxuICAgIGlmIChwYWNEYXRhLmluZGVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGluZGVudCA9IHBhY0RhdGEuaW5kZW50O1xuICAgICAgdmFyIHByZXZQb3MgPSBNYXRoLm1heChpbmRlbnQgLSAxLCAwKTtcbiAgICAgIHJvdy5zZXRDdXJzb3IocGFjRGF0YS5pbmRlbnQpO1xuICAgICAgcGFjRGF0YS5jb2xvciA9IHJvdy5jaGFyc1twcmV2UG9zXS5wZW5TdGF0ZS5mb3JlZ3JvdW5kO1xuICAgIH1cblxuICAgIHZhciBzdHlsZXMgPSB7XG4gICAgICBmb3JlZ3JvdW5kOiBwYWNEYXRhLmNvbG9yLFxuICAgICAgdW5kZXJsaW5lOiBwYWNEYXRhLnVuZGVybGluZSxcbiAgICAgIGl0YWxpY3M6IHBhY0RhdGEuaXRhbGljcyxcbiAgICAgIGJhY2tncm91bmQ6ICdibGFjaycsXG4gICAgICBmbGFzaDogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuc2V0UGVuKHN0eWxlcyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBiYWNrZ3JvdW5kL2V4dHJhIGZvcmVncm91bmQsIGJ1dCBmaXJzdCBkbyBiYWNrX3NwYWNlLCBhbmQgdGhlbiBpbnNlcnQgc3BhY2UgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KS5cbiAgICovXG4gIDtcblxuICBfcHJvdG81LnNldEJrZ0RhdGEgPSBmdW5jdGlvbiBzZXRCa2dEYXRhKGJrZ0RhdGEpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdia2dEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KGJrZ0RhdGEpKTtcbiAgICB0aGlzLmJhY2tTcGFjZSgpO1xuICAgIHRoaXMuc2V0UGVuKGJrZ0RhdGEpO1xuICAgIHRoaXMuaW5zZXJ0Q2hhcigweDIwKTsgLy8gU3BhY2VcbiAgfTtcblxuICBfcHJvdG81LnNldFJvbGxVcFJvd3MgPSBmdW5jdGlvbiBzZXRSb2xsVXBSb3dzKG5yUm93cykge1xuICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnJSb3dzO1xuICB9O1xuXG4gIF9wcm90bzUucm9sbFVwID0gZnVuY3Rpb24gcm9sbFVwKCkge1xuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5ERUJVRywgJ3JvbGxfdXAgYnV0IG5yUm9sbFVwUm93cyBub3Qgc2V0IHlldCcpO1xuICAgICAgcmV0dXJuOyAvLyBOb3QgcHJvcGVybHkgc2V0dXBcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLlRFWFQsIHRoaXMuZ2V0RGlzcGxheVRleHQoKSk7XG4gICAgdmFyIHRvcFJvd0luZGV4ID0gdGhpcy5jdXJyUm93ICsgMSAtIHRoaXMubnJSb2xsVXBSb3dzO1xuICAgIHZhciB0b3BSb3cgPSB0aGlzLnJvd3Muc3BsaWNlKHRvcFJvd0luZGV4LCAxKVswXTtcbiAgICB0b3BSb3cuY2xlYXIoKTtcbiAgICB0aGlzLnJvd3Muc3BsaWNlKHRoaXMuY3VyclJvdywgMCwgdG9wUm93KTtcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdSb2xsaW5nIHVwJyk7IC8vIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuVEVYVCwgdGhpcy5nZXRfZGlzcGxheV90ZXh0KCkpXG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbGwgbm9uLWVtcHR5IHJvd3Mgd2l0aCBhcyB1bmljb2RlIHRleHQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvNS5nZXREaXNwbGF5VGV4dCA9IGZ1bmN0aW9uIGdldERpc3BsYXlUZXh0KGFzT25lUm93KSB7XG4gICAgYXNPbmVSb3cgPSBhc09uZVJvdyB8fCBmYWxzZTtcbiAgICB2YXIgZGlzcGxheVRleHQgPSBbXTtcbiAgICB2YXIgdGV4dCA9ICcnO1xuICAgIHZhciByb3dOciA9IC0xO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHZhciByb3dUZXh0ID0gdGhpcy5yb3dzW2ldLmdldFRleHRTdHJpbmcoKTtcblxuICAgICAgaWYgKHJvd1RleHQpIHtcbiAgICAgICAgcm93TnIgPSBpICsgMTtcblxuICAgICAgICBpZiAoYXNPbmVSb3cpIHtcbiAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKCdSb3cgJyArIHJvd05yICsgXCI6ICdcIiArIHJvd1RleHQgKyBcIidcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlzcGxheVRleHQucHVzaChyb3dUZXh0LnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlzcGxheVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgIHRleHQgPSAnWycgKyBkaXNwbGF5VGV4dC5qb2luKCcgfCAnKSArICddJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBkaXNwbGF5VGV4dC5qb2luKCdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcblxuICBfcHJvdG81LmdldFRleHRBbmRGb3JtYXQgPSBmdW5jdGlvbiBnZXRUZXh0QW5kRm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLnJvd3M7XG4gIH07XG5cbiAgcmV0dXJuIENhcHRpb25TY3JlZW47XG59KCk7IC8vIHZhciBtb2RlcyA9IFsnTU9ERV9ST0xMLVVQJywgJ01PREVfUE9QLU9OJywgJ01PREVfUEFJTlQtT04nLCAnTU9ERV9URVhUJ107XG5cbnZhciBDZWE2MDhDaGFubmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2VhNjA4Q2hhbm5lbChjaGFubmVsTnVtYmVyLCBvdXRwdXRGaWx0ZXIsIGxvZ2dlcikge1xuICAgIHRoaXMuY2hOciA9IHZvaWQgMDtcbiAgICB0aGlzLm91dHB1dEZpbHRlciA9IHZvaWQgMDtcbiAgICB0aGlzLm1vZGUgPSB2b2lkIDA7XG4gICAgdGhpcy52ZXJib3NlID0gdm9pZCAwO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gdm9pZCAwO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB2b2lkIDA7XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNoTnIgPSBjaGFubmVsTnVtYmVyO1xuICAgIHRoaXMub3V0cHV0RmlsdGVyID0gb3V0cHV0RmlsdGVyO1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy52ZXJib3NlID0gMDtcbiAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbihsb2dnZXIpO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsOyAvLyBLZWVwcyB0cmFjayBvZiB3aGVyZSBhIGN1ZSBzdGFydGVkLlxuXG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIH1cblxuICB2YXIgX3Byb3RvNiA9IENlYTYwOENoYW5uZWwucHJvdG90eXBlO1xuXG4gIF9wcm90bzYucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4ucmVzZXQoKTtcbiAgICB0aGlzLm91dHB1dEZpbHRlci5yZXNldCgpO1xuICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LnJvd3NbTlJfUk9XUyAtIDFdO1xuICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG82LmdldEhhbmRsZXIgPSBmdW5jdGlvbiBnZXRIYW5kbGVyKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dEZpbHRlcjtcbiAgfTtcblxuICBfcHJvdG82LnNldEhhbmRsZXIgPSBmdW5jdGlvbiBzZXRIYW5kbGVyKG5ld0hhbmRsZXIpIHtcbiAgICB0aGlzLm91dHB1dEZpbHRlciA9IG5ld0hhbmRsZXI7XG4gIH07XG5cbiAgX3Byb3RvNi5zZXRQQUMgPSBmdW5jdGlvbiBzZXRQQUMocGFjRGF0YSkge1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UEFDKHBhY0RhdGEpO1xuICB9O1xuXG4gIF9wcm90bzYuc2V0QmtnRGF0YSA9IGZ1bmN0aW9uIHNldEJrZ0RhdGEoYmtnRGF0YSkge1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgfTtcblxuICBfcHJvdG82LnNldE1vZGUgPSBmdW5jdGlvbiBzZXRNb2RlKG5ld01vZGUpIHtcbiAgICBpZiAobmV3TW9kZSA9PT0gdGhpcy5tb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdNT0RFPScgKyBuZXdNb2RlKTtcblxuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy53cml0ZVNjcmVlbi5yZXNldCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1vZGUgIT09ICdNT0RFX1JPTEwtVVAnKSB7XG4gICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICB9O1xuXG4gIF9wcm90bzYuaW5zZXJ0Q2hhcnMgPSBmdW5jdGlvbiBpbnNlcnRDaGFycyhjaGFycykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4uaW5zZXJ0Q2hhcihjaGFyc1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIHNjcmVlbiA9IHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5ID8gJ0RJU1AnIDogJ05PTl9ESVNQJztcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sIHNjcmVlbiArICc6ICcgKyB0aGlzLndyaXRlU2NyZWVuLmdldERpc3BsYXlUZXh0KHRydWUpKTtcblxuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BBSU5ULU9OJyB8fCB0aGlzLm1vZGUgPT09ICdNT0RFX1JPTEwtVVAnKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLlRFWFQsICdESVNQTEFZRUQ6ICcgKyB0aGlzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCh0cnVlKSk7XG4gICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvNi5jY1JDTCA9IGZ1bmN0aW9uIGNjUkNMKCkge1xuICAgIC8vIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcgKHN3aXRjaCBtb2RlIHRvIFBvcCBPbilcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdSQ0wgLSBSZXN1bWUgQ2FwdGlvbiBMb2FkaW5nJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BPUC1PTicpO1xuICB9O1xuXG4gIF9wcm90bzYuY2NCUyA9IGZ1bmN0aW9uIGNjQlMoKSB7XG4gICAgLy8gQmFja1NwYWNlXG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnQlMgLSBCYWNrU3BhY2UnKTtcblxuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1RFWFQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy53cml0ZVNjcmVlbi5iYWNrU3BhY2UoKTtcblxuICAgIGlmICh0aGlzLndyaXRlU2NyZWVuID09PSB0aGlzLmRpc3BsYXllZE1lbW9yeSkge1xuICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzYuY2NBT0YgPSBmdW5jdGlvbiBjY0FPRigpIHsvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT2ZmKVxuICB9O1xuXG4gIF9wcm90bzYuY2NBT04gPSBmdW5jdGlvbiBjY0FPTigpIHsvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT24pXG4gIH07XG5cbiAgX3Byb3RvNi5jY0RFUiA9IGZ1bmN0aW9uIGNjREVSKCkge1xuICAgIC8vIERlbGV0ZSB0byBFbmQgb2YgUm93XG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnREVSLSBEZWxldGUgdG8gRW5kIG9mIFJvdycpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uY2xlYXJUb0VuZE9mUm93KCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gIH07XG5cbiAgX3Byb3RvNi5jY1JVID0gZnVuY3Rpb24gY2NSVShuclJvd3MpIHtcbiAgICAvLyBSb2xsLVVwIENhcHRpb25zLTIsMyxvciA0IFJvd3NcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdSVSgnICsgbnJSb3dzICsgJykgLSBSb2xsIFVwJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9ST0xMLVVQJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRSb2xsVXBSb3dzKG5yUm93cyk7XG4gIH07XG5cbiAgX3Byb3RvNi5jY0ZPTiA9IGZ1bmN0aW9uIGNjRk9OKCkge1xuICAgIC8vIEZsYXNoIE9uXG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnRk9OIC0gRmxhc2ggT24nKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbih7XG4gICAgICBmbGFzaDogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzYuY2NSREMgPSBmdW5jdGlvbiBjY1JEQygpIHtcbiAgICAvLyBSZXN1bWUgRGlyZWN0IENhcHRpb25pbmcgKHN3aXRjaCBtb2RlIHRvIFBhaW50T24pXG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnUkRDIC0gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BBSU5ULU9OJyk7XG4gIH07XG5cbiAgX3Byb3RvNi5jY1RSID0gZnVuY3Rpb24gY2NUUigpIHtcbiAgICAvLyBUZXh0IFJlc3RhcnQgaW4gdGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ1RSJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcbiAgfTtcblxuICBfcHJvdG82LmNjUlREID0gZnVuY3Rpb24gY2NSVEQoKSB7XG4gICAgLy8gUmVzdW1lIFRleHQgRGlzcGxheSBpbiBUZXh0IG1vZGUgKG5vdCBzdXBwb3J0ZWQsIGhvd2V2ZXIpXG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnUlREJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcbiAgfTtcblxuICBfcHJvdG82LmNjRURNID0gZnVuY3Rpb24gY2NFRE0oKSB7XG4gICAgLy8gRXJhc2UgRGlzcGxheWVkIE1lbW9yeVxuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ0VETSAtIEVyYXNlIERpc3BsYXllZCBNZW1vcnknKTtcbiAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgfTtcblxuICBfcHJvdG82LmNjQ1IgPSBmdW5jdGlvbiBjY0NSKCkge1xuICAgIC8vIENhcnJpYWdlIFJldHVyblxuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ0NSIC0gQ2FycmlhZ2UgUmV0dXJuJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5yb2xsVXAoKTtcbiAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUodHJ1ZSk7XG4gIH07XG5cbiAgX3Byb3RvNi5jY0VOTSA9IGZ1bmN0aW9uIGNjRU5NKCkge1xuICAgIC8vIEVyYXNlIE5vbi1EaXNwbGF5ZWQgTWVtb3J5XG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnRU5NIC0gRXJhc2UgTm9uLWRpc3BsYXllZCBNZW1vcnknKTtcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICB9O1xuXG4gIF9wcm90bzYuY2NFT0MgPSBmdW5jdGlvbiBjY0VPQygpIHtcbiAgICAvLyBFbmQgb2YgQ2FwdGlvbiAoRmxpcCBNZW1vcmllcylcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdFT0MgLSBFbmQgT2YgQ2FwdGlvbicpO1xuXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUE9QLU9OJykge1xuICAgICAgdmFyIHRtcCA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gdG1wO1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5URVhULCAnRElTUDogJyArIHRoaXMuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KCkpO1xuICAgIH1cblxuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgfTtcblxuICBfcHJvdG82LmNjVE8gPSBmdW5jdGlvbiBjY1RPKG5yQ29scykge1xuICAgIC8vIFRhYiBPZmZzZXQgMSwyLCBvciAzIGNvbHVtbnNcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdUTygnICsgbnJDb2xzICsgJykgLSBUYWIgT2Zmc2V0Jyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5tb3ZlQ3Vyc29yKG5yQ29scyk7XG4gIH07XG5cbiAgX3Byb3RvNi5jY01JRFJPVyA9IGZ1bmN0aW9uIGNjTUlEUk9XKHNlY29uZEJ5dGUpIHtcbiAgICAvLyBQYXJzZSBNSURST1cgY29tbWFuZFxuICAgIHZhciBzdHlsZXMgPSB7XG4gICAgICBmbGFzaDogZmFsc2VcbiAgICB9O1xuICAgIHN0eWxlcy51bmRlcmxpbmUgPSBzZWNvbmRCeXRlICUgMiA9PT0gMTtcbiAgICBzdHlsZXMuaXRhbGljcyA9IHNlY29uZEJ5dGUgPj0gMHgyZTtcblxuICAgIGlmICghc3R5bGVzLml0YWxpY3MpIHtcbiAgICAgIHZhciBjb2xvckluZGV4ID0gTWF0aC5mbG9vcihzZWNvbmRCeXRlIC8gMikgLSAweDEwO1xuICAgICAgdmFyIGNvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YSddO1xuICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSBjb2xvcnNbY29sb3JJbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdNSURST1c6ICcgKyBKU09OLnN0cmluZ2lmeShzdHlsZXMpKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbihzdHlsZXMpO1xuICB9O1xuXG4gIF9wcm90bzYub3V0cHV0RGF0YVVwZGF0ZSA9IGZ1bmN0aW9uIG91dHB1dERhdGFVcGRhdGUoZGlzcGF0Y2gpIHtcbiAgICBpZiAoZGlzcGF0Y2ggPT09IHZvaWQgMCkge1xuICAgICAgZGlzcGF0Y2ggPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdGltZSA9IHRoaXMubG9nZ2VyLnRpbWU7XG5cbiAgICBpZiAodGltZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgaWYgKHRoaXMuY3VlU3RhcnRUaW1lID09PSBudWxsICYmICF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHtcbiAgICAgICAgLy8gU3RhcnQgb2YgYSBuZXcgY3VlXG4gICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZXF1YWxzKHRoaXMubGFzdE91dHB1dFNjcmVlbikpIHtcbiAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHRpbWUsIHRoaXMubGFzdE91dHB1dFNjcmVlbik7XG5cbiAgICAgICAgICBpZiAoZGlzcGF0Y2ggJiYgdGhpcy5vdXRwdXRGaWx0ZXIuZGlzcGF0Y2hDdWUpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLmRpc3BhdGNoQ3VlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkgPyBudWxsIDogdGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4uY29weSh0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzYuY3VlU3BsaXRBdFRpbWUgPSBmdW5jdGlvbiBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyKSB7XG4gICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkge1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XG4gICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0LCB0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDZWE2MDhDaGFubmVsO1xufSgpO1xuXG52YXIgQ2VhNjA4UGFyc2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2VhNjA4UGFyc2VyKGZpZWxkLCBvdXQxLCBvdXQyKSB7XG4gICAgdGhpcy5jaGFubmVscyA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJlbnRDaGFubmVsID0gMDtcbiAgICB0aGlzLmNtZEhpc3RvcnkgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgdmFyIGxvZ2dlciA9IG5ldyBDYXB0aW9uc0xvZ2dlcigpO1xuICAgIHRoaXMuY2hhbm5lbHMgPSBbbnVsbCwgbmV3IENlYTYwOENoYW5uZWwoZmllbGQsIG91dDEsIGxvZ2dlciksIG5ldyBDZWE2MDhDaGFubmVsKGZpZWxkICsgMSwgb3V0MiwgbG9nZ2VyKV07XG4gICAgdGhpcy5jbWRIaXN0b3J5ID0gY3JlYXRlQ21kSGlzdG9yeSgpO1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICB9XG5cbiAgdmFyIF9wcm90bzcgPSBDZWE2MDhQYXJzZXIucHJvdG90eXBlO1xuXG4gIF9wcm90bzcuZ2V0SGFuZGxlciA9IGZ1bmN0aW9uIGdldEhhbmRsZXIoY2hhbm5lbCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWxzW2NoYW5uZWxdLmdldEhhbmRsZXIoKTtcbiAgfTtcblxuICBfcHJvdG83LnNldEhhbmRsZXIgPSBmdW5jdGlvbiBzZXRIYW5kbGVyKGNoYW5uZWwsIG5ld0hhbmRsZXIpIHtcbiAgICB0aGlzLmNoYW5uZWxzW2NoYW5uZWxdLnNldEhhbmRsZXIobmV3SGFuZGxlcik7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBkYXRhIGZvciB0aW1lIHQgaW4gZm9ybXMgb2YgbGlzdCBvZiBieXRlcyAodW5zaWduZWQgaW50cykuIFRoZSBieXRlcyBhcmUgdHJlYXRlZCBhcyBwYWlycy5cbiAgICovXG4gIDtcblxuICBfcHJvdG83LmFkZERhdGEgPSBmdW5jdGlvbiBhZGREYXRhKHRpbWUsIGJ5dGVMaXN0KSB7XG4gICAgdmFyIGNtZEZvdW5kO1xuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIHZhciBjaGFyc0ZvdW5kID0gZmFsc2U7XG4gICAgdGhpcy5sb2dnZXIudGltZSA9IHRpbWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVMaXN0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBhID0gYnl0ZUxpc3RbaV0gJiAweDdmO1xuICAgICAgYiA9IGJ5dGVMaXN0W2kgKyAxXSAmIDB4N2Y7XG5cbiAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLkRBVEEsICdbJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2kgKyAxXV0pICsgJ10gLT4gKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJyk7XG4gICAgICB9XG5cbiAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZUNtZChhLCBiKTtcblxuICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VNaWRyb3coYSwgYik7XG4gICAgICB9XG5cbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlUEFDKGEsIGIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzKGEsIGIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNoYXJzRm91bmQgPSB0aGlzLnBhcnNlQ2hhcnMoYSwgYik7XG5cbiAgICAgICAgaWYgKGNoYXJzRm91bmQpIHtcbiAgICAgICAgICB2YXIgY3VyckNoTnIgPSB0aGlzLmN1cnJlbnRDaGFubmVsO1xuXG4gICAgICAgICAgaWYgKGN1cnJDaE5yICYmIGN1cnJDaE5yID4gMCkge1xuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2N1cnJDaE5yXTtcbiAgICAgICAgICAgIGNoYW5uZWwuaW5zZXJ0Q2hhcnMoY2hhcnNGb3VuZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuV0FSTklORywgJ05vIGNoYW5uZWwgZm91bmQgeWV0LiBURVhULU1PREU/Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghY21kRm91bmQgJiYgIWNoYXJzRm91bmQpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5XQVJOSU5HLCBcIkNvdWxkbid0IHBhcnNlIGNsZWFuZWQgZGF0YSBcIiArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyBvcmlnOiAnICsgbnVtQXJyYXlUb0hleEFycmF5KFtieXRlTGlzdFtpXSwgYnl0ZUxpc3RbaSArIDFdXSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGFyc2UgQ29tbWFuZC5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIGEgY29tbWFuZCB3YXMgZm91bmRcbiAgICovXG4gIDtcblxuICBfcHJvdG83LnBhcnNlQ21kID0gZnVuY3Rpb24gcGFyc2VDbWQoYSwgYikge1xuICAgIHZhciBjbWRIaXN0b3J5ID0gdGhpcy5jbWRIaXN0b3J5O1xuICAgIHZhciBjb25kMSA9IChhID09PSAweDE0IHx8IGEgPT09IDB4MWMgfHwgYSA9PT0gMHgxNSB8fCBhID09PSAweDFkKSAmJiBiID49IDB4MjAgJiYgYiA8PSAweDJmO1xuICAgIHZhciBjb25kMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MWYpICYmIGIgPj0gMHgyMSAmJiBiIDw9IDB4MjM7XG5cbiAgICBpZiAoIShjb25kMSB8fCBjb25kMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaGFzQ21kUmVwZWF0ZWQoYSwgYiwgY21kSGlzdG9yeSkpIHtcbiAgICAgIHNldExhc3RDbWQobnVsbCwgbnVsbCwgY21kSGlzdG9yeSk7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLkRFQlVHLCAnUmVwZWF0ZWQgY29tbWFuZCAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJykgaXMgZHJvcHBlZCcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGNoTnIgPSBhID09PSAweDE0IHx8IGEgPT09IDB4MTUgfHwgYSA9PT0gMHgxNyA/IDEgOiAyO1xuICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yXTtcblxuICAgIGlmIChhID09PSAweDE0IHx8IGEgPT09IDB4MTUgfHwgYSA9PT0gMHgxYyB8fCBhID09PSAweDFkKSB7XG4gICAgICBpZiAoYiA9PT0gMHgyMCkge1xuICAgICAgICBjaGFubmVsLmNjUkNMKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjEpIHtcbiAgICAgICAgY2hhbm5lbC5jY0JTKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjIpIHtcbiAgICAgICAgY2hhbm5lbC5jY0FPRigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDIzKSB7XG4gICAgICAgIGNoYW5uZWwuY2NBT04oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNCkge1xuICAgICAgICBjaGFubmVsLmNjREVSKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjUpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JVKDIpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI2KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVSgzKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNykge1xuICAgICAgICBjaGFubmVsLmNjUlUoNCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjgpIHtcbiAgICAgICAgY2hhbm5lbC5jY0ZPTigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI5KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSREMoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyYSkge1xuICAgICAgICBjaGFubmVsLmNjVFIoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyYikge1xuICAgICAgICBjaGFubmVsLmNjUlREKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmMpIHtcbiAgICAgICAgY2hhbm5lbC5jY0VETSgpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJkKSB7XG4gICAgICAgIGNoYW5uZWwuY2NDUigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJlKSB7XG4gICAgICAgIGNoYW5uZWwuY2NFTk0oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyZikge1xuICAgICAgICBjaGFubmVsLmNjRU9DKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGEgPT0gMHgxNyB8fCBhID09IDB4MUZcbiAgICAgIGNoYW5uZWwuY2NUTyhiIC0gMHgyMCk7XG4gICAgfVxuXG4gICAgc2V0TGFzdENtZChhLCBiLCBjbWRIaXN0b3J5KTtcbiAgICB0aGlzLmN1cnJlbnRDaGFubmVsID0gY2hOcjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUGFyc2UgbWlkcm93IHN0eWxpbmcgY29tbWFuZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIDtcblxuICBfcHJvdG83LnBhcnNlTWlkcm93ID0gZnVuY3Rpb24gcGFyc2VNaWRyb3coYSwgYikge1xuICAgIHZhciBjaE5yID0gMDtcblxuICAgIGlmICgoYSA9PT0gMHgxMSB8fCBhID09PSAweDE5KSAmJiBiID49IDB4MjAgJiYgYiA8PSAweDJmKSB7XG4gICAgICBpZiAoYSA9PT0gMHgxMSkge1xuICAgICAgICBjaE5yID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoTnIgPSAyO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hOciAhPT0gdGhpcy5jdXJyZW50Q2hhbm5lbCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLkVSUk9SLCAnTWlzbWF0Y2ggY2hhbm5lbCBpbiBtaWRyb3cgcGFyc2luZycpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yXTtcblxuICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY2hhbm5lbC5jY01JRFJPVyhiKTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuREVCVUcsICdNSURST1cgKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIFByZWFibGUgQWNjZXNzIENvZGVzIChUYWJsZSA1MykuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBQQUMgZm91bmRcbiAgICovXG4gIDtcblxuICBfcHJvdG83LnBhcnNlUEFDID0gZnVuY3Rpb24gcGFyc2VQQUMoYSwgYikge1xuICAgIHZhciByb3c7XG4gICAgdmFyIGNtZEhpc3RvcnkgPSB0aGlzLmNtZEhpc3Rvcnk7XG4gICAgdmFyIGNhc2UxID0gKGEgPj0gMHgxMSAmJiBhIDw9IDB4MTcgfHwgYSA+PSAweDE5ICYmIGEgPD0gMHgxZikgJiYgYiA+PSAweDQwICYmIGIgPD0gMHg3ZjtcbiAgICB2YXIgY2FzZTIgPSAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSAmJiBiID49IDB4NDAgJiYgYiA8PSAweDVmO1xuXG4gICAgaWYgKCEoY2FzZTEgfHwgY2FzZTIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGhhc0NtZFJlcGVhdGVkKGEsIGIsIGNtZEhpc3RvcnkpKSB7XG4gICAgICBzZXRMYXN0Q21kKG51bGwsIG51bGwsIGNtZEhpc3RvcnkpO1xuICAgICAgcmV0dXJuIHRydWU7IC8vIFJlcGVhdGVkIGNvbW1hbmRzIGFyZSBkcm9wcGVkIChvbmNlKVxuICAgIH1cblxuICAgIHZhciBjaE5yID0gYSA8PSAweDE3ID8gMSA6IDI7XG5cbiAgICBpZiAoYiA+PSAweDQwICYmIGIgPD0gMHg1Zikge1xuICAgICAgcm93ID0gY2hOciA9PT0gMSA/IHJvd3NMb3dDaDFbYV0gOiByb3dzTG93Q2gyW2FdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAweDYwIDw9IGIgPD0gMHg3RlxuICAgICAgcm93ID0gY2hOciA9PT0gMSA/IHJvd3NIaWdoQ2gxW2FdIDogcm93c0hpZ2hDaDJbYV07XG4gICAgfVxuXG4gICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnJdO1xuXG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY2hhbm5lbC5zZXRQQUModGhpcy5pbnRlcnByZXRQQUMocm93LCBiKSk7XG4gICAgc2V0TGFzdENtZChhLCBiLCBjbWRIaXN0b3J5KTtcbiAgICB0aGlzLmN1cnJlbnRDaGFubmVsID0gY2hOcjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogSW50ZXJwcmV0IHRoZSBzZWNvbmQgYnl0ZSBvZiB0aGUgcGFjLCBhbmQgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbi5cbiAgICogQHJldHVybnMge09iamVjdH0gcGFjRGF0YSB3aXRoIHN0eWxlIHBhcmFtZXRlcnMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvNy5pbnRlcnByZXRQQUMgPSBmdW5jdGlvbiBpbnRlcnByZXRQQUMocm93LCBfYnl0ZTMpIHtcbiAgICB2YXIgcGFjSW5kZXg7XG4gICAgdmFyIHBhY0RhdGEgPSB7XG4gICAgICBjb2xvcjogbnVsbCxcbiAgICAgIGl0YWxpY3M6IGZhbHNlLFxuICAgICAgaW5kZW50OiBudWxsLFxuICAgICAgdW5kZXJsaW5lOiBmYWxzZSxcbiAgICAgIHJvdzogcm93XG4gICAgfTtcblxuICAgIGlmIChfYnl0ZTMgPiAweDVmKSB7XG4gICAgICBwYWNJbmRleCA9IF9ieXRlMyAtIDB4NjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY0luZGV4ID0gX2J5dGUzIC0gMHg0MDtcbiAgICB9XG5cbiAgICBwYWNEYXRhLnVuZGVybGluZSA9IChwYWNJbmRleCAmIDEpID09PSAxO1xuXG4gICAgaWYgKHBhY0luZGV4IDw9IDB4ZCkge1xuICAgICAgcGFjRGF0YS5jb2xvciA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YScsICd3aGl0ZSddW01hdGguZmxvb3IocGFjSW5kZXggLyAyKV07XG4gICAgfSBlbHNlIGlmIChwYWNJbmRleCA8PSAweGYpIHtcbiAgICAgIHBhY0RhdGEuaXRhbGljcyA9IHRydWU7XG4gICAgICBwYWNEYXRhLmNvbG9yID0gJ3doaXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFjRGF0YS5pbmRlbnQgPSBNYXRoLmZsb29yKChwYWNJbmRleCAtIDB4MTApIC8gMikgKiA0O1xuICAgIH1cblxuICAgIHJldHVybiBwYWNEYXRhOyAvLyBOb3RlIHRoYXQgcm93IGhhcyB6ZXJvIG9mZnNldC4gVGhlIHNwZWMgdXNlcyAxLlxuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBjaGFyYWN0ZXJzLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIDEgdG8gMiBjb2RlcyBjb3JyZXNwb25kaW5nIHRvIGNoYXJzLCBpZiBmb3VuZC4gbnVsbCBvdGhlcndpc2UuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvNy5wYXJzZUNoYXJzID0gZnVuY3Rpb24gcGFyc2VDaGFycyhhLCBiKSB7XG4gICAgdmFyIGNoYW5uZWxOcjtcbiAgICB2YXIgY2hhckNvZGVzID0gbnVsbDtcbiAgICB2YXIgY2hhckNvZGUxID0gbnVsbDtcblxuICAgIGlmIChhID49IDB4MTkpIHtcbiAgICAgIGNoYW5uZWxOciA9IDI7XG4gICAgICBjaGFyQ29kZTEgPSBhIC0gODtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbm5lbE5yID0gMTtcbiAgICAgIGNoYXJDb2RlMSA9IGE7XG4gICAgfVxuXG4gICAgaWYgKGNoYXJDb2RlMSA+PSAweDExICYmIGNoYXJDb2RlMSA8PSAweDEzKSB7XG4gICAgICAvLyBTcGVjaWFsIGNoYXJhY3RlclxuICAgICAgdmFyIG9uZUNvZGU7XG5cbiAgICAgIGlmIChjaGFyQ29kZTEgPT09IDB4MTEpIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDUwO1xuICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZTEgPT09IDB4MTIpIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDcwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDkwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sIFwiU3BlY2lhbCBjaGFyICdcIiArIGdldENoYXJGb3JCeXRlKG9uZUNvZGUpICsgXCInIGluIGNoYW5uZWwgXCIgKyBjaGFubmVsTnIpO1xuICAgICAgY2hhckNvZGVzID0gW29uZUNvZGVdO1xuICAgIH0gZWxzZSBpZiAoYSA+PSAweDIwICYmIGEgPD0gMHg3Zikge1xuICAgICAgY2hhckNvZGVzID0gYiA9PT0gMCA/IFthXSA6IFthLCBiXTtcbiAgICB9XG5cbiAgICBpZiAoY2hhckNvZGVzKSB7XG4gICAgICB2YXIgaGV4Q29kZXMgPSBudW1BcnJheVRvSGV4QXJyYXkoY2hhckNvZGVzKTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuREVCVUcsICdDaGFyIGNvZGVzID0gICcgKyBoZXhDb2Rlcy5qb2luKCcsJykpO1xuICAgICAgc2V0TGFzdENtZChhLCBiLCB0aGlzLmNtZEhpc3RvcnkpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFyQ29kZXM7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGV4dGVuZGVkIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcyB3ZWxsIGFzIG5ldyBmb3JlZ3JvdW5kIGNvbG9yIGJsYWNrLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVGVsbHMgaWYgYmFja2dyb3VuZCBhdHRyaWJ1dGVzIGFyZSBmb3VuZFxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzcucGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyA9IGZ1bmN0aW9uIHBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYikge1xuICAgIHZhciBjYXNlMSA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmIGIgPj0gMHgyMCAmJiBiIDw9IDB4MmY7XG4gICAgdmFyIGNhc2UyID0gKGEgPT09IDB4MTcgfHwgYSA9PT0gMHgxZikgJiYgYiA+PSAweDJkICYmIGIgPD0gMHgyZjtcblxuICAgIGlmICghKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpbmRleDtcbiAgICB2YXIgYmtnRGF0YSA9IHt9O1xuXG4gICAgaWYgKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkge1xuICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChiIC0gMHgyMCkgLyAyKTtcbiAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9IGJhY2tncm91bmRDb2xvcnNbaW5kZXhdO1xuXG4gICAgICBpZiAoYiAlIDIgPT09IDEpIHtcbiAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmtnRGF0YS5iYWNrZ3JvdW5kICsgJ19zZW1pJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJrZ0RhdGEuZm9yZWdyb3VuZCA9ICdibGFjayc7XG5cbiAgICAgIGlmIChiID09PSAweDJmKSB7XG4gICAgICAgIGJrZ0RhdGEudW5kZXJsaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hOciA9IGEgPD0gMHgxNyA/IDEgOiAyO1xuICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yXTtcbiAgICBjaGFubmVsLnNldEJrZ0RhdGEoYmtnRGF0YSk7XG4gICAgc2V0TGFzdENtZChhLCBiLCB0aGlzLmNtZEhpc3RvcnkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldCBzdGF0ZSBvZiBwYXJzZXIgYW5kIGl0cyBjaGFubmVscy5cbiAgICovXG4gIDtcblxuICBfcHJvdG83LnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBPYmplY3Qua2V5cyh0aGlzLmNoYW5uZWxzKS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2ldO1xuXG4gICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICBjaGFubmVsLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jbWRIaXN0b3J5ID0gY3JlYXRlQ21kSGlzdG9yeSgpO1xuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VyIHRoZSBnZW5lcmF0aW9uIG9mIGEgY3VlLCBhbmQgdGhlIHN0YXJ0IG9mIGEgbmV3IG9uZSBpZiBkaXNwbGF5U2NyZWVucyBhcmUgbm90IGVtcHR5LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzcuY3VlU3BsaXRBdFRpbWUgPSBmdW5jdGlvbiBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbaV07XG5cbiAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgIGNoYW5uZWwuY3VlU3BsaXRBdFRpbWUodCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDZWE2MDhQYXJzZXI7XG59KCk7XG5cbmZ1bmN0aW9uIHNldExhc3RDbWQoYSwgYiwgY21kSGlzdG9yeSkge1xuICBjbWRIaXN0b3J5LmEgPSBhO1xuICBjbWRIaXN0b3J5LmIgPSBiO1xufVxuXG5mdW5jdGlvbiBoYXNDbWRSZXBlYXRlZChhLCBiLCBjbWRIaXN0b3J5KSB7XG4gIHJldHVybiBjbWRIaXN0b3J5LmEgPT09IGEgJiYgY21kSGlzdG9yeS5iID09PSBiO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbWRIaXN0b3J5KCkge1xuICByZXR1cm4ge1xuICAgIGE6IG51bGwsXG4gICAgYjogbnVsbFxuICB9O1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENlYTYwOFBhcnNlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2NvZGVjcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvY29kZWNzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBpc0NvZGVjVHlwZSwgaXNDb2RlY1N1cHBvcnRlZEluTXA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzQ29kZWNUeXBlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNDb2RlY1R5cGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzQ29kZWNTdXBwb3J0ZWRJbk1wNFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzQ29kZWNTdXBwb3J0ZWRJbk1wNDsgfSk7XG4vLyBmcm9tIGh0dHA6Ly9tcDRyYS5vcmcvY29kZWNzLmh0bWxcbnZhciBzYW1wbGVFbnRyeUNvZGVzSVNPID0ge1xuICBhdWRpbzoge1xuICAgIGEzZHM6IHRydWUsXG4gICAgJ2FjLTMnOiB0cnVlLFxuICAgICdhYy00JzogdHJ1ZSxcbiAgICBhbGFjOiB0cnVlLFxuICAgIGFsYXc6IHRydWUsXG4gICAgZHJhMTogdHJ1ZSxcbiAgICAnZHRzKyc6IHRydWUsXG4gICAgJ2R0cy0nOiB0cnVlLFxuICAgIGR0c2M6IHRydWUsXG4gICAgZHRzZTogdHJ1ZSxcbiAgICBkdHNoOiB0cnVlLFxuICAgICdlYy0zJzogdHJ1ZSxcbiAgICBlbmNhOiB0cnVlLFxuICAgIGc3MTk6IHRydWUsXG4gICAgZzcyNjogdHJ1ZSxcbiAgICBtNGFlOiB0cnVlLFxuICAgIG1oYTE6IHRydWUsXG4gICAgbWhhMjogdHJ1ZSxcbiAgICBtaG0xOiB0cnVlLFxuICAgIG1obTI6IHRydWUsXG4gICAgbWxwYTogdHJ1ZSxcbiAgICBtcDRhOiB0cnVlLFxuICAgICdyYXcgJzogdHJ1ZSxcbiAgICBPcHVzOiB0cnVlLFxuICAgIHNhbXI6IHRydWUsXG4gICAgc2F3YjogdHJ1ZSxcbiAgICBzYXdwOiB0cnVlLFxuICAgIHNldmM6IHRydWUsXG4gICAgc3FjcDogdHJ1ZSxcbiAgICBzc212OiB0cnVlLFxuICAgIHR3b3M6IHRydWUsXG4gICAgdWxhdzogdHJ1ZVxuICB9LFxuICB2aWRlbzoge1xuICAgIGF2YzE6IHRydWUsXG4gICAgYXZjMjogdHJ1ZSxcbiAgICBhdmMzOiB0cnVlLFxuICAgIGF2YzQ6IHRydWUsXG4gICAgYXZjcDogdHJ1ZSxcbiAgICBhdjAxOiB0cnVlLFxuICAgIGRyYWM6IHRydWUsXG4gICAgZHZhdjogdHJ1ZSxcbiAgICBkdmhlOiB0cnVlLFxuICAgIGVuY3Y6IHRydWUsXG4gICAgaGV2MTogdHJ1ZSxcbiAgICBodmMxOiB0cnVlLFxuICAgIG1qcDI6IHRydWUsXG4gICAgbXA0djogdHJ1ZSxcbiAgICBtdmMxOiB0cnVlLFxuICAgIG12YzI6IHRydWUsXG4gICAgbXZjMzogdHJ1ZSxcbiAgICBtdmM0OiB0cnVlLFxuICAgIHJlc3Y6IHRydWUsXG4gICAgcnY2MDogdHJ1ZSxcbiAgICBzMjYzOiB0cnVlLFxuICAgIHN2YzE6IHRydWUsXG4gICAgc3ZjMjogdHJ1ZSxcbiAgICAndmMtMSc6IHRydWUsXG4gICAgdnAwODogdHJ1ZSxcbiAgICB2cDA5OiB0cnVlXG4gIH0sXG4gIHRleHQ6IHtcbiAgICBzdHBwOiB0cnVlLFxuICAgIHd2dHQ6IHRydWVcbiAgfVxufTtcbmZ1bmN0aW9uIGlzQ29kZWNUeXBlKGNvZGVjLCB0eXBlKSB7XG4gIHZhciB0eXBlQ29kZXMgPSBzYW1wbGVFbnRyeUNvZGVzSVNPW3R5cGVdO1xuICByZXR1cm4gISF0eXBlQ29kZXMgJiYgdHlwZUNvZGVzW2NvZGVjLnNsaWNlKDAsIDQpXSA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzQ29kZWNTdXBwb3J0ZWRJbk1wNChjb2RlYywgdHlwZSkge1xuICByZXR1cm4gTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCh0eXBlIHx8ICd2aWRlbycpICsgXCIvbXA0O2NvZGVjcz1cXFwiXCIgKyBjb2RlYyArIFwiXFxcIlwiKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvY3Vlcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2N1ZXMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF92dHRwYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdnR0cGFyc2VyICovIFwiLi9zcmMvdXRpbHMvdnR0cGFyc2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF93ZWJ2dHRfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3dlYnZ0dC1wYXJzZXIgKi8gXCIuL3NyYy91dGlscy93ZWJ2dHQtcGFyc2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGV4dHRyYWNrLXV0aWxzICovIFwiLi9zcmMvdXRpbHMvdGV4dHRyYWNrLXV0aWxzLnRzXCIpO1xuXG5cblxudmFyIFdISVRFU1BBQ0VfQ0hBUiA9IC9cXHMvO1xudmFyIEN1ZXMgPSB7XG4gIG5ld0N1ZTogZnVuY3Rpb24gbmV3Q3VlKHRyYWNrLCBzdGFydFRpbWUsIGVuZFRpbWUsIGNhcHRpb25TY3JlZW4pIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHJvdzsgLy8gdGhlIHR5cGUgZGF0YSBzdGF0ZXMgdGhpcyBpcyBWVFRDdWUsIGJ1dCBpdCBjYW4gcG90ZW50aWFsbHkgYmUgYSBUZXh0VHJhY2tDdWUgb24gb2xkIGJyb3dzZXJzXG5cbiAgICB2YXIgY3VlO1xuICAgIHZhciBpbmRlbnRpbmc7XG4gICAgdmFyIGluZGVudDtcbiAgICB2YXIgdGV4dDtcbiAgICB2YXIgQ3VlID0gc2VsZi5WVFRDdWUgfHwgc2VsZi5UZXh0VHJhY2tDdWU7XG5cbiAgICBmb3IgKHZhciByID0gMDsgciA8IGNhcHRpb25TY3JlZW4ucm93cy5sZW5ndGg7IHIrKykge1xuICAgICAgcm93ID0gY2FwdGlvblNjcmVlbi5yb3dzW3JdO1xuICAgICAgaW5kZW50aW5nID0gdHJ1ZTtcbiAgICAgIGluZGVudCA9IDA7XG4gICAgICB0ZXh0ID0gJyc7XG5cbiAgICAgIGlmICghcm93LmlzRW1wdHkoKSkge1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHJvdy5jaGFycy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgIGlmIChXSElURVNQQUNFX0NIQVIudGVzdChyb3cuY2hhcnNbY10udWNoYXIpICYmIGluZGVudGluZykge1xuICAgICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHQgKz0gcm93LmNoYXJzW2NdLnVjaGFyO1xuICAgICAgICAgICAgaW5kZW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRvIGJlIHVzZWQgZm9yIGNsZWFuaW5nLXVwIG9ycGhhbmVkIHJvbGwtdXAgY2FwdGlvbnNcblxuXG4gICAgICAgIHJvdy5jdWVTdGFydFRpbWUgPSBzdGFydFRpbWU7IC8vIEdpdmUgYSBzbGlnaHQgYnVtcCB0byB0aGUgZW5kVGltZSBpZiBpdCdzIGVxdWFsIHRvIHN0YXJ0VGltZSB0byBhdm9pZCBhIFN5bnRheEVycm9yIGluIElFXG5cbiAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gZW5kVGltZSkge1xuICAgICAgICAgIGVuZFRpbWUgKz0gMC4wMDAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGVudCA+PSAxNikge1xuICAgICAgICAgIGluZGVudC0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1ZVRleHQgPSBPYmplY3QoX3Z0dHBhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZml4TGluZUJyZWFrc1wiXSkodGV4dC50cmltKCkpO1xuICAgICAgICB2YXIgaWQgPSBPYmplY3QoX3dlYnZ0dF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdlbmVyYXRlQ3VlSWRcIl0pKHN0YXJ0VGltZSwgZW5kVGltZSwgY3VlVGV4dCk7IC8vIElmIHRoaXMgY3VlIGFscmVhZHkgZXhpc3RzIGluIHRoZSB0cmFjayBkbyBub3QgcHVzaCBpdFxuXG4gICAgICAgIGlmICghdHJhY2sgfHwgIXRyYWNrLmN1ZXMgfHwgIXRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChpZCkpIHtcbiAgICAgICAgICBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgY3VlVGV4dCk7XG4gICAgICAgICAgY3VlLmlkID0gaWQ7XG4gICAgICAgICAgY3VlLmxpbmUgPSByICsgMTtcbiAgICAgICAgICBjdWUuYWxpZ24gPSAnbGVmdCc7IC8vIENsYW1wIHRoZSBwb3NpdGlvbiBiZXR3ZWVuIDEwIGFuZCA4MCBwZXJjZW50IChDRUEtNjA4IFBBQyBpbmRlbnQgY29kZSlcbiAgICAgICAgICAvLyBodHRwczovL2R2Y3MudzMub3JnL2hnL3RleHQtdHJhY2tzL3Jhdy1maWxlL2RlZmF1bHQvNjA4dG9WVFQvNjA4dG9WVFQuaHRtbCNwb3NpdGlvbmluZy1pbi1jZWEtNjA4XG4gICAgICAgICAgLy8gRmlyZWZveCB0aHJvd3MgYW4gZXhjZXB0aW9uIGFuZCBjYXB0aW9ucyBicmVhayB3aXRoIG91dCBvZiBib3VuZHMgMC0xMDAgdmFsdWVzXG5cbiAgICAgICAgICBjdWUucG9zaXRpb24gPSAxMCArIE1hdGgubWluKDgwLCBNYXRoLmZsb29yKGluZGVudCAqIDggLyAzMikgKiAxMCk7XG4gICAgICAgICAgcmVzdWx0LnB1c2goY3VlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0cmFjayAmJiByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAvLyBTb3J0IGJvdHRvbSBjdWVzIGluIHJldmVyc2Ugb3JkZXIgc28gdGhhdCB0aGV5IHJlbmRlciBpbiBsaW5lIG9yZGVyIHdoZW4gb3ZlcmxhcHBpbmcgaW4gQ2hyb21lXG4gICAgICByZXN1bHQuc29ydChmdW5jdGlvbiAoY3VlQSwgY3VlQikge1xuICAgICAgICBpZiAoY3VlQS5saW5lID09PSAnYXV0bycgfHwgY3VlQi5saW5lID09PSAnYXV0bycpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdWVBLmxpbmUgPiA4ICYmIGN1ZUIubGluZSA+IDgpIHtcbiAgICAgICAgICByZXR1cm4gY3VlQi5saW5lIC0gY3VlQS5saW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1ZUEubGluZSAtIGN1ZUIubGluZTtcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0KF90ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImFkZEN1ZVRvVHJhY2tcIl0pKHRyYWNrLCBjdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ3Vlcyk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2Rpc2NvbnRpbnVpdGllcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvZGlzY29udGludWl0aWVzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBmaW5kRmlyc3RGcmFnV2l0aENDLCBzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzLCBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWcsIGFkanVzdFNsaWRpbmdTdGFydCwgYWxpZ25TdHJlYW0sIGFsaWduUERULCBhbGlnbkZyYWdtZW50QnlQRFREZWx0YSwgYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZmluZEZpcnN0RnJhZ1dpdGhDQ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZpbmRGaXJzdEZyYWdXaXRoQ0M7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFkanVzdFNsaWRpbmdTdGFydFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFkanVzdFNsaWRpbmdTdGFydDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWxpZ25TdHJlYW1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhbGlnblN0cmVhbTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWxpZ25QRFRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhbGlnblBEVDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWxpZ25GcmFnbWVudEJ5UERURGVsdGFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhbGlnbkZyYWdtZW50QnlQRFREZWx0YTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhbGlnbk1lZGlhUGxheWxpc3RCeVBEVDsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnRyb2xsZXJfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9jb250cm9sbGVyL2xldmVsLWhlbHBlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLnRzXCIpO1xuXG5cblxuXG5mdW5jdGlvbiBmaW5kRmlyc3RGcmFnV2l0aENDKGZyYWdtZW50cywgY2MpIHtcbiAgdmFyIGZpcnN0RnJhZyA9IG51bGw7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZyYWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjdXJyZW50RnJhZyA9IGZyYWdtZW50c1tpXTtcblxuICAgIGlmIChjdXJyZW50RnJhZyAmJiBjdXJyZW50RnJhZy5jYyA9PT0gY2MpIHtcbiAgICAgIGZpcnN0RnJhZyA9IGN1cnJlbnRGcmFnO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpcnN0RnJhZztcbn1cbmZ1bmN0aW9uIHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMobGFzdEZyYWcsIGxhc3RMZXZlbCwgZGV0YWlscykge1xuICBpZiAobGFzdExldmVsLmRldGFpbHMpIHtcbiAgICBpZiAoZGV0YWlscy5lbmRDQyA+IGRldGFpbHMuc3RhcnRDQyB8fCBsYXN0RnJhZyAmJiBsYXN0RnJhZy5jYyA8IGRldGFpbHMuc3RhcnRDQykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBGaW5kIHRoZSBmaXJzdCBmcmFnIGluIHRoZSBwcmV2aW91cyBsZXZlbCB3aGljaCBtYXRjaGVzIHRoZSBDQyBvZiB0aGUgZmlyc3QgZnJhZyBvZiB0aGUgbmV3IGxldmVsXG5cbmZ1bmN0aW9uIGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyhwcmV2RGV0YWlscywgY3VyRGV0YWlscykge1xuICB2YXIgcHJldkZyYWdzID0gcHJldkRldGFpbHMuZnJhZ21lbnRzO1xuICB2YXIgY3VyRnJhZ3MgPSBjdXJEZXRhaWxzLmZyYWdtZW50cztcblxuICBpZiAoIWN1ckZyYWdzLmxlbmd0aCB8fCAhcHJldkZyYWdzLmxlbmd0aCkge1xuICAgIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImxvZ2dlclwiXS5sb2coJ05vIGZyYWdtZW50cyB0byBhbGlnbicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwcmV2U3RhcnRGcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhwcmV2RnJhZ3MsIGN1ckZyYWdzWzBdLmNjKTtcblxuICBpZiAoIXByZXZTdGFydEZyYWcgfHwgcHJldlN0YXJ0RnJhZyAmJiAhcHJldlN0YXJ0RnJhZy5zdGFydFBUUykge1xuICAgIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImxvZ2dlclwiXS5sb2coJ05vIGZyYWcgaW4gcHJldmlvdXMgbGV2ZWwgdG8gYWxpZ24gb24nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gcHJldlN0YXJ0RnJhZztcbn1cblxuZnVuY3Rpb24gYWRqdXN0RnJhZ21lbnRTdGFydChmcmFnLCBzbGlkaW5nKSB7XG4gIGlmIChmcmFnKSB7XG4gICAgdmFyIHN0YXJ0ID0gZnJhZy5zdGFydCArIHNsaWRpbmc7XG4gICAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydDtcbiAgICBmcmFnLmVuZFBUUyA9IHN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGp1c3RTbGlkaW5nU3RhcnQoc2xpZGluZywgZGV0YWlscykge1xuICAvLyBVcGRhdGUgc2VnbWVudHNcbiAgdmFyIGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmcmFnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhZGp1c3RGcmFnbWVudFN0YXJ0KGZyYWdtZW50c1tpXSwgc2xpZGluZyk7XG4gIH0gLy8gVXBkYXRlIExMLUhMUyBwYXJ0cyBhdCB0aGUgZW5kIG9mIHRoZSBwbGF5bGlzdFxuXG5cbiAgaWYgKGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgYWRqdXN0RnJhZ21lbnRTdGFydChkZXRhaWxzLmZyYWdtZW50SGludCwgc2xpZGluZyk7XG4gIH1cblxuICBkZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbn1cbi8qKlxuICogVXNpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGxhc3QgbGV2ZWwsIHRoaXMgZnVuY3Rpb24gY29tcHV0ZXMgUFRTJyBvZiB0aGUgbmV3IGZyYWdtZW50cyBzbyB0aGF0IHRoZXkgZm9ybSBhXG4gKiBjb250aWd1b3VzIHN0cmVhbSB3aXRoIHRoZSBsYXN0IGZyYWdtZW50cy5cbiAqIFRoZSBQVFMgb2YgYSBmcmFnbWVudCBsZXRzIEhscy5qcyBrbm93IHdoZXJlIGl0IGZpdHMgaW50byBhIHN0cmVhbSAtIGJ5IGtub3dpbmcgZXZlcnkgUFRTLCB3ZSBrbm93IHdoaWNoIGZyYWdtZW50IHRvXG4gKiBkb3dubG9hZCBhdCBhbnkgZ2l2ZW4gdGltZS4gUFRTIGlzIG5vcm1hbGx5IGNvbXB1dGVkIHdoZW4gdGhlIGZyYWdtZW50IGlzIGRlbXV4ZWQsIHNvIHRha2luZyB0aGlzIHN0ZXAgc2F2ZXMgdXMgdGltZVxuICogYW5kIGFuIGV4dHJhIGRvd25sb2FkLlxuICogQHBhcmFtIGxhc3RGcmFnXG4gKiBAcGFyYW0gbGFzdExldmVsXG4gKiBAcGFyYW0gZGV0YWlsc1xuICovXG5cbmZ1bmN0aW9uIGFsaWduU3RyZWFtKGxhc3RGcmFnLCBsYXN0TGV2ZWwsIGRldGFpbHMpIHtcbiAgaWYgKCFsYXN0TGV2ZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhbGlnbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgZGV0YWlscywgbGFzdExldmVsKTtcblxuICBpZiAoIWRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiYgbGFzdExldmVsLmRldGFpbHMpIHtcbiAgICAvLyBJZiB0aGUgUFRTIHdhc24ndCBmaWd1cmVkIG91dCB2aWEgZGlzY29udGludWl0eSBzZXF1ZW5jZSB0aGF0IG1lYW5zIHRoZXJlIHdhcyBubyBDQyBpbmNyZWFzZSB3aXRoaW4gdGhlIGxldmVsLlxuICAgIC8vIEFsaWduaW5nIHZpYSBQcm9ncmFtIERhdGUgVGltZSBzaG91bGQgdGhlcmVmb3JlIGJlIHJlbGlhYmxlLCBzaW5jZSBQRFQgc2hvdWxkIGJlIHRoZSBzYW1lIHdpdGhpbiB0aGUgc2FtZVxuICAgIC8vIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UuXG4gICAgYWxpZ25QRFQoZGV0YWlscywgbGFzdExldmVsLmRldGFpbHMpO1xuICB9XG5cbiAgaWYgKCFkZXRhaWxzLmFsaWduZWRTbGlkaW5nICYmIGxhc3RMZXZlbC5kZXRhaWxzICYmICFkZXRhaWxzLnNraXBwZWRTZWdtZW50cykge1xuICAgIC8vIFRyeSB0byBhbGlnbiBvbiBzbiBzbyB0aGF0IHdlIHBpY2sgYSBiZXR0ZXIgc3RhcnQgZnJhZ21lbnQuXG4gICAgLy8gRG8gbm90IHBlcmZvcm0gdGhpcyBvbiBwbGF5bGlzdHMgd2l0aCBkZWx0YSB1cGRhdGVzIGFzIHRoaXMgaXMgb25seSB0byBhbGlnbiBsZXZlbHMgb24gc3dpdGNoXG4gICAgLy8gYW5kIGFkanVzdFNsaWRpbmcgb25seSBhZGp1c3RzIGZyYWdtZW50cyBhZnRlciBza2lwcGVkU2VnbWVudHMuXG4gICAgT2JqZWN0KF9jb250cm9sbGVyX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiYWRqdXN0U2xpZGluZ1wiXSkobGFzdExldmVsLmRldGFpbHMsIGRldGFpbHMpO1xuICB9XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBQVFMgaWYgYSBuZXcgbGV2ZWwncyBmcmFnbWVudHMgdXNpbmcgdGhlIFBUUyBvZiBhIGZyYWdtZW50IGluIHRoZSBsYXN0IGxldmVsIHdoaWNoIHNoYXJlcyB0aGUgc2FtZVxuICogZGlzY29udGludWl0eSBzZXF1ZW5jZS5cbiAqIEBwYXJhbSBsYXN0RnJhZyAtIFRoZSBsYXN0IEZyYWdtZW50IHdoaWNoIHNoYXJlcyB0aGUgc2FtZSBkaXNjb250aW51aXR5IHNlcXVlbmNlXG4gKiBAcGFyYW0gbGFzdExldmVsIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBuZXcgbGV2ZWxcbiAqL1xuXG5mdW5jdGlvbiBhbGlnbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgZGV0YWlscywgbGFzdExldmVsKSB7XG4gIGlmIChzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBsYXN0TGV2ZWwsIGRldGFpbHMpKSB7XG4gICAgdmFyIHJlZmVyZW5jZUZyYWcgPSBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWcobGFzdExldmVsLmRldGFpbHMsIGRldGFpbHMpO1xuXG4gICAgaWYgKHJlZmVyZW5jZUZyYWcgJiYgT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShyZWZlcmVuY2VGcmFnLnN0YXJ0KSkge1xuICAgICAgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wibG9nZ2VyXCJdLmxvZyhcIkFkanVzdGluZyBQVFMgdXNpbmcgbGFzdCBsZXZlbCBkdWUgdG8gQ0MgaW5jcmVhc2Ugd2l0aGluIGN1cnJlbnQgbGV2ZWwgXCIgKyBkZXRhaWxzLnVybCk7XG4gICAgICBhZGp1c3RTbGlkaW5nU3RhcnQocmVmZXJlbmNlRnJhZy5zdGFydCwgZGV0YWlscyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBQVFMgb2YgYSBuZXcgbGV2ZWwncyBmcmFnbWVudHMgdXNpbmcgdGhlIGRpZmZlcmVuY2UgaW4gUHJvZ3JhbSBEYXRlIFRpbWUgZnJvbSB0aGUgbGFzdCBsZXZlbC5cbiAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIG5ldyBsZXZlbFxuICogQHBhcmFtIGxhc3REZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXG4gKi9cblxuXG5mdW5jdGlvbiBhbGlnblBEVChkZXRhaWxzLCBsYXN0RGV0YWlscykge1xuICAvLyBUaGlzIGNoZWNrIHByb3RlY3RzIHRoZSB1bnNhZmUgXCIhXCIgdXNhZ2UgYmVsb3cgZm9yIG51bGwgcHJvZ3JhbSBkYXRlIHRpbWUgYWNjZXNzLlxuICBpZiAoIWxhc3REZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggfHwgIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICFsYXN0RGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gaWYgbGFzdCBsZXZlbCBzbGlkaW5nIGlzIDEwMDAgYW5kIGl0cyBmaXJzdCBmcmFnIFBST0dSQU0tREFURS1USU1FIGlzIDIwMTctMDgtMjAgMToxMDowMCBBTVxuICAvLyBhbmQgaWYgbmV3IGRldGFpbHMgZmlyc3QgZnJhZyBQUk9HUkFNIERBVEUtVElNRSBpcyAyMDE3LTA4LTIwIDE6MTA6MDggQU1cbiAgLy8gdGhlbiB3ZSBjYW4gZGVkdWNlIHRoYXQgcGxheWxpc3QgQiBzbGlkaW5nIGlzIDEwMDArOCA9IDEwMDhzXG5cblxuICB2YXIgbGFzdFBEVCA9IGxhc3REZXRhaWxzLmZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7IC8vIGhhc1Byb2dyYW1EYXRlVGltZSBjaGVjayBhYm92ZSBtYWtlcyB0aGlzIHNhZmUuXG5cbiAgdmFyIG5ld1BEVCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZTsgLy8gZGF0ZSBkaWZmIGlzIGluIG1zLiBmcmFnLnN0YXJ0IGlzIGluIHNlY29uZHNcblxuICB2YXIgc2xpZGluZyA9IChuZXdQRFQgLSBsYXN0UERUKSAvIDEwMDAgKyBsYXN0RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG5cbiAgaWYgKHNsaWRpbmcgJiYgT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShzbGlkaW5nKSkge1xuICAgIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImxvZ2dlclwiXS5sb2coXCJBZGp1c3RpbmcgUFRTIHVzaW5nIHByb2dyYW1EYXRlVGltZSBkZWx0YSBcIiArIChuZXdQRFQgLSBsYXN0UERUKSArIFwibXMsIHNsaWRpbmc6XCIgKyBzbGlkaW5nLnRvRml4ZWQoMykgKyBcIiBcIiArIGRldGFpbHMudXJsICsgXCIgXCIpO1xuICAgIGFkanVzdFNsaWRpbmdTdGFydChzbGlkaW5nLCBkZXRhaWxzKTtcbiAgfVxufVxuZnVuY3Rpb24gYWxpZ25GcmFnbWVudEJ5UERURGVsdGEoZnJhZywgZGVsdGEpIHtcbiAgdmFyIHByb2dyYW1EYXRlVGltZSA9IGZyYWcucHJvZ3JhbURhdGVUaW1lO1xuICBpZiAoIXByb2dyYW1EYXRlVGltZSkgcmV0dXJuO1xuICB2YXIgc3RhcnQgPSAocHJvZ3JhbURhdGVUaW1lIC0gZGVsdGEpIC8gMTAwMDtcbiAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydDtcbiAgZnJhZy5lbmRQVFMgPSBzdGFydCArIGZyYWcuZHVyYXRpb247XG59XG4vKipcbiAqIEVuc3VyZXMgYXBwcm9wcmlhdGUgdGltZS1hbGlnbm1lbnQgYmV0d2VlbiByZW5kaXRpb25zIGJhc2VkIG9uIFBEVC4gVW5saWtlIGBhbGlnblBEVGAsIHdoaWNoIGFkanVzdHNcbiAqIHRoZSB0aW1lbGluZSBiYXNlZCBvbiB0aGUgZGVsdGEgYmV0d2VlbiBQRFRzIG9mIHRoZSAwdGggZnJhZ21lbnQgb2YgdHdvIHBsYXlsaXN0cy9gTGV2ZWxEZXRhaWxzYCxcbiAqIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGUgdGltZWxpbmVzIHJlcHJlc2VudGVkIGluIGByZWZEZXRhaWxzYCBhcmUgYWNjdXJhdGUsIGluY2x1ZGluZyB0aGUgUERUcyxcbiAqIGFuZCB1c2VzIHRoZSBcIndhbGxjbG9ja1wiL1BEVCB0aW1lbGluZSBhcyBhIGNyb3NzLXJlZmVyZW5jZSB0byBgZGV0YWlsc2AsIGFkanVzdGluZyB0aGUgcHJlc2VudGF0aW9uXG4gKiB0aW1lcy90aW1lbGluZXMgb2YgYGRldGFpbHNgIGFjY29yZGluZ2x5LlxuICogR2l2ZW4gdGhlIGFzeW5jaHJvbm91cyBuYXR1cmUgb2YgZmV0Y2hlcyBhbmQgaW5pdGlhbCBsb2FkcyBvZiBsaXZlIGBtYWluYCBhbmQgYXVkaW8vc3VidGl0bGUgdHJhY2tzLFxuICogdGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIGVuc3VyZSB0aGUgXCJsb2NhbCB0aW1lbGluZXNcIiBvZiBhdWRpby9zdWJ0aXRsZSB0cmFja3NcbiAqIGFyZSBhbGlnbmVkIHRvIHRoZSBtYWluL3ZpZGVvIHRpbWVsaW5lLCB1c2luZyBQRFQgYXMgdGhlIGNyb3NzLXJlZmVyZW5jZS9cImFuY2hvclwiIHRoYXQgc2hvdWxkXG4gKiBiZSBjb25zaXN0ZW50IGFjcm9zcyBwbGF5bGlzdHMsIHBlciB0aGUgSExTIHNwZWMuXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSByZW5kaXRpb24geW91J2QgbGlrZSB0byB0aW1lLWFsaWduIChlLmcuIGFuIGF1ZGlvIHJlbmRpdGlvbikuXG4gKiBAcGFyYW0gcmVmRGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSByZWZlcmVuY2UgcmVuZGl0aW9uIHdpdGggc3RhcnQgYW5kIFBEVCB0aW1lcyBmb3IgYWxpZ25tZW50LlxuICovXG5cbmZ1bmN0aW9uIGFsaWduTWVkaWFQbGF5bGlzdEJ5UERUKGRldGFpbHMsIHJlZkRldGFpbHMpIHtcbiAgLy8gVGhpcyBjaGVjayBwcm90ZWN0cyB0aGUgdW5zYWZlIFwiIVwiIHVzYWdlIGJlbG93IGZvciBudWxsIHByb2dyYW0gZGF0ZSB0aW1lIGFjY2Vzcy5cbiAgaWYgKCFyZWZEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggfHwgIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICFyZWZEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZWZQRFQgPSByZWZEZXRhaWxzLmZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7IC8vIGhhc1Byb2dyYW1EYXRlVGltZSBjaGVjayBhYm92ZSBtYWtlcyB0aGlzIHNhZmUuXG5cbiAgdmFyIHJlZlN0YXJ0ID0gcmVmRGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7IC8vIFVzZSB0aGUgZGVsdGEgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGRldGFpbHMnIHByZXNlbnRhdGlvbiB0aW1lbGluZSdzIHN0YXJ0IHRpbWUgYW5kIGl0cyBQRFRcbiAgLy8gdG8gYWxpZ24gdGhlIG90aGVyIHJlbmRpdGlvbidzIHRpbWVsaW5lLlxuXG4gIHZhciBkZWx0YSA9IHJlZlBEVCAtIHJlZlN0YXJ0ICogMTAwMDsgLy8gUGVyIHNwZWM6IFwiSWYgYW55IE1lZGlhIFBsYXlsaXN0IGluIGEgTWFzdGVyIFBsYXlsaXN0IGNvbnRhaW5zIGFuIEVYVC1YLVBST0dSQU0tREFURS1USU1FIHRhZywgdGhlbiBhbGxcbiAgLy8gTWVkaWEgUGxheWxpc3RzIGluIHRoYXQgTWFzdGVyIFBsYXlsaXN0IE1VU1QgY29udGFpbiBFWFQtWC1QUk9HUkFNLURBVEUtVElNRSB0YWdzIHdpdGggY29uc2lzdGVudCBtYXBwaW5nc1xuICAvLyBvZiBkYXRlIGFuZCB0aW1lIHRvIG1lZGlhIHRpbWVzdGFtcHMuXCJcbiAgLy8gU28gd2Ugc2hvdWxkIGJlIGFibGUgdG8gdXNlIGVhY2ggcmVuZGl0aW9uJ3MgUERUIGFzIGEgcmVmZXJlbmNlIHRpbWUgYW5kIHVzZSB0aGUgZGVsdGEgdG8gY29tcHV0ZSBvdXIgcmVsZXZhbnRcbiAgLy8gc3RhcnQgYW5kIGVuZCB0aW1lcy5cbiAgLy8gTk9URTogVGhpcyBjb2RlIGFzc3VtZXMgZWFjaCBsZXZlbC9kZXRhaWxzIHRpbWVsaW5lcyBoYXZlIGFscmVhZHkgYmVlbiBtYWRlIFwiaW50ZXJuYWxseSBjb25zaXN0ZW50XCJcblxuICBkZXRhaWxzLmZyYWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgYWxpZ25GcmFnbWVudEJ5UERURGVsdGEoZnJhZywgZGVsdGEpO1xuICB9KTtcblxuICBpZiAoZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICBhbGlnbkZyYWdtZW50QnlQRFREZWx0YShkZXRhaWxzLmZyYWdtZW50SGludCwgZGVsdGEpO1xuICB9XG5cbiAgZGV0YWlscy5hbGlnbmVkU2xpZGluZyA9IHRydWU7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2V3bWEtYmFuZHdpZHRoLWVzdGltYXRvci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19ld21hX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9ld21hICovIFwiLi9zcmMvdXRpbHMvZXdtYS50c1wiKTtcbi8qXG4gKiBFV01BIEJhbmR3aWR0aCBFc3RpbWF0b3JcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAqIFRyYWNrcyBiYW5kd2lkdGggc2FtcGxlcyBhbmQgZXN0aW1hdGVzIGF2YWlsYWJsZSBiYW5kd2lkdGguXG4gKiBCYXNlZCBvbiB0aGUgbWluaW11bSBvZiB0d28gZXhwb25lbnRpYWxseS13ZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZXMgd2l0aFxuICogZGlmZmVyZW50IGhhbGYtbGl2ZXMuXG4gKi9cblxuXG52YXIgRXdtYUJhbmRXaWR0aEVzdGltYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3Ioc2xvdywgZmFzdCwgZGVmYXVsdEVzdGltYXRlKSB7XG4gICAgdGhpcy5kZWZhdWx0RXN0aW1hdGVfID0gdm9pZCAwO1xuICAgIHRoaXMubWluV2VpZ2h0XyA9IHZvaWQgMDtcbiAgICB0aGlzLm1pbkRlbGF5TXNfID0gdm9pZCAwO1xuICAgIHRoaXMuc2xvd18gPSB2b2lkIDA7XG4gICAgdGhpcy5mYXN0XyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlZmF1bHRFc3RpbWF0ZV8gPSBkZWZhdWx0RXN0aW1hdGU7XG4gICAgdGhpcy5taW5XZWlnaHRfID0gMC4wMDE7XG4gICAgdGhpcy5taW5EZWxheU1zXyA9IDUwO1xuICAgIHRoaXMuc2xvd18gPSBuZXcgX3V0aWxzX2V3bWFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0oc2xvdyk7XG4gICAgdGhpcy5mYXN0XyA9IG5ldyBfdXRpbHNfZXdtYV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXShmYXN0KTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBFd21hQmFuZFdpZHRoRXN0aW1hdG9yLnByb3RvdHlwZTtcblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNsb3csIGZhc3QpIHtcbiAgICB2YXIgc2xvd18gPSB0aGlzLnNsb3dfLFxuICAgICAgICBmYXN0XyA9IHRoaXMuZmFzdF87XG5cbiAgICBpZiAodGhpcy5zbG93Xy5oYWxmTGlmZSAhPT0gc2xvdykge1xuICAgICAgdGhpcy5zbG93XyA9IG5ldyBfdXRpbHNfZXdtYV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXShzbG93LCBzbG93Xy5nZXRFc3RpbWF0ZSgpLCBzbG93Xy5nZXRUb3RhbFdlaWdodCgpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mYXN0Xy5oYWxmTGlmZSAhPT0gZmFzdCkge1xuICAgICAgdGhpcy5mYXN0XyA9IG5ldyBfdXRpbHNfZXdtYV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXShmYXN0LCBmYXN0Xy5nZXRFc3RpbWF0ZSgpLCBmYXN0Xy5nZXRUb3RhbFdlaWdodCgpKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNhbXBsZSA9IGZ1bmN0aW9uIHNhbXBsZShkdXJhdGlvbk1zLCBudW1CeXRlcykge1xuICAgIGR1cmF0aW9uTXMgPSBNYXRoLm1heChkdXJhdGlvbk1zLCB0aGlzLm1pbkRlbGF5TXNfKTtcbiAgICB2YXIgbnVtQml0cyA9IDggKiBudW1CeXRlczsgLy8gd2VpZ2h0IGlzIGR1cmF0aW9uIGluIHNlY29uZHNcblxuICAgIHZhciBkdXJhdGlvblMgPSBkdXJhdGlvbk1zIC8gMTAwMDsgLy8gdmFsdWUgaXMgYmFuZHdpZHRoIGluIGJpdHMvc1xuXG4gICAgdmFyIGJhbmR3aWR0aEluQnBzID0gbnVtQml0cyAvIGR1cmF0aW9uUztcbiAgICB0aGlzLmZhc3RfLnNhbXBsZShkdXJhdGlvblMsIGJhbmR3aWR0aEluQnBzKTtcbiAgICB0aGlzLnNsb3dfLnNhbXBsZShkdXJhdGlvblMsIGJhbmR3aWR0aEluQnBzKTtcbiAgfTtcblxuICBfcHJvdG8uY2FuRXN0aW1hdGUgPSBmdW5jdGlvbiBjYW5Fc3RpbWF0ZSgpIHtcbiAgICB2YXIgZmFzdCA9IHRoaXMuZmFzdF87XG4gICAgcmV0dXJuIGZhc3QgJiYgZmFzdC5nZXRUb3RhbFdlaWdodCgpID49IHRoaXMubWluV2VpZ2h0XztcbiAgfTtcblxuICBfcHJvdG8uZ2V0RXN0aW1hdGUgPSBmdW5jdGlvbiBnZXRFc3RpbWF0ZSgpIHtcbiAgICBpZiAodGhpcy5jYW5Fc3RpbWF0ZSgpKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnc2xvdyBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ2Zhc3QgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLmZhc3RfLmdldEVzdGltYXRlKCkpKTtcbiAgICAgIC8vIFRha2UgdGhlIG1pbmltdW0gb2YgdGhlc2UgdHdvIGVzdGltYXRlcy4gIFRoaXMgc2hvdWxkIGhhdmUgdGhlIGVmZmVjdCBvZlxuICAgICAgLy8gYWRhcHRpbmcgZG93biBxdWlja2x5LCBidXQgdXAgbW9yZSBzbG93bHkuXG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpLCB0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXN0aW1hdGVfO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fTtcblxuICByZXR1cm4gRXdtYUJhbmRXaWR0aEVzdGltYXRvcjtcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChFd21hQmFuZFdpZHRoRXN0aW1hdG9yKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvZXdtYS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2V3bWEudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLypcbiAqIGNvbXB1dGUgYW4gRXhwb25lbnRpYWwgV2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VcbiAqIC0gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW92aW5nX2F2ZXJhZ2UjRXhwb25lbnRpYWxfbW92aW5nX2F2ZXJhZ2VcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAqL1xudmFyIEVXTUEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyAgQWJvdXQgaGFsZiBvZiB0aGUgZXN0aW1hdGVkIHZhbHVlIHdpbGwgYmUgZnJvbSB0aGUgbGFzdCB8aGFsZkxpZmV8IHNhbXBsZXMgYnkgd2VpZ2h0LlxuICBmdW5jdGlvbiBFV01BKGhhbGZMaWZlLCBlc3RpbWF0ZSwgd2VpZ2h0KSB7XG4gICAgaWYgKGVzdGltYXRlID09PSB2b2lkIDApIHtcbiAgICAgIGVzdGltYXRlID0gMDtcbiAgICB9XG5cbiAgICBpZiAod2VpZ2h0ID09PSB2b2lkIDApIHtcbiAgICAgIHdlaWdodCA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5oYWxmTGlmZSA9IHZvaWQgMDtcbiAgICB0aGlzLmFscGhhXyA9IHZvaWQgMDtcbiAgICB0aGlzLmVzdGltYXRlXyA9IHZvaWQgMDtcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyA9IHZvaWQgMDtcbiAgICB0aGlzLmhhbGZMaWZlID0gaGFsZkxpZmU7IC8vIExhcmdlciB2YWx1ZXMgb2YgYWxwaGEgZXhwaXJlIGhpc3RvcmljYWwgZGF0YSBtb3JlIHNsb3dseS5cblxuICAgIHRoaXMuYWxwaGFfID0gaGFsZkxpZmUgPyBNYXRoLmV4cChNYXRoLmxvZygwLjUpIC8gaGFsZkxpZmUpIDogMDtcbiAgICB0aGlzLmVzdGltYXRlXyA9IGVzdGltYXRlO1xuICAgIHRoaXMudG90YWxXZWlnaHRfID0gd2VpZ2h0O1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEVXTUEucHJvdG90eXBlO1xuXG4gIF9wcm90by5zYW1wbGUgPSBmdW5jdGlvbiBzYW1wbGUod2VpZ2h0LCB2YWx1ZSkge1xuICAgIHZhciBhZGpBbHBoYSA9IE1hdGgucG93KHRoaXMuYWxwaGFfLCB3ZWlnaHQpO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gdmFsdWUgKiAoMSAtIGFkakFscGhhKSArIGFkakFscGhhICogdGhpcy5lc3RpbWF0ZV87XG4gICAgdGhpcy50b3RhbFdlaWdodF8gKz0gd2VpZ2h0O1xuICB9O1xuXG4gIF9wcm90by5nZXRUb3RhbFdlaWdodCA9IGZ1bmN0aW9uIGdldFRvdGFsV2VpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnRvdGFsV2VpZ2h0XztcbiAgfTtcblxuICBfcHJvdG8uZ2V0RXN0aW1hdGUgPSBmdW5jdGlvbiBnZXRFc3RpbWF0ZSgpIHtcbiAgICBpZiAodGhpcy5hbHBoYV8pIHtcbiAgICAgIHZhciB6ZXJvRmFjdG9yID0gMSAtIE1hdGgucG93KHRoaXMuYWxwaGFfLCB0aGlzLnRvdGFsV2VpZ2h0Xyk7XG5cbiAgICAgIGlmICh6ZXJvRmFjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlXyAvIHplcm9GYWN0b3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfO1xuICB9O1xuXG4gIHJldHVybiBFV01BO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKEVXTUEpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9mZXRjaC1sb2FkZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2ZldGNoLWxvYWRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZmV0Y2hTdXBwb3J0ZWQsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZmV0Y2hTdXBwb3J0ZWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmZXRjaFN1cHBvcnRlZDsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRlcl9sb2FkX3N0YXRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2FkZXIvbG9hZC1zdGF0cyAqLyBcIi4vc3JjL2xvYWRlci9sb2FkLXN0YXRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF9jaHVua19jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvY2h1bmstY2FjaGUgKi8gXCIuL3NyYy9kZW11eC9jaHVuay1jYWNoZS50c1wiKTtcblxuXG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3QuYmluZCgpOyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuXG5cbmZ1bmN0aW9uIGZldGNoU3VwcG9ydGVkKCkge1xuICBpZiAoIC8vIEB0cy1pZ25vcmVcbiAgc2VsZi5mZXRjaCAmJiBzZWxmLkFib3J0Q29udHJvbGxlciAmJiBzZWxmLlJlYWRhYmxlU3RyZWFtICYmIHNlbGYuUmVxdWVzdCkge1xuICAgIHRyeSB7XG4gICAgICBuZXcgc2VsZi5SZWFkYWJsZVN0cmVhbSh7fSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIG5vb3AgKi9cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBGZXRjaExvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZldGNoTG9hZGVyKGNvbmZpZ1xuICAvKiBIbHNDb25maWcgKi9cbiAgKSB7XG4gICAgdGhpcy5mZXRjaFNldHVwID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXF1ZXN0ID0gdm9pZCAwO1xuICAgIHRoaXMucmVzcG9uc2UgPSB2b2lkIDA7XG4gICAgdGhpcy5jb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29udGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuc3RhdHMgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIHRoaXMuZmV0Y2hTZXR1cCA9IGNvbmZpZy5mZXRjaFNldHVwIHx8IGdldFJlcXVlc3Q7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbmV3IHNlbGYuQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5zdGF0cyA9IG5ldyBfbG9hZGVyX2xvYWRfc3RhdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkxvYWRTdGF0c1wiXSgpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEZldGNoTG9hZGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5sb2FkZXIgPSB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gIH07XG5cbiAgX3Byb3RvLmFib3J0SW50ZXJuYWwgPSBmdW5jdGlvbiBhYm9ydEludGVybmFsKCkge1xuICAgIHZhciByZXNwb25zZSA9IHRoaXMucmVzcG9uc2U7XG5cbiAgICBpZiAoIXJlc3BvbnNlIHx8ICFyZXNwb25zZS5vaykge1xuICAgICAgdGhpcy5zdGF0cy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICB2YXIgX3RoaXMkY2FsbGJhY2tzO1xuXG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG5cbiAgICBpZiAoKF90aGlzJGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzKSAhPT0gbnVsbCAmJiBfdGhpcyRjYWxsYmFja3MgIT09IHZvaWQgMCAmJiBfdGhpcyRjYWxsYmFja3Mub25BYm9ydCkge1xuICAgICAgdGhpcy5jYWxsYmFja3Mub25BYm9ydCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIHRoaXMucmVzcG9uc2UpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ubG9hZCA9IGZ1bmN0aW9uIGxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcblxuICAgIGlmIChzdGF0cy5sb2FkaW5nLnN0YXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWRlciBjYW4gb25seSBiZSB1c2VkIG9uY2UuJyk7XG4gICAgfVxuXG4gICAgc3RhdHMubG9hZGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdmFyIGluaXRQYXJhbXMgPSBnZXRSZXF1ZXN0UGFyYW1ldGVycyhjb250ZXh0LCB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICB2YXIgb25Qcm9ncmVzcyA9IGNhbGxiYWNrcy5vblByb2dyZXNzO1xuICAgIHZhciBpc0FycmF5QnVmZmVyID0gY29udGV4dC5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcic7XG4gICAgdmFyIExFTkdUSCA9IGlzQXJyYXlCdWZmZXIgPyAnYnl0ZUxlbmd0aCcgOiAnbGVuZ3RoJztcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIHRoaXMucmVxdWVzdCA9IHRoaXMuZmV0Y2hTZXR1cChjb250ZXh0LCBpbml0UGFyYW1zKTtcbiAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmFib3J0SW50ZXJuYWwoKTtcblxuICAgICAgY2FsbGJhY2tzLm9uVGltZW91dChzdGF0cywgY29udGV4dCwgX3RoaXMucmVzcG9uc2UpO1xuICAgIH0sIGNvbmZpZy50aW1lb3V0KTtcbiAgICBzZWxmLmZldGNoKHRoaXMucmVxdWVzdCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIF90aGlzLnJlc3BvbnNlID0gX3RoaXMubG9hZGVyID0gcmVzcG9uc2U7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0dXNUZXh0O1xuICAgICAgICB0aHJvdyBuZXcgRmV0Y2hFcnJvcihzdGF0dXNUZXh0IHx8ICdmZXRjaCwgYmFkIG5ldHdvcmsgcmVzcG9uc2UnLCBzdGF0dXMsIHJlc3BvbnNlKTtcbiAgICAgIH1cblxuICAgICAgc3RhdHMubG9hZGluZy5maXJzdCA9IE1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLmxvYWRpbmcuc3RhcnQpO1xuICAgICAgc3RhdHMudG90YWwgPSBwYXJzZUludChyZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1MZW5ndGgnKSB8fCAnMCcpO1xuXG4gICAgICBpZiAob25Qcm9ncmVzcyAmJiBPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGNvbmZpZy5oaWdoV2F0ZXJNYXJrKSkge1xuICAgICAgICByZXR1cm4gX3RoaXMubG9hZFByb2dyZXNzaXZlbHkocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBjb25maWcuaGlnaFdhdGVyTWFyaywgb25Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlRGF0YSkge1xuICAgICAgdmFyIHJlc3BvbnNlID0gX3RoaXMucmVzcG9uc2U7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dChfdGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICBzdGF0cy5sb2FkaW5nLmVuZCA9IE1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLmxvYWRpbmcuZmlyc3QpO1xuICAgICAgc3RhdHMubG9hZGVkID0gc3RhdHMudG90YWwgPSByZXNwb25zZURhdGFbTEVOR1RIXTtcbiAgICAgIHZhciBsb2FkZXJSZXNwb25zZSA9IHtcbiAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YVxuICAgICAgfTtcblxuICAgICAgaWYgKG9uUHJvZ3Jlc3MgJiYgIU9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoY29uZmlnLmhpZ2hXYXRlck1hcmspKSB7XG4gICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIHJlc3BvbnNlRGF0YSwgcmVzcG9uc2UpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFja3Mub25TdWNjZXNzKGxvYWRlclJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgcmVzcG9uc2UpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQoX3RoaXMucmVxdWVzdFRpbWVvdXQpO1xuXG4gICAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIENPUlMgZXJyb3JzIHJlc3VsdCBpbiBhbiB1bmRlZmluZWQgY29kZS4gU2V0IGl0IHRvIDAgaGVyZSB0byBhbGlnbiB3aXRoIFhIUidzIGJlaGF2aW9yXG4gICAgICAvLyB3aGVuIGRlc3Ryb3lpbmcsICdlcnJvcicgaXRzZWxmIGNhbiBiZSB1bmRlZmluZWRcblxuXG4gICAgICB2YXIgY29kZSA9ICFlcnJvciA/IDAgOiBlcnJvci5jb2RlIHx8IDA7XG4gICAgICB2YXIgdGV4dCA9ICFlcnJvciA/IG51bGwgOiBlcnJvci5tZXNzYWdlO1xuICAgICAgY2FsbGJhY2tzLm9uRXJyb3Ioe1xuICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICB9LCBjb250ZXh0LCBlcnJvciA/IGVycm9yLmRldGFpbHMgOiBudWxsKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0Q2FjaGVBZ2UgPSBmdW5jdGlvbiBnZXRDYWNoZUFnZSgpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLnJlc3BvbnNlKSB7XG4gICAgICB2YXIgYWdlSGVhZGVyID0gdGhpcy5yZXNwb25zZS5oZWFkZXJzLmdldCgnYWdlJyk7XG4gICAgICByZXN1bHQgPSBhZ2VIZWFkZXIgPyBwYXJzZUZsb2F0KGFnZUhlYWRlcikgOiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRQcm9ncmVzc2l2ZWx5ID0gZnVuY3Rpb24gbG9hZFByb2dyZXNzaXZlbHkocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBoaWdoV2F0ZXJNYXJrLCBvblByb2dyZXNzKSB7XG4gICAgaWYgKGhpZ2hXYXRlck1hcmsgPT09IHZvaWQgMCkge1xuICAgICAgaGlnaFdhdGVyTWFyayA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGNodW5rQ2FjaGUgPSBuZXcgX2RlbXV4X2NodW5rX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKCk7XG4gICAgdmFyIHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG5cbiAgICB2YXIgcHVtcCA9IGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgICByZXR1cm4gcmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmRvbmUpIHtcbiAgICAgICAgICBpZiAoY2h1bmtDYWNoZS5kYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVua0NhY2hlLmZsdXNoKCksIHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2h1bmsgPSBkYXRhLnZhbHVlO1xuICAgICAgICB2YXIgbGVuID0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBzdGF0cy5sb2FkZWQgKz0gbGVuO1xuXG4gICAgICAgIGlmIChsZW4gPCBoaWdoV2F0ZXJNYXJrIHx8IGNodW5rQ2FjaGUuZGF0YUxlbmd0aCkge1xuICAgICAgICAgIC8vIFRoZSBjdXJyZW50IGNodW5rIGlzIHRvbyBzbWFsbCB0byB0byBiZSBlbWl0dGVkIG9yIHRoZSBjYWNoZSBhbHJlYWR5IGhhcyBkYXRhXG4gICAgICAgICAgLy8gUHVzaCBpdCB0byB0aGUgY2FjaGVcbiAgICAgICAgICBjaHVua0NhY2hlLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgaWYgKGNodW5rQ2FjaGUuZGF0YUxlbmd0aCA+PSBoaWdoV2F0ZXJNYXJrKSB7XG4gICAgICAgICAgICAvLyBmbHVzaCBpbiBvcmRlciB0byBqb2luIHRoZSB0eXBlZCBhcnJheXNcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGNodW5rQ2FjaGUuZmx1c2goKSwgcmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vdGhpbmcgY2FjaGVkIGFscmVhZHksIGFuZCB0aGUgY2hhY2hlIGlzIGxhcmdlIGVub3VnaFxuICAgICAgICAgIC8vIGp1c3QgZW1pdCB0aGUgcHJvZ3Jlc3MgZXZlbnRcbiAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVuaywgcmVzcG9uc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHB1bXAoKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyogYWJvcnRlZCAqL1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gcHVtcCgpO1xuICB9O1xuXG4gIHJldHVybiBGZXRjaExvYWRlcjtcbn0oKTtcblxuZnVuY3Rpb24gZ2V0UmVxdWVzdFBhcmFtZXRlcnMoY29udGV4dCwgc2lnbmFsKSB7XG4gIHZhciBpbml0UGFyYW1zID0ge1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgbW9kZTogJ2NvcnMnLFxuICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgIHNpZ25hbDogc2lnbmFsLFxuICAgIGhlYWRlcnM6IG5ldyBzZWxmLkhlYWRlcnMoX2V4dGVuZHMoe30sIGNvbnRleHQuaGVhZGVycykpXG4gIH07XG5cbiAgaWYgKGNvbnRleHQucmFuZ2VFbmQpIHtcbiAgICBpbml0UGFyYW1zLmhlYWRlcnMuc2V0KCdSYW5nZScsICdieXRlcz0nICsgY29udGV4dC5yYW5nZVN0YXJ0ICsgJy0nICsgU3RyaW5nKGNvbnRleHQucmFuZ2VFbmQgLSAxKSk7XG4gIH1cblxuICByZXR1cm4gaW5pdFBhcmFtcztcbn1cblxuZnVuY3Rpb24gZ2V0UmVxdWVzdChjb250ZXh0LCBpbml0UGFyYW1zKSB7XG4gIHJldHVybiBuZXcgc2VsZi5SZXF1ZXN0KGNvbnRleHQudXJsLCBpbml0UGFyYW1zKTtcbn1cblxudmFyIEZldGNoRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHNMb29zZShGZXRjaEVycm9yLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIEZldGNoRXJyb3IobWVzc2FnZSwgY29kZSwgZGV0YWlscykge1xuICAgIHZhciBfdGhpczI7XG5cbiAgICBfdGhpczIgPSBfRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgIF90aGlzMi5jb2RlID0gdm9pZCAwO1xuICAgIF90aGlzMi5kZXRhaWxzID0gdm9pZCAwO1xuICAgIF90aGlzMi5jb2RlID0gY29kZTtcbiAgICBfdGhpczIuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIHJldHVybiBGZXRjaEVycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChGZXRjaExvYWRlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2ltc2MxLXR0bWwtcGFyc2VyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2ltc2MxLXR0bWwtcGFyc2VyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IElNU0MxX0NPREVDLCBwYXJzZUlNU0MxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIklNU0MxX0NPREVDXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gSU1TQzFfQ09ERUM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInBhcnNlSU1TQzFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwYXJzZUlNU0MxOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21wNC10b29scyAqLyBcIi4vc3JjL3V0aWxzL21wNC10b29scy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdnR0cGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Z0dHBhcnNlciAqLyBcIi4vc3JjL3V0aWxzL3Z0dHBhcnNlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdnR0Y3VlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Z0dGN1ZSAqLyBcIi4vc3JjL3V0aWxzL3Z0dGN1ZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9pZDMgKi8gXCIuL3NyYy9kZW11eC9pZDMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RpbWVzY2FsZV9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RpbWVzY2FsZS1jb252ZXJzaW9uICovIFwiLi9zcmMvdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24udHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3dlYnZ0dF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vd2VidnR0LXBhcnNlciAqLyBcIi4vc3JjL3V0aWxzL3dlYnZ0dC1wYXJzZXIudHNcIik7XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuXG5cblxuXG5cblxudmFyIElNU0MxX0NPREVDID0gJ3N0cHAudHRtbC5pbTF0JzsgLy8gVGltZSBmb3JtYXQ6IGg6bTpzOmZyYW1lcyguc3ViZnJhbWVzKVxuXG52YXIgSE1TRl9SRUdFWCA9IC9eKFxcZHsyLH0pOihcXGR7Mn0pOihcXGR7Mn0pOihcXGR7Mn0pXFwuPyhcXGQrKT8kLzsgLy8gVGltZSBmb3JtYXQ6IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIGZyYW1lcywgdGlja3NcblxudmFyIFRJTUVfVU5JVF9SRUdFWCA9IC9eKFxcZCooPzpcXC5cXGQqKT8pKGh8bXxzfG1zfGZ8dCkkLztcbnZhciB0ZXh0QWxpZ25Ub0xpbmVBbGlnbiA9IHtcbiAgbGVmdDogJ3N0YXJ0JyxcbiAgY2VudGVyOiAnY2VudGVyJyxcbiAgcmlnaHQ6ICdlbmQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgZW5kOiAnZW5kJ1xufTtcbmZ1bmN0aW9uIHBhcnNlSU1TQzEocGF5bG9hZCwgaW5pdFBUUywgdGltZXNjYWxlLCBjYWxsQmFjaywgZXJyb3JDYWxsQmFjaykge1xuICB2YXIgcmVzdWx0cyA9IE9iamVjdChfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJmaW5kQm94XCJdKShuZXcgVWludDhBcnJheShwYXlsb2FkKSwgWydtZGF0J10pO1xuXG4gIGlmIChyZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGVycm9yQ2FsbEJhY2sobmV3IEVycm9yKCdDb3VsZCBub3QgcGFyc2UgSU1TQzEgbWRhdCcpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdHRtbExpc3QgPSByZXN1bHRzLm1hcChmdW5jdGlvbiAobWRhdCkge1xuICAgIHJldHVybiBPYmplY3QoX2RlbXV4X2lkM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1widXRmOEFycmF5VG9TdHJcIl0pKG1kYXQpO1xuICB9KTtcbiAgdmFyIHN5bmNUaW1lID0gT2JqZWN0KF90aW1lc2NhbGVfY29udmVyc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1widG9UaW1lc2NhbGVGcm9tU2NhbGVcIl0pKGluaXRQVFMsIDEsIHRpbWVzY2FsZSk7XG5cbiAgdHJ5IHtcbiAgICB0dG1sTGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh0dG1sKSB7XG4gICAgICByZXR1cm4gY2FsbEJhY2socGFyc2VUVE1MKHR0bWwsIHN5bmNUaW1lKSk7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZXJyb3JDYWxsQmFjayhlcnJvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VUVE1MKHR0bWwsIHN5bmNUaW1lKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gIHZhciB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHR0bWwsICd0ZXh0L3htbCcpO1xuICB2YXIgdHQgPSB4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3R0JylbMF07XG5cbiAgaWYgKCF0dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0dG1sJyk7XG4gIH1cblxuICB2YXIgZGVmYXVsdFJhdGVJbmZvID0ge1xuICAgIGZyYW1lUmF0ZTogMzAsXG4gICAgc3ViRnJhbWVSYXRlOiAxLFxuICAgIGZyYW1lUmF0ZU11bHRpcGxpZXI6IDAsXG4gICAgdGlja1JhdGU6IDBcbiAgfTtcbiAgdmFyIHJhdGVJbmZvID0gT2JqZWN0LmtleXMoZGVmYXVsdFJhdGVJbmZvKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB0dC5nZXRBdHRyaWJ1dGUoXCJ0dHA6XCIgKyBrZXkpIHx8IGRlZmF1bHRSYXRlSW5mb1trZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbiAgdmFyIHRyaW0gPSB0dC5nZXRBdHRyaWJ1dGUoJ3htbDpzcGFjZScpICE9PSAncHJlc2VydmUnO1xuICB2YXIgc3R5bGVFbGVtZW50cyA9IGNvbGxlY3Rpb25Ub0RpY3Rpb25hcnkoZ2V0RWxlbWVudENvbGxlY3Rpb24odHQsICdzdHlsaW5nJywgJ3N0eWxlJykpO1xuICB2YXIgcmVnaW9uRWxlbWVudHMgPSBjb2xsZWN0aW9uVG9EaWN0aW9uYXJ5KGdldEVsZW1lbnRDb2xsZWN0aW9uKHR0LCAnbGF5b3V0JywgJ3JlZ2lvbicpKTtcbiAgdmFyIGN1ZUVsZW1lbnRzID0gZ2V0RWxlbWVudENvbGxlY3Rpb24odHQsICdib2R5JywgJ1tiZWdpbl0nKTtcbiAgcmV0dXJuIFtdLm1hcC5jYWxsKGN1ZUVsZW1lbnRzLCBmdW5jdGlvbiAoY3VlRWxlbWVudCkge1xuICAgIHZhciBjdWVUZXh0ID0gZ2V0VGV4dENvbnRlbnQoY3VlRWxlbWVudCwgdHJpbSk7XG5cbiAgICBpZiAoIWN1ZVRleHQgfHwgIWN1ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCdiZWdpbicpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRUaW1lID0gcGFyc2VUdG1sVGltZShjdWVFbGVtZW50LmdldEF0dHJpYnV0ZSgnYmVnaW4nKSwgcmF0ZUluZm8pO1xuICAgIHZhciBkdXJhdGlvbiA9IHBhcnNlVHRtbFRpbWUoY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2R1cicpLCByYXRlSW5mbyk7XG4gICAgdmFyIGVuZFRpbWUgPSBwYXJzZVR0bWxUaW1lKGN1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdlbmQnKSwgcmF0ZUluZm8pO1xuXG4gICAgaWYgKHN0YXJ0VGltZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgdGltZXN0YW1wUGFyc2luZ0Vycm9yKGN1ZUVsZW1lbnQpO1xuICAgIH1cblxuICAgIGlmIChlbmRUaW1lID09PSBudWxsKSB7XG4gICAgICBpZiAoZHVyYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgdGltZXN0YW1wUGFyc2luZ0Vycm9yKGN1ZUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBlbmRUaW1lID0gc3RhcnRUaW1lICsgZHVyYXRpb247XG4gICAgfVxuXG4gICAgdmFyIGN1ZSA9IG5ldyBfdnR0Y3VlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKHN0YXJ0VGltZSAtIHN5bmNUaW1lLCBlbmRUaW1lIC0gc3luY1RpbWUsIGN1ZVRleHQpO1xuICAgIGN1ZS5pZCA9IE9iamVjdChfd2VidnR0X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZ2VuZXJhdGVDdWVJZFwiXSkoY3VlLnN0YXJ0VGltZSwgY3VlLmVuZFRpbWUsIGN1ZS50ZXh0KTtcbiAgICB2YXIgcmVnaW9uID0gcmVnaW9uRWxlbWVudHNbY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JlZ2lvbicpXTtcbiAgICB2YXIgc3R5bGUgPSBzdHlsZUVsZW1lbnRzW2N1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpXTsgLy8gVE9ETzogQWRkIHJlZ2lvbnMgdG8gdHJhY2sgYW5kIGN1ZSAob3JpZ2luIGFuZCBleHRlbmQpXG4gICAgLy8gVGhlc2UgdmFsdWVzIGFyZSBoYXJkLWNvZGVkIChmb3Igbm93KSB0byBzaW11bGF0ZSByZWdpb24gc2V0dGluZ3MgaW4gdGhlIGRlbW9cblxuICAgIGN1ZS5wb3NpdGlvbiA9IDEwO1xuICAgIGN1ZS5zaXplID0gODA7IC8vIEFwcGx5IHN0eWxlcyB0byBjdWVcblxuICAgIHZhciBzdHlsZXMgPSBnZXRUdG1sU3R5bGVzKHJlZ2lvbiwgc3R5bGUsIHN0eWxlRWxlbWVudHMpO1xuICAgIHZhciB0ZXh0QWxpZ24gPSBzdHlsZXMudGV4dEFsaWduO1xuXG4gICAgaWYgKHRleHRBbGlnbikge1xuICAgICAgLy8gY3VlLnBvc2l0aW9uQWxpZ24gbm90IHNldHRhYmxlIGluIEZGfjIwMTZcbiAgICAgIHZhciBsaW5lQWxpZ24gPSB0ZXh0QWxpZ25Ub0xpbmVBbGlnblt0ZXh0QWxpZ25dO1xuXG4gICAgICBpZiAobGluZUFsaWduKSB7XG4gICAgICAgIGN1ZS5saW5lQWxpZ24gPSBsaW5lQWxpZ247XG4gICAgICB9XG5cbiAgICAgIGN1ZS5hbGlnbiA9IHRleHRBbGlnbjtcbiAgICB9XG5cbiAgICBfZXh0ZW5kcyhjdWUsIHN0eWxlcyk7XG5cbiAgICByZXR1cm4gY3VlO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKGN1ZSkge1xuICAgIHJldHVybiBjdWUgIT09IG51bGw7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50Q29sbGVjdGlvbihmcm9tRWxlbWVudCwgcGFyZW50TmFtZSwgY2hpbGROYW1lKSB7XG4gIHZhciBwYXJlbnQgPSBmcm9tRWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShwYXJlbnROYW1lKVswXTtcblxuICBpZiAocGFyZW50KSB7XG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY2hpbGROYW1lKSk7XG4gIH1cblxuICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25Ub0RpY3Rpb25hcnkoZWxlbWVudHNXaXRoSWQpIHtcbiAgcmV0dXJuIGVsZW1lbnRzV2l0aElkLnJlZHVjZShmdW5jdGlvbiAoZGljdCwgZWxlbWVudCkge1xuICAgIHZhciBpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd4bWw6aWQnKTtcblxuICAgIGlmIChpZCkge1xuICAgICAgZGljdFtpZF0gPSBlbGVtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBkaWN0O1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50KGVsZW1lbnQsIHRyaW0pIHtcbiAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoZWxlbWVudC5jaGlsZE5vZGVzKS5yZWR1Y2UoZnVuY3Rpb24gKHN0ciwgbm9kZSwgaSkge1xuICAgIHZhciBfbm9kZSRjaGlsZE5vZGVzO1xuXG4gICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdicicgJiYgaSkge1xuICAgICAgcmV0dXJuIHN0ciArICdcXG4nO1xuICAgIH1cblxuICAgIGlmICgoX25vZGUkY2hpbGROb2RlcyA9IG5vZGUuY2hpbGROb2RlcykgIT09IG51bGwgJiYgX25vZGUkY2hpbGROb2RlcyAhPT0gdm9pZCAwICYmIF9ub2RlJGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZ2V0VGV4dENvbnRlbnQobm9kZSwgdHJpbSk7XG4gICAgfSBlbHNlIGlmICh0cmltKSB7XG4gICAgICByZXR1cm4gc3RyICsgbm9kZS50ZXh0Q29udGVudC50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHIgKyBub2RlLnRleHRDb250ZW50O1xuICB9LCAnJyk7XG59XG5cbmZ1bmN0aW9uIGdldFR0bWxTdHlsZXMocmVnaW9uLCBzdHlsZSwgc3R5bGVFbGVtZW50cykge1xuICB2YXIgdHRzTnMgPSAnaHR0cDovL3d3dy53My5vcmcvbnMvdHRtbCNzdHlsaW5nJztcbiAgdmFyIHJlZ2lvblN0eWxlID0gbnVsbDtcbiAgdmFyIHN0eWxlQXR0cmlidXRlcyA9IFsnZGlzcGxheUFsaWduJywgJ3RleHRBbGlnbicsICdjb2xvcicsICdiYWNrZ3JvdW5kQ29sb3InLCAnZm9udFNpemUnLCAnZm9udEZhbWlseScgLy8gJ2ZvbnRXZWlnaHQnLFxuICAvLyAnbGluZUhlaWdodCcsXG4gIC8vICd3cmFwT3B0aW9uJyxcbiAgLy8gJ2ZvbnRTdHlsZScsXG4gIC8vICdkaXJlY3Rpb24nLFxuICAvLyAnd3JpdGluZ01vZGUnXG4gIF07XG4gIHZhciByZWdpb25TdHlsZU5hbWUgPSByZWdpb24gIT09IG51bGwgJiYgcmVnaW9uICE9PSB2b2lkIDAgJiYgcmVnaW9uLmhhc0F0dHJpYnV0ZSgnc3R5bGUnKSA/IHJlZ2lvbi5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgOiBudWxsO1xuXG4gIGlmIChyZWdpb25TdHlsZU5hbWUgJiYgc3R5bGVFbGVtZW50cy5oYXNPd25Qcm9wZXJ0eShyZWdpb25TdHlsZU5hbWUpKSB7XG4gICAgcmVnaW9uU3R5bGUgPSBzdHlsZUVsZW1lbnRzW3JlZ2lvblN0eWxlTmFtZV07XG4gIH1cblxuICByZXR1cm4gc3R5bGVBdHRyaWJ1dGVzLnJlZHVjZShmdW5jdGlvbiAoc3R5bGVzLCBuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0QXR0cmlidXRlTlMoc3R5bGUsIHR0c05zLCBuYW1lKSB8fCBnZXRBdHRyaWJ1dGVOUyhyZWdpb24sIHR0c05zLCBuYW1lKSB8fCBnZXRBdHRyaWJ1dGVOUyhyZWdpb25TdHlsZSwgdHRzTnMsIG5hbWUpO1xuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBzdHlsZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGVzO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZU5TKGVsZW1lbnQsIG5zLCBuYW1lKSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlTlMobnMsIG5hbWUpID8gZWxlbWVudC5nZXRBdHRyaWJ1dGVOUyhucywgbmFtZSkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0aW1lc3RhbXBQYXJzaW5nRXJyb3Iobm9kZSkge1xuICByZXR1cm4gbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlIHR0bWwgdGltZXN0YW1wIFwiICsgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHRtbFRpbWUodGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbykge1xuICBpZiAoIXRpbWVBdHRyaWJ1dGVWYWx1ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNlY29uZHMgPSBPYmplY3QoX3Z0dHBhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wicGFyc2VUaW1lU3RhbXBcIl0pKHRpbWVBdHRyaWJ1dGVWYWx1ZSk7XG5cbiAgaWYgKHNlY29uZHMgPT09IG51bGwpIHtcbiAgICBpZiAoSE1TRl9SRUdFWC50ZXN0KHRpbWVBdHRyaWJ1dGVWYWx1ZSkpIHtcbiAgICAgIHNlY29uZHMgPSBwYXJzZUhvdXJzTWludXRlc1NlY29uZHNGcmFtZXModGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbyk7XG4gICAgfSBlbHNlIGlmIChUSU1FX1VOSVRfUkVHRVgudGVzdCh0aW1lQXR0cmlidXRlVmFsdWUpKSB7XG4gICAgICBzZWNvbmRzID0gcGFyc2VUaW1lVW5pdHModGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlY29uZHM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSG91cnNNaW51dGVzU2Vjb25kc0ZyYW1lcyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKSB7XG4gIHZhciBtID0gSE1TRl9SRUdFWC5leGVjKHRpbWVBdHRyaWJ1dGVWYWx1ZSk7XG4gIHZhciBmcmFtZXMgPSAobVs0XSB8IDApICsgKG1bNV0gfCAwKSAvIHJhdGVJbmZvLnN1YkZyYW1lUmF0ZTtcbiAgcmV0dXJuIChtWzFdIHwgMCkgKiAzNjAwICsgKG1bMl0gfCAwKSAqIDYwICsgKG1bM10gfCAwKSArIGZyYW1lcyAvIHJhdGVJbmZvLmZyYW1lUmF0ZTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lVW5pdHModGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbykge1xuICB2YXIgbSA9IFRJTUVfVU5JVF9SRUdFWC5leGVjKHRpbWVBdHRyaWJ1dGVWYWx1ZSk7XG4gIHZhciB2YWx1ZSA9IE51bWJlcihtWzFdKTtcbiAgdmFyIHVuaXQgPSBtWzJdO1xuXG4gIHN3aXRjaCAodW5pdCkge1xuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIHZhbHVlICogMzYwMDtcblxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIHZhbHVlICogNjA7XG5cbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gdmFsdWUgKiAxMDAwO1xuXG4gICAgY2FzZSAnZic6XG4gICAgICByZXR1cm4gdmFsdWUgLyByYXRlSW5mby5mcmFtZVJhdGU7XG5cbiAgICBjYXNlICd0JzpcbiAgICAgIHJldHVybiB2YWx1ZSAvIHJhdGVJbmZvLnRpY2tSYXRlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2xvZ2dlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZW5hYmxlTG9ncywgbG9nZ2VyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVuYWJsZUxvZ3NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBlbmFibGVMb2dzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJsb2dnZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2dnZXI7IH0pO1xudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbnZhciBmYWtlTG9nZ2VyID0ge1xuICB0cmFjZTogbm9vcCxcbiAgZGVidWc6IG5vb3AsXG4gIGxvZzogbm9vcCxcbiAgd2Fybjogbm9vcCxcbiAgaW5mbzogbm9vcCxcbiAgZXJyb3I6IG5vb3Bcbn07XG52YXIgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyOyAvLyBsZXQgbGFzdENhbGxUaW1lO1xuLy8gZnVuY3Rpb24gZm9ybWF0TXNnV2l0aFRpbWVJbmZvKHR5cGUsIG1zZykge1xuLy8gICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuLy8gICBjb25zdCBkaWZmID0gbGFzdENhbGxUaW1lID8gJysnICsgKG5vdyAtIGxhc3RDYWxsVGltZSkgOiAnMCc7XG4vLyAgIGxhc3RDYWxsVGltZSA9IG5vdztcbi8vICAgbXNnID0gKG5ldyBEYXRlKG5vdykpLnRvSVNPU3RyaW5nKCkgKyAnIHwgWycgKyAgdHlwZSArICddID4gJyArIG1zZyArICcgKCAnICsgZGlmZiArICcgbXMgKSc7XG4vLyAgIHJldHVybiBtc2c7XG4vLyB9XG5cbmZ1bmN0aW9uIGNvbnNvbGVQcmludEZuKHR5cGUpIHtcbiAgdmFyIGZ1bmMgPSBzZWxmLmNvbnNvbGVbdHlwZV07XG5cbiAgaWYgKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuYy5iaW5kKHNlbGYuY29uc29sZSwgXCJbXCIgKyB0eXBlICsgXCJdID5cIik7XG4gIH1cblxuICByZXR1cm4gbm9vcDtcbn1cblxuZnVuY3Rpb24gZXhwb3J0TG9nZ2VyRnVuY3Rpb25zKGRlYnVnQ29uZmlnKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jdGlvbnMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmN0aW9uc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBmdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGV4cG9ydGVkTG9nZ2VyW3R5cGVdID0gZGVidWdDb25maWdbdHlwZV0gPyBkZWJ1Z0NvbmZpZ1t0eXBlXS5iaW5kKGRlYnVnQ29uZmlnKSA6IGNvbnNvbGVQcmludEZuKHR5cGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlTG9ncyhkZWJ1Z0NvbmZpZykge1xuICAvLyBjaGVjayB0aGF0IGNvbnNvbGUgaXMgYXZhaWxhYmxlXG4gIGlmIChzZWxmLmNvbnNvbGUgJiYgZGVidWdDb25maWcgPT09IHRydWUgfHwgdHlwZW9mIGRlYnVnQ29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyhkZWJ1Z0NvbmZpZywgLy8gUmVtb3ZlIG91dCBmcm9tIGxpc3QgaGVyZSB0byBoYXJkLWRpc2FibGUgYSBsb2ctbGV2ZWxcbiAgICAvLyAndHJhY2UnLFxuICAgICdkZWJ1ZycsICdsb2cnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJyk7IC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3QgYWxsb3cgdG8gdXNlIGJpbmQgb24gY29uc29sZSBvYmplY3QgYW55d2F5XG4gICAgLy8gZmFsbGJhY2sgdG8gZGVmYXVsdCBpZiBuZWVkZWRcblxuICAgIHRyeSB7XG4gICAgICBleHBvcnRlZExvZ2dlci5sb2coKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcbiAgfVxufVxudmFyIGxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9tZWRpYWtleXMtaGVscGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvbWVkaWFrZXlzLWhlbHBlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IEtleVN5c3RlbXMsIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJLZXlTeXN0ZW1zXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gS2V5U3lzdGVtczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzOyB9KTtcbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTmF2aWdhdG9yL3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1xuICovXG52YXIgS2V5U3lzdGVtcztcblxuKGZ1bmN0aW9uIChLZXlTeXN0ZW1zKSB7XG4gIEtleVN5c3RlbXNbXCJXSURFVklORVwiXSA9IFwiY29tLndpZGV2aW5lLmFscGhhXCI7XG4gIEtleVN5c3RlbXNbXCJQTEFZUkVBRFlcIl0gPSBcImNvbS5taWNyb3NvZnQucGxheXJlYWR5XCI7XG59KShLZXlTeXN0ZW1zIHx8IChLZXlTeXN0ZW1zID0ge30pKTtcblxudmFyIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLm5hdmlnYXRvciAmJiBzZWxmLm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICByZXR1cm4gc2VsZi5uYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzLmJpbmQoc2VsZi5uYXZpZ2F0b3IpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL21lZGlhc291cmNlLWhlbHBlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZ2V0TWVkaWFTb3VyY2UgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0TWVkaWFTb3VyY2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRNZWRpYVNvdXJjZTsgfSk7XG4vKipcbiAqIE1lZGlhU291cmNlIGhlbHBlclxuICovXG5mdW5jdGlvbiBnZXRNZWRpYVNvdXJjZSgpIHtcbiAgcmV0dXJuIHNlbGYuTWVkaWFTb3VyY2UgfHwgc2VsZi5XZWJLaXRNZWRpYVNvdXJjZTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvbXA0LXRvb2xzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9tcDQtdG9vbHMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFJlbXV4ZXJUcmFja0lkQ29uZmlnLCBiaW4yc3RyLCByZWFkVWludDE2LCByZWFkVWludDMyLCByZWFkU2ludDMyLCB3cml0ZVVpbnQzMiwgZmluZEJveCwgcGFyc2VTZWdtZW50SW5kZXgsIHBhcnNlSW5pdFNlZ21lbnQsIGdldFN0YXJ0RFRTLCBnZXREdXJhdGlvbiwgY29tcHV0ZVJhd0R1cmF0aW9uRnJvbVNhbXBsZXMsIG9mZnNldFN0YXJ0RFRTLCBzZWdtZW50VmFsaWRSYW5nZSwgYXBwZW5kVWludDhBcnJheSwgcGFyc2VTYW1wbGVzLCBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdSwgcGFyc2VFbXNnICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlJlbXV4ZXJUcmFja0lkQ29uZmlnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUmVtdXhlclRyYWNrSWRDb25maWc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJpbjJzdHJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBiaW4yc3RyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJyZWFkVWludDE2XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVhZFVpbnQxNjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicmVhZFVpbnQzMlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlYWRVaW50MzI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInJlYWRTaW50MzJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZWFkU2ludDMyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ3cml0ZVVpbnQzMlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlVWludDMyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJmaW5kQm94XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmluZEJveDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicGFyc2VTZWdtZW50SW5kZXhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwYXJzZVNlZ21lbnRJbmRleDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicGFyc2VJbml0U2VnbWVudFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhcnNlSW5pdFNlZ21lbnQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldFN0YXJ0RFRTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0U3RhcnREVFM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldER1cmF0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0RHVyYXRpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNvbXB1dGVSYXdEdXJhdGlvbkZyb21TYW1wbGVzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29tcHV0ZVJhd0R1cmF0aW9uRnJvbVNhbXBsZXM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm9mZnNldFN0YXJ0RFRTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb2Zmc2V0U3RhcnREVFM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNlZ21lbnRWYWxpZFJhbmdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VnbWVudFZhbGlkUmFuZ2U7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFwcGVuZFVpbnQ4QXJyYXlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhcHBlbmRVaW50OEFycmF5OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwYXJzZVNhbXBsZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwYXJzZVNhbXBsZXM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInBhcnNlU0VJTWVzc2FnZUZyb21OQUx1XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcGFyc2VTRUlNZXNzYWdlRnJvbU5BTHU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInBhcnNlRW1zZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhcnNlRW1zZzsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3R5cGVkLWFycmF5ICovIFwiLi9zcmMvdXRpbHMvdHlwZWQtYXJyYXkudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL2ZyYWdtZW50ICovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2lkMyAqLyBcIi4vc3JjL2RlbXV4L2lkMy50c1wiKTtcblxuXG5cbnZhciBVSU5UMzJfTUFYID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcbnZhciBwdXNoID0gW10ucHVzaDsgLy8gV2UgYXJlIHVzaW5nIGZpeGVkIHRyYWNrIElEcyBmb3IgZHJpdmluZyB0aGUgTVA0IHJlbXV4ZXJcbi8vIGluc3RlYWQgb2YgZm9sbG93aW5nIHRoZSBUUyBQSURzLlxuLy8gVGhlcmUgaXMgbm8gcmVhc29uIG5vdCB0byBkbyB0aGlzIGFuZCBzb21lIGJyb3dzZXJzL1NvdXJjZUJ1ZmZlci1kZW11eGVyc1xuLy8gbWF5IG5vdCBsaWtlIGlmIHRoZXJlIGFyZSBUcmFja0lEIFwic3dpdGNoZXNcIlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8xMzMxXG4vLyBIZXJlIHdlIGFyZSBtYXBwaW5nIG91ciBpbnRlcm5hbCB0cmFjayB0eXBlcyB0byBjb25zdGFudCBNUDQgdHJhY2sgSURzXG4vLyBXaXRoIE1TRSBjdXJyZW50bHkgb25lIGNhbiBvbmx5IGhhdmUgb25lIHRyYWNrIG9mIGVhY2gsIGFuZCB3ZSBhcmUgbXV4aW5nXG4vLyB3aGF0ZXZlciB2aWRlby9hdWRpbyByZW5kaXRpb24gaW4gdGhlbS5cblxudmFyIFJlbXV4ZXJUcmFja0lkQ29uZmlnID0ge1xuICB2aWRlbzogMSxcbiAgYXVkaW86IDIsXG4gIGlkMzogMyxcbiAgdGV4dDogNFxufTtcbmZ1bmN0aW9uIGJpbjJzdHIoZGF0YSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIHJlYWRVaW50MTYoYnVmZmVyLCBvZmZzZXQpIHtcbiAgdmFyIHZhbCA9IGJ1ZmZlcltvZmZzZXRdIDw8IDggfCBidWZmZXJbb2Zmc2V0ICsgMV07XG4gIHJldHVybiB2YWwgPCAwID8gNjU1MzYgKyB2YWwgOiB2YWw7XG59XG5mdW5jdGlvbiByZWFkVWludDMyKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIHZhciB2YWwgPSByZWFkU2ludDMyKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgcmV0dXJuIHZhbCA8IDAgPyA0Mjk0OTY3Mjk2ICsgdmFsIDogdmFsO1xufVxuZnVuY3Rpb24gcmVhZFNpbnQzMihidWZmZXIsIG9mZnNldCkge1xuICByZXR1cm4gYnVmZmVyW29mZnNldF0gPDwgMjQgfCBidWZmZXJbb2Zmc2V0ICsgMV0gPDwgMTYgfCBidWZmZXJbb2Zmc2V0ICsgMl0gPDwgOCB8IGJ1ZmZlcltvZmZzZXQgKyAzXTtcbn1cbmZ1bmN0aW9uIHdyaXRlVWludDMyKGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZSkge1xuICBidWZmZXJbb2Zmc2V0XSA9IHZhbHVlID4+IDI0O1xuICBidWZmZXJbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+PiAxNiAmIDB4ZmY7XG4gIGJ1ZmZlcltvZmZzZXQgKyAyXSA9IHZhbHVlID4+IDggJiAweGZmO1xuICBidWZmZXJbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDB4ZmY7XG59IC8vIEZpbmQgdGhlIGRhdGEgZm9yIGEgYm94IHNwZWNpZmllZCBieSBpdHMgcGF0aFxuXG5mdW5jdGlvbiBmaW5kQm94KGRhdGEsIHBhdGgpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICBpZiAoIXBhdGgubGVuZ3RoKSB7XG4gICAgLy8gc2hvcnQtY2lyY3VpdCB0aGUgc2VhcmNoIGZvciBlbXB0eSBwYXRoc1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgdmFyIGVuZCA9IGRhdGEuYnl0ZUxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDspIHtcbiAgICB2YXIgc2l6ZSA9IHJlYWRVaW50MzIoZGF0YSwgaSk7XG4gICAgdmFyIHR5cGUgPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkoaSArIDQsIGkgKyA4KSk7XG4gICAgdmFyIGVuZGJveCA9IHNpemUgPiAxID8gaSArIHNpemUgOiBlbmQ7XG5cbiAgICBpZiAodHlwZSA9PT0gcGF0aFswXSkge1xuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgcGF0aCBhbmQgd2UndmUgZm91bmQgdGhlIGJveCB3ZSB3ZXJlXG4gICAgICAgIC8vIGxvb2tpbmcgZm9yXG4gICAgICAgIHJlc3VsdHMucHVzaChkYXRhLnN1YmFycmF5KGkgKyA4LCBlbmRib3gpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgdGhlIG5leHQgYm94IGFsb25nIHRoZSBwYXRoXG4gICAgICAgIHZhciBzdWJyZXN1bHRzID0gZmluZEJveChkYXRhLnN1YmFycmF5KGkgKyA4LCBlbmRib3gpLCBwYXRoLnNsaWNlKDEpKTtcblxuICAgICAgICBpZiAoc3VicmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIHN1YnJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaSA9IGVuZGJveDtcbiAgfSAvLyB3ZSd2ZSBmaW5pc2hlZCBzZWFyY2hpbmcgYWxsIG9mIGRhdGFcblxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuZnVuY3Rpb24gcGFyc2VTZWdtZW50SW5kZXgoaW5pdFNlZ21lbnQpIHtcbiAgdmFyIG1vb3ZCb3ggPSBmaW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnXSk7XG4gIHZhciBtb292ID0gbW9vdkJveFswXTtcbiAgdmFyIG1vb3ZFbmRPZmZzZXQgPSBtb292ID8gbW9vdi5sZW5ndGggOiBudWxsOyAvLyB3ZSBuZWVkIHRoaXMgaW4gY2FzZSB3ZSBuZWVkIHRvIGNob3Agb2YgZ2FyYmFnZSBvZiB0aGUgZW5kIG9mIGN1cnJlbnQgZGF0YVxuXG4gIHZhciBzaWR4Qm94ID0gZmluZEJveChpbml0U2VnbWVudCwgWydzaWR4J10pO1xuXG4gIGlmICghc2lkeEJveCB8fCAhc2lkeEJveFswXSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHJlZmVyZW5jZXMgPSBbXTtcbiAgdmFyIHNpZHggPSBzaWR4Qm94WzBdO1xuICB2YXIgdmVyc2lvbiA9IHNpZHhbMF07IC8vIHNldCBpbml0aWFsIG9mZnNldCwgd2Ugc2tpcCB0aGUgcmVmZXJlbmNlIElEIChub3QgbmVlZGVkKVxuXG4gIHZhciBpbmRleCA9IDg7XG4gIHZhciB0aW1lc2NhbGUgPSByZWFkVWludDMyKHNpZHgsIGluZGV4KTtcbiAgaW5kZXggKz0gNDsgLy8gVE9ETzogcGFyc2UgZWFybGllc3RQcmVzZW50YXRpb25UaW1lIGFuZCBmaXJzdE9mZnNldFxuICAvLyB1c3VhbGx5IHplcm8gaW4gb3VyIGNhc2VcblxuICB2YXIgZWFybGllc3RQcmVzZW50YXRpb25UaW1lID0gMDtcbiAgdmFyIGZpcnN0T2Zmc2V0ID0gMDtcblxuICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgIGluZGV4ICs9IDg7XG4gIH0gZWxzZSB7XG4gICAgaW5kZXggKz0gMTY7XG4gIH0gLy8gc2tpcCByZXNlcnZlZFxuXG5cbiAgaW5kZXggKz0gMjtcbiAgdmFyIHN0YXJ0Qnl0ZSA9IHNpZHgubGVuZ3RoICsgZmlyc3RPZmZzZXQ7XG4gIHZhciByZWZlcmVuY2VzQ291bnQgPSByZWFkVWludDE2KHNpZHgsIGluZGV4KTtcbiAgaW5kZXggKz0gMjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZmVyZW5jZXNDb3VudDsgaSsrKSB7XG4gICAgdmFyIHJlZmVyZW5jZUluZGV4ID0gaW5kZXg7XG4gICAgdmFyIHJlZmVyZW5jZUluZm8gPSByZWFkVWludDMyKHNpZHgsIHJlZmVyZW5jZUluZGV4KTtcbiAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuICAgIHZhciByZWZlcmVuY2VTaXplID0gcmVmZXJlbmNlSW5mbyAmIDB4N2ZmZmZmZmY7XG4gICAgdmFyIHJlZmVyZW5jZVR5cGUgPSAocmVmZXJlbmNlSW5mbyAmIDB4ODAwMDAwMDApID4+PiAzMTtcblxuICAgIGlmIChyZWZlcmVuY2VUeXBlID09PSAxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKCdTSURYIGhhcyBoaWVyYXJjaGljYWwgcmVmZXJlbmNlcyAobm90IHN1cHBvcnRlZCknKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBzdWJzZWdtZW50RHVyYXRpb24gPSByZWFkVWludDMyKHNpZHgsIHJlZmVyZW5jZUluZGV4KTtcbiAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICByZWZlcmVuY2VTaXplOiByZWZlcmVuY2VTaXplLFxuICAgICAgc3Vic2VnbWVudER1cmF0aW9uOiBzdWJzZWdtZW50RHVyYXRpb24sXG4gICAgICAvLyB1bnNjYWxlZFxuICAgICAgaW5mbzoge1xuICAgICAgICBkdXJhdGlvbjogc3Vic2VnbWVudER1cmF0aW9uIC8gdGltZXNjYWxlLFxuICAgICAgICBzdGFydDogc3RhcnRCeXRlLFxuICAgICAgICBlbmQ6IHN0YXJ0Qnl0ZSArIHJlZmVyZW5jZVNpemUgLSAxXG4gICAgICB9XG4gICAgfSk7XG4gICAgc3RhcnRCeXRlICs9IHJlZmVyZW5jZVNpemU7IC8vIFNraXBwaW5nIDEgYml0IGZvciB8c3RhcnRzV2l0aFNhcHwsIDMgYml0cyBmb3IgfHNhcFR5cGV8LCBhbmQgMjggYml0c1xuICAgIC8vIGZvciB8c2FwRGVsdGF8LlxuXG4gICAgcmVmZXJlbmNlSW5kZXggKz0gNDsgLy8gc2tpcCB0byBuZXh0IHJlZlxuXG4gICAgaW5kZXggPSByZWZlcmVuY2VJbmRleDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZWFybGllc3RQcmVzZW50YXRpb25UaW1lOiBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUsXG4gICAgdGltZXNjYWxlOiB0aW1lc2NhbGUsXG4gICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICByZWZlcmVuY2VzQ291bnQ6IHJlZmVyZW5jZXNDb3VudCxcbiAgICByZWZlcmVuY2VzOiByZWZlcmVuY2VzLFxuICAgIG1vb3ZFbmRPZmZzZXQ6IG1vb3ZFbmRPZmZzZXRcbiAgfTtcbn1cbi8qKlxuICogUGFyc2VzIGFuIE1QNCBpbml0aWFsaXphdGlvbiBzZWdtZW50IGFuZCBleHRyYWN0cyBzdHJlYW0gdHlwZSBhbmRcbiAqIHRpbWVzY2FsZSB2YWx1ZXMgZm9yIGFueSBkZWNsYXJlZCB0cmFja3MuIFRpbWVzY2FsZSB2YWx1ZXMgaW5kaWNhdGUgdGhlXG4gKiBudW1iZXIgb2YgY2xvY2sgdGlja3MgcGVyIHNlY29uZCB0byBhc3N1bWUgZm9yIHRpbWUtYmFzZWQgdmFsdWVzXG4gKiBlbHNld2hlcmUgaW4gdGhlIE1QNC5cbiAqXG4gKiBUbyBkZXRlcm1pbmUgdGhlIHN0YXJ0IHRpbWUgb2YgYW4gTVA0LCB5b3UgbmVlZCB0d28gcGllY2VzIG9mXG4gKiBpbmZvcm1hdGlvbjogdGhlIHRpbWVzY2FsZSB1bml0IGFuZCB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGVcbiAqIHRpbWUuIE11bHRpcGxlIHRpbWVzY2FsZXMgY2FuIGJlIHNwZWNpZmllZCB3aXRoaW4gYW4gTVA0IGJ1dCB0aGVcbiAqIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgaXMgYWx3YXlzIGV4cHJlc3NlZCBpbiB0aGUgdGltZXNjYWxlIGZyb21cbiAqIHRoZSBtZWRpYSBoZWFkZXIgYm94IGZvciB0aGUgdHJhY2s6XG4gKiBgYGBcbiAqIG1vb3YgPiB0cmFrID4gbWRpYSA+IG1kaGQudGltZXNjYWxlXG4gKiBtb292ID4gdHJhayA+IG1kaWEgPiBoZGxyXG4gKiBgYGBcbiAqIEBwYXJhbSBpbml0U2VnbWVudCB7VWludDhBcnJheX0gdGhlIGJ5dGVzIG9mIHRoZSBpbml0IHNlZ21lbnRcbiAqIEByZXR1cm4ge0luaXREYXRhfSBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzIG9yIG51bGwgaWZcbiAqIHRoZSBpbml0IHNlZ21lbnQgaXMgbWFsZm9ybWVkLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgdHJha3MgPSBmaW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnLCAndHJhayddKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWtzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRyYWsgPSB0cmFrc1tpXTtcbiAgICB2YXIgdGtoZCA9IGZpbmRCb3godHJhaywgWyd0a2hkJ10pWzBdO1xuXG4gICAgaWYgKHRraGQpIHtcbiAgICAgIHZhciB2ZXJzaW9uID0gdGtoZFswXTtcblxuICAgICAgdmFyIF9pbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xuXG4gICAgICB2YXIgdHJhY2tJZCA9IHJlYWRVaW50MzIodGtoZCwgX2luZGV4KTtcbiAgICAgIHZhciBtZGhkID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWRoZCddKVswXTtcblxuICAgICAgaWYgKG1kaGQpIHtcbiAgICAgICAgdmVyc2lvbiA9IG1kaGRbMF07XG4gICAgICAgIF9pbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xuICAgICAgICB2YXIgdGltZXNjYWxlID0gcmVhZFVpbnQzMihtZGhkLCBfaW5kZXgpO1xuICAgICAgICB2YXIgaGRsciA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ2hkbHInXSlbMF07XG5cbiAgICAgICAgaWYgKGhkbHIpIHtcbiAgICAgICAgICB2YXIgaGRsclR5cGUgPSBiaW4yc3RyKGhkbHIuc3ViYXJyYXkoOCwgMTIpKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IHtcbiAgICAgICAgICAgIHNvdW46IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJTyxcbiAgICAgICAgICAgIHZpZGU6IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5WSURFT1xuICAgICAgICAgIH1baGRsclR5cGVdO1xuXG4gICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGNvZGVjIGRldGFpbHNcbiAgICAgICAgICAgIHZhciBzdHNkID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWluZicsICdzdGJsJywgJ3N0c2QnXSlbMF07XG4gICAgICAgICAgICB2YXIgY29kZWMgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChzdHNkKSB7XG4gICAgICAgICAgICAgIGNvZGVjID0gYmluMnN0cihzdHNkLnN1YmFycmF5KDEyLCAxNikpOyAvLyBUT0RPOiBQYXJzZSBjb2RlYyBkZXRhaWxzIHRvIGJlIGFibGUgdG8gYnVpbGQgTUlNRSB0eXBlLlxuICAgICAgICAgICAgICAvLyBzdHNkLnN0YXJ0ICs9IDg7XG4gICAgICAgICAgICAgIC8vIGNvbnN0IGNvZGVjQm94ID0gZmluZEJveChzdHNkLCBbY29kZWNdKVswXTtcbiAgICAgICAgICAgICAgLy8gaWYgKGNvZGVjQm94KSB7XG4gICAgICAgICAgICAgIC8vICAgVE9ETzogQ29kZWMgcGFyc2luZyBzdXBwb3J0IGZvciBhdmMxLCBtcDRhLCBoZXZjLCBhdjAxLi4uXG4gICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0W3RyYWNrSWRdID0ge1xuICAgICAgICAgICAgICB0aW1lc2NhbGU6IHRpbWVzY2FsZSxcbiAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFt0eXBlXSA9IHtcbiAgICAgICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGUsXG4gICAgICAgICAgICAgIGlkOiB0cmFja0lkLFxuICAgICAgICAgICAgICBjb2RlYzogY29kZWNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHRyZXggPSBmaW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnLCAnbXZleCcsICd0cmV4J10pO1xuICB0cmV4LmZvckVhY2goZnVuY3Rpb24gKHRyZXgpIHtcbiAgICB2YXIgdHJhY2tJZCA9IHJlYWRVaW50MzIodHJleCwgNCk7XG4gICAgdmFyIHRyYWNrID0gcmVzdWx0W3RyYWNrSWRdO1xuXG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5kZWZhdWx0ID0ge1xuICAgICAgICBkdXJhdGlvbjogcmVhZFVpbnQzMih0cmV4LCAxMiksXG4gICAgICAgIGZsYWdzOiByZWFkVWludDMyKHRyZXgsIDIwKVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHN0YXJ0IHRpbWUsIGluIHNlY29uZHMsIGZvciBhbiBNUDRcbiAqIGZyYWdtZW50LiBJZiBtdWx0aXBsZSBmcmFnbWVudHMgYXJlIHNwZWNpZmllZCwgdGhlIGVhcmxpZXN0IHRpbWUgaXNcbiAqIHJldHVybmVkLlxuICpcbiAqIFRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGNhbiBiZSBwYXJzZWQgZnJvbSB0cmFjayBmcmFnbWVudFxuICogbWV0YWRhdGE6XG4gKiBgYGBcbiAqIG1vb2YgPiB0cmFmID4gdGZkdC5iYXNlTWVkaWFEZWNvZGVUaW1lXG4gKiBgYGBcbiAqIEl0IHJlcXVpcmVzIHRoZSB0aW1lc2NhbGUgdmFsdWUgZnJvbSB0aGUgbWRoZCB0byBpbnRlcnByZXQuXG4gKlxuICogQHBhcmFtIGluaXREYXRhIHtJbml0RGF0YX0gYSBoYXNoIG9mIHRyYWNrIHR5cGUgdG8gdGltZXNjYWxlIHZhbHVlc1xuICogQHBhcmFtIGZtcDQge1VpbnQ4QXJyYXl9IHRoZSBieXRlcyBvZiB0aGUgbXA0IGZyYWdtZW50XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lIGZvciB0aGVcbiAqIGZyYWdtZW50LCBpbiBzZWNvbmRzXG4gKi9cblxuZnVuY3Rpb24gZ2V0U3RhcnREVFMoaW5pdERhdGEsIGZtcDQpIHtcbiAgLy8gd2UgbmVlZCBpbmZvIGZyb20gdHdvIGNoaWxkcmVuIG9mIGVhY2ggdHJhY2sgZnJhZ21lbnQgYm94XG4gIHJldHVybiBmaW5kQm94KGZtcDQsIFsnbW9vZicsICd0cmFmJ10pLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCB0cmFmKSB7XG4gICAgdmFyIHRmZHQgPSBmaW5kQm94KHRyYWYsIFsndGZkdCddKVswXTtcbiAgICB2YXIgdmVyc2lvbiA9IHRmZHRbMF07XG4gICAgdmFyIHN0YXJ0ID0gZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHRmaGQpIHtcbiAgICAgIC8vIGdldCB0aGUgdHJhY2sgaWQgZnJvbSB0aGUgdGZoZFxuICAgICAgdmFyIGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgIHZhciB0cmFjayA9IGluaXREYXRhW2lkXTtcblxuICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgIHZhciBiYXNlVGltZSA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG5cbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICBiYXNlVGltZSAqPSBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgYmFzZVRpbWUgKz0gcmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgfSAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuXG5cbiAgICAgICAgdmFyIHNjYWxlID0gdHJhY2sudGltZXNjYWxlIHx8IDkwZTM7IC8vIGNvbnZlcnQgYmFzZSB0aW1lIHRvIHNlY29uZHNcblxuICAgICAgICB2YXIgc3RhcnRUaW1lID0gYmFzZVRpbWUgLyBzY2FsZTtcblxuICAgICAgICBpZiAoaXNGaW5pdGUoc3RhcnRUaW1lKSAmJiAocmVzdWx0ID09PSBudWxsIHx8IHN0YXJ0VGltZSA8IHJlc3VsdCkpIHtcbiAgICAgICAgICByZXR1cm4gc3RhcnRUaW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgbnVsbCk7XG5cbiAgICBpZiAoc3RhcnQgIT09IG51bGwgJiYgaXNGaW5pdGUoc3RhcnQpICYmIChyZXN1bHQgPT09IG51bGwgfHwgc3RhcnQgPCByZXN1bHQpKSB7XG4gICAgICByZXR1cm4gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgbnVsbCkgfHwgMDtcbn1cbi8qXG4gIEZvciBSZWZlcmVuY2U6XG4gIGFsaWduZWQoOCkgY2xhc3MgVHJhY2tGcmFnbWVudEhlYWRlckJveFxuICAgICAgICAgICBleHRlbmRzIEZ1bGxCb3go4oCYdGZoZOKAmSwgMCwgdGZfZmxhZ3Mpe1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICB0cmFja19JRDtcbiAgICAgLy8gYWxsIHRoZSBmb2xsb3dpbmcgYXJlIG9wdGlvbmFsIGZpZWxkc1xuICAgICB1bnNpZ25lZCBpbnQoNjQpICBiYXNlX2RhdGFfb2Zmc2V0O1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfZGVzY3JpcHRpb25faW5kZXg7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uO1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBkZWZhdWx0X3NhbXBsZV9zaXplO1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBkZWZhdWx0X3NhbXBsZV9mbGFnc1xuICB9XG4gKi9cblxuZnVuY3Rpb24gZ2V0RHVyYXRpb24oZGF0YSwgaW5pdERhdGEpIHtcbiAgdmFyIHJhd0R1cmF0aW9uID0gMDtcbiAgdmFyIHZpZGVvRHVyYXRpb24gPSAwO1xuICB2YXIgYXVkaW9EdXJhdGlvbiA9IDA7XG4gIHZhciB0cmFmcyA9IGZpbmRCb3goZGF0YSwgWydtb29mJywgJ3RyYWYnXSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFmcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0cmFmID0gdHJhZnNbaV07IC8vIFRoZXJlIGlzIG9ubHkgb25lIHRmaGQgJiB0cnVuIHBlciB0cmFmXG4gICAgLy8gVGhpcyBpcyB0cnVlIGZvciBDTUFGIHN0eWxlIGNvbnRlbnQsIGFuZCB3ZSBzaG91bGQgcGVyaGFwcyBjaGVjayB0aGUgZnR5cFxuICAgIC8vIGFuZCBvbmx5IGxvb2sgZm9yIGEgc2luZ2xlIHRydW4gdGhlbiwgYnV0IGZvciBJU09CTUZGIHdlIHNob3VsZCBjaGVja1xuICAgIC8vIGZvciBtdWx0aXBsZSB0cmFjayBydW5zLlxuXG4gICAgdmFyIHRmaGQgPSBmaW5kQm94KHRyYWYsIFsndGZoZCddKVswXTsgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG5cbiAgICB2YXIgaWQgPSByZWFkVWludDMyKHRmaGQsIDQpO1xuICAgIHZhciB0cmFjayA9IGluaXREYXRhW2lkXTtcblxuICAgIGlmICghdHJhY2spIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciB0cmFja0RlZmF1bHQgPSB0cmFjay5kZWZhdWx0O1xuICAgIHZhciB0ZmhkRmxhZ3MgPSByZWFkVWludDMyKHRmaGQsIDApIHwgKHRyYWNrRGVmYXVsdCA9PT0gbnVsbCB8fCB0cmFja0RlZmF1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrRGVmYXVsdC5mbGFncyk7XG4gICAgdmFyIHNhbXBsZUR1cmF0aW9uID0gdHJhY2tEZWZhdWx0ID09PSBudWxsIHx8IHRyYWNrRGVmYXVsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhY2tEZWZhdWx0LmR1cmF0aW9uO1xuXG4gICAgaWYgKHRmaGRGbGFncyAmIDB4MDAwMDA4KSB7XG4gICAgICAvLyAweDAwMDAwOCBpbmRpY2F0ZXMgdGhlIHByZXNlbmNlIG9mIHRoZSBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiBmaWVsZFxuICAgICAgaWYgKHRmaGRGbGFncyAmIDB4MDAwMDAyKSB7XG4gICAgICAgIC8vIDB4MDAwMDAyIGluZGljYXRlcyB0aGUgcHJlc2VuY2Ugb2YgdGhlIHNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleCBmaWVsZCwgd2hpY2ggcHJlY2VkZXMgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb25cbiAgICAgICAgLy8gSWYgcHJlc2VudCwgdGhlIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uIGV4aXN0cyBhdCBieXRlIG9mZnNldCAxMlxuICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodGZoZCwgMTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgZHVyYXRpb24gaXMgYXQgYnl0ZSBvZmZzZXQgOFxuICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodGZoZCwgOCk7XG4gICAgICB9XG4gICAgfSAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuXG5cbiAgICB2YXIgdGltZXNjYWxlID0gdHJhY2sudGltZXNjYWxlIHx8IDkwZTM7XG4gICAgdmFyIHRydW5zID0gZmluZEJveCh0cmFmLCBbJ3RydW4nXSk7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRydW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICByYXdEdXJhdGlvbiA9IGNvbXB1dGVSYXdEdXJhdGlvbkZyb21TYW1wbGVzKHRydW5zW2pdKTtcblxuICAgICAgaWYgKCFyYXdEdXJhdGlvbiAmJiBzYW1wbGVEdXJhdGlvbikge1xuICAgICAgICB2YXIgc2FtcGxlQ291bnQgPSByZWFkVWludDMyKHRydW5zW2pdLCA0KTtcbiAgICAgICAgcmF3RHVyYXRpb24gPSBzYW1wbGVEdXJhdGlvbiAqIHNhbXBsZUNvdW50O1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhY2sudHlwZSA9PT0gX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRWxlbWVudGFyeVN0cmVhbVR5cGVzXCJdLlZJREVPKSB7XG4gICAgICAgIHZpZGVvRHVyYXRpb24gKz0gcmF3RHVyYXRpb24gLyB0aW1lc2NhbGU7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrLnR5cGUgPT09IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJTykge1xuICAgICAgICBhdWRpb0R1cmF0aW9uICs9IHJhd0R1cmF0aW9uIC8gdGltZXNjYWxlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh2aWRlb0R1cmF0aW9uID09PSAwICYmIGF1ZGlvRHVyYXRpb24gPT09IDApIHtcbiAgICAvLyBJZiBkdXJhdGlvbiBzYW1wbGVzIGFyZSBub3QgYXZhaWxhYmxlIGluIHRoZSB0cmFmIHVzZSBzaWR4IHN1YnNlZ21lbnRfZHVyYXRpb25cbiAgICB2YXIgc2lkeCA9IHBhcnNlU2VnbWVudEluZGV4KGRhdGEpO1xuXG4gICAgaWYgKHNpZHggIT09IG51bGwgJiYgc2lkeCAhPT0gdm9pZCAwICYmIHNpZHgucmVmZXJlbmNlcykge1xuICAgICAgcmV0dXJuIHNpZHgucmVmZXJlbmNlcy5yZWR1Y2UoZnVuY3Rpb24gKGR1ciwgcmVmKSB7XG4gICAgICAgIHJldHVybiBkdXIgKyByZWYuaW5mby5kdXJhdGlvbiB8fCAwO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHZpZGVvRHVyYXRpb24pIHtcbiAgICByZXR1cm4gdmlkZW9EdXJhdGlvbjtcbiAgfVxuXG4gIHJldHVybiBhdWRpb0R1cmF0aW9uO1xufVxuLypcbiAgRm9yIFJlZmVyZW5jZTpcbiAgYWxpZ25lZCg4KSBjbGFzcyBUcmFja1J1bkJveFxuICAgICAgICAgICBleHRlbmRzIEZ1bGxCb3go4oCYdHJ1buKAmSwgdmVyc2lvbiwgdHJfZmxhZ3MpIHtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX2NvdW50O1xuICAgICAvLyB0aGUgZm9sbG93aW5nIGFyZSBvcHRpb25hbCBmaWVsZHNcbiAgICAgc2lnbmVkIGludCgzMikgZGF0YV9vZmZzZXQ7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIGZpcnN0X3NhbXBsZV9mbGFncztcbiAgICAgLy8gYWxsIGZpZWxkcyBpbiB0aGUgZm9sbG93aW5nIGFycmF5IGFyZSBvcHRpb25hbFxuICAgICB7XG4gICAgICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9kdXJhdGlvbjtcbiAgICAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX3NpemU7XG4gICAgICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9mbGFnc1xuICAgICAgICBpZiAodmVyc2lvbiA9PSAwKVxuICAgICAgICAgICB7IHVuc2lnbmVkIGludCgzMilcbiAgICAgICAgZWxzZVxuICAgICAgICAgICB7IHNpZ25lZCBpbnQoMzIpXG4gICAgIH1bIHNhbXBsZV9jb3VudCBdXG4gIH1cbiAqL1xuXG5mdW5jdGlvbiBjb21wdXRlUmF3RHVyYXRpb25Gcm9tU2FtcGxlcyh0cnVuKSB7XG4gIHZhciBmbGFncyA9IHJlYWRVaW50MzIodHJ1biwgMCk7IC8vIEZsYWdzIGFyZSBhdCBvZmZzZXQgMCwgbm9uLW9wdGlvbmFsIHNhbXBsZV9jb3VudCBpcyBhdCBvZmZzZXQgNC4gVGhlcmVmb3JlIHdlIHN0YXJ0IDggYnl0ZXMgaW4uXG4gIC8vIEVhY2ggZmllbGQgaXMgYW4gaW50MzIsIHdoaWNoIGlzIDQgYnl0ZXNcblxuICB2YXIgb2Zmc2V0ID0gODsgLy8gZGF0YS1vZmZzZXQtcHJlc2VudCBmbGFnXG5cbiAgaWYgKGZsYWdzICYgMHgwMDAwMDEpIHtcbiAgICBvZmZzZXQgKz0gNDtcbiAgfSAvLyBmaXJzdC1zYW1wbGUtZmxhZ3MtcHJlc2VudCBmbGFnXG5cblxuICBpZiAoZmxhZ3MgJiAweDAwMDAwNCkge1xuICAgIG9mZnNldCArPSA0O1xuICB9XG5cbiAgdmFyIGR1cmF0aW9uID0gMDtcbiAgdmFyIHNhbXBsZUNvdW50ID0gcmVhZFVpbnQzMih0cnVuLCA0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZUNvdW50OyBpKyspIHtcbiAgICAvLyBzYW1wbGUtZHVyYXRpb24tcHJlc2VudCBmbGFnXG4gICAgaWYgKGZsYWdzICYgMHgwMDAxMDApIHtcbiAgICAgIHZhciBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodHJ1biwgb2Zmc2V0KTtcbiAgICAgIGR1cmF0aW9uICs9IHNhbXBsZUR1cmF0aW9uO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfSAvLyBzYW1wbGUtc2l6ZS1wcmVzZW50IGZsYWdcblxuXG4gICAgaWYgKGZsYWdzICYgMHgwMDAyMDApIHtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH0gLy8gc2FtcGxlLWZsYWdzLXByZXNlbnQgZmxhZ1xuXG5cbiAgICBpZiAoZmxhZ3MgJiAweDAwMDQwMCkge1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfSAvLyBzYW1wbGUtY29tcG9zaXRpb24tdGltZS1vZmZzZXRzLXByZXNlbnQgZmxhZ1xuXG5cbiAgICBpZiAoZmxhZ3MgJiAweDAwMDgwMCkge1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGR1cmF0aW9uO1xufVxuZnVuY3Rpb24gb2Zmc2V0U3RhcnREVFMoaW5pdERhdGEsIGZtcDQsIHRpbWVPZmZzZXQpIHtcbiAgZmluZEJveChmbXA0LCBbJ21vb2YnLCAndHJhZiddKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFmKSB7XG4gICAgZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkuZm9yRWFjaChmdW5jdGlvbiAodGZoZCkge1xuICAgICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgICB2YXIgaWQgPSByZWFkVWludDMyKHRmaGQsIDQpO1xuICAgICAgdmFyIHRyYWNrID0gaW5pdERhdGFbaWRdO1xuXG4gICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcblxuXG4gICAgICB2YXIgdGltZXNjYWxlID0gdHJhY2sudGltZXNjYWxlIHx8IDkwZTM7IC8vIGdldCB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBmcm9tIHRoZSB0ZmR0XG5cbiAgICAgIGZpbmRCb3godHJhZiwgWyd0ZmR0J10pLmZvckVhY2goZnVuY3Rpb24gKHRmZHQpIHtcbiAgICAgICAgdmFyIHZlcnNpb24gPSB0ZmR0WzBdO1xuICAgICAgICB2YXIgYmFzZU1lZGlhRGVjb2RlVGltZSA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG5cbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lIC09IHRpbWVPZmZzZXQgKiB0aW1lc2NhbGU7XG4gICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGgubWF4KGJhc2VNZWRpYURlY29kZVRpbWUsIDApO1xuICAgICAgICAgIHdyaXRlVWludDMyKHRmZHQsIDQsIGJhc2VNZWRpYURlY29kZVRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgKj0gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgKz0gcmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lIC09IHRpbWVPZmZzZXQgKiB0aW1lc2NhbGU7XG4gICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGgubWF4KGJhc2VNZWRpYURlY29kZVRpbWUsIDApO1xuICAgICAgICAgIHZhciB1cHBlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgICAgIHZhciBsb3dlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgICAgIHdyaXRlVWludDMyKHRmZHQsIDQsIHVwcGVyKTtcbiAgICAgICAgICB3cml0ZVVpbnQzMih0ZmR0LCA4LCBsb3dlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0gLy8gVE9ETzogQ2hlY2sgaWYgdGhlIGxhc3QgbW9vZittZGF0IHBhaXIgaXMgcGFydCBvZiB0aGUgdmFsaWQgcmFuZ2VcblxuZnVuY3Rpb24gc2VnbWVudFZhbGlkUmFuZ2UoZGF0YSkge1xuICB2YXIgc2VnbWVudGVkUmFuZ2UgPSB7XG4gICAgdmFsaWQ6IG51bGwsXG4gICAgcmVtYWluZGVyOiBudWxsXG4gIH07XG4gIHZhciBtb29mcyA9IGZpbmRCb3goZGF0YSwgWydtb29mJ10pO1xuXG4gIGlmICghbW9vZnMpIHtcbiAgICByZXR1cm4gc2VnbWVudGVkUmFuZ2U7XG4gIH0gZWxzZSBpZiAobW9vZnMubGVuZ3RoIDwgMikge1xuICAgIHNlZ21lbnRlZFJhbmdlLnJlbWFpbmRlciA9IGRhdGE7XG4gICAgcmV0dXJuIHNlZ21lbnRlZFJhbmdlO1xuICB9XG5cbiAgdmFyIGxhc3QgPSBtb29mc1ttb29mcy5sZW5ndGggLSAxXTsgLy8gT2Zmc2V0IGJ5IDggYnl0ZXM7IGZpbmRCb3ggb2Zmc2V0cyB0aGUgc3RhcnQgYnkgYXMgbXVjaFxuXG4gIHNlZ21lbnRlZFJhbmdlLnZhbGlkID0gT2JqZWN0KF90eXBlZF9hcnJheV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wic2xpY2VVaW50OFwiXSkoZGF0YSwgMCwgbGFzdC5ieXRlT2Zmc2V0IC0gOCk7XG4gIHNlZ21lbnRlZFJhbmdlLnJlbWFpbmRlciA9IE9iamVjdChfdHlwZWRfYXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInNsaWNlVWludDhcIl0pKGRhdGEsIGxhc3QuYnl0ZU9mZnNldCAtIDgpO1xuICByZXR1cm4gc2VnbWVudGVkUmFuZ2U7XG59XG5mdW5jdGlvbiBhcHBlbmRVaW50OEFycmF5KGRhdGExLCBkYXRhMikge1xuICB2YXIgdGVtcCA9IG5ldyBVaW50OEFycmF5KGRhdGExLmxlbmd0aCArIGRhdGEyLmxlbmd0aCk7XG4gIHRlbXAuc2V0KGRhdGExKTtcbiAgdGVtcC5zZXQoZGF0YTIsIGRhdGExLmxlbmd0aCk7XG4gIHJldHVybiB0ZW1wO1xufVxuZnVuY3Rpb24gcGFyc2VTYW1wbGVzKHRpbWVPZmZzZXQsIHRyYWNrKSB7XG4gIHZhciBzZWlTYW1wbGVzID0gW107XG4gIHZhciB2aWRlb0RhdGEgPSB0cmFjay5zYW1wbGVzO1xuICB2YXIgdGltZXNjYWxlID0gdHJhY2sudGltZXNjYWxlO1xuICB2YXIgdHJhY2tJZCA9IHRyYWNrLmlkO1xuICB2YXIgaXNIRVZDRmxhdm9yID0gZmFsc2U7XG4gIHZhciBtb29mcyA9IGZpbmRCb3godmlkZW9EYXRhLCBbJ21vb2YnXSk7XG4gIG1vb2ZzLm1hcChmdW5jdGlvbiAobW9vZikge1xuICAgIHZhciBtb29mT2Zmc2V0ID0gbW9vZi5ieXRlT2Zmc2V0IC0gODtcbiAgICB2YXIgdHJhZnMgPSBmaW5kQm94KG1vb2YsIFsndHJhZiddKTtcbiAgICB0cmFmcy5tYXAoZnVuY3Rpb24gKHRyYWYpIHtcbiAgICAgIC8vIGdldCB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBmcm9tIHRoZSB0ZmR0XG4gICAgICB2YXIgYmFzZVRpbWUgPSBmaW5kQm94KHRyYWYsIFsndGZkdCddKS5tYXAoZnVuY3Rpb24gKHRmZHQpIHtcbiAgICAgICAgdmFyIHZlcnNpb24gPSB0ZmR0WzBdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVhZFVpbnQzMih0ZmR0LCA0KTtcblxuICAgICAgICBpZiAodmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgIHJlc3VsdCAqPSBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgcmVzdWx0ICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0IC8gdGltZXNjYWxlO1xuICAgICAgfSlbMF07XG5cbiAgICAgIGlmIChiYXNlVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRpbWVPZmZzZXQgPSBiYXNlVGltZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLm1hcChmdW5jdGlvbiAodGZoZCkge1xuICAgICAgICB2YXIgaWQgPSByZWFkVWludDMyKHRmaGQsIDQpO1xuICAgICAgICB2YXIgdGZoZEZsYWdzID0gcmVhZFVpbnQzMih0ZmhkLCAwKSAmIDB4ZmZmZmZmO1xuICAgICAgICB2YXIgYmFzZURhdGFPZmZzZXRQcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDAxKSAhPT0gMDtcbiAgICAgICAgdmFyIHNhbXBsZURlc2NyaXB0aW9uSW5kZXhQcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDAyKSAhPT0gMDtcbiAgICAgICAgdmFyIGRlZmF1bHRTYW1wbGVEdXJhdGlvblByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMDgpICE9PSAwO1xuICAgICAgICB2YXIgZGVmYXVsdFNhbXBsZUR1cmF0aW9uID0gMDtcbiAgICAgICAgdmFyIGRlZmF1bHRTYW1wbGVTaXplUHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAxMCkgIT09IDA7XG4gICAgICAgIHZhciBkZWZhdWx0U2FtcGxlU2l6ZSA9IDA7XG4gICAgICAgIHZhciBkZWZhdWx0U2FtcGxlRmxhZ3NQcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDIwKSAhPT0gMDtcbiAgICAgICAgdmFyIHRmaGRPZmZzZXQgPSA4O1xuXG4gICAgICAgIGlmIChpZCA9PT0gdHJhY2tJZCkge1xuICAgICAgICAgIGlmIChiYXNlRGF0YU9mZnNldFByZXNlbnQpIHtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gODtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2FtcGxlRGVzY3JpcHRpb25JbmRleFByZXNlbnQpIHtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGVmYXVsdFNhbXBsZUR1cmF0aW9uUHJlc2VudCkge1xuICAgICAgICAgICAgZGVmYXVsdFNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0ZmhkLCB0ZmhkT2Zmc2V0KTtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGVmYXVsdFNhbXBsZVNpemVQcmVzZW50KSB7XG4gICAgICAgICAgICBkZWZhdWx0U2FtcGxlU2l6ZSA9IHJlYWRVaW50MzIodGZoZCwgdGZoZE9mZnNldCk7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRlZmF1bHRTYW1wbGVGbGFnc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHJhY2sudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgaXNIRVZDRmxhdm9yID0gaXNIRVZDKHRyYWNrLmNvZGVjKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaW5kQm94KHRyYWYsIFsndHJ1biddKS5tYXAoZnVuY3Rpb24gKHRydW4pIHtcbiAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gdHJ1blswXTtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IHJlYWRVaW50MzIodHJ1biwgMCkgJiAweGZmZmZmZjtcbiAgICAgICAgICAgIHZhciBkYXRhT2Zmc2V0UHJlc2VudCA9IChmbGFncyAmIDB4MDAwMDAxKSAhPT0gMDtcbiAgICAgICAgICAgIHZhciBkYXRhT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHZhciBmaXJzdFNhbXBsZUZsYWdzUHJlc2VudCA9IChmbGFncyAmIDB4MDAwMDA0KSAhPT0gMDtcbiAgICAgICAgICAgIHZhciBzYW1wbGVEdXJhdGlvblByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDEwMCkgIT09IDA7XG4gICAgICAgICAgICB2YXIgc2FtcGxlRHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgdmFyIHNhbXBsZVNpemVQcmVzZW50ID0gKGZsYWdzICYgMHgwMDAyMDApICE9PSAwO1xuICAgICAgICAgICAgdmFyIHNhbXBsZVNpemUgPSAwO1xuICAgICAgICAgICAgdmFyIHNhbXBsZUZsYWdzUHJlc2VudCA9IChmbGFncyAmIDB4MDAwNDAwKSAhPT0gMDtcbiAgICAgICAgICAgIHZhciBzYW1wbGVDb21wb3NpdGlvbk9mZnNldHNQcmVzZW50ID0gKGZsYWdzICYgMHgwMDA4MDApICE9PSAwO1xuICAgICAgICAgICAgdmFyIGNvbXBvc2l0aW9uT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHZhciBzYW1wbGVDb3VudCA9IHJlYWRVaW50MzIodHJ1biwgNCk7XG4gICAgICAgICAgICB2YXIgdHJ1bk9mZnNldCA9IDg7IC8vIHBhc3QgdmVyc2lvbiwgZmxhZ3MsIGFuZCBzYW1wbGUgY291bnRcblxuICAgICAgICAgICAgaWYgKGRhdGFPZmZzZXRQcmVzZW50KSB7XG4gICAgICAgICAgICAgIGRhdGFPZmZzZXQgPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaXJzdFNhbXBsZUZsYWdzUHJlc2VudCkge1xuICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzYW1wbGVPZmZzZXQgPSBkYXRhT2Zmc2V0ICsgbW9vZk9mZnNldDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaXggPSAwOyBpeCA8IHNhbXBsZUNvdW50OyBpeCsrKSB7XG4gICAgICAgICAgICAgIGlmIChzYW1wbGVEdXJhdGlvblByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gZGVmYXVsdFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHNhbXBsZVNpemVQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgc2FtcGxlU2l6ZSA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNhbXBsZVNpemUgPSBkZWZhdWx0U2FtcGxlU2l6ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChzYW1wbGVGbGFnc1ByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoc2FtcGxlQ29tcG9zaXRpb25PZmZzZXRzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb21wb3NpdGlvbk9mZnNldCA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uT2Zmc2V0ID0gcmVhZFNpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodHJhY2sudHlwZSA9PT0gX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRWxlbWVudGFyeVN0cmVhbVR5cGVzXCJdLlZJREVPKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbHVUb3RhbFNpemUgPSAwO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5hbHVUb3RhbFNpemUgPCBzYW1wbGVTaXplKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbmFsdVNpemUgPSByZWFkVWludDMyKHZpZGVvRGF0YSwgc2FtcGxlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgIHNhbXBsZU9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgICAgdmFyIG5hbHVUeXBlID0gdmlkZW9EYXRhW3NhbXBsZU9mZnNldF0gJiAweDFmO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoaXNTRUlNZXNzYWdlKGlzSEVWQ0ZsYXZvciwgbmFsdVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdmlkZW9EYXRhLnN1YmFycmF5KHNhbXBsZU9mZnNldCwgc2FtcGxlT2Zmc2V0ICsgbmFsdVNpemUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdShkYXRhLCB0aW1lT2Zmc2V0ICsgY29tcG9zaXRpb25PZmZzZXQgLyB0aW1lc2NhbGUsIHNlaVNhbXBsZXMpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBzYW1wbGVPZmZzZXQgKz0gbmFsdVNpemU7XG4gICAgICAgICAgICAgICAgICBuYWx1VG90YWxTaXplICs9IG5hbHVTaXplICsgNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aW1lT2Zmc2V0ICs9IHNhbXBsZUR1cmF0aW9uIC8gdGltZXNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzZWlTYW1wbGVzO1xufVxuXG5mdW5jdGlvbiBpc0hFVkMoY29kZWMpIHtcbiAgaWYgKCFjb2RlYykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBkZWxpbWl0ID0gY29kZWMuaW5kZXhPZignLicpO1xuICB2YXIgYmFzZUNvZGVjID0gZGVsaW1pdCA8IDAgPyBjb2RlYyA6IGNvZGVjLnN1YnN0cmluZygwLCBkZWxpbWl0KTtcbiAgcmV0dXJuIGJhc2VDb2RlYyA9PT0gJ2h2YzEnIHx8IGJhc2VDb2RlYyA9PT0gJ2hldjEnIHx8IC8vIERvbGJ5IFZpc2lvblxuICBiYXNlQ29kZWMgPT09ICdkdmgxJyB8fCBiYXNlQ29kZWMgPT09ICdkdmhlJztcbn1cblxuZnVuY3Rpb24gaXNTRUlNZXNzYWdlKGlzSEVWQ0ZsYXZvciwgbmFsdVR5cGUpIHtcbiAgcmV0dXJuIGlzSEVWQ0ZsYXZvciA/IG5hbHVUeXBlID09PSAzOSB8fCBuYWx1VHlwZSA9PT0gNDAgOiBuYWx1VHlwZSA9PT0gNjtcbn1cblxuZnVuY3Rpb24gcGFyc2VTRUlNZXNzYWdlRnJvbU5BTHUodW5lc2NhcGVkRGF0YSwgcHRzLCBzYW1wbGVzKSB7XG4gIHZhciBkYXRhID0gZGlzY2FyZEVQQih1bmVzY2FwZWREYXRhKTtcbiAgdmFyIHNlaVB0ciA9IDA7IC8vIHNraXAgZnJhbWVUeXBlXG5cbiAgc2VpUHRyKys7XG4gIHZhciBwYXlsb2FkVHlwZSA9IDA7XG4gIHZhciBwYXlsb2FkU2l6ZSA9IDA7XG4gIHZhciBlbmRPZkNhcHRpb25zID0gZmFsc2U7XG4gIHZhciBiID0gMDtcblxuICB3aGlsZSAoc2VpUHRyIDwgZGF0YS5sZW5ndGgpIHtcbiAgICBwYXlsb2FkVHlwZSA9IDA7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoc2VpUHRyID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBiID0gZGF0YVtzZWlQdHIrK107XG4gICAgICBwYXlsb2FkVHlwZSArPSBiO1xuICAgIH0gd2hpbGUgKGIgPT09IDB4ZmYpOyAvLyBQYXJzZSBwYXlsb2FkIHNpemUuXG5cblxuICAgIHBheWxvYWRTaXplID0gMDtcblxuICAgIGRvIHtcbiAgICAgIGlmIChzZWlQdHIgPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGIgPSBkYXRhW3NlaVB0cisrXTtcbiAgICAgIHBheWxvYWRTaXplICs9IGI7XG4gICAgfSB3aGlsZSAoYiA9PT0gMHhmZik7XG5cbiAgICB2YXIgbGVmdE92ZXIgPSBkYXRhLmxlbmd0aCAtIHNlaVB0cjtcblxuICAgIGlmICghZW5kT2ZDYXB0aW9ucyAmJiBwYXlsb2FkVHlwZSA9PT0gNCAmJiBzZWlQdHIgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgZW5kT2ZDYXB0aW9ucyA9IHRydWU7XG4gICAgICB2YXIgY291bnRyeUNvZGUgPSBkYXRhW3NlaVB0cisrXTtcblxuICAgICAgaWYgKGNvdW50cnlDb2RlID09PSAxODEpIHtcbiAgICAgICAgdmFyIHByb3ZpZGVyQ29kZSA9IHJlYWRVaW50MTYoZGF0YSwgc2VpUHRyKTtcbiAgICAgICAgc2VpUHRyICs9IDI7XG5cbiAgICAgICAgaWYgKHByb3ZpZGVyQ29kZSA9PT0gNDkpIHtcbiAgICAgICAgICB2YXIgdXNlclN0cnVjdHVyZSA9IHJlYWRVaW50MzIoZGF0YSwgc2VpUHRyKTtcbiAgICAgICAgICBzZWlQdHIgKz0gNDtcblxuICAgICAgICAgIGlmICh1c2VyU3RydWN0dXJlID09PSAweDQ3NDEzOTM0KSB7XG4gICAgICAgICAgICB2YXIgdXNlckRhdGFUeXBlID0gZGF0YVtzZWlQdHIrK107IC8vIFJhdyBDRUEtNjA4IGJ5dGVzIHdyYXBwZWQgaW4gQ0VBLTcwOCBwYWNrZXRcblxuICAgICAgICAgICAgaWYgKHVzZXJEYXRhVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICB2YXIgZmlyc3RCeXRlID0gZGF0YVtzZWlQdHIrK107XG4gICAgICAgICAgICAgIHZhciB0b3RhbENDcyA9IDB4MWYgJiBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgIHZhciBlbmFibGVkID0gMHg0MCAmIGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgdmFyIHRvdGFsQnl0ZXMgPSBlbmFibGVkID8gMiArIHRvdGFsQ0NzICogMyA6IDA7XG4gICAgICAgICAgICAgIHZhciBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheSh0b3RhbEJ5dGVzKTtcblxuICAgICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGJ5dGVBcnJheVswXSA9IGZpcnN0Qnl0ZTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdG90YWxCeXRlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBieXRlQXJyYXlbaV0gPSBkYXRhW3NlaVB0cisrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IHVzZXJEYXRhVHlwZSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkVHlwZTogcGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgcHRzOiBwdHMsXG4gICAgICAgICAgICAgICAgYnl0ZXM6IGJ5dGVBcnJheVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBheWxvYWRUeXBlID09PSA1ICYmIHBheWxvYWRTaXplIDwgbGVmdE92ZXIpIHtcbiAgICAgIGVuZE9mQ2FwdGlvbnMgPSB0cnVlO1xuXG4gICAgICBpZiAocGF5bG9hZFNpemUgPiAxNikge1xuICAgICAgICB2YXIgdXVpZFN0ckFycmF5ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IDE2OyBfaSsrKSB7XG4gICAgICAgICAgdmFyIF9iID0gZGF0YVtzZWlQdHIrK10udG9TdHJpbmcoMTYpO1xuXG4gICAgICAgICAgdXVpZFN0ckFycmF5LnB1c2goX2IubGVuZ3RoID09IDEgPyAnMCcgKyBfYiA6IF9iKTtcblxuICAgICAgICAgIGlmIChfaSA9PT0gMyB8fCBfaSA9PT0gNSB8fCBfaSA9PT0gNyB8fCBfaSA9PT0gOSkge1xuICAgICAgICAgICAgdXVpZFN0ckFycmF5LnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gcGF5bG9hZFNpemUgLSAxNjtcbiAgICAgICAgdmFyIHVzZXJEYXRhQnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB1c2VyRGF0YUJ5dGVzW19pMl0gPSBkYXRhW3NlaVB0cisrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgcGF5bG9hZFR5cGU6IHBheWxvYWRUeXBlLFxuICAgICAgICAgIHB0czogcHRzLFxuICAgICAgICAgIHV1aWQ6IHV1aWRTdHJBcnJheS5qb2luKCcnKSxcbiAgICAgICAgICB1c2VyRGF0YTogT2JqZWN0KF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcInV0ZjhBcnJheVRvU3RyXCJdKSh1c2VyRGF0YUJ5dGVzKSxcbiAgICAgICAgICB1c2VyRGF0YUJ5dGVzOiB1c2VyRGF0YUJ5dGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF5bG9hZFNpemUgPCBsZWZ0T3Zlcikge1xuICAgICAgc2VpUHRyICs9IHBheWxvYWRTaXplO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZFNpemUgPiBsZWZ0T3Zlcikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIHJlbW92ZSBFbXVsYXRpb24gUHJldmVudGlvbiBieXRlcyBmcm9tIGEgUkJTUFxuICovXG5cbmZ1bmN0aW9uIGRpc2NhcmRFUEIoZGF0YSkge1xuICB2YXIgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICB2YXIgRVBCUG9zaXRpb25zID0gW107XG4gIHZhciBpID0gMTsgLy8gRmluZCBhbGwgYEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzYFxuXG4gIHdoaWxlIChpIDwgbGVuZ3RoIC0gMikge1xuICAgIGlmIChkYXRhW2ldID09PSAwICYmIGRhdGFbaSArIDFdID09PSAwICYmIGRhdGFbaSArIDJdID09PSAweDAzKSB7XG4gICAgICBFUEJQb3NpdGlvbnMucHVzaChpICsgMik7XG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICB9XG4gIH0gLy8gSWYgbm8gRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXMgd2VyZSBmb3VuZCBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWxcbiAgLy8gYXJyYXlcblxuXG4gIGlmIChFUEJQb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIGhvbGQgdGhlIE5BTCB1bml0IGRhdGFcblxuXG4gIHZhciBuZXdMZW5ndGggPSBsZW5ndGggLSBFUEJQb3NpdGlvbnMubGVuZ3RoO1xuICB2YXIgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG4gIHZhciBzb3VyY2VJbmRleCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IG5ld0xlbmd0aDsgc291cmNlSW5kZXgrKywgaSsrKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4ID09PSBFUEJQb3NpdGlvbnNbMF0pIHtcbiAgICAgIC8vIFNraXAgdGhpcyBieXRlXG4gICAgICBzb3VyY2VJbmRleCsrOyAvLyBSZW1vdmUgdGhpcyBwb3NpdGlvbiBpbmRleFxuXG4gICAgICBFUEJQb3NpdGlvbnMuc2hpZnQoKTtcbiAgICB9XG5cbiAgICBuZXdEYXRhW2ldID0gZGF0YVtzb3VyY2VJbmRleF07XG4gIH1cblxuICByZXR1cm4gbmV3RGF0YTtcbn1cblxuZnVuY3Rpb24gcGFyc2VFbXNnKGRhdGEpIHtcbiAgdmFyIHZlcnNpb24gPSBkYXRhWzBdO1xuICB2YXIgc2NoZW1lSWRVcmkgPSAnJztcbiAgdmFyIHZhbHVlID0gJyc7XG4gIHZhciB0aW1lU2NhbGUgPSAwO1xuICB2YXIgcHJlc2VudGF0aW9uVGltZURlbHRhID0gMDtcbiAgdmFyIHByZXNlbnRhdGlvblRpbWUgPSAwO1xuICB2YXIgZXZlbnREdXJhdGlvbiA9IDA7XG4gIHZhciBpZCA9IDA7XG4gIHZhciBvZmZzZXQgPSAwO1xuXG4gIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cblxuICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICBvZmZzZXQgKz0gMTtcblxuICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG5cbiAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgb2Zmc2V0ICs9IDE7XG4gICAgdGltZVNjYWxlID0gcmVhZFVpbnQzMihkYXRhLCAxMik7XG4gICAgcHJlc2VudGF0aW9uVGltZURlbHRhID0gcmVhZFVpbnQzMihkYXRhLCAxNik7XG4gICAgZXZlbnREdXJhdGlvbiA9IHJlYWRVaW50MzIoZGF0YSwgMjApO1xuICAgIGlkID0gcmVhZFVpbnQzMihkYXRhLCAyNCk7XG4gICAgb2Zmc2V0ID0gMjg7XG4gIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gMSkge1xuICAgIG9mZnNldCArPSA0O1xuICAgIHRpbWVTY2FsZSA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB2YXIgbGVmdFByZXNlbnRhdGlvblRpbWUgPSByZWFkVWludDMyKGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgdmFyIHJpZ2h0UHJlc2VudGF0aW9uVGltZSA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBwcmVzZW50YXRpb25UaW1lID0gTWF0aC5wb3coMiwgMzIpICogbGVmdFByZXNlbnRhdGlvblRpbWUgKyByaWdodFByZXNlbnRhdGlvblRpbWU7XG5cbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHByZXNlbnRhdGlvblRpbWUpKSB7XG4gICAgICBwcmVzZW50YXRpb25UaW1lID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cbiAgICAgIGNvbnNvbGUud2FybignUHJlc2VudGF0aW9uIHRpbWUgZXhjZWVkcyBzYWZlIGludGVnZXIgbGltaXQgYW5kIHdyYXBwZWQgdG8gbWF4IHNhZmUgaW50ZWdlciBpbiBwYXJzaW5nIGVtc2cgYm94Jyk7XG4gICAgfVxuXG4gICAgZXZlbnREdXJhdGlvbiA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBpZCA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcblxuICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICBzY2hlbWVJZFVyaSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG5cbiAgICBzY2hlbWVJZFVyaSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgb2Zmc2V0ICs9IDE7XG5cbiAgICB3aGlsZSAoYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpICE9PSAnXFwwJykge1xuICAgICAgdmFsdWUgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgfVxuXG4gICAgdmFsdWUgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgIG9mZnNldCArPSAxO1xuICB9XG5cbiAgdmFyIHBheWxvYWQgPSBkYXRhLnN1YmFycmF5KG9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHtcbiAgICBzY2hlbWVJZFVyaTogc2NoZW1lSWRVcmksXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIHRpbWVTY2FsZTogdGltZVNjYWxlLFxuICAgIHByZXNlbnRhdGlvblRpbWU6IHByZXNlbnRhdGlvblRpbWUsXG4gICAgcHJlc2VudGF0aW9uVGltZURlbHRhOiBwcmVzZW50YXRpb25UaW1lRGVsdGEsXG4gICAgZXZlbnREdXJhdGlvbjogZXZlbnREdXJhdGlvbixcbiAgICBpZDogaWQsXG4gICAgcGF5bG9hZDogcGF5bG9hZFxuICB9O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9vdXRwdXQtZmlsdGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvb3V0cHV0LWZpbHRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIE91dHB1dEZpbHRlcjsgfSk7XG52YXIgT3V0cHV0RmlsdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT3V0cHV0RmlsdGVyKHRpbWVsaW5lQ29udHJvbGxlciwgdHJhY2tOYW1lKSB7XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jdWVSYW5nZXMgPSBbXTtcbiAgICB0aGlzLnRyYWNrTmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy5lbmRUaW1lID0gbnVsbDtcbiAgICB0aGlzLnNjcmVlbiA9IG51bGw7XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSB0aW1lbGluZUNvbnRyb2xsZXI7XG4gICAgdGhpcy50cmFja05hbWUgPSB0cmFja05hbWU7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT3V0cHV0RmlsdGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGlzcGF0Y2hDdWUgPSBmdW5jdGlvbiBkaXNwYXRjaEN1ZSgpIHtcbiAgICBpZiAodGhpcy5zdGFydFRpbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlci5hZGRDdWVzKHRoaXMudHJhY2tOYW1lLCB0aGlzLnN0YXJ0VGltZSwgdGhpcy5lbmRUaW1lLCB0aGlzLnNjcmVlbiwgdGhpcy5jdWVSYW5nZXMpO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ubmV3Q3VlID0gZnVuY3Rpb24gbmV3Q3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRUaW1lID09PSBudWxsIHx8IHRoaXMuc3RhcnRUaW1lID4gc3RhcnRUaW1lKSB7XG4gICAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICB9XG5cbiAgICB0aGlzLmVuZFRpbWUgPSBlbmRUaW1lO1xuICAgIHRoaXMuc2NyZWVuID0gc2NyZWVuO1xuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyLmNyZWF0ZUNhcHRpb25zVHJhY2sodGhpcy50cmFja05hbWUpO1xuICB9O1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMuY3VlUmFuZ2VzID0gW107XG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiBPdXRwdXRGaWx0ZXI7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy90ZXh0dHJhY2stdXRpbHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL3RleHR0cmFjay11dGlscy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogc2VuZEFkZFRyYWNrRXZlbnQsIGFkZEN1ZVRvVHJhY2ssIGNsZWFyQ3VycmVudEN1ZXMsIHJlbW92ZUN1ZXNJblJhbmdlLCBnZXRDdWVzSW5SYW5nZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZW5kQWRkVHJhY2tFdmVudFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbmRBZGRUcmFja0V2ZW50OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhZGRDdWVUb1RyYWNrXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYWRkQ3VlVG9UcmFjazsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY2xlYXJDdXJyZW50Q3Vlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNsZWFyQ3VycmVudEN1ZXM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInJlbW92ZUN1ZXNJblJhbmdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVtb3ZlQ3Vlc0luUmFuZ2U7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldEN1ZXNJblJhbmdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0Q3Vlc0luUmFuZ2U7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuXG5mdW5jdGlvbiBzZW5kQWRkVHJhY2tFdmVudCh0cmFjaywgdmlkZW9FbCkge1xuICB2YXIgZXZlbnQ7XG5cbiAgdHJ5IHtcbiAgICBldmVudCA9IG5ldyBFdmVudCgnYWRkdHJhY2snKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gZm9yIElFMTFcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmluaXRFdmVudCgnYWRkdHJhY2snLCBmYWxzZSwgZmFsc2UpO1xuICB9XG5cbiAgZXZlbnQudHJhY2sgPSB0cmFjaztcbiAgdmlkZW9FbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGFkZEN1ZVRvVHJhY2sodHJhY2ssIGN1ZSkge1xuICAvLyBTb21ldGltZXMgdGhlcmUgYXJlIGN1ZSBvdmVybGFwcyBvbiBzZWdtZW50ZWQgdnR0cyBzbyB0aGUgc2FtZVxuICAvLyBjdWUgY2FuIGFwcGVhciBtb3JlIHRoYW4gb25jZSBpbiBkaWZmZXJlbnQgdnR0IGZpbGVzLlxuICAvLyBUaGlzIGF2b2lkIHNob3dpbmcgZHVwbGljYXRlZCBjdWVzIHdpdGggc2FtZSB0aW1lY29kZSBhbmQgdGV4dC5cbiAgdmFyIG1vZGUgPSB0cmFjay5tb2RlO1xuXG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICB9XG5cbiAgaWYgKHRyYWNrLmN1ZXMgJiYgIXRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xuXG4gICAgICBpZiAoIXRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZEN1ZSBpcyBmYWlsZWQgZm9yOiBcIiArIGN1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJsb2dnZXJcIl0uZGVidWcoXCJbdGV4dHRyYWNrLXV0aWxzXTogXCIgKyBlcnIpO1xuICAgICAgdmFyIHRleHRUcmFja0N1ZSA9IG5ldyBzZWxmLlRleHRUcmFja0N1ZShjdWUuc3RhcnRUaW1lLCBjdWUuZW5kVGltZSwgY3VlLnRleHQpO1xuICAgICAgdGV4dFRyYWNrQ3VlLmlkID0gY3VlLmlkO1xuICAgICAgdHJhY2suYWRkQ3VlKHRleHRUcmFja0N1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gbW9kZTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYXJDdXJyZW50Q3Vlcyh0cmFjaykge1xuICAvLyBXaGVuIHRyYWNrLm1vZGUgaXMgZGlzYWJsZWQsIHRyYWNrLmN1ZXMgd2lsbCBiZSBudWxsLlxuICAvLyBUbyBndWFyYW50ZWUgdGhlIHJlbW92YWwgb2YgY3Vlcywgd2UgbmVlZCB0byB0ZW1wb3JhcmlseVxuICAvLyBjaGFuZ2UgdGhlIG1vZGUgdG8gaGlkZGVuXG4gIHZhciBtb2RlID0gdHJhY2subW9kZTtcblxuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgfVxuXG4gIGlmICh0cmFjay5jdWVzKSB7XG4gICAgZm9yICh2YXIgaSA9IHRyYWNrLmN1ZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICB0cmFjay5yZW1vdmVDdWUodHJhY2suY3Vlc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gbW9kZTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ3Vlc0luUmFuZ2UodHJhY2ssIHN0YXJ0LCBlbmQsIHByZWRpY2F0ZSkge1xuICB2YXIgbW9kZSA9IHRyYWNrLm1vZGU7XG5cbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gJ2hpZGRlbic7XG4gIH1cblxuICBpZiAodHJhY2suY3VlcyAmJiB0cmFjay5jdWVzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgY3VlcyA9IGdldEN1ZXNJblJhbmdlKHRyYWNrLmN1ZXMsIHN0YXJ0LCBlbmQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoY3Vlc1tpXSkpIHtcbiAgICAgICAgdHJhY2sucmVtb3ZlQ3VlKGN1ZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9IG1vZGU7XG4gIH1cbn0gLy8gRmluZCBmaXJzdCBjdWUgc3RhcnRpbmcgYWZ0ZXIgZ2l2ZW4gdGltZS5cbi8vIE1vZGlmaWVkIHZlcnNpb24gb2YgYmluYXJ5IHNlYXJjaCBPKGxvZyhuKSkuXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q3VlSW5kZXhBZnRlclRpbWUoY3VlcywgdGltZSkge1xuICAvLyBJZiBmaXJzdCBjdWUgc3RhcnRzIGFmdGVyIHRpbWUsIHN0YXJ0IHRoZXJlXG4gIGlmICh0aW1lIDwgY3Vlc1swXS5zdGFydFRpbWUpIHtcbiAgICByZXR1cm4gMDtcbiAgfSAvLyBJZiB0aGUgbGFzdCBjdWUgZW5kcyBiZWZvcmUgdGltZSB0aGVyZSBpcyBubyBvdmVybGFwXG5cblxuICB2YXIgbGVuID0gY3Vlcy5sZW5ndGggLSAxO1xuXG4gIGlmICh0aW1lID4gY3Vlc1tsZW5dLmVuZFRpbWUpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB2YXIgbGVmdCA9IDA7XG4gIHZhciByaWdodCA9IGxlbjtcblxuICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChyaWdodCArIGxlZnQpIC8gMik7XG5cbiAgICBpZiAodGltZSA8IGN1ZXNbbWlkXS5zdGFydFRpbWUpIHtcbiAgICAgIHJpZ2h0ID0gbWlkIC0gMTtcbiAgICB9IGVsc2UgaWYgKHRpbWUgPiBjdWVzW21pZF0uc3RhcnRUaW1lICYmIGxlZnQgPCBsZW4pIHtcbiAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIG5vdCBsb3dlciBvciBoaWdoZXIsIGl0IG11c3QgYmUgZXF1YWwuXG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgfSAvLyBBdCB0aGlzIHBvaW50LCBsZWZ0IGFuZCByaWdodCBoYXZlIHN3YXBwZWQuXG4gIC8vIE5vIGRpcmVjdCBtYXRjaCB3YXMgZm91bmQsIGxlZnQgb3IgcmlnaHQgZWxlbWVudCBtdXN0IGJlIHRoZSBjbG9zZXN0LiBDaGVjayB3aGljaCBvbmUgaGFzIHRoZSBzbWFsbGVzdCBkaWZmLlxuXG5cbiAgcmV0dXJuIGN1ZXNbbGVmdF0uc3RhcnRUaW1lIC0gdGltZSA8IHRpbWUgLSBjdWVzW3JpZ2h0XS5zdGFydFRpbWUgPyBsZWZ0IDogcmlnaHQ7XG59XG5cbmZ1bmN0aW9uIGdldEN1ZXNJblJhbmdlKGN1ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGN1ZXNGb3VuZCA9IFtdO1xuICB2YXIgZmlyc3RDdWVJblJhbmdlID0gZ2V0Rmlyc3RDdWVJbmRleEFmdGVyVGltZShjdWVzLCBzdGFydCk7XG5cbiAgaWYgKGZpcnN0Q3VlSW5SYW5nZSA+IC0xKSB7XG4gICAgZm9yICh2YXIgaSA9IGZpcnN0Q3VlSW5SYW5nZSwgbGVuID0gY3Vlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIF9jdWUgPSBjdWVzW2ldO1xuXG4gICAgICBpZiAoX2N1ZS5zdGFydFRpbWUgPj0gc3RhcnQgJiYgX2N1ZS5lbmRUaW1lIDw9IGVuZCkge1xuICAgICAgICBjdWVzRm91bmQucHVzaChfY3VlKTtcbiAgICAgIH0gZWxzZSBpZiAoX2N1ZS5zdGFydFRpbWUgPiBlbmQpIHtcbiAgICAgICAgcmV0dXJuIGN1ZXNGb3VuZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3Vlc0ZvdW5kO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy90aW1lLXJhbmdlcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy90aW1lLXJhbmdlcy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyoqXG4gKiAgVGltZVJhbmdlcyB0byBzdHJpbmcgaGVscGVyXG4gKi9cbnZhciBUaW1lUmFuZ2VzID0ge1xuICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcocikge1xuICAgIHZhciBsb2cgPSAnJztcbiAgICB2YXIgbGVuID0gci5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsb2cgKz0gJ1snICsgci5zdGFydChpKS50b0ZpeGVkKDMpICsgJywnICsgci5lbmQoaSkudG9GaXhlZCgzKSArICddJztcbiAgICB9XG5cbiAgICByZXR1cm4gbG9nO1xuICB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChUaW1lUmFuZ2VzKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogdG9UaW1lc2NhbGVGcm9tQmFzZSwgdG9UaW1lc2NhbGVGcm9tU2NhbGUsIHRvTXNGcm9tTXBlZ1RzQ2xvY2ssIHRvTXBlZ1RzQ2xvY2tGcm9tVGltZXNjYWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInRvVGltZXNjYWxlRnJvbUJhc2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ0b1RpbWVzY2FsZUZyb21TY2FsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRvVGltZXNjYWxlRnJvbVNjYWxlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ0b01zRnJvbU1wZWdUc0Nsb2NrXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdG9Nc0Zyb21NcGVnVHNDbG9jazsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidG9NcGVnVHNDbG9ja0Zyb21UaW1lc2NhbGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB0b01wZWdUc0Nsb2NrRnJvbVRpbWVzY2FsZTsgfSk7XG52YXIgTVBFR19UU19DTE9DS19GUkVRX0haID0gOTAwMDA7XG5mdW5jdGlvbiB0b1RpbWVzY2FsZUZyb21CYXNlKHZhbHVlLCBkZXN0U2NhbGUsIHNyY0Jhc2UsIHJvdW5kKSB7XG4gIGlmIChzcmNCYXNlID09PSB2b2lkIDApIHtcbiAgICBzcmNCYXNlID0gMTtcbiAgfVxuXG4gIGlmIChyb3VuZCA9PT0gdm9pZCAwKSB7XG4gICAgcm91bmQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB2YWx1ZSAqIGRlc3RTY2FsZSAqIHNyY0Jhc2U7IC8vIGVxdWl2YWxlbnQgdG8gYCh2YWx1ZSAqIHNjYWxlKSAvICgxIC8gYmFzZSlgXG5cbiAgcmV0dXJuIHJvdW5kID8gTWF0aC5yb3VuZChyZXN1bHQpIDogcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9UaW1lc2NhbGVGcm9tU2NhbGUodmFsdWUsIGRlc3RTY2FsZSwgc3JjU2NhbGUsIHJvdW5kKSB7XG4gIGlmIChzcmNTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgc3JjU2NhbGUgPSAxO1xuICB9XG5cbiAgaWYgKHJvdW5kID09PSB2b2lkIDApIHtcbiAgICByb3VuZCA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRvVGltZXNjYWxlRnJvbUJhc2UodmFsdWUsIGRlc3RTY2FsZSwgMSAvIHNyY1NjYWxlLCByb3VuZCk7XG59XG5mdW5jdGlvbiB0b01zRnJvbU1wZWdUc0Nsb2NrKHZhbHVlLCByb3VuZCkge1xuICBpZiAocm91bmQgPT09IHZvaWQgMCkge1xuICAgIHJvdW5kID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdG9UaW1lc2NhbGVGcm9tQmFzZSh2YWx1ZSwgMTAwMCwgMSAvIE1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiwgcm91bmQpO1xufVxuZnVuY3Rpb24gdG9NcGVnVHNDbG9ja0Zyb21UaW1lc2NhbGUodmFsdWUsIHNyY1NjYWxlKSB7XG4gIGlmIChzcmNTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgc3JjU2NhbGUgPSAxO1xuICB9XG5cbiAgcmV0dXJuIHRvVGltZXNjYWxlRnJvbUJhc2UodmFsdWUsIE1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiwgMSAvIHNyY1NjYWxlKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvdHlwZWQtYXJyYXkudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvdHlwZWQtYXJyYXkudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogc2xpY2VVaW50OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzbGljZVVpbnQ4XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2xpY2VVaW50ODsgfSk7XG5mdW5jdGlvbiBzbGljZVVpbnQ4KGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBwb2x5ZmlsbHMgSUUxMSB1c2FnZSBvZiBVaW50OEFycmF5IHNsaWNlLlxuICAvLyBJdCBhbHdheXMgZXhpc3RzIGluIHRoZSBUeXBlU2NyaXB0IGRlZmluaXRpb24gc28gZmFpbHMsIGJ1dCBpdCBmYWlscyBhdCBydW50aW1lIG9uIElFMTEuXG4gIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZSA/IGFycmF5LnNsaWNlKHN0YXJ0LCBlbmQpIDogbmV3IFVpbnQ4QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXksIHN0YXJ0LCBlbmQpKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvdnR0Y3VlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy92dHRjdWUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLlZUVEN1ZSkge1xuICAgIHJldHVybiBzZWxmLlZUVEN1ZTtcbiAgfVxuXG4gIHZhciBBbGxvd2VkRGlyZWN0aW9ucyA9IFsnJywgJ2xyJywgJ3JsJ107XG4gIHZhciBBbGxvd2VkQWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnbWlkZGxlJywgJ2VuZCcsICdsZWZ0JywgJ3JpZ2h0J107XG5cbiAgZnVuY3Rpb24gaXNBbGxvd2VkVmFsdWUoYWxsb3dlZCwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gbmVjZXNzYXJ5IGZvciBhc3N1cmluZyB0aGUgZ2VuZXJpYyBjb25mb3JtcyB0byB0aGUgQXJyYXkgaW50ZXJmYWNlXG5cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShhbGxvd2VkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gcmVzZXQgdGhlIHR5cGUgc28gdGhhdCB0aGUgbmV4dCBuYXJyb3dpbmcgd29ya3Mgd2VsbFxuXG5cbiAgICB2YXIgbGNWYWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7IC8vIHVzZSB0aGUgYWxsb3cgbGlzdCB0byBuYXJyb3cgdGhlIHR5cGUgdG8gYSBzcGVjaWZpYyBzdWJzZXQgb2Ygc3RyaW5nc1xuXG4gICAgaWYgKH5hbGxvd2VkLmluZGV4T2YobGNWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBsY1ZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQWxsb3dlZFZhbHVlKEFsbG93ZWREaXJlY3Rpb25zLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQWxsb3dlZFZhbHVlKEFsbG93ZWRBbGlnbm1lbnRzLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQob2JqKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcmVzdFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGkgPSAxO1xuXG4gICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjb2JqID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIGNvYmopIHtcbiAgICAgICAgb2JqW3BdID0gY29ialtwXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gVlRUQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgdGV4dCkge1xuICAgIHZhciBjdWUgPSB0aGlzO1xuICAgIHZhciBiYXNlT2JqID0ge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hpbSBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyBwcm9wZXJ0aWVzLiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgaW5cbiAgICAgKiB0aGUgc3BlYy5cbiAgICAgKi9cbiAgICAvLyBMZXRzIHVzIGtub3cgd2hlbiB0aGUgVlRUQ3VlJ3MgZGF0YSBoYXMgY2hhbmdlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgbmVlZFxuICAgIC8vIHRvIHJlY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZS4gVGhpcyBsZXRzIHVzIGNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGVcbiAgICAvLyBsYXppbHkuXG5cbiAgICBjdWUuaGFzQmVlblJlc2V0ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVlRUQ3VlIGFuZCBUZXh0VHJhY2tDdWUgcHJvcGVydGllc1xuICAgICAqIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0Y3VlLWludGVyZmFjZVxuICAgICAqL1xuXG4gICAgdmFyIF9pZCA9ICcnO1xuICAgIHZhciBfcGF1c2VPbkV4aXQgPSBmYWxzZTtcbiAgICB2YXIgX3N0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICB2YXIgX2VuZFRpbWUgPSBlbmRUaW1lO1xuICAgIHZhciBfdGV4dCA9IHRleHQ7XG4gICAgdmFyIF9yZWdpb24gPSBudWxsO1xuICAgIHZhciBfdmVydGljYWwgPSAnJztcbiAgICB2YXIgX3NuYXBUb0xpbmVzID0gdHJ1ZTtcbiAgICB2YXIgX2xpbmUgPSAnYXV0byc7XG4gICAgdmFyIF9saW5lQWxpZ24gPSAnc3RhcnQnO1xuICAgIHZhciBfcG9zaXRpb24gPSA1MDtcbiAgICB2YXIgX3Bvc2l0aW9uQWxpZ24gPSAnbWlkZGxlJztcbiAgICB2YXIgX3NpemUgPSA1MDtcbiAgICB2YXIgX2FsaWduID0gJ21pZGRsZSc7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2lkJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9pZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfaWQgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncGF1c2VPbkV4aXQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3BhdXNlT25FeGl0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9wYXVzZU9uRXhpdCA9ICEhdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzdGFydFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3N0YXJ0VGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0YXJ0IHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfc3RhcnRUaW1lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2VuZFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2VuZFRpbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9lbmRUaW1lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3RleHQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3RleHQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX3RleHQgPSAnJyArIHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyB0b2RvOiBpbXBsZW1lbnQgVlRUUmVnaW9uIHBvbHlmaWxsP1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3JlZ2lvbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfcmVnaW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9yZWdpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndmVydGljYWwnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3ZlcnRpY2FsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpOyAvLyBIYXZlIHRvIGNoZWNrIGZvciBmYWxzZSBiZWNhdXNlIHRoZSBzZXR0aW5nIGFuIGJlIGFuIGVtcHR5IHN0cmluZy5cblxuICAgICAgICBpZiAoc2V0dGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF92ZXJ0aWNhbCA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NuYXBUb0xpbmVzJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwVG9MaW5lcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfc25hcFRvTGluZXMgPSAhIXZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdsaW5lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9saW5lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInICYmIHZhbHVlICE9PSAnYXV0bycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgbnVtYmVyIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfbGluZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdsaW5lQWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2xpbmVBbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuXG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2xpbmVBbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NpdGlvbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3Bvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uQWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uQWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcblxuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wb3NpdGlvbkFsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc2l6ZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaXplIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfc2l6ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdhbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfYWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcblxuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9hbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgLyoqXG4gICAgICogT3RoZXIgPHRyYWNrPiBzcGVjIGRlZmluZWQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS12aWRlby1lbGVtZW50Lmh0bWwjdGV4dC10cmFjay1jdWUtZGlzcGxheS1zdGF0ZVxuXG4gICAgY3VlLmRpc3BsYXlTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogVlRUQ3VlIG1ldGhvZHNcbiAgICovXG5cblxuICBWVFRDdWUucHJvdG90eXBlLmdldEN1ZUFzSFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBBc3N1bWUgV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUgaXMgb24gdGhlIGdsb2JhbC5cbiAgICB2YXIgV2ViVlRUID0gc2VsZi5XZWJWVFQ7XG4gICAgcmV0dXJuIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlKHNlbGYsIHRoaXMudGV4dCk7XG4gIH07IC8vIHRoaXMgaXMgYSBwb2x5ZmlsbCBoYWNrXG5cblxuICByZXR1cm4gVlRUQ3VlO1xufSkoKSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL3Z0dHBhcnNlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvdnR0cGFyc2VyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBwYXJzZVRpbWVTdGFtcCwgZml4TGluZUJyZWFrcywgVlRUUGFyc2VyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInBhcnNlVGltZVN0YW1wXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcGFyc2VUaW1lU3RhbXA7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZpeExpbmVCcmVha3NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmaXhMaW5lQnJlYWtzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWVFRQYXJzZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBWVFRQYXJzZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF92dHRjdWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdnR0Y3VlICovIFwiLi9zcmMvdXRpbHMvdnR0Y3VlLnRzXCIpO1xuLypcbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvdnR0LmpzL2Jsb2IvbWFzdGVyL2Rpc3QvdnR0LmpzXG4gKi9cblxuXG52YXIgU3RyaW5nRGVjb2RlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoKSB7fVxuXG4gIHZhciBfcHJvdG8gPSBTdHJpbmdEZWNvZGVyLnByb3RvdHlwZTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIF9wcm90by5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoZGF0YSwgb3B0aW9ucykge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgLSBleHBlY3RlZCBzdHJpbmcgZGF0YS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudChkYXRhKSk7XG4gIH07XG5cbiAgcmV0dXJuIFN0cmluZ0RlY29kZXI7XG59KCk7IC8vIFRyeSB0byBwYXJzZSBpbnB1dCBhcyBhIHRpbWUgc3RhbXAuXG5cblxuZnVuY3Rpb24gcGFyc2VUaW1lU3RhbXAoaW5wdXQpIHtcbiAgZnVuY3Rpb24gY29tcHV0ZVNlY29uZHMoaCwgbSwgcywgZikge1xuICAgIHJldHVybiAoaCB8IDApICogMzYwMCArIChtIHwgMCkgKiA2MCArIChzIHwgMCkgKyBwYXJzZUZsb2F0KGYgfHwgMCk7XG4gIH1cblxuICB2YXIgbSA9IGlucHV0Lm1hdGNoKC9eKD86KFxcZCspOik/KFxcZHsyfSk6KFxcZHsyfSkoXFwuXFxkKyk/Lyk7XG5cbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VGbG9hdChtWzJdKSA+IDU5KSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdLlttaWxsaXNlY29uZHNdXG4gICAgLy8gRmlyc3QgcG9zaXRpb24gaXMgaG91cnMgYXMgaXQncyBvdmVyIDU5LlxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzJdLCBtWzNdLCAwLCBtWzRdKTtcbiAgfSAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzIChvcHRpb25hbCldOlttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cblxuXG4gIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCBtWzNdLCBtWzRdKTtcbn0gLy8gQSBzZXR0aW5ncyBvYmplY3QgaG9sZHMga2V5L3ZhbHVlIHBhaXJzIGFuZCB3aWxsIGlnbm9yZSBhbnl0aGluZyBidXQgdGhlIGZpcnN0XG4vLyBhc3NpZ25tZW50IHRvIGEgc3BlY2lmaWMga2V5LlxuXG52YXIgU2V0dGluZ3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTZXR0aW5ncygpIHtcbiAgICB0aGlzLnZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IFNldHRpbmdzLnByb3RvdHlwZTtcblxuICAvLyBPbmx5IGFjY2VwdCB0aGUgZmlyc3QgYXNzaWdubWVudCB0byBhbnkga2V5LlxuICBfcHJvdG8yLnNldCA9IGZ1bmN0aW9uIHNldChrLCB2KSB7XG4gICAgaWYgKCF0aGlzLmdldChrKSAmJiB2ICE9PSAnJykge1xuICAgICAgdGhpcy52YWx1ZXNba10gPSB2O1xuICAgIH1cbiAgfSAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciBhIGtleSwgb3IgYSBkZWZhdWx0IHZhbHVlLlxuICAvLyBJZiAnZGVmYXVsdEtleScgaXMgcGFzc2VkIHRoZW4gJ2RmbHQnIGlzIGFzc3VtZWQgdG8gYmUgYW4gb2JqZWN0IHdpdGhcbiAgLy8gYSBudW1iZXIgb2YgcG9zc2libGUgZGVmYXVsdCB2YWx1ZXMgYXMgcHJvcGVydGllcyB3aGVyZSAnZGVmYXVsdEtleScgaXNcbiAgLy8gdGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIGNob3Nlbjsgb3RoZXJ3aXNlIGl0J3MgYXNzdW1lZCB0byBiZVxuICAvLyBhIHNpbmdsZSB2YWx1ZS5cbiAgO1xuXG4gIF9wcm90bzIuZ2V0ID0gZnVuY3Rpb24gZ2V0KGssIGRmbHQsIGRlZmF1bHRLZXkpIHtcbiAgICBpZiAoZGVmYXVsdEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0W2RlZmF1bHRLZXldO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdDtcbiAgfSAvLyBDaGVjayB3aGV0aGVyIHdlIGhhdmUgYSB2YWx1ZSBmb3IgYSBrZXkuXG4gIDtcblxuICBfcHJvdG8yLmhhcyA9IGZ1bmN0aW9uIGhhcyhrKSB7XG4gICAgcmV0dXJuIGsgaW4gdGhpcy52YWx1ZXM7XG4gIH0gLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgb25lIG9mIHRoZSBnaXZlbiBhbHRlcm5hdGl2ZXMuXG4gIDtcblxuICBfcHJvdG8yLmFsdCA9IGZ1bmN0aW9uIGFsdChrLCB2LCBhKSB7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBhLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAodiA9PT0gYVtuXSkge1xuICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIGEgdmFsaWQgKHNpZ25lZCkgaW50ZWdlci5cbiAgO1xuXG4gIF9wcm90bzIuaW50ZWdlciA9IGZ1bmN0aW9uIGludGVnZXIoaywgdikge1xuICAgIGlmICgvXi0/XFxkKyQvLnRlc3QodikpIHtcbiAgICAgIC8vIGludGVnZXJcbiAgICAgIHRoaXMuc2V0KGssIHBhcnNlSW50KHYsIDEwKSk7XG4gICAgfVxuICB9IC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIGEgdmFsaWQgcGVyY2VudGFnZS5cbiAgO1xuXG4gIF9wcm90bzIucGVyY2VudCA9IGZ1bmN0aW9uIHBlcmNlbnQoaywgdikge1xuICAgIGlmICgvXihbXFxkXXsxLDN9KShcXC5bXFxkXSopPyUkLy50ZXN0KHYpKSB7XG4gICAgICB2YXIgcGVyY2VudCA9IHBhcnNlRmxvYXQodik7XG5cbiAgICAgIGlmIChwZXJjZW50ID49IDAgJiYgcGVyY2VudCA8PSAxMDApIHtcbiAgICAgICAgdGhpcy5zZXQoaywgcGVyY2VudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICByZXR1cm4gU2V0dGluZ3M7XG59KCk7IC8vIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBpbnB1dCBpbnRvIGdyb3VwcyBzZXBhcmF0ZWQgYnkgJ2dyb3VwRGVsaW0nLCBhbmRcbi8vIGludGVycHJldCBlYWNoIGdyb3VwIGFzIGEga2V5L3ZhbHVlIHBhaXIgc2VwYXJhdGVkIGJ5ICdrZXlWYWx1ZURlbGltJy5cblxuXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMoaW5wdXQsIGNhbGxiYWNrLCBrZXlWYWx1ZURlbGltLCBncm91cERlbGltKSB7XG4gIHZhciBncm91cHMgPSBncm91cERlbGltID8gaW5wdXQuc3BsaXQoZ3JvdXBEZWxpbSkgOiBbaW5wdXRdO1xuXG4gIGZvciAodmFyIGkgaW4gZ3JvdXBzKSB7XG4gICAgaWYgKHR5cGVvZiBncm91cHNbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIga3YgPSBncm91cHNbaV0uc3BsaXQoa2V5VmFsdWVEZWxpbSk7XG5cbiAgICBpZiAoa3YubGVuZ3RoICE9PSAyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgX2sgPSBrdlswXTtcbiAgICB2YXIgX3YgPSBrdlsxXTtcbiAgICBjYWxsYmFjayhfaywgX3YpO1xuICB9XG59XG5cbnZhciBkZWZhdWx0cyA9IG5ldyBfdnR0Y3VlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKDAsIDAsICcnKTsgLy8gJ21pZGRsZScgd2FzIGNoYW5nZWQgdG8gJ2NlbnRlcicgaW4gdGhlIHNwZWM6IGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvd2VidnR0L3B1bGwvMjQ0XG4vLyAgU2FmYXJpIGRvZXNuJ3QgeWV0IHN1cHBvcnQgdGhpcyBjaGFuZ2UsIGJ1dCBGRiBhbmQgQ2hyb21lIGRvLlxuXG52YXIgY2VudGVyID0gZGVmYXVsdHMuYWxpZ24gPT09ICdtaWRkbGUnID8gJ21pZGRsZScgOiAnY2VudGVyJztcblxuZnVuY3Rpb24gcGFyc2VDdWUoaW5wdXQsIGN1ZSwgcmVnaW9uTGlzdCkge1xuICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgaW5wdXQgaWYgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cbiAgdmFyIG9JbnB1dCA9IGlucHV0OyAvLyA0LjEgV2ViVlRUIHRpbWVzdGFtcFxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVUaW1lU3RhbXAoKSB7XG4gICAgdmFyIHRzID0gcGFyc2VUaW1lU3RhbXAoaW5wdXQpO1xuXG4gICAgaWYgKHRzID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCB0aW1lc3RhbXA6ICcgKyBvSW5wdXQpO1xuICAgIH0gLy8gUmVtb3ZlIHRpbWUgc3RhbXAgZnJvbSBpbnB1dC5cblxuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eW15cXHNhLXpBLVotXSsvLCAnJyk7XG4gICAgcmV0dXJuIHRzO1xuICB9IC8vIDQuNC4yIFdlYlZUVCBjdWUgc2V0dGluZ3NcblxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKSB7XG4gICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG4gICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgdmFyIHZhbHM7XG5cbiAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICBjYXNlICdyZWdpb24nOlxuICAgICAgICAgIC8vIEZpbmQgdGhlIGxhc3QgcmVnaW9uIHdlIHBhcnNlZCB3aXRoIHRoZSBzYW1lIHJlZ2lvbiBpZC5cbiAgICAgICAgICBmb3IgKHZhciBpID0gcmVnaW9uTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHJlZ2lvbkxpc3RbaV0uaWQgPT09IHYpIHtcbiAgICAgICAgICAgICAgc2V0dGluZ3Muc2V0KGssIHJlZ2lvbkxpc3RbaV0ucmVnaW9uKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3JsJywgJ2xyJ10pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgICAgIHZhbHMgPSB2LnNwbGl0KCcsJyk7XG4gICAgICAgICAgc2V0dGluZ3MuaW50ZWdlcihrLCB2YWxzWzBdKTtcblxuICAgICAgICAgIGlmIChzZXR0aW5ncy5wZXJjZW50KGssIHZhbHNbMF0pKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5zZXQoJ3NuYXBUb0xpbmVzJywgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2YWxzWzBdLCBbJ2F1dG8nXSk7XG5cbiAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmFsdCgnbGluZUFsaWduJywgdmFsc1sxXSwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCddKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgICAgdmFscyA9IHYuc3BsaXQoJywnKTtcbiAgICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHZhbHNbMF0pO1xuXG4gICAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hbHQoJ3Bvc2l0aW9uQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJywgJ2xpbmUtbGVmdCcsICdsaW5lLXJpZ2h0JywgJ2F1dG8nXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2l6ZSc6XG4gICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhbGlnbic6XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnLCAnbGVmdCcsICdyaWdodCddKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LCAvOi8sIC9cXHMvKTsgLy8gQXBwbHkgZGVmYXVsdCB2YWx1ZXMgZm9yIGFueSBtaXNzaW5nIGZpZWxkcy5cblxuICAgIGN1ZS5yZWdpb24gPSBzZXR0aW5ncy5nZXQoJ3JlZ2lvbicsIG51bGwpO1xuICAgIGN1ZS52ZXJ0aWNhbCA9IHNldHRpbmdzLmdldCgndmVydGljYWwnLCAnJyk7XG4gICAgdmFyIGxpbmUgPSBzZXR0aW5ncy5nZXQoJ2xpbmUnLCAnYXV0bycpO1xuXG4gICAgaWYgKGxpbmUgPT09ICdhdXRvJyAmJiBkZWZhdWx0cy5saW5lID09PSAtMSkge1xuICAgICAgLy8gc2V0IG51bWVyaWMgbGluZSBudW1iZXIgZm9yIFNhZmFyaVxuICAgICAgbGluZSA9IC0xO1xuICAgIH1cblxuICAgIGN1ZS5saW5lID0gbGluZTtcbiAgICBjdWUubGluZUFsaWduID0gc2V0dGluZ3MuZ2V0KCdsaW5lQWxpZ24nLCAnc3RhcnQnKTtcbiAgICBjdWUuc25hcFRvTGluZXMgPSBzZXR0aW5ncy5nZXQoJ3NuYXBUb0xpbmVzJywgdHJ1ZSk7XG4gICAgY3VlLnNpemUgPSBzZXR0aW5ncy5nZXQoJ3NpemUnLCAxMDApO1xuICAgIGN1ZS5hbGlnbiA9IHNldHRpbmdzLmdldCgnYWxpZ24nLCBjZW50ZXIpO1xuICAgIHZhciBwb3NpdGlvbiA9IHNldHRpbmdzLmdldCgncG9zaXRpb24nLCAnYXV0bycpO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgZGVmYXVsdHMucG9zaXRpb24gPT09IDUwKSB7XG4gICAgICAvLyBzZXQgbnVtZXJpYyBwb3NpdGlvbiBmb3IgU2FmYXJpXG4gICAgICBwb3NpdGlvbiA9IGN1ZS5hbGlnbiA9PT0gJ3N0YXJ0JyB8fCBjdWUuYWxpZ24gPT09ICdsZWZ0JyA/IDAgOiBjdWUuYWxpZ24gPT09ICdlbmQnIHx8IGN1ZS5hbGlnbiA9PT0gJ3JpZ2h0JyA/IDEwMCA6IDUwO1xuICAgIH1cblxuICAgIGN1ZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbiAgfSAvLyA0LjEgV2ViVlRUIGN1ZSB0aW1pbmdzLlxuXG5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY3VlLnN0YXJ0VGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDEpIGNvbGxlY3QgY3VlIHN0YXJ0IHRpbWVcblxuICBza2lwV2hpdGVzcGFjZSgpO1xuXG4gIGlmIChpbnB1dC5zbGljZSgwLCAzKSAhPT0gJy0tPicpIHtcbiAgICAvLyAoMykgbmV4dCBjaGFyYWN0ZXJzIG11c3QgbWF0Y2ggJy0tPidcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgdGltZSBzdGFtcCAodGltZSBzdGFtcHMgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgJy0tPicpOiBcIiArIG9JbnB1dCk7XG4gIH1cblxuICBpbnB1dCA9IGlucHV0LnNsaWNlKDMpO1xuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuZW5kVGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDUpIGNvbGxlY3QgY3VlIGVuZCB0aW1lXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHNldHRpbmdzIGxpc3QuXG5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpO1xufVxuXG5mdW5jdGlvbiBmaXhMaW5lQnJlYWtzKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5yZXBsYWNlKC88YnIoPzogXFwvKT8+L2dpLCAnXFxuJyk7XG59XG52YXIgVlRUUGFyc2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVlRUUGFyc2VyKCkge1xuICAgIHRoaXMuc3RhdGUgPSAnSU5JVElBTCc7XG4gICAgdGhpcy5idWZmZXIgPSAnJztcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcigpO1xuICAgIHRoaXMucmVnaW9uTGlzdCA9IFtdO1xuICAgIHRoaXMuY3VlID0gbnVsbDtcbiAgICB0aGlzLm9uY3VlID0gdm9pZCAwO1xuICAgIHRoaXMub25wYXJzaW5nZXJyb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5vbmZsdXNoID0gdm9pZCAwO1xuICB9XG5cbiAgdmFyIF9wcm90bzMgPSBWVFRQYXJzZXIucHJvdG90eXBlO1xuXG4gIF9wcm90bzMucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShkYXRhKSB7XG4gICAgdmFyIF90aGlzID0gdGhpczsgLy8gSWYgdGhlcmUgaXMgbm8gZGF0YSB0aGVuIHdlIHdvbid0IGRlY29kZSBpdCwgYnV0IHdpbGwganVzdCB0cnkgdG8gcGFyc2VcbiAgICAvLyB3aGF0ZXZlciBpcyBpbiBidWZmZXIgYWxyZWFkeS4gVGhpcyBtYXkgb2NjdXIgaW4gY2lyY3Vtc3RhbmNlcywgZm9yXG4gICAgLy8gZXhhbXBsZSB3aGVuIGZsdXNoKCkgaXMgY2FsbGVkLlxuXG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgLy8gVHJ5IHRvIGRlY29kZSB0aGUgZGF0YSB0aGF0IHdlIHJlY2VpdmVkLlxuICAgICAgX3RoaXMuYnVmZmVyICs9IF90aGlzLmRlY29kZXIuZGVjb2RlKGRhdGEsIHtcbiAgICAgICAgc3RyZWFtOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0TmV4dExpbmUoKSB7XG4gICAgICB2YXIgYnVmZmVyID0gX3RoaXMuYnVmZmVyO1xuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICBidWZmZXIgPSBmaXhMaW5lQnJlYWtzKGJ1ZmZlcik7XG5cbiAgICAgIHdoaWxlIChwb3MgPCBidWZmZXIubGVuZ3RoICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxyJyAmJiBidWZmZXJbcG9zXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG5cbiAgICAgIHZhciBsaW5lID0gYnVmZmVyLnNsaWNlKDAsIHBvcyk7IC8vIEFkdmFuY2UgdGhlIGJ1ZmZlciBlYXJseSBpbiBjYXNlIHdlIGZhaWwgYmVsb3cuXG5cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xccicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG5cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmJ1ZmZlciA9IGJ1ZmZlci5zbGljZShwb3MpO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfSAvLyAzLjIgV2ViVlRUIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcblxuXG4gICAgZnVuY3Rpb24gcGFyc2VIZWFkZXIoaW5wdXQpIHtcbiAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHsvLyBzd2l0Y2ggKGspIHtcbiAgICAgICAgLy8gY2FzZSAncmVnaW9uJzpcbiAgICAgICAgLy8gMy4zIFdlYlZUVCByZWdpb24gbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgICAgICAvLyBjb25zb2xlLmxvZygncGFyc2UgcmVnaW9uJywgdik7XG4gICAgICAgIC8vIHBhcnNlUmVnaW9uKHYpO1xuICAgICAgICAvLyBicmVhaztcbiAgICAgICAgLy8gfVxuICAgICAgfSwgLzovKTtcbiAgICB9IC8vIDUuMSBXZWJWVFQgZmlsZSBwYXJzaW5nLlxuXG5cbiAgICB0cnkge1xuICAgICAgdmFyIGxpbmUgPSAnJztcblxuICAgICAgaWYgKF90aGlzLnN0YXRlID09PSAnSU5JVElBTCcpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc3RhcnQgcGFyc2luZyB1bnRpbCB3ZSBoYXZlIHRoZSBmaXJzdCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KF90aGlzLmJ1ZmZlcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTsgLy8gc3RyaXAgb2YgVVRGLTggQk9NIGlmIGFueVxuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CeXRlX29yZGVyX21hcmsjVVRGLThcblxuICAgICAgICB2YXIgbSA9IGxpbmUubWF0Y2goL14ow6/Cu8K/KT9XRUJWVFQoWyBcXHRdLiopPyQvKTtcblxuICAgICAgICBpZiAoIW0gfHwgIW1bMF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSAnSEVBREVSJztcbiAgICAgIH1cblxuICAgICAgdmFyIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChfdGhpcy5idWZmZXIpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgcGFyc2UgYSBsaW5lIHVudGlsIHdlIGhhdmUgdGhlIGZ1bGwgbGluZS5cbiAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChfdGhpcy5idWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFscmVhZHlDb2xsZWN0ZWRMaW5lKSB7XG4gICAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKF90aGlzLnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSAnSEVBREVSJzpcbiAgICAgICAgICAgIC8vIDEzLTE4IC0gQWxsb3cgYSBoZWFkZXIgKG1ldGFkYXRhKSB1bmRlciB0aGUgV0VCVlRUIGxpbmUuXG4gICAgICAgICAgICBpZiAoLzovLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgcGFyc2VIZWFkZXIobGluZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIC8vIEFuIGVtcHR5IGxpbmUgdGVybWluYXRlcyB0aGUgaGVhZGVyIGFuZCBzdGFydHMgdGhlIGJvZHkgKGN1ZXMpLlxuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgY2FzZSAnTk9URSc6XG4gICAgICAgICAgICAvLyBJZ25vcmUgTk9URSBibG9ja3MuXG4gICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgIGNhc2UgJ0lEJzpcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgTk9URSBibG9ja3MuXG4gICAgICAgICAgICBpZiAoL15OT1RFKCR8WyBcXHRdKS8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdOT1RFJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIDE5LTI5IC0gQWxsb3cgYW55IG51bWJlciBvZiBsaW5lIHRlcm1pbmF0b3JzLCB0aGVuIGluaXRpYWxpemUgbmV3IGN1ZSB2YWx1ZXMuXG5cblxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfdGhpcy5jdWUgPSBuZXcgX3Z0dGN1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSgwLCAwLCAnJyk7XG4gICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdDVUUnOyAvLyAzMC0zOSAtIENoZWNrIGlmIHNlbGYgbGluZSBjb250YWlucyBhbiBvcHRpb25hbCBpZGVudGlmaWVyIG9yIHRpbWluZyBkYXRhLlxuXG4gICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCctLT4nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgX3RoaXMuY3VlLmlkID0gbGluZTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQcm9jZXNzIGxpbmUgYXMgc3RhcnQgb2YgYSBjdWUuXG5cbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICAgICAgICBjYXNlICdDVUUnOlxuICAgICAgICAgICAgLy8gNDAgLSBDb2xsZWN0IGN1ZSB0aW1pbmdzIGFuZCBzZXR0aW5ncy5cbiAgICAgICAgICAgIGlmICghX3RoaXMuY3VlKSB7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0JBRENVRSc7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwYXJzZUN1ZShsaW5lLCBfdGhpcy5jdWUsIF90aGlzLnJlZ2lvbkxpc3QpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXG4gICAgICAgICAgICAgIF90aGlzLmN1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0JBRENVRSc7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdDVUVURVhUJztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgY2FzZSAnQ1VFVEVYVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBoYXNTdWJzdHJpbmcgPSBsaW5lLmluZGV4T2YoJy0tPicpICE9PSAtMTsgLy8gMzQgLSBJZiB3ZSBoYXZlIGFuIGVtcHR5IGxpbmUgdGhlbiByZXBvcnQgdGhlIGN1ZS5cbiAgICAgICAgICAgICAgLy8gMzUgLSBJZiB3ZSBoYXZlIHRoZSBzcGVjaWFsIHN1YnN0cmluZyAnLS0+JyB0aGVuIHJlcG9ydCB0aGUgY3VlLFxuICAgICAgICAgICAgICAvLyBidXQgZG8gbm90IGNvbGxlY3QgdGhlIGxpbmUgYXMgd2UgbmVlZCB0byBwcm9jZXNzIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgIC8vIG9uZSBhcyBhIG5ldyBjdWUuXG5cbiAgICAgICAgICAgICAgaWYgKCFsaW5lIHx8IGhhc1N1YnN0cmluZyAmJiAoYWxyZWFkeUNvbGxlY3RlZExpbmUgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBkb25lIHBhcnNpbmcgc2VsZiBjdWUuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9uY3VlICYmIF90aGlzLmN1ZSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMub25jdWUoX3RoaXMuY3VlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfdGhpcy5jdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChfdGhpcy5jdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChfdGhpcy5jdWUudGV4dCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmN1ZS50ZXh0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX3RoaXMuY3VlLnRleHQgKz0gbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgY2FzZSAnQkFEQ1VFJzpcbiAgICAgICAgICAgIC8vIDU0LTYyIC0gQ29sbGVjdCBhbmQgZGlzY2FyZCB0aGUgcmVtYWluaW5nIGN1ZS5cbiAgICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgcGFyc2luZyBhIGN1ZSwgcmVwb3J0IHdoYXQgd2UgaGF2ZS5cbiAgICAgIGlmIChfdGhpcy5zdGF0ZSA9PT0gJ0NVRVRFWFQnICYmIF90aGlzLmN1ZSAmJiBfdGhpcy5vbmN1ZSkge1xuICAgICAgICBfdGhpcy5vbmN1ZShfdGhpcy5jdWUpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5jdWUgPSBudWxsOyAvLyBFbnRlciBCQURXRUJWVFQgc3RhdGUgaWYgaGVhZGVyIHdhcyBub3QgcGFyc2VkIGNvcnJlY3RseSBvdGhlcndpc2VcbiAgICAgIC8vIGFub3RoZXIgZXhjZXB0aW9uIG9jY3VycmVkIHNvIGVudGVyIEJBRENVRSBzdGF0ZS5cblxuICAgICAgX3RoaXMuc3RhdGUgPSBfdGhpcy5zdGF0ZSA9PT0gJ0lOSVRJQUwnID8gJ0JBRFdFQlZUVCcgOiAnQkFEQ1VFJztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8zLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRyeSB7XG4gICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cbiAgICAgIC8vIF90aGlzLmJ1ZmZlciArPSBfdGhpcy5kZWNvZGVyLmRlY29kZSgpO1xuICAgICAgLy8gU3ludGhlc2l6ZSB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGN1ZSBvciByZWdpb24uXG4gICAgICBpZiAoX3RoaXMuY3VlIHx8IF90aGlzLnN0YXRlID09PSAnSEVBREVSJykge1xuICAgICAgICBfdGhpcy5idWZmZXIgKz0gJ1xcblxcbic7XG5cbiAgICAgICAgX3RoaXMucGFyc2UoKTtcbiAgICAgIH0gLy8gSWYgd2UndmUgZmx1c2hlZCwgcGFyc2VkLCBhbmQgd2UncmUgc3RpbGwgb24gdGhlIElOSVRJQUwgc3RhdGUgdGhlblxuICAgICAgLy8gdGhhdCBtZWFucyB3ZSBkb24ndCBoYXZlIGVub3VnaCBvZiB0aGUgc3RyZWFtIHRvIHBhcnNlIHRoZSBmaXJzdFxuICAgICAgLy8gbGluZS5cblxuXG4gICAgICBpZiAoX3RoaXMuc3RhdGUgPT09ICdJTklUSUFMJyB8fCBfdGhpcy5zdGF0ZSA9PT0gJ0JBRFdFQlZUVCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS4nKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoX3RoaXMub25wYXJzaW5nZXJyb3IpIHtcbiAgICAgICAgX3RoaXMub25wYXJzaW5nZXJyb3IoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLm9uZmx1c2gpIHtcbiAgICAgIF90aGlzLm9uZmx1c2goKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gVlRUUGFyc2VyO1xufSgpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy93ZWJ2dHQtcGFyc2VyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvd2VidnR0LXBhcnNlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGdlbmVyYXRlQ3VlSWQsIHBhcnNlV2ViVlRUICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdlbmVyYXRlQ3VlSWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZW5lcmF0ZUN1ZUlkOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwYXJzZVdlYlZUVFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhcnNlV2ViVlRUOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdnR0cGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Z0dHBhcnNlciAqLyBcIi4vc3JjL3V0aWxzL3Z0dHBhcnNlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9pZDMgKi8gXCIuL3NyYy9kZW11eC9pZDMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RpbWVzY2FsZV9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RpbWVzY2FsZS1jb252ZXJzaW9uICovIFwiLi9zcmMvdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24udHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3JlbXV4X21wNF9yZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9yZW11eC9tcDQtcmVtdXhlciAqLyBcIi4vc3JjL3JlbXV4L21wNC1yZW11eGVyLnRzXCIpO1xuXG5cblxuXG5cblxuXG5cbnZhciBMSU5FQlJFQUtTID0gL1xcclxcbnxcXG5cXHJ8XFxufFxcci9nOyAvLyBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggaXMgbm90IHN1cHBvcnRlZCBpbiBJRTExXG5cbnZhciBzdGFydHNXaXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aChpbnB1dFN0cmluZywgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICBpZiAocG9zaXRpb24gPT09IHZvaWQgMCkge1xuICAgIHBvc2l0aW9uID0gMDtcbiAgfVxuXG4gIHJldHVybiBpbnB1dFN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nO1xufTtcblxudmFyIGN1ZVN0cmluZzJtaWxsaXMgPSBmdW5jdGlvbiBjdWVTdHJpbmcybWlsbGlzKHRpbWVTdHJpbmcpIHtcbiAgdmFyIHRzID0gcGFyc2VJbnQodGltZVN0cmluZy5zbGljZSgtMykpO1xuICB2YXIgc2VjcyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc2xpY2UoLTYsIC00KSk7XG4gIHZhciBtaW5zID0gcGFyc2VJbnQodGltZVN0cmluZy5zbGljZSgtOSwgLTcpKTtcbiAgdmFyIGhvdXJzID0gdGltZVN0cmluZy5sZW5ndGggPiA5ID8gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHJpbmcoMCwgdGltZVN0cmluZy5pbmRleE9mKCc6JykpKSA6IDA7XG5cbiAgaWYgKCFPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKHRzKSB8fCAhT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShzZWNzKSB8fCAhT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShtaW5zKSB8fCAhT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShob3VycykpIHtcbiAgICB0aHJvdyBFcnJvcihcIk1hbGZvcm1lZCBYLVRJTUVTVEFNUC1NQVA6IExvY2FsOlwiICsgdGltZVN0cmluZyk7XG4gIH1cblxuICB0cyArPSAxMDAwICogc2VjcztcbiAgdHMgKz0gNjAgKiAxMDAwICogbWlucztcbiAgdHMgKz0gNjAgKiA2MCAqIDEwMDAgKiBob3VycztcbiAgcmV0dXJuIHRzO1xufTsgLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaFxuXG5cbnZhciBoYXNoID0gZnVuY3Rpb24gaGFzaCh0ZXh0KSB7XG4gIHZhciBoYXNoID0gNTM4MTtcbiAgdmFyIGkgPSB0ZXh0Lmxlbmd0aDtcblxuICB3aGlsZSAoaSkge1xuICAgIGhhc2ggPSBoYXNoICogMzMgXiB0ZXh0LmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuXG4gIHJldHVybiAoaGFzaCA+Pj4gMCkudG9TdHJpbmcoKTtcbn07IC8vIENyZWF0ZSBhIHVuaXF1ZSBoYXNoIGlkIGZvciBhIGN1ZSBiYXNlZCBvbiBzdGFydC9lbmQgdGltZXMgYW5kIHRleHQuXG4vLyBUaGlzIGhlbHBzIHRpbWVsaW5lLWNvbnRyb2xsZXIgdG8gYXZvaWQgc2hvd2luZyByZXBlYXRlZCBjYXB0aW9ucy5cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZUN1ZUlkKHN0YXJ0VGltZSwgZW5kVGltZSwgdGV4dCkge1xuICByZXR1cm4gaGFzaChzdGFydFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKGVuZFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKHRleHQpO1xufVxuXG52YXIgY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KHZ0dENDcywgY2MsIHByZXNlbnRhdGlvblRpbWUpIHtcbiAgdmFyIGN1cnJDQyA9IHZ0dENDc1tjY107XG4gIHZhciBwcmV2Q0MgPSB2dHRDQ3NbY3VyckNDLnByZXZDQ107IC8vIFRoaXMgaXMgdGhlIGZpcnN0IGRpc2NvbnRpbnVpdHkgb3IgY3VlcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHNpbmNlIHRoZSBsYXN0IGRpc2NvbnRpbnVpdHlcbiAgLy8gT2Zmc2V0ID0gY3VycmVudCBkaXNjb250aW51aXR5IHRpbWVcblxuICBpZiAoIXByZXZDQyB8fCAhcHJldkNDLm5ldyAmJiBjdXJyQ0MubmV3KSB7XG4gICAgdnR0Q0NzLmNjT2Zmc2V0ID0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9IC8vIFRoZXJlIGhhdmUgYmVlbiBkaXNjb250aW51aXRpZXMgc2luY2UgY3VlcyB3ZXJlIGxhc3QgcGFyc2VkLlxuICAvLyBPZmZzZXQgPSB0aW1lIGVsYXBzZWRcblxuXG4gIHdoaWxlICgoX3ByZXZDQyA9IHByZXZDQykgIT09IG51bGwgJiYgX3ByZXZDQyAhPT0gdm9pZCAwICYmIF9wcmV2Q0MubmV3KSB7XG4gICAgdmFyIF9wcmV2Q0M7XG5cbiAgICB2dHRDQ3MuY2NPZmZzZXQgKz0gY3VyckNDLnN0YXJ0IC0gcHJldkNDLnN0YXJ0O1xuICAgIGN1cnJDQy5uZXcgPSBmYWxzZTtcbiAgICBjdXJyQ0MgPSBwcmV2Q0M7XG4gICAgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuICB9XG5cbiAgdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IHByZXNlbnRhdGlvblRpbWU7XG59O1xuXG5mdW5jdGlvbiBwYXJzZVdlYlZUVCh2dHRCeXRlQXJyYXksIGluaXRQVFMsIHRpbWVzY2FsZSwgdnR0Q0NzLCBjYywgdGltZU9mZnNldCwgY2FsbEJhY2ssIGVycm9yQ2FsbEJhY2spIHtcbiAgdmFyIHBhcnNlciA9IG5ldyBfdnR0cGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJWVFRQYXJzZXJcIl0oKTsgLy8gQ29udmVydCBieXRlQXJyYXkgaW50byBzdHJpbmcsIHJlcGxhY2luZyBhbnkgc29tZXdoYXQgZXhvdGljIGxpbmVmZWVkcyB3aXRoIFwiXFxuXCIsIHRoZW4gc3BsaXQgb24gdGhhdCBjaGFyYWN0ZXIuXG4gIC8vIFVpbnQ4QXJyYXkucHJvdG90eXBlLnJlZHVjZSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gSUUxMVxuXG4gIHZhciB2dHRMaW5lcyA9IE9iamVjdChfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJ1dGY4QXJyYXlUb1N0clwiXSkobmV3IFVpbnQ4QXJyYXkodnR0Qnl0ZUFycmF5KSkudHJpbSgpLnJlcGxhY2UoTElORUJSRUFLUywgJ1xcbicpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGN1ZXMgPSBbXTtcbiAgdmFyIGluaXRQVFM5MEh6ID0gT2JqZWN0KF90aW1lc2NhbGVfY29udmVyc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1widG9NcGVnVHNDbG9ja0Zyb21UaW1lc2NhbGVcIl0pKGluaXRQVFMsIHRpbWVzY2FsZSk7XG4gIHZhciBjdWVUaW1lID0gJzAwOjAwLjAwMCc7XG4gIHZhciB0aW1lc3RhbXBNYXBNUEVHVFMgPSAwO1xuICB2YXIgdGltZXN0YW1wTWFwTE9DQUwgPSAwO1xuICB2YXIgcGFyc2luZ0Vycm9yO1xuICB2YXIgaW5IZWFkZXIgPSB0cnVlO1xuXG4gIHBhcnNlci5vbmN1ZSA9IGZ1bmN0aW9uIChjdWUpIHtcbiAgICAvLyBBZGp1c3QgY3VlIHRpbWluZzsgY2xhbXAgY3VlcyB0byBzdGFydCBubyBlYXJsaWVyIHRoYW4gLSBhbmQgZHJvcCBjdWVzIHRoYXQgZG9uJ3QgZW5kIGFmdGVyIC0gMCBvbiB0aW1lbGluZS5cbiAgICB2YXIgY3VyckNDID0gdnR0Q0NzW2NjXTtcbiAgICB2YXIgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0OyAvLyBDYWxjdWxhdGUgc3VidGl0bGUgUFRTIG9mZnNldFxuXG4gICAgdmFyIHdlYlZ0dE1wZWdUc01hcE9mZnNldCA9ICh0aW1lc3RhbXBNYXBNUEVHVFMgLSBpbml0UFRTOTBIeikgLyA5MDAwMDsgLy8gVXBkYXRlIG9mZnNldHMgZm9yIG5ldyBkaXNjb250aW51aXRpZXNcblxuICAgIGlmIChjdXJyQ0MgIT09IG51bGwgJiYgY3VyckNDICE9PSB2b2lkIDAgJiYgY3VyckNDLm5ldykge1xuICAgICAgaWYgKHRpbWVzdGFtcE1hcExPQ0FMICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gV2hlbiBsb2NhbCB0aW1lIGlzIHByb3ZpZGVkLCBvZmZzZXQgPSBkaXNjb250aW51aXR5IHN0YXJ0IHRpbWUgLSBsb2NhbCB0aW1lXG4gICAgICAgIGN1ZU9mZnNldCA9IHZ0dENDcy5jY09mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCB3ZWJWdHRNcGVnVHNNYXBPZmZzZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3ZWJWdHRNcGVnVHNNYXBPZmZzZXQpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgTVBFR1RTLCBvZmZzZXQgPSBwcmVzZW50YXRpb24gdGltZSArIGRpc2NvbnRpbnVpdHkgb2Zmc2V0XG4gICAgICBjdWVPZmZzZXQgPSB3ZWJWdHRNcGVnVHNNYXBPZmZzZXQgLSB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciBkdXJhdGlvbiA9IGN1ZS5lbmRUaW1lIC0gY3VlLnN0YXJ0VGltZTtcbiAgICB2YXIgc3RhcnRUaW1lID0gT2JqZWN0KF9yZW11eF9tcDRfcmVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wibm9ybWFsaXplUHRzXCJdKSgoY3VlLnN0YXJ0VGltZSArIGN1ZU9mZnNldCAtIHRpbWVzdGFtcE1hcExPQ0FMKSAqIDkwMDAwLCB0aW1lT2Zmc2V0ICogOTAwMDApIC8gOTAwMDA7XG4gICAgY3VlLnN0YXJ0VGltZSA9IE1hdGgubWF4KHN0YXJ0VGltZSwgMCk7XG4gICAgY3VlLmVuZFRpbWUgPSBNYXRoLm1heChzdGFydFRpbWUgKyBkdXJhdGlvbiwgMCk7IC8vdHJpbSB0cmFpbGluZyB3ZWJ2dHQgYmxvY2sgd2hpdGVzcGFjZXNcblxuICAgIHZhciB0ZXh0ID0gY3VlLnRleHQudHJpbSgpOyAvLyBGaXggZW5jb2Rpbmcgb2Ygc3BlY2lhbCBjaGFyYWN0ZXJzXG5cbiAgICBjdWUudGV4dCA9IGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQodGV4dCkpOyAvLyBJZiB0aGUgY3VlIHdhcyBub3QgYXNzaWduZWQgYW4gaWQgZnJvbSB0aGUgVlRUIGZpbGUgKGxpbmUgYWJvdmUgdGhlIGNvbnRlbnQpLCBjcmVhdGUgb25lLlxuXG4gICAgaWYgKCFjdWUuaWQpIHtcbiAgICAgIGN1ZS5pZCA9IGdlbmVyYXRlQ3VlSWQoY3VlLnN0YXJ0VGltZSwgY3VlLmVuZFRpbWUsIHRleHQpO1xuICAgIH1cblxuICAgIGlmIChjdWUuZW5kVGltZSA+IDApIHtcbiAgICAgIGN1ZXMucHVzaChjdWUpO1xuICAgIH1cbiAgfTtcblxuICBwYXJzZXIub25wYXJzaW5nZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBwYXJzaW5nRXJyb3IgPSBlcnJvcjtcbiAgfTtcblxuICBwYXJzZXIub25mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocGFyc2luZ0Vycm9yKSB7XG4gICAgICBlcnJvckNhbGxCYWNrKHBhcnNpbmdFcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbEJhY2soY3Vlcyk7XG4gIH07IC8vIEdvIHRocm91Z2ggY29udGVudHMgbGluZSBieSBsaW5lLlxuXG5cbiAgdnR0TGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgIGlmIChpbkhlYWRlcikge1xuICAgICAgLy8gTG9vayBmb3IgWC1USU1FU1RBTVAtTUFQIGluIGhlYWRlci5cbiAgICAgIGlmIChzdGFydHNXaXRoKGxpbmUsICdYLVRJTUVTVEFNUC1NQVA9JykpIHtcbiAgICAgICAgLy8gT25jZSBmb3VuZCwgbm8gbW9yZSBhcmUgYWxsb3dlZCBhbnl3YXksIHNvIHN0b3Agc2VhcmNoaW5nLlxuICAgICAgICBpbkhlYWRlciA9IGZhbHNlOyAvLyBFeHRyYWN0IExPQ0FMIGFuZCBNUEVHVFMuXG5cbiAgICAgICAgbGluZS5zbGljZSgxNikuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICAgICAgICBpZiAoc3RhcnRzV2l0aCh0aW1lc3RhbXAsICdMT0NBTDonKSkge1xuICAgICAgICAgICAgY3VlVGltZSA9IHRpbWVzdGFtcC5zbGljZSg2KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0c1dpdGgodGltZXN0YW1wLCAnTVBFR1RTOicpKSB7XG4gICAgICAgICAgICB0aW1lc3RhbXBNYXBNUEVHVFMgPSBwYXJzZUludCh0aW1lc3RhbXAuc2xpY2UoNykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBDb252ZXJ0IGN1ZSB0aW1lIHRvIHNlY29uZHNcbiAgICAgICAgICB0aW1lc3RhbXBNYXBMT0NBTCA9IGN1ZVN0cmluZzJtaWxsaXMoY3VlVGltZSkgLyAxMDAwO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHBhcnNpbmdFcnJvciA9IGVycm9yO1xuICAgICAgICB9IC8vIFJldHVybiB3aXRob3V0IHBhcnNpbmcgWC1USU1FU1RBTVAtTUFQIGxpbmUuXG5cblxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgICAgIGluSGVhZGVyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSAvLyBQYXJzZSBsaW5lIGJ5IGRlZmF1bHQuXG5cblxuICAgIHBhcnNlci5wYXJzZShsaW5lICsgJ1xcbicpO1xuICB9KTtcbiAgcGFyc2VyLmZsdXNoKCk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL3hoci1sb2FkZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy94aHItbG9hZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRlcl9sb2FkX3N0YXRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2FkZXIvbG9hZC1zdGF0cyAqLyBcIi4vc3JjL2xvYWRlci9sb2FkLXN0YXRzLnRzXCIpO1xuXG5cbnZhciBBR0VfSEVBREVSX0xJTkVfUkVHRVggPSAvXmFnZTpcXHMqW1xcZC5dK1xccyokL207XG5cbnZhciBYaHJMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYaHJMb2FkZXIoY29uZmlnXG4gIC8qIEhsc0NvbmZpZyAqL1xuICApIHtcbiAgICB0aGlzLnhoclNldHVwID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXRyeVRpbWVvdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLnN0YXRzID0gdm9pZCAwO1xuICAgIHRoaXMueGhyU2V0dXAgPSBjb25maWcgPyBjb25maWcueGhyU2V0dXAgOiBudWxsO1xuICAgIHRoaXMuc3RhdHMgPSBuZXcgX2xvYWRlcl9sb2FkX3N0YXRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJMb2FkU3RhdHNcIl0oKTtcbiAgICB0aGlzLnJldHJ5RGVsYXkgPSAwO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFhockxvYWRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5hYm9ydEludGVybmFsID0gZnVuY3Rpb24gYWJvcnRJbnRlcm5hbCgpIHtcbiAgICB2YXIgbG9hZGVyID0gdGhpcy5sb2FkZXI7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xuXG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICBsb2FkZXIub25wcm9ncmVzcyA9IG51bGw7XG5cbiAgICAgIGlmIChsb2FkZXIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgdmFyIF90aGlzJGNhbGxiYWNrcztcblxuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuXG4gICAgaWYgKChfdGhpcyRjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrcykgIT09IG51bGwgJiYgX3RoaXMkY2FsbGJhY2tzICE9PSB2b2lkIDAgJiYgX3RoaXMkY2FsbGJhY2tzLm9uQWJvcnQpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uQWJvcnQodGhpcy5zdGF0cywgdGhpcy5jb250ZXh0LCB0aGlzLmxvYWRlcik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5sb2FkID0gZnVuY3Rpb24gbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgIGlmICh0aGlzLnN0YXRzLmxvYWRpbmcuc3RhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTG9hZGVyIGNhbiBvbmx5IGJlIHVzZWQgb25jZS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRzLmxvYWRpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gY29uZmlnLnJldHJ5RGVsYXk7XG4gICAgdGhpcy5sb2FkSW50ZXJuYWwoKTtcbiAgfTtcblxuICBfcHJvdG8ubG9hZEludGVybmFsID0gZnVuY3Rpb24gbG9hZEludGVybmFsKCkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgIGlmICghY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHhociA9IHRoaXMubG9hZGVyID0gbmV3IHNlbGYuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgIHN0YXRzLmxvYWRpbmcuZmlyc3QgPSAwO1xuICAgIHN0YXRzLmxvYWRlZCA9IDA7XG4gICAgdmFyIHhoclNldHVwID0gdGhpcy54aHJTZXR1cDtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoeGhyU2V0dXApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB4aHJTZXR1cCh4aHIsIGNvbnRleHQudXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGZpeCB4aHJTZXR1cDogKHhociwgdXJsKSA9PiB7eGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LUxhbmd1YWdlXCIsIFwidGVzdFwiKTt9XG4gICAgICAgICAgLy8gbm90IHdvcmtpbmcsIGFzIHhoci5zZXRSZXF1ZXN0SGVhZGVyIGV4cGVjdHMgeGhyLnJlYWR5U3RhdGUgPT09IE9QRU5cbiAgICAgICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xuICAgICAgICAgIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgheGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLmNvbnRleHQuaGVhZGVycztcblxuICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJRTExIHRocm93cyBhbiBleGNlcHRpb24gb24geGhyLm9wZW4gaWYgYXR0ZW1wdGluZyB0byBhY2Nlc3MgYW4gSFRUUCByZXNvdXJjZSBvdmVyIEhUVFBTXG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkVycm9yKHtcbiAgICAgICAgY29kZTogeGhyLnN0YXR1cyxcbiAgICAgICAgdGV4dDogZS5tZXNzYWdlXG4gICAgICB9LCBjb250ZXh0LCB4aHIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0LnJhbmdlRW5kKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCAnYnl0ZXM9JyArIGNvbnRleHQucmFuZ2VTdGFydCArICctJyArIChjb250ZXh0LnJhbmdlRW5kIC0gMSkpO1xuICAgIH1cblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLnJlYWR5c3RhdGVjaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB4aHIub25wcm9ncmVzcyA9IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcyk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IGNvbnRleHQucmVzcG9uc2VUeXBlOyAvLyBzZXR1cCB0aW1lb3V0IGJlZm9yZSB3ZSBwZXJmb3JtIHJlcXVlc3RcblxuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBjb25maWcudGltZW91dCk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfTtcblxuICBfcHJvdG8ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIHJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgIHhociA9IHRoaXMubG9hZGVyLFxuICAgICAgICBzdGF0cyA9IHRoaXMuc3RhdHM7XG5cbiAgICBpZiAoIWNvbnRleHQgfHwgIXhocikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGU7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnOyAvLyBkb24ndCBwcm9jZWVkIGlmIHhociBoYXMgYmVlbiBhYm9ydGVkXG5cbiAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gPj0gSEVBREVSU19SRUNFSVZFRFxuXG5cbiAgICBpZiAocmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICAvLyBjbGVhciB4aHIgdGltZW91dCBhbmQgcmVhcm0gaXQgaWYgcmVhZHlTdGF0ZSBsZXNzIHRoYW4gNFxuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG5cbiAgICAgIGlmIChzdGF0cy5sb2FkaW5nLmZpcnN0ID09PSAwKSB7XG4gICAgICAgIHN0YXRzLmxvYWRpbmcuZmlyc3QgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy5sb2FkaW5nLnN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHhoci5vbnByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHhoci5zdGF0dXM7IC8vIGh0dHAgc3RhdHVzIGJldHdlZW4gMjAwIHRvIDI5OSBhcmUgYWxsIHN1Y2Nlc3NmdWxcblxuICAgICAgICBpZiAoc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICBzdGF0cy5sb2FkaW5nLmVuZCA9IE1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLmxvYWRpbmcuZmlyc3QpO1xuICAgICAgICAgIHZhciBkYXRhO1xuICAgICAgICAgIHZhciBsZW47XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgICAgIGRhdGEgPSB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhdHMubG9hZGVkID0gc3RhdHMudG90YWwgPSBsZW47XG5cbiAgICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9uUHJvZ3Jlc3MgPSB0aGlzLmNhbGxiYWNrcy5vblByb2dyZXNzO1xuXG4gICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGRhdGEsIHhocik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIHVybDogeGhyLnJlc3BvbnNlVVJMLFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgeGhyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxuICAgICAgICAgIGlmIChzdGF0cy5yZXRyeSA+PSBjb25maWcubWF4UmV0cnkgfHwgc3RhdHVzID49IDQwMCAmJiBzdGF0dXMgPCA0OTkpIHtcbiAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImxvZ2dlclwiXS5lcnJvcihzdGF0dXMgKyBcIiB3aGlsZSBsb2FkaW5nIFwiICsgY29udGV4dC51cmwpO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcih7XG4gICAgICAgICAgICAgIGNvZGU6IHN0YXR1cyxcbiAgICAgICAgICAgICAgdGV4dDogeGhyLnN0YXR1c1RleHRcbiAgICAgICAgICAgIH0sIGNvbnRleHQsIHhocik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJldHJ5XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJsb2dnZXJcIl0ud2FybihzdGF0dXMgKyBcIiB3aGlsZSBsb2FkaW5nIFwiICsgY29udGV4dC51cmwgKyBcIiwgcmV0cnlpbmcgaW4gXCIgKyB0aGlzLnJldHJ5RGVsYXkgKyBcIi4uLlwiKTsgLy8gYWJvcnQgYW5kIHJlc2V0IGludGVybmFsIHN0YXRlXG5cbiAgICAgICAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBudWxsOyAvLyBzY2hlZHVsZSByZXRyeVxuXG4gICAgICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnJldHJ5VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLCB0aGlzLnJldHJ5RGVsYXkpOyAvLyBzZXQgZXhwb25lbnRpYWwgYmFja29mZlxuXG4gICAgICAgICAgICB0aGlzLnJldHJ5RGVsYXkgPSBNYXRoLm1pbigyICogdGhpcy5yZXRyeURlbGF5LCBjb25maWcubWF4UmV0cnlEZWxheSk7XG4gICAgICAgICAgICBzdGF0cy5yZXRyeSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVhZHlTdGF0ZSA+PSAyIEFORCByZWFkeVN0YXRlICE9PTQgKHJlYWR5U3RhdGUgPSBIRUFERVJTX1JFQ0VJVkVEIHx8IExPQURJTkcpIHJlYXJtIHRpbWVvdXQgYXMgeGhyIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBjb25maWcudGltZW91dCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5sb2FkdGltZW91dCA9IGZ1bmN0aW9uIGxvYWR0aW1lb3V0KCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImxvZ2dlclwiXS53YXJuKFwidGltZW91dCB3aGlsZSBsb2FkaW5nIFwiICsgdGhpcy5jb250ZXh0LnVybCk7XG4gICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzO1xuXG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgICBjYWxsYmFja3Mub25UaW1lb3V0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgdGhpcy5sb2FkZXIpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ubG9hZHByb2dyZXNzID0gZnVuY3Rpb24gbG9hZHByb2dyZXNzKGV2ZW50KSB7XG4gICAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBzdGF0cy5sb2FkZWQgPSBldmVudC5sb2FkZWQ7XG5cbiAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgc3RhdHMudG90YWwgPSBldmVudC50b3RhbDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldENhY2hlQWdlID0gZnVuY3Rpb24gZ2V0Q2FjaGVBZ2UoKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5sb2FkZXIgJiYgQUdFX0hFQURFUl9MSU5FX1JFR0VYLnRlc3QodGhpcy5sb2FkZXIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKSB7XG4gICAgICB2YXIgYWdlSGVhZGVyID0gdGhpcy5sb2FkZXIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2FnZScpO1xuICAgICAgcmVzdWx0ID0gYWdlSGVhZGVyID8gcGFyc2VGbG9hdChhZ2VIZWFkZXIpIDogbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBYaHJMb2FkZXI7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoWGhyTG9hZGVyKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSlbXCJkZWZhdWx0XCJdO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/hls.js/dist/hls.js\n"));

/***/ }),

/***/ "./src/components/WatchView/Player.tsx":
/*!*********************************************!*\
  !*** ./src/components/WatchView/Player.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/src/_object_spread.mjs */ \"./node_modules/@swc/helpers/src/_object_spread.mjs\");\n/* harmony import */ var _swc_helpers_src_object_spread_props_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/src/_object_spread_props.mjs */ \"./node_modules/@swc/helpers/src/_object_spread_props.mjs\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ducanh2912_react_hls_player__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ducanh2912/react-hls-player */ \"./node_modules/@ducanh2912/react-hls-player/dist/index.modern.mjs\");\n/* harmony import */ var react_tuby__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-tuby */ \"./node_modules/react-tuby/dist/react-tuby.esm.js\");\n\n\nvar _this = undefined;\n\n\n\nvar Player = function(props) {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_tuby__WEBPACK_IMPORTED_MODULE_2__.Player, (0,_swc_helpers_src_object_spread_props_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"])((0,_swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])({}, props), {\n        children: function(ref, props) {\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ducanh2912_react_hls_player__WEBPACK_IMPORTED_MODULE_1__[\"default\"], (0,_swc_helpers_src_object_spread_props_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"])((0,_swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])({\n                playerRef: ref\n            }, props), {\n                src: props.src\n            }), void 0, false, {\n                fileName: \"E:\\\\LearnReact\\\\dev88phim\\\\src\\\\components\\\\WatchView\\\\Player.tsx\",\n                lineNumber: 8,\n                columnNumber: 24\n            }, _this);\n        }\n    }), void 0, false, {\n        fileName: \"E:\\\\LearnReact\\\\dev88phim\\\\src\\\\components\\\\WatchView\\\\Player.tsx\",\n        lineNumber: 7,\n        columnNumber: 5\n    }, _this);\n};\n_c = Player;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Player);\nvar _c;\n$RefreshReg$(_c, \"Player\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9XYXRjaFZpZXcvUGxheWVyLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7QUFBcUQ7QUFFVztBQUVoRSxJQUFNQyxNQUFNLEdBQW9CLFNBQUNFLEtBQUssRUFBSztJQUN6QyxxQkFDRSw4REFBQ0QsOENBQVcsMEtBQUtDLEtBQUs7a0JBQ25CLFNBQUNDLEdBQUcsRUFBRUQsS0FBSztpQ0FBSyw4REFBQ0gsb0VBQVM7Z0JBQUNLLFNBQVMsRUFBRUQsR0FBRztlQUFNRCxLQUFLO2dCQUFFRyxHQUFHLEVBQUVILEtBQUssQ0FBQ0csR0FBRzs7Ozs7cUJBQUk7U0FBQTs7Ozs7YUFDN0QsQ0FDZDtBQUNKLENBQUM7QUFOS0wsS0FBQUEsTUFBTTtBQVFaLCtEQUFlQSxNQUFNLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvV2F0Y2hWaWV3L1BsYXllci50c3g/YmU0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSGxzUGxheWVyIGZyb20gXCJAZHVjYW5oMjkxMi9yZWFjdC1obHMtcGxheWVyXCI7XG5pbXBvcnQgeyBGQyB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgUGxheWVyIGFzIFZpZGVvUGxheWVyLCBQbGF5ZXJQcm9wcyB9IGZyb20gXCJyZWFjdC10dWJ5XCI7XG5cbmNvbnN0IFBsYXllcjogRkM8UGxheWVyUHJvcHM+ID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPFZpZGVvUGxheWVyIHsuLi5wcm9wc30+XG4gICAgICB7KHJlZiwgcHJvcHMpID0+IDxIbHNQbGF5ZXIgcGxheWVyUmVmPXtyZWZ9IHsuLi5wcm9wc30gc3JjPXtwcm9wcy5zcmN9IC8+fVxuICAgIDwvVmlkZW9QbGF5ZXI+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBQbGF5ZXI7XG4iXSwibmFtZXMiOlsiSGxzUGxheWVyIiwiUGxheWVyIiwiVmlkZW9QbGF5ZXIiLCJwcm9wcyIsInJlZiIsInBsYXllclJlZiIsInNyYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/WatchView/Player.tsx\n"));

/***/ }),

/***/ "./node_modules/react-tuby/dist/react-tuby.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/react-tuby/dist/react-tuby.esm.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Player\": function() { return /* binding */ Player$1; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar ClientRender = function ClientRender(_ref) {\n  var children = _ref.children;\n\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(typeof window !== \"undefined\"),\n      rendered = _useState[0],\n      setRendered = _useState[1];\n\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    setRendered(true);\n  }, []);\n  if (rendered) return children;\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null);\n};\n\nvar ErrorBoundary = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(ErrorBoundary, _Component);\n\n  function ErrorBoundary(props) {\n    var _this;\n\n    _this = _Component.call(this, props) || this;\n    _this.state = {\n      hasError: false\n    };\n    _this.playerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    _this.videoProps = {\n      crossOrigin: \"anonymous\",\n      playsInline: true,\n      controls: true,\n      src: typeof _this.props.src === \"string\" ? _this.props.src : _this.props.src[0].url,\n      children: react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, _this.props.subtitles && _this.props.subtitles.length > 0 && _this.props.subtitles.map(function (subtitle, index) {\n        return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"track\", {\n          key: subtitle.lang,\n          kind: \"subtitles\",\n          srcLang: subtitle.lang,\n          label: subtitle.language,\n          src: subtitle.url,\n          \"default\": index === 0\n        });\n      }))\n    };\n    return _this;\n  }\n\n  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError() {\n    return {\n      hasError: true\n    };\n  };\n\n  var _proto = ErrorBoundary.prototype;\n\n  _proto.render = function render() {\n    if (this.state.hasError) {\n      return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        className: \"tuby-container\"\n      }, this.props.renderer ? this.props.renderer(this.playerRef, this.videoProps) : react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"video\", Object.assign({\n        ref: this.playerRef\n      }, this.videoProps)));\n    }\n\n    return this.props.children;\n  };\n\n  return ErrorBoundary;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n\nvar formatVideoTime = function formatVideoTime(time) {\n  try {\n    var date = new Date(0);\n    date.setSeconds(time);\n    var timeString = date.toISOString().slice(11, 19);\n    var result = timeString.startsWith(\"00:0\") ? timeString.slice(4) : timeString.startsWith(\"00\") ? timeString.slice(3) : timeString;\n    return result;\n  } catch (error) {\n    return \"0:00\";\n  }\n};\nvar isMobile = function isMobile() {\n  var _window, _window$navigator;\n\n  return /iPhone|iPad|iPod|Android/i.test((_window = window) == null ? void 0 : (_window$navigator = _window.navigator) == null ? void 0 : _window$navigator.userAgent);\n};\n\nvar CircularProgress = function CircularProgress() {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", {\n    className: \"tuby-progress\",\n    viewBox: \"25 25 50 50\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"circle\", {\n    cx: \"50\",\n    cy: \"50\",\n    r: \"20\"\n  }));\n};\n\nvar ClickAwayListener = function ClickAwayListener(_ref) {\n  var children = _ref.children,\n      onClickAway = _ref.onClickAway;\n  var childrenRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    var handler = function handler(e) {\n      if (childrenRef.current && !childrenRef.current.contains(e.target)) {\n        onClickAway();\n      }\n    };\n\n    window.addEventListener(\"click\", handler);\n    return function () {\n      return window.removeEventListener(\"click\", handler);\n    };\n  }, [onClickAway]);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, children(childrenRef));\n};\n\nvar Cog = function Cog(_ref) {\n  var others = _extends({}, _ref);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    viewBox: \"0 0 50 50\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, others), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M44.1242 27.4467C44.2208 26.6625 44.2852 25.8469 44.2852 25C44.2852 24.1531 44.2208 23.3689 44.1242 22.5533L49.5331 18.4128C50.016 18.0364 50.1448 17.3777 49.8228 16.8131L44.6715 8.15558C44.3818 7.62233 43.6735 7.40276 43.1262 7.62233L36.7192 10.1317C35.3992 9.12798 33.9504 8.31242 32.3728 7.68507L31.4069 1.03513C31.3425 0.439147 30.7952 0 30.1513 0H19.8487C19.2048 0 18.6897 0.439147 18.5931 1.03513L17.6272 7.68507C16.0818 8.31242 14.633 9.15935 13.2808 10.1317L6.87385 7.62233C6.29432 7.40276 5.61822 7.62233 5.32846 8.15558L0.17715 16.8131C-0.144806 17.3463 0.0161725 18.0364 0.466912 18.4128L5.87578 22.5533C5.7792 23.3375 5.7148 24.1844 5.7148 25C5.7148 25.8156 5.7792 26.6311 5.87578 27.4467L0.466912 31.5872C-0.0160232 31.9636 -0.144806 32.6223 0.17715 33.187L5.32846 41.8444C5.61822 42.3777 6.32652 42.5972 6.87385 42.3777L13.2808 39.8683C14.6008 40.872 16.0496 41.6876 17.6272 42.3149L18.5931 48.9649C18.6575 49.5609 19.2048 50 19.8487 50H30.1513C30.7952 50 31.3103 49.5609 31.4069 48.9649L32.3728 42.3149C33.9182 41.6876 35.367 40.8407 36.7192 39.8683L43.1262 42.3777C43.7057 42.5972 44.3818 42.3777 44.6715 41.8444L49.8228 33.187C50.1126 32.6537 49.9838 31.9636 49.5331 31.5872L44.1242 27.4467V27.4467ZM25 33.7516C20.0419 33.7516 15.9852 29.8306 15.9852 24.9686C15.9852 20.138 20.0097 16.1857 25 16.1857C29.9581 16.1857 34.0148 20.1067 34.0148 24.9686C34.0148 29.7992 29.9903 33.7516 25 33.7516Z\",\n    fill: \"white\"\n  }));\n};\n\nvar ExitFullScreen = function ExitFullScreen(_ref) {\n  var others = _extends({}, _ref);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    viewBox: \"0 0 50 50\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, others), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M12.5 12.5H0V18.75H18.75V0H12.5V12.5Z\",\n    fill: \"white\"\n  }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M37.5 12.5V1.14441e-05H31.25V18.75H50V12.5H37.5Z\",\n    fill: \"white\"\n  }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M31.25 50H37.5V37.5H50V31.25H31.25V50Z\",\n    fill: \"white\"\n  }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M0 37.5H12.5V50H18.75V31.25H0V37.5Z\",\n    fill: \"white\"\n  }));\n};\n\nvar FullScreen = function FullScreen(_ref) {\n  var others = _extends({}, _ref);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    viewBox: \"0 0 50 50\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, others), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M0 18.75H6.25V6.25H18.75V0H0V18.75Z\",\n    fill: \"white\"\n  }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M31.25 0V6.25H43.75V18.75H50V0H31.25Z\",\n    fill: \"white\"\n  }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M43.75 43.75H31.25V50H50V31.25H43.75V43.75Z\",\n    fill: \"white\"\n  }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M6.25 31.25H0V50H18.75V43.75H6.25V31.25Z\",\n    fill: \"white\"\n  }));\n};\n\nvar Pause = function Pause(_ref) {\n  var others = _extends({}, _ref);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    viewBox: \"0 0 50 50\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, others), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M5 50H17.3077V0H5V50ZM32.6923 50H45V0H32.6923V50Z\",\n    fill: \"white\"\n  }));\n};\n\nvar PauseEffect = function PauseEffect() {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-fade-zoom-out tuby-effect-icon\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Pause, {\n    className: \"tuby-icon-md\"\n  }));\n};\n\nvar PictureInPicture = function PictureInPicture(_ref) {\n  var others = _extends({}, _ref);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    viewBox: \"0 0 50 50\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, others), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M40.9091 22.6667H22.7273V36.6667H40.9091V22.6667ZM50 41.3333V8.62C50 6.05333 47.9545 4 45.4545 4H4.54545C2.04545 4 0 6.05333 0 8.62V41.3333C0 43.9 2.04545 46 4.54545 46H45.4545C47.9545 46 50 43.9 50 41.3333ZM45.4545 41.38H4.54545V8.59667H45.4545V41.38Z\",\n    fill: \"white\"\n  }));\n};\n\nvar Play = function Play(_ref) {\n  var others = _extends({}, _ref);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    width: \"50\",\n    height: \"50\",\n    viewBox: \"0 0 26 26\",\n    fill: \"#FFFFFF\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, others), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M3 1V25L23 13L3 1Z\"\n  }));\n};\n\nvar PlayEffect = function PlayEffect() {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-fade-zoom-out tuby-effect-icon\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Play, {\n    className: \"tuby-icon-md\"\n  }));\n};\n\nvar Check = function Check(_ref) {\n  var others = _extends({}, _ref);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    viewBox: \"0 0 50 50\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, others), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M48.9536 8.08584C50.3488 9.53131 50.3488 11.8672 48.9536 13.3127L20.3806 42.9159C18.9854 44.3614 16.7308 44.3614 15.3357 42.9159L1.04604 28.1143C-0.34868 26.6688 -0.34868 24.3329 1.04604 22.8875C2.44098 21.442 4.70227 21.442 6.09744 22.8875L17.7577 35.0641L43.9087 8.08584C45.3039 6.63805 47.5585 6.63805 48.9536 8.08584Z\",\n    fill: \"#fff\"\n  }));\n};\n\nvar ChevronLeft = function ChevronLeft(_ref) {\n  var others = _extends({}, _ref);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    viewBox: \"0 0 50 50\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, others), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M40 5.875L21.4575 25L40 44.125L34.2915 50L10 25L34.2915 0L40 5.875Z\",\n    fill: \"white\"\n  }));\n};\n\nvar ChevronRight = function ChevronRight(_ref) {\n  var others = _extends({}, _ref);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    viewBox: \"0 0 50 50\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, others), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M10 44.125L28.5425 25L10 5.875L15.7085 0L40 25L15.7085 50L10 44.125Z\",\n    fill: \"white\"\n  }));\n};\n\nvar Speed = function Speed(_ref) {\n  var others = _extends({}, _ref);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    viewBox: \"0 0 50 50\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, others), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M33.3333 40.5294H50V43.3529H33.3333V40.5294ZM22.2222 40.5294H0V43.3529H22.2222V49H25V43.3529V40.5294V34.8824H22.2222V40.5294ZM30.5556 15.1176H33.3333V9.47059V6.64706V1H30.5556V6.64706H0V9.47059H30.5556V15.1176ZM41.6667 6.64706V9.47059H50V6.64706H41.6667ZM8.33333 32.0588H11.1111V26.4118V23.5882V17.9412H8.33333V23.5882H0V26.4118H8.33333V32.0588ZM19.4444 26.4118H50V23.5882H19.4444V26.4118Z\",\n    fill: \"white\"\n  }));\n};\n\nvar SelectSubtitle = function SelectSubtitle(_ref) {\n  var others = _extends({}, _ref);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    viewBox: \"0 0 50 50\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, others), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M8.33333 30.5556V19.4444C8.33333 17.9167 9.58333 16.6667 11.1111 16.6667H19.4444C20.9722 16.6667 22.2222 17.9167 22.2222 19.4444V22.2222H18.0556V20.8333H12.5V29.1667H18.0556V27.7778H22.2222V30.5556C22.2222 32.0833 20.9722 33.3333 19.4444 33.3333H11.1111C9.58333 33.3333 8.33333 32.0833 8.33333 30.5556ZM30.5556 33.3333H38.8889C40.4167 33.3333 41.6667 32.0833 41.6667 30.5556V27.7778H37.5V29.1667H31.9444V20.8333H37.5V22.2222H41.6667V19.4444C41.6667 17.9167 40.4167 16.6667 38.8889 16.6667H30.5556C29.0278 16.6667 27.7778 17.9167 27.7778 19.4444V30.5556C27.7778 32.0833 29.0278 33.3333 30.5556 33.3333ZM47.2222 2.77778H2.77778V47.2222H47.2222V2.77778ZM50 0V50H0V0.0277778C0 -2.58701e-08 -2.58701e-08 0 0.0277778 0H50Z\",\n    fill: \"white\"\n  }));\n};\n\nvar Speed$1 = function Speed(_ref) {\n  var others = _extends({}, _ref);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    viewBox: \"0 0 50 50\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, others), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M20 15V35L35 25L20 15ZM10.75 7.5L9.25 5.5C13 2.5 17.5 0.5 22.5 0L22.75 2.5C18.25 3 14.25 4.75 10.75 7.5ZM7.5 10.75L5.5 9.25C2.5 13 0.5 17.5 0 22.5L2.5 22.75C3 18.25 4.75 14.25 7.5 10.75ZM7.5 39.25C4.75 35.75 3 31.5 2.5 27.25L0 27.5C0.5 32.5 2.5 37 5.5 41L7.5 39.25ZM22.75 47.5C18.25 47 14.25 45.25 10.75 42.5L9.25 44.5C13 47.5 17.5 49.5 22.5 50L22.75 47.5ZM50 25C50 12 40.25 1.5 27.5 0L27.25 2.5C38.75 3.75 47.5 13.25 47.5 25C47.5 36.75 38.75 46.25 27.25 47.5L27.5 50C40.5 48.75 50 38 50 25Z\",\n    fill: \"white\"\n  }));\n};\n\nvar SettingsDialog = function SettingsDialog(_ref) {\n  var settingsActive = _ref.settingsActive,\n      src = _ref.src,\n      subtitles = _ref.subtitles,\n      playbackSpeed = _ref.playbackSpeed,\n      setPlaybackSpeed = _ref.setPlaybackSpeed,\n      subtitleIndex = _ref.subtitleIndex,\n      setSubtitleIndex = _ref.setSubtitleIndex,\n      quality = _ref.quality,\n      setQuality = _ref.setQuality,\n      internationalization = _ref.internationalization;\n\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0),\n      height = _useState[0],\n      setHeight = _useState[1];\n\n  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"main\"),\n      activeSection = _useState2[0],\n      setActiveSection = _useState2[1];\n\n  var mainSectionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var speedSectionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var subtitlesSectionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var qualitySectionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var sections = {\n    main: mainSectionRef,\n    speed: speedSectionRef,\n    subtitles: subtitlesSectionRef,\n    quality: qualitySectionRef\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    if (sections[activeSection].current) {\n      var elementHeight = sections[activeSection].current.offsetHeight;\n      setHeight(elementHeight > 250 ? 250 : elementHeight);\n      sections[activeSection].current.scrollTo && sections[activeSection].current.scrollTo(0, 0);\n    } // eslint-disable-next-line\n\n  }, [activeSection]);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-settings-dialog \" + (settingsActive ? \"tuby-show\" : \"\")\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    style: {\n      height: height\n    },\n    className: \"tuby-settings-outer\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    ref: mainSectionRef,\n    className: \"tuby-settings-section tuby-settings-py \" + (activeSection === \"main\" ? \"tuby-settings-translate-center\" : \"tuby-settings-translate-left\")\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    onClick: function onClick() {\n      return setActiveSection(\"speed\");\n    },\n    className: \"tuby-settings-item\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-settings-item-left\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Speed$1, {\n    className: \"tuby-icon-sm\"\n  }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, (internationalization == null ? void 0 : internationalization.settingsPlaybackSpeed) || \"Playback Speed\")), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ChevronRight, {\n    className: \"tuby-chevron\"\n  })), subtitles && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    onClick: function onClick() {\n      return setActiveSection(\"subtitles\");\n    },\n    className: \"tuby-settings-item\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-settings-item-left\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SelectSubtitle, {\n    className: \"tuby-icon-sm\"\n  }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, (internationalization == null ? void 0 : internationalization.settingsSubtitles) || \"Subtitles\")), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ChevronRight, {\n    style: {\n      width: 15,\n      height: 15\n    }\n  })), typeof src !== \"string\" && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    onClick: function onClick() {\n      return setActiveSection(\"quality\");\n    },\n    className: \"tuby-settings-item\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-settings-item-left\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Speed, {\n    className: \"tuby-icon-sm\"\n  }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, (internationalization == null ? void 0 : internationalization.settingsQuality) || \"Quality\")), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ChevronRight, {\n    className: \"tuby-chevron\"\n  }))), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    ref: speedSectionRef,\n    className: \"tuby-settings-section \" + (activeSection === \"speed\" ? \"tuby-settings-translate-center\" : \"tuby-settings-translate-right\")\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    onClick: function onClick() {\n      return setActiveSection(\"main\");\n    },\n    className: \"tuby-settings-section-header\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ChevronLeft, {\n    className: \"tuby-chevron\"\n  }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", null, (internationalization == null ? void 0 : internationalization.settingsPlaybackSpeed) || \"Playback speed\")), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-settings-py\"\n  }, new Array(8).fill(\"\").map(function (_, index) {\n    return index === 3 ? (internationalization == null ? void 0 : internationalization.settingsPlaybackSpeedNormal) || \"Normal\" : (index + 1) / 4;\n  }).map(function (item, index) {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n      key: item,\n      onClick: function onClick() {\n        setPlaybackSpeed((index + 1) / 4);\n        setActiveSection(\"main\");\n      },\n      className: \"tuby-settings-item-2\"\n    }, playbackSpeed === (index + 1) / 4 ? react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Check, {\n      className: \"tuby-chevron\"\n    }) : react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n      style: {\n        width: 15,\n        height: 15\n      }\n    }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", null, item));\n  }))), subtitles && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    ref: subtitlesSectionRef,\n    className: \"tuby-settings-section \" + (activeSection === \"subtitles\" ? \"tuby-settings-translate-center\" : \"tuby-settings-translate-right\")\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    onClick: function onClick() {\n      return setActiveSection(\"main\");\n    },\n    className: \"tuby-settings-section-header\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ChevronLeft, {\n    className: \"tuby-chevron\"\n  }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", null, (internationalization == null ? void 0 : internationalization.settingsSubtitles) || \"Subtitles\")), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-settings-py\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    onClick: function onClick() {\n      setSubtitleIndex(-1);\n      setActiveSection(\"main\");\n    },\n    className: \"tuby-settings-item-2\"\n  }, subtitleIndex === -1 ? react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Check, {\n    className: \"tuby-chevron\"\n  }) : react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    style: {\n      width: 15,\n      height: 15\n    }\n  }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", null, (internationalization == null ? void 0 : internationalization.settingsSubtitlesOff) || \"Off\")), subtitles.map(function (subtitle, index) {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n      key: subtitle.lang,\n      onClick: function onClick() {\n        setSubtitleIndex(index);\n        setActiveSection(\"main\");\n      },\n      className: \"tuby-settings-item-2\"\n    }, subtitleIndex === index ? react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Check, {\n      className: \"tuby-chevron\"\n    }) : react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n      style: {\n        width: 15,\n        height: 15\n      }\n    }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", null, subtitle.language));\n  }))), typeof src !== \"string\" && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    ref: qualitySectionRef,\n    className: \"tuby-settings-section \" + (activeSection === \"quality\" ? \"tuby-settings-translate-center\" : \"tuby-settings-translate-right\")\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    onClick: function onClick() {\n      return setActiveSection(\"main\");\n    },\n    className: \"tuby-settings-section-header\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ChevronLeft, {\n    className: \"tuby-chevron\"\n  }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", null, (internationalization == null ? void 0 : internationalization.settingsQuality) || \"Quality\")), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-settings-py\"\n  }, src.map(function (source, index) {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n      key: source.quality,\n      onClick: function onClick() {\n        setQuality(index);\n        setActiveSection(\"main\");\n      },\n      className: \"tuby-settings-item-2\"\n    }, quality === index ? react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Check, {\n      className: \"tuby-chevron\"\n    }) : react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n      style: {\n        width: 15,\n        height: 15\n      }\n    }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", null, typeof source.quality === \"number\" ? source.quality + \"p\" : source.quality));\n  })))));\n};\n\nvar SettingsModal = function SettingsModal(_ref) {\n  var settingsActive = _ref.settingsActive,\n      setSettingsActive = _ref.setSettingsActive,\n      src = _ref.src,\n      subtitles = _ref.subtitles,\n      playbackSpeed = _ref.playbackSpeed,\n      setPlaybackSpeed = _ref.setPlaybackSpeed,\n      subtitleIndex = _ref.subtitleIndex,\n      setSubtitleIndex = _ref.setSubtitleIndex,\n      quality = _ref.quality,\n      setQuality = _ref.setQuality,\n      internationalization = _ref.internationalization;\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    onClick: function onClick() {\n      return setSettingsActive(false);\n    },\n    className: \"tuby-backdrop \" + (settingsActive ? \"tuby-show\" : \"\")\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    onClick: function onClick(e) {\n      return e.stopPropagation();\n    },\n    className: \"tuby-modal\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h1\", null, (internationalization == null ? void 0 : internationalization.tooltipsSettings) || \"Settings\"), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, (internationalization == null ? void 0 : internationalization.settingsPlaybackSpeed) || \"Speed\"), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"select\", {\n    value: playbackSpeed * 4 - 1,\n    onChange: function onChange(e) {\n      return setPlaybackSpeed((+e.target.value + 1) / 4);\n    }\n  }, new Array(8).fill(\"\").map(function (_, index) {\n    return index === 3 ? (internationalization == null ? void 0 : internationalization.settingsPlaybackSpeedNormal) || \"Normal\" : (index + 1) / 4;\n  }).map(function (item, index) {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"option\", {\n      key: item,\n      value: index\n    }, item);\n  }))), subtitles && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, (internationalization == null ? void 0 : internationalization.settingsSubtitles) || \"Subtitles\"), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"select\", {\n    value: subtitleIndex,\n    onChange: function onChange(e) {\n      return setSubtitleIndex(+e.target.value);\n    }\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"option\", {\n    value: -1\n  }, (internationalization == null ? void 0 : internationalization.settingsSubtitlesOff) || \"Off\"), subtitles.map(function (subtitle, index) {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"option\", {\n      key: subtitle.lang,\n      onClick: function onClick() {\n        setSubtitleIndex(index);\n      },\n      value: index\n    }, subtitle.language);\n  }))), typeof src === \"object\" && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, (internationalization == null ? void 0 : internationalization.settingsQuality) || \"Quality\"), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"select\", {\n    value: quality,\n    onChange: function onChange(e) {\n      return setQuality(+e.target.value);\n    }\n  }, src.map(function (source, index) {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"option\", {\n      key: source.quality,\n      onClick: function onClick() {\n        setQuality(index);\n      },\n      value: index\n    }, typeof source.quality === \"number\" ? source.quality + \"p\" : source.quality);\n  }))), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-modal-btn-container\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n    style: {\n      padding: 5\n    },\n    onClick: function onClick() {\n      return setSettingsActive(false);\n    }\n  }, (internationalization == null ? void 0 : internationalization.settingsModalOff) || \"OK\"))));\n};\n\nvar Subtitle = function Subtitle(_ref) {\n  var others = _extends({}, _ref);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    viewBox: \"0 0 50 50\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, others), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M5.55556 5C2.47222 5 0 7.57143 0 10.7143V39.2857C0 42.4286 2.47222 45 5.55556 45H44.4444C47.5 45 50 42.4286 50 39.2857V10.7143C50 7.57143 47.5 5 44.4444 5H5.55556ZM22.2222 22.1429H18.0556V20.7143H12.5V29.2857H18.0556V27.8571H22.2222V30.7143C22.2222 32.2857 20.9722 33.5714 19.4444 33.5714H11.1111C9.58333 33.5714 8.33333 32.2857 8.33333 30.7143V19.2857C8.33333 17.7143 9.58333 16.4286 11.1111 16.4286H19.4444C20.9722 16.4286 22.2222 17.7143 22.2222 19.2857V22.1429ZM41.6667 22.1429H37.5V20.7143H31.9444V29.2857H37.5V27.8571H41.6667V30.7143C41.6667 32.2857 40.4167 33.5714 38.8889 33.5714H30.5556C29.0278 33.5714 27.7778 32.2857 27.7778 30.7143V19.2857C27.7778 17.7143 29.0278 16.4286 30.5556 16.4286H38.8889C40.4167 16.4286 41.6667 17.7143 41.6667 19.2857V22.1429Z\",\n    fill: \"white\"\n  }));\n};\n\nvar VolumeFull = function VolumeFull(_ref) {\n  var others = _extends({}, _ref);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    viewBox: \"0 0 50 50\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, others), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M0 33.5519H11.1111L25 47.805V2.19498L11.1111 16.4481H0V33.5519ZM30.5556 13.5975V36.4025C34.6667 34.4641 37.5 30.0456 37.5 25C37.5 20.0399 34.6667 15.707 30.5556 13.5975ZM30.5556 5.87229C38.5833 8.32383 44.4444 15.9635 44.4444 25C44.4444 34.0365 38.5833 41.6762 30.5556 44.1277V50C41.6944 47.4059 50 37.2007 50 25C50 12.7993 41.6944 2.59407 30.5556 0V5.87229Z\",\n    fill: \"white\"\n  }));\n};\n\nvar VolumeHalf = function VolumeHalf(_ref) {\n  var others = _extends({}, _ref);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    viewBox: \"0 0 50 50\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, others), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M0 34.375H14.8148L33.3333 50V0L14.8148 15.625H0V34.375ZM40.7407 12.5V37.5C46.2222 35.375 50 30.5312 50 25C50 19.5625 46.2222 14.8125 40.7407 12.5Z\",\n    fill: \"white\"\n  }));\n};\n\nvar VolumeMuted = function VolumeMuted(_ref) {\n  var others = _extends({}, _ref);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    viewBox: \"0 0 50 50\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, others), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M37.5 25.0139C37.5 20.0945 34.6667 15.8699 30.5556 13.8132V19.9555L37.3611 26.7649C37.4444 26.209 37.5 25.6253 37.5 25.0139ZM44.4444 25.0139C44.4444 27.6265 43.8889 30.0723 42.9444 32.3513L47.1389 36.5481C48.9722 33.1017 50 29.1829 50 25.0139C50 13.1184 41.6944 3.16843 30.5556 0.667039V6.36465C38.5833 8.75487 44.4444 16.2034 44.4444 25.0139V25.0139ZM3.52778 0L0 3.50195L13.1111 16.6481H0V33.3241H11.1111L25 47.2207V28.5158L36.8056 40.328C34.9444 41.7732 32.8611 42.9127 30.5556 43.6076V49.333C34.3889 48.4714 37.8611 46.6926 40.8056 44.3024L46.4722 50L50 46.4703L25 21.4564L3.55556 0H3.52778ZM24.9722 2.75153L19.1667 8.53252L24.9722 14.3413V2.77932V2.75153Z\",\n    fill: \"white\"\n  }));\n};\n\nvar useEffectUpdate = function useEffectUpdate(cb, dependencies) {\n  var updated = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    if (!updated.current) {\n      updated.current = true;\n      return;\n    }\n\n    cb(); // eslint-disable-next-line\n  }, dependencies);\n};\n\nvar Player = function Player(_ref) {\n  var _seekRef$current, _seekRef$current2, _seekRef$current3, _document2;\n\n  var playerKey = _ref.playerKey,\n      src = _ref.src,\n      subtitles = _ref.subtitles,\n      children = _ref.children,\n      poster = _ref.poster,\n      _ref$seekDuration = _ref.seekDuration,\n      seekDuration = _ref$seekDuration === void 0 ? 10 : _ref$seekDuration,\n      internationalization = _ref.internationalization,\n      passedDownRef = _ref.playerRef,\n      _ref$pictureInPicture = _ref.pictureInPicture,\n      pictureInPicture = _ref$pictureInPicture === void 0 ? false : _ref$pictureInPicture,\n      _ref$keyboardShortcut = _ref.keyboardShortcut,\n      keyboardShortcut = _ref$keyboardShortcut === void 0 ? true : _ref$keyboardShortcut;\n\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0),\n      quality = _useState[0],\n      setQuality = _useState[1];\n\n  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(Number(localStorage.getItem(\"tuby-speed\")) || 1),\n      playbackSpeed = _useState2[0],\n      setPlaybackSpeed = _useState2[1];\n\n  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true),\n      paused = _useState3[0],\n      setPaused = _useState3[1];\n\n  var _useState4 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),\n      onFullScreen = _useState4[0],\n      setOnFullScreen = _useState4[1];\n\n  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),\n      loading = _useState5[0],\n      setLoading = _useState5[1];\n\n  var _useState6 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),\n      settingsActive = _useState6[0],\n      setSettingsActive = _useState6[1];\n\n  var _useState7 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0),\n      subtitleIndex = _useState7[0],\n      setSubtitleIndex = _useState7[1];\n\n  var _useState8 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0),\n      currentTime = _useState8[0],\n      setCurrentTime = _useState8[1];\n\n  var _useState9 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0),\n      duration = _useState9[0],\n      setDuration = _useState9[1];\n\n  var _useState10 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null),\n      seekPreview = _useState10[0],\n      setSeekPreview = _useState10[1];\n\n  var _useState11 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),\n      loadedData = _useState11[0],\n      setLoadedData = _useState11[1];\n\n  var _useState12 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isNaN(parseInt(localStorage.getItem(\"tuby-volume\"))) ? 100 : Number(localStorage.getItem(\"tuby-volume\"))),\n      volume = _useState12[0],\n      setVolume = _useState12[1];\n\n  var _useState13 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(Boolean(Number(localStorage.getItem(\"tuby-muted\")))),\n      isMuted = _useState13[0],\n      setIsMuted = _useState13[1];\n\n  var _useState14 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true),\n      hoverEnabled = _useState14[0],\n      setHoverEnabled = _useState14[1];\n\n  var _useState15 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),\n      pauseDidUpdate = _useState15[0],\n      setPauseDidUpdate = _useState15[1];\n\n  var myRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var playerRef = passedDownRef || myRef;\n  var containerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var seekRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var mouseDownRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  var timeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var fullscreenToggleButton = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var pauseButton = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var volumeButtonRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var subtitleButtonRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n\n  var seekTime = function seekTime(amount) {\n    playerRef.current && (playerRef.current.currentTime += amount);\n  };\n\n  var updateHoverState = function updateHoverState() {\n    if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    setHoverEnabled(true);\n    timeoutRef.current = setTimeout(function () {\n      setHoverEnabled(false);\n    }, 2000);\n  };\n\n  var toggleSound = function toggleSound() {\n    setIsMuted(!isMuted);\n    setVolume(volume === 0 ? 100 : volume);\n  };\n\n  var handleSeeking = function handleSeeking(offsetX) {\n    if (!playerRef.current || !seekRef.current) return;\n    var offset = (offsetX - seekRef.current.getBoundingClientRect().left) / seekRef.current.offsetWidth;\n    var newTime = (Math.abs(offset) === Infinity || isNaN(offset) ? 0 : offset) * playerRef.current.duration;\n    playerRef.current.currentTime = newTime;\n    setCurrentTime(newTime);\n  };\n\n  var handleSeekPreview = function handleSeekPreview(offsetX) {\n    if (!playerRef.current || !seekRef.current) return;\n    var left = seekRef.current.getBoundingClientRect().left;\n    var offsetInPercentage = (offsetX - left) / seekRef.current.offsetWidth;\n    offsetInPercentage = Math.abs(offsetInPercentage) === Infinity || isNaN(offsetInPercentage) ? 0 : offsetInPercentage;\n    var offsetInPixel = offsetInPercentage * seekRef.current.offsetWidth;\n    var newTime = offsetInPercentage * playerRef.current.duration;\n    if (isNaN(newTime)) setSeekPreview(null);\n    if (newTime < 0) newTime = 0;\n    setSeekPreview({\n      time: Math.round(newTime),\n      offset: offsetInPixel\n    });\n  };\n\n  var listenMouseMoveSeeking = function listenMouseMoveSeeking() {\n    var moveHandler = function moveHandler(e) {\n      handleSeekPreview(e.clientX);\n\n      if (mouseDownRef.current) {\n        handleSeeking(e.clientX);\n      }\n    };\n\n    window.addEventListener(\"mousemove\", moveHandler);\n\n    var touchMoveHandler = function touchMoveHandler(e) {\n      var _e$touches, _e$touches$;\n\n      handleSeekPreview((_e$touches = e.touches) == null ? void 0 : (_e$touches$ = _e$touches[0]) == null ? void 0 : _e$touches$.pageX);\n\n      if (mouseDownRef.current) {\n        var _e$touches2, _e$touches2$;\n\n        handleSeeking((_e$touches2 = e.touches) == null ? void 0 : (_e$touches2$ = _e$touches2[0]) == null ? void 0 : _e$touches2$.pageX);\n      }\n    };\n\n    window.addEventListener(\"touchmove\", touchMoveHandler);\n    window.addEventListener(\"mouseup\", function () {\n      window.removeEventListener(\"mousemove\", moveHandler);\n      mouseDownRef.current = false;\n      setSeekPreview(null);\n    });\n    window.addEventListener(\"touchend\", function () {\n      window.removeEventListener(\"touchmove\", touchMoveHandler);\n      mouseDownRef.current = false;\n      setSeekPreview(null);\n    });\n  };\n\n  var handleScreenClicked = function handleScreenClicked(e) {\n    if (settingsActive) {\n      setSettingsActive(false);\n    } else {\n      setPaused(function (prev) {\n        return !prev;\n      });\n    }\n\n    if (e.detail === 2 && !isMobile()) {\n      setOnFullScreen(function (prev) {\n        return !prev;\n      });\n    }\n  };\n\n  useEffectUpdate(function () {\n    var _document, _document$activeEleme;\n\n    updateHoverState();\n    setPauseDidUpdate(true);\n\n    if (paused) {\n      var _playerRef$current;\n\n      (_playerRef$current = playerRef.current) == null ? void 0 : _playerRef$current.pause();\n    } else {\n      var _playerRef$current2;\n\n      (_playerRef$current2 = playerRef.current) == null ? void 0 : _playerRef$current2.play();\n    }\n\n    (_document = document) == null ? void 0 : (_document$activeEleme = _document.activeElement) == null ? void 0 : _document$activeEleme.blur();\n  }, [paused]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    if (playerRef.current) {\n      playerRef.current.muted = isMuted;\n      playerRef.current.volume = isMuted ? 0 : volume / 100;\n    }\n\n    localStorage.setItem(\"tuby-volume\", String(volume));\n    localStorage.setItem(\"tuby-muted\", String(+isMuted));\n  }, [volume, isMuted]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    var changeHandler = function changeHandler() {\n      var doc = document;\n      var fullscreenElement = doc.fullscreenElement || doc.webkitFullscreenElement || doc.webkitCurrentFullScreenElement || doc.mozFullScreenElement || doc.msFullscreenElement;\n\n      if (fullscreenElement) {\n        setOnFullScreen(true);\n      } else {\n        setOnFullScreen(false);\n      }\n    };\n\n    document.addEventListener(\"fullscreenchange\", changeHandler);\n    document.addEventListener(\"webkitfullscreenchange\", changeHandler);\n    document.addEventListener(\"mozfullscreenchange\", changeHandler);\n    document.addEventListener(\"MSFullscreenChange\", changeHandler);\n\n    var endFullScreenHandler = function endFullScreenHandler() {\n      changeHandler();\n      setPaused(true);\n    };\n\n    var player = playerRef.current;\n    player == null ? void 0 : player.addEventListener(\"webkitendfullscreen\", endFullScreenHandler);\n    return function () {\n      document.removeEventListener(\"fullscreenchange\", changeHandler);\n      document.removeEventListener(\"webkitfullscreenchange\", changeHandler);\n      document.removeEventListener(\"mozfullscreenchange\", changeHandler);\n      document.removeEventListener(\"MSFullscreenChange\", changeHandler);\n      player == null ? void 0 : player.removeEventListener(\"webkitendfullscreen\", endFullScreenHandler);\n    };\n  }, []);\n  useEffectUpdate(function () {\n    try {\n      if (onFullScreen) {\n        if (isMobile()) {\n          var elem = playerRef.current;\n          var requestFullScreen = elem.requestFullscreen || elem.webkitRequestFullscreen || elem.webkitRequestFullScreen || elem.webkitEnterFullscreen || elem.mozRequestFullScreen || elem.msRequestFullscreen;\n          requestFullScreen == null ? void 0 : requestFullScreen.call(elem)[\"catch\"](function (err) {\n            return console.log(err);\n          });\n        } else {\n          var _elem = containerRef.current;\n\n          var _requestFullScreen = _elem.requestFullscreen || _elem.webkitRequestFullscreen || _elem.webkitRequestFullScreen || _elem.webkitEnterFullscreen || _elem.mozRequestFullScreen || _elem.msRequestFullscreen;\n\n          _requestFullScreen == null ? void 0 : _requestFullScreen.call(_elem)[\"catch\"](function (err) {\n            return console.log(err);\n          });\n        }\n      } else {\n        var doc = document;\n        var exitFullScreen = doc.exitFullscreen || doc.webkitExitFullscreen || doc.webkitCancelFullScreen || doc.mozCancelFullScreen || doc.msExitFullscreen;\n        exitFullScreen == null ? void 0 : exitFullScreen.call(document)[\"catch\"](function (err) {\n          return console.log(err);\n        });\n      }\n    } catch (error) {}\n\n    updateHoverState();\n  }, [onFullScreen]);\n  useEffectUpdate(function () {\n    if (!playerRef.current) return;\n    playerRef.current.addEventListener(\"loadeddata\", function () {\n      if (playerRef.current) {\n        if (currentTime) {\n          playerRef.current.currentTime = currentTime;\n          playerRef.current.play();\n        }\n      }\n    }, {\n      once: true\n    });\n    playerRef.current.addEventListener(\"error\", function () {\n      var _playerRef$current3;\n\n      (_playerRef$current3 = playerRef.current) == null ? void 0 : _playerRef$current3.pause();\n    });\n  }, [quality]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    if (!playerRef.current) return;\n    localStorage.setItem(\"tuby-speed\", String(playbackSpeed));\n    playerRef.current.playbackRate = playbackSpeed;\n  }, [playbackSpeed]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    var keyHandler = function keyHandler(e) {\n      var _containerRef$current, _document$activeEleme2, _pauseButton$current, _fullscreenToggleButt, _volumeButtonRef$curr, _subtitleButtonRef$cu;\n\n      if (!keyboardShortcut) return;\n      if ((_containerRef$current = containerRef.current) != null && _containerRef$current.contains(document.activeElement)) (_document$activeEleme2 = document.activeElement) == null ? void 0 : _document$activeEleme2.blur(); // Pause\n\n      if ((keyboardShortcut === true || keyboardShortcut.pause) && (e.key === \" \" || e.key === \"k\")) (_pauseButton$current = pauseButton.current) == null ? void 0 : _pauseButton$current.click(); // Rewind\n\n      if ((keyboardShortcut === true || keyboardShortcut.rewind) && e.key === \"ArrowLeft\") seekTime(-seekDuration); // Forward\n\n      if ((keyboardShortcut === true || keyboardShortcut.forward) && e.key === \"ArrowRight\") seekTime(seekDuration); // Full screen\n\n      if ((keyboardShortcut === true || keyboardShortcut.fullScreen) && e.key === \"f\") (_fullscreenToggleButt = fullscreenToggleButton.current) == null ? void 0 : _fullscreenToggleButt.click(); // Mute\n\n      if ((keyboardShortcut === true || keyboardShortcut.mute) && e.key === \"m\") (_volumeButtonRef$curr = volumeButtonRef.current) == null ? void 0 : _volumeButtonRef$curr.click(); // Subtitle\n\n      if ((keyboardShortcut === true || keyboardShortcut.subtitle) && e.key === \"c\") (_subtitleButtonRef$cu = subtitleButtonRef.current) == null ? void 0 : _subtitleButtonRef$cu.click();\n    };\n\n    var spacePressHandler = function spacePressHandler(e) {\n      if (keyboardShortcut && e.key === \" \") e.preventDefault();\n    };\n\n    window.addEventListener(\"keyup\", keyHandler);\n    window.addEventListener(\"keydown\", spacePressHandler);\n    return function () {\n      window.removeEventListener(\"keyup\", keyHandler);\n      window.removeEventListener(\"keydown\", spacePressHandler);\n    };\n  }, [seekDuration, keyboardShortcut]);\n  var videoProps = {\n    crossOrigin: \"anonymous\",\n    playsInline: true,\n    onClickCapture: handleScreenClicked,\n    controls: false,\n    src: typeof src === \"string\" ? src : src[quality].url,\n    onWaiting: function onWaiting() {\n      return setLoading(true);\n    },\n    onPlaying: function onPlaying() {\n      setLoading(false);\n      setPaused(false);\n    },\n    onLoadedData: function onLoadedData() {\n      var _playerRef$current4;\n\n      setLoadedData(true);\n      setDuration(((_playerRef$current4 = playerRef.current) == null ? void 0 : _playerRef$current4.duration) || 0);\n      var currentTime;\n\n      if (playerKey) {\n        currentTime = Number(localStorage.getItem(playerKey + \"-time\"));\n      } else currentTime = 0;\n\n      setCurrentTime(currentTime);\n      playerRef.current && (playerRef.current.currentTime = currentTime);\n    },\n    onTimeUpdate: function onTimeUpdate() {\n      var _playerRef$current5, _playerRef$current6, _playerRef$current7;\n\n      if (playerKey) localStorage.setItem(playerKey + \"-time\", String(((_playerRef$current5 = playerRef.current) == null ? void 0 : _playerRef$current5.currentTime) || 0));\n      setCurrentTime(((_playerRef$current6 = playerRef.current) == null ? void 0 : _playerRef$current6.currentTime) || 0);\n      setDuration(((_playerRef$current7 = playerRef.current) == null ? void 0 : _playerRef$current7.duration) || 0);\n    },\n    onEnded: function onEnded() {\n      setPaused(true);\n    },\n    onMouseMove: function onMouseMove() {\n      return updateHoverState();\n    },\n    children: react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, subtitles && subtitles.length > 0 && subtitleIndex >= 0 && loadedData && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"track\", {\n      kind: \"subtitles\",\n      srcLang: subtitles[subtitleIndex].lang,\n      label: subtitles[subtitleIndex].language,\n      src: subtitles[subtitleIndex].url,\n      \"default\": true\n    }))\n  };\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, poster && !pauseDidUpdate && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"img\", {\n    src: poster,\n    className: \"tuby-poster\",\n    alt: \"Tuby Poster\"\n  }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    ref: containerRef,\n    className: \"tuby-container \" + (hoverEnabled ? \"tuby-controls-hovered\" : \"\")\n  }, children ? children(playerRef, videoProps) : react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"video\", Object.assign({\n    ref: playerRef\n  }, videoProps)), (!loadedData && pauseDidUpdate || loading && !paused) && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-center\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CircularProgress, null)), paused && pauseDidUpdate && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-center\",\n    onClickCapture: handleScreenClicked\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PauseEffect, null)), !paused && pauseDidUpdate && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-center\",\n    onClickCapture: handleScreenClicked\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PlayEffect, null)), !pauseDidUpdate && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-center\",\n    onClickCapture: handleScreenClicked\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Play, {\n    className: \"tuby-icon-md\"\n  })), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    onTouchEnd: function onTouchEnd() {\n      return setHoverEnabled(true);\n    },\n    onClick: function onClick() {\n      return setHoverEnabled(true);\n    },\n    onMouseEnter: function onMouseEnter() {\n      return timeoutRef.current && clearTimeout(timeoutRef.current);\n    },\n    className: \"tuby-controls \" + (paused || settingsActive ? \"tuby-show\" : \"\")\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    ref: seekRef,\n    onMouseDown: function onMouseDown(e) {\n      mouseDownRef.current = true;\n      handleSeeking(e.clientX);\n      listenMouseMoveSeeking();\n    },\n    onTouchStart: function onTouchStart(e) {\n      var _e$touches3, _e$touches3$;\n\n      mouseDownRef.current = true;\n      handleSeeking((_e$touches3 = e.touches) == null ? void 0 : (_e$touches3$ = _e$touches3[0]) == null ? void 0 : _e$touches3$.pageX);\n      listenMouseMoveSeeking();\n    },\n    onMouseMove: function onMouseMove(e) {\n      return handleSeekPreview(e.clientX);\n    },\n    onMouseLeave: function onMouseLeave() {\n      return setSeekPreview(null);\n    },\n    className: \"tuby-seek\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-seek-bar\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    style: {\n      width: duration !== 0 ? Math.round(currentTime / duration * 1000) / 10 + \"%\" : 0\n    },\n    className: \"tuby-seek-left\"\n  })), seekPreview !== null && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-seek-preview\",\n    style: {\n      left: seekPreview.offset < 16 ? 0 : seekPreview.offset > (((_seekRef$current = seekRef.current) == null ? void 0 : _seekRef$current.offsetWidth) || 0) - 16 ? \"auto\" : seekPreview.offset,\n      right: seekPreview.offset > (((_seekRef$current2 = seekRef.current) == null ? void 0 : _seekRef$current2.offsetWidth) || 0) - 16 ? 0 : \"auto\",\n      transform: seekPreview.offset < 16 || seekPreview.offset > (((_seekRef$current3 = seekRef.current) == null ? void 0 : _seekRef$current3.offsetWidth) || 0) - 16 ? \"none\" : \"translateX(-50%)\"\n    }\n  }, formatVideoTime(seekPreview.time))), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-controls-main\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-controls-left\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n    ref: pauseButton,\n    className: \"tuby-center-container tuby-tooltips-left\",\n    \"data-tuby-tooltips\": paused ? (internationalization == null ? void 0 : internationalization.tooltipsPlay) || \"Play (k)\" : (internationalization == null ? void 0 : internationalization.tooltipsPause) || \"Pause (k)\",\n    onClickCapture: function onClickCapture() {\n      return setPaused(function (prev) {\n        return !prev;\n      });\n    }\n  }, paused ? react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Play, {\n    className: \"tuby-icon-sm\"\n  }) : react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Pause, {\n    className: \"tuby-icon-sm\"\n  })), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-volume-container\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n    ref: volumeButtonRef,\n    className: \"tuby-center-container\",\n    \"data-tuby-tooltips\": isMuted || volume === 0 ? (internationalization == null ? void 0 : internationalization.tooltipsUnmute) || \"Unmute (m)\" : (internationalization == null ? void 0 : internationalization.tooltipsMute) || \"Mute (m)\",\n    onClickCapture: toggleSound\n  }, isMuted || volume === 0 ? react__WEBPACK_IMPORTED_MODULE_0___default().createElement(VolumeMuted, {\n    className: \"tuby-icon-sm\"\n  }) : volume === 100 ? react__WEBPACK_IMPORTED_MODULE_0___default().createElement(VolumeFull, {\n    className: \"tuby-icon-sm\"\n  }) : react__WEBPACK_IMPORTED_MODULE_0___default().createElement(VolumeHalf, {\n    className: \"tuby-icon-sm\"\n  })), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-volume-wrapper\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", {\n    className: \"tuby-volume-slider\",\n    type: \"range\",\n    min: 0,\n    max: 100,\n    value: isMuted ? 0 : volume,\n    onChange: function onChange(e) {\n      setVolume(+e.target.value);\n      setIsMuted(+e.target.value === 0);\n    }\n  }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-volume-left-bar\",\n    style: {\n      width: isMuted ? 0 : volume * 0.52\n    }\n  }))), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-time\"\n  }, formatVideoTime(currentTime), \" / \", formatVideoTime(duration))), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby-controls-right\"\n  }, Boolean(subtitles) && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n    ref: subtitleButtonRef,\n    className: \"tuby-center-container \" + (subtitleIndex >= 0 ? \"tuby-icon-underline\" : \"\"),\n    \"data-tuby-tooltips\": (internationalization == null ? void 0 : internationalization.tooltipsSubtitles) || \"Subtitles (c)\",\n    onClickCapture: function onClickCapture() {\n      return subtitleIndex >= 0 ? setSubtitleIndex(-1) : setSubtitleIndex(0);\n    }\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Subtitle, {\n    className: \"tuby-icon-sm\"\n  })), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ClickAwayListener, {\n    onClickAway: function onClickAway() {\n      return setSettingsActive(false);\n    }\n  }, function (ref) {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n      ref: ref,\n      style: {\n        position: \"relative\"\n      }\n    }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", Object.assign({\n      className: \"tuby-center-container\",\n      onClickCapture: function onClickCapture() {\n        return setSettingsActive(function (prev) {\n          return !prev;\n        });\n      }\n    }, !settingsActive ? {\n      \"data-tuby-tooltips\": (internationalization == null ? void 0 : internationalization.tooltipsSettings) || \"Settings\"\n    } : {}), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Cog, {\n      className: \"tuby-icon-sm\"\n    })), !isMobile() ? react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SettingsDialog, {\n      settingsActive: settingsActive,\n      setSettingsActive: setSettingsActive,\n      src: src,\n      subtitles: subtitles,\n      playbackSpeed: playbackSpeed,\n      setPlaybackSpeed: setPlaybackSpeed,\n      subtitleIndex: subtitleIndex,\n      setSubtitleIndex: setSubtitleIndex,\n      quality: quality,\n      setQuality: setQuality,\n      internationalization: internationalization\n    }) : react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SettingsModal, {\n      settingsActive: settingsActive,\n      setSettingsActive: setSettingsActive,\n      src: src,\n      subtitles: subtitles,\n      playbackSpeed: playbackSpeed,\n      setPlaybackSpeed: setPlaybackSpeed,\n      subtitleIndex: subtitleIndex,\n      setSubtitleIndex: setSubtitleIndex,\n      quality: quality,\n      setQuality: setQuality,\n      internationalization: internationalization\n    }));\n  }), pictureInPicture && ((_document2 = document) == null ? void 0 : _document2.pictureInPictureEnabled) && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n    className: \"tuby-center-container\",\n    ref: fullscreenToggleButton,\n    \"data-tuby-tooltips\": \"Picture in Picture\",\n    onClickCapture: function onClickCapture() {\n      try {\n        var _playerRef$current8;\n\n        var doc = document;\n        if (doc != null && doc.pictureInPictureElement) doc == null ? void 0 : doc.exitPictureInPicture();else (_playerRef$current8 = playerRef.current) == null ? void 0 : _playerRef$current8.requestPictureInPicture();\n      } catch (error) {}\n    }\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PictureInPicture, {\n    className: \"tuby-icon-sm\"\n  })), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n    className: \"tuby-center-container tuby-tooltips-right\",\n    ref: fullscreenToggleButton,\n    \"data-tuby-tooltips\": \"\" + (onFullScreen ? (internationalization == null ? void 0 : internationalization.tooltipsExitFullscreen) || \"Exit full screen (f)\" : (internationalization == null ? void 0 : internationalization.tooltipsFullscreen) || \"Full screen (f)\"),\n    onClickCapture: function onClickCapture() {\n      return setOnFullScreen(function (prev) {\n        return !prev;\n      });\n    }\n  }, onFullScreen ? react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ExitFullScreen, {\n    className: \"tuby-icon-sm\"\n  }) : react__WEBPACK_IMPORTED_MODULE_0___default().createElement(FullScreen, {\n    className: \"tuby-icon-sm\"\n  })))))));\n};\n\nvar Player$1 = function Player$1(props) {\n  var _ref;\n\n  var dimensions = props.dimensions,\n      primaryColor = props.primaryColor;\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"tuby\",\n    style: _extends({}, typeof dimensions === \"number\" ? {\n      width: \"100%\",\n      height: 0,\n      paddingBottom: dimensions + \"%\"\n    } : typeof dimensions === \"object\" ? {\n      width: dimensions.width,\n      height: dimensions.height\n    } : {\n      width: \"100%\",\n      height: 0,\n      paddingBottom: \"56.25%\"\n    }, primaryColor ? (_ref = {}, _ref[\"--tuby-primary-color\"] = primaryColor, _ref) : {})\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ClientRender, null, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ErrorBoundary, Object.assign({\n    renderer: props.children\n  }, props), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Player, Object.assign({}, props)))));\n};\n\n\n//# sourceMappingURL=react-tuby.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtdHVieS9kaXN0L3JlYWN0LXR1YnkuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpRjs7QUFFakY7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsK0NBQVE7QUFDMUI7QUFDQTs7QUFFQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxTQUFTLDBEQUFtQixDQUFDLHVEQUFjO0FBQzNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnREFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUFtQixDQUFDLHVEQUFjO0FBQ2xELGVBQWUsMERBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWEsMERBQW1CO0FBQ2hDO0FBQ0EsT0FBTywrRUFBK0UsMERBQW1CO0FBQ3pHO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLENBQUMsNENBQVM7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUywwREFBbUI7QUFDNUI7QUFDQTtBQUNBLEdBQUcsRUFBRSwwREFBbUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtB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QTtBQUNBLFNBQVMsMERBQW1CO0FBQzVCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUssMkJBQTJCLHlEQUF5RDtBQUN6RixHQUFHLEVBQUUsMERBQW1CLHFCQUFxQiwwREFBbUI7QUFDaEU7QUFDQSxHQUFHLFVBQVUsMERBQW1CLHlCQUF5QjtBQUN6RDs7QUFFOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXR1YnkvZGlzdC9yZWFjdC10dWJ5LmVzbS5qcz8zNTE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCBjcmVhdGVSZWYsIENvbXBvbmVudCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG5cbiAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbnZhciBDbGllbnRSZW5kZXIgPSBmdW5jdGlvbiBDbGllbnRSZW5kZXIoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuXG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSxcbiAgICAgIHJlbmRlcmVkID0gX3VzZVN0YXRlWzBdLFxuICAgICAgc2V0UmVuZGVyZWQgPSBfdXNlU3RhdGVbMV07XG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBzZXRSZW5kZXJlZCh0cnVlKTtcbiAgfSwgW10pO1xuICBpZiAocmVuZGVyZWQpIHJldHVybiBjaGlsZHJlbjtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwpO1xufTtcblxudmFyIEVycm9yQm91bmRhcnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoRXJyb3JCb3VuZGFyeSwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRXJyb3JCb3VuZGFyeShwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgaGFzRXJyb3I6IGZhbHNlXG4gICAgfTtcbiAgICBfdGhpcy5wbGF5ZXJSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICBfdGhpcy52aWRlb1Byb3BzID0ge1xuICAgICAgY3Jvc3NPcmlnaW46IFwiYW5vbnltb3VzXCIsXG4gICAgICBwbGF5c0lubGluZTogdHJ1ZSxcbiAgICAgIGNvbnRyb2xzOiB0cnVlLFxuICAgICAgc3JjOiB0eXBlb2YgX3RoaXMucHJvcHMuc3JjID09PSBcInN0cmluZ1wiID8gX3RoaXMucHJvcHMuc3JjIDogX3RoaXMucHJvcHMuc3JjWzBdLnVybCxcbiAgICAgIGNoaWxkcmVuOiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBfdGhpcy5wcm9wcy5zdWJ0aXRsZXMgJiYgX3RoaXMucHJvcHMuc3VidGl0bGVzLmxlbmd0aCA+IDAgJiYgX3RoaXMucHJvcHMuc3VidGl0bGVzLm1hcChmdW5jdGlvbiAoc3VidGl0bGUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwidHJhY2tcIiwge1xuICAgICAgICAgIGtleTogc3VidGl0bGUubGFuZyxcbiAgICAgICAgICBraW5kOiBcInN1YnRpdGxlc1wiLFxuICAgICAgICAgIHNyY0xhbmc6IHN1YnRpdGxlLmxhbmcsXG4gICAgICAgICAgbGFiZWw6IHN1YnRpdGxlLmxhbmd1YWdlLFxuICAgICAgICAgIHNyYzogc3VidGl0bGUudXJsLFxuICAgICAgICAgIFwiZGVmYXVsdFwiOiBpbmRleCA9PT0gMFxuICAgICAgICB9KTtcbiAgICAgIH0pKVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgRXJyb3JCb3VuZGFyeS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPSBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc0Vycm9yOiB0cnVlXG4gICAgfTtcbiAgfTtcblxuICB2YXIgX3Byb3RvID0gRXJyb3JCb3VuZGFyeS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5oYXNFcnJvcikge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwidHVieS1jb250YWluZXJcIlxuICAgICAgfSwgdGhpcy5wcm9wcy5yZW5kZXJlciA/IHRoaXMucHJvcHMucmVuZGVyZXIodGhpcy5wbGF5ZXJSZWYsIHRoaXMudmlkZW9Qcm9wcykgOiBSZWFjdC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHJlZjogdGhpcy5wbGF5ZXJSZWZcbiAgICAgIH0sIHRoaXMudmlkZW9Qcm9wcykpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfTtcblxuICByZXR1cm4gRXJyb3JCb3VuZGFyeTtcbn0oQ29tcG9uZW50KTtcblxudmFyIGZvcm1hdFZpZGVvVGltZSA9IGZ1bmN0aW9uIGZvcm1hdFZpZGVvVGltZSh0aW1lKSB7XG4gIHRyeSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgwKTtcbiAgICBkYXRlLnNldFNlY29uZHModGltZSk7XG4gICAgdmFyIHRpbWVTdHJpbmcgPSBkYXRlLnRvSVNPU3RyaW5nKCkuc2xpY2UoMTEsIDE5KTtcbiAgICB2YXIgcmVzdWx0ID0gdGltZVN0cmluZy5zdGFydHNXaXRoKFwiMDA6MFwiKSA/IHRpbWVTdHJpbmcuc2xpY2UoNCkgOiB0aW1lU3RyaW5nLnN0YXJ0c1dpdGgoXCIwMFwiKSA/IHRpbWVTdHJpbmcuc2xpY2UoMykgOiB0aW1lU3RyaW5nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIFwiMDowMFwiO1xuICB9XG59O1xudmFyIGlzTW9iaWxlID0gZnVuY3Rpb24gaXNNb2JpbGUoKSB7XG4gIHZhciBfd2luZG93LCBfd2luZG93JG5hdmlnYXRvcjtcblxuICByZXR1cm4gL2lQaG9uZXxpUGFkfGlQb2R8QW5kcm9pZC9pLnRlc3QoKF93aW5kb3cgPSB3aW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiAoX3dpbmRvdyRuYXZpZ2F0b3IgPSBfd2luZG93Lm5hdmlnYXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckbmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59O1xuXG52YXIgQ2lyY3VsYXJQcm9ncmVzcyA9IGZ1bmN0aW9uIENpcmN1bGFyUHJvZ3Jlc3MoKSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICBjbGFzc05hbWU6IFwidHVieS1wcm9ncmVzc1wiLFxuICAgIHZpZXdCb3g6IFwiMjUgMjUgNTAgNTBcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHtcbiAgICBjeDogXCI1MFwiLFxuICAgIGN5OiBcIjUwXCIsXG4gICAgcjogXCIyMFwiXG4gIH0pKTtcbn07XG5cbnZhciBDbGlja0F3YXlMaXN0ZW5lciA9IGZ1bmN0aW9uIENsaWNrQXdheUxpc3RlbmVyKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIG9uQ2xpY2tBd2F5ID0gX3JlZi5vbkNsaWNrQXdheTtcbiAgdmFyIGNoaWxkcmVuUmVmID0gdXNlUmVmKG51bGwpO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihlKSB7XG4gICAgICBpZiAoY2hpbGRyZW5SZWYuY3VycmVudCAmJiAhY2hpbGRyZW5SZWYuY3VycmVudC5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgICAgb25DbGlja0F3YXkoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlcik7XG4gICAgfTtcbiAgfSwgW29uQ2xpY2tBd2F5XSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbihjaGlsZHJlblJlZikpO1xufTtcblxudmFyIENvZyA9IGZ1bmN0aW9uIENvZyhfcmVmKSB7XG4gIHZhciBvdGhlcnMgPSBfZXh0ZW5kcyh7fSwgX3JlZik7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgdmlld0JveDogXCIwIDAgNTAgNTBcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIG90aGVycyksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIk00NC4xMjQyIDI3LjQ0NjdDNDQuMjIwOCAyNi42NjI1IDQ0LjI4NTIgMjUuODQ2OSA0NC4yODUyIDI1QzQ0LjI4NTIgMjQuMTUzMSA0NC4yMjA4IDIzLjM2ODkgNDQuMTI0MiAyMi41NTMzTDQ5LjUzMzEgMTguNDEyOEM1MC4wMTYgMTguMDM2NCA1MC4xNDQ4IDE3LjM3NzcgNDkuODIyOCAxNi44MTMxTDQ0LjY3MTUgOC4xNTU1OEM0NC4zODE4IDcuNjIyMzMgNDMuNjczNSA3LjQwMjc2IDQzLjEyNjIgNy42MjIzM0wzNi43MTkyIDEwLjEzMTdDMzUuMzk5MiA5LjEyNzk4IDMzLjk1MDQgOC4zMTI0MiAzMi4zNzI4IDcuNjg1MDdMMzEuNDA2OSAxLjAzNTEzQzMxLjM0MjUgMC40MzkxNDcgMzAuNzk1MiAwIDMwLjE1MTMgMEgxOS44NDg3QzE5LjIwNDggMCAxOC42ODk3IDAuNDM5MTQ3IDE4LjU5MzEgMS4wMzUxM0wxNy42MjcyIDcuNjg1MDdDMTYuMDgxOCA4LjMxMjQyIDE0LjYzMyA5LjE1OTM1IDEzLjI4MDggMTAuMTMxN0w2Ljg3Mzg1IDcuNjIyMzNDNi4yOTQzMiA3LjQwMjc2IDUuNjE4MjIgNy42MjIzMyA1LjMyODQ2IDguMTU1NThMMC4xNzcxNSAxNi44MTMxQy0wLjE0NDgwNiAxNy4zNDYzIDAuMDE2MTcyNSAxOC4wMzY0IDAuNDY2OTEyIDE4LjQxMjhMNS44NzU3OCAyMi41NTMzQzUuNzc5MiAyMy4zMzc1IDUuNzE0OCAyNC4xODQ0IDUuNzE0OCAyNUM1LjcxNDggMjUuODE1NiA1Ljc3OTIgMjYuNjMxMSA1Ljg3NTc4IDI3LjQ0NjdMMC40NjY5MTIgMzEuNTg3MkMtMC4wMTYwMjMyIDMxLjk2MzYgLTAuMTQ0ODA2IDMyLjYyMjMgMC4xNzcxNSAzMy4xODdMNS4zMjg0NiA0MS44NDQ0QzUuNjE4MjIgNDIuMzc3NyA2LjMyNjUyIDQyLjU5NzIgNi44NzM4NSA0Mi4zNzc3TDEzLjI4MDggMzkuODY4M0MxNC42MDA4IDQwLjg3MiAxNi4wNDk2IDQxLjY4NzYgMTcuNjI3MiA0Mi4zMTQ5TDE4LjU5MzEgNDguOTY0OUMxOC42NTc1IDQ5LjU2MDkgMTkuMjA0OCA1MCAxOS44NDg3IDUwSDMwLjE1MTNDMzAuNzk1MiA1MCAzMS4zMTAzIDQ5LjU2MDkgMzEuNDA2OSA0OC45NjQ5TDMyLjM3MjggNDIuMzE0OUMzMy45MTgyIDQxLjY4NzYgMzUuMzY3IDQwLjg0MDcgMzYuNzE5MiAzOS44NjgzTDQzLjEyNjIgNDIuMzc3N0M0My43MDU3IDQyLjU5NzIgNDQuMzgxOCA0Mi4zNzc3IDQ0LjY3MTUgNDEuODQ0NEw0OS44MjI4IDMzLjE4N0M1MC4xMTI2IDMyLjY1MzcgNDkuOTgzOCAzMS45NjM2IDQ5LjUzMzEgMzEuNTg3Mkw0NC4xMjQyIDI3LjQ0NjdWMjcuNDQ2N1pNMjUgMzMuNzUxNkMyMC4wNDE5IDMzLjc1MTYgMTUuOTg1MiAyOS44MzA2IDE1Ljk4NTIgMjQuOTY4NkMxNS45ODUyIDIwLjEzOCAyMC4wMDk3IDE2LjE4NTcgMjUgMTYuMTg1N0MyOS45NTgxIDE2LjE4NTcgMzQuMDE0OCAyMC4xMDY3IDM0LjAxNDggMjQuOTY4NkMzNC4wMTQ4IDI5Ljc5OTIgMjkuOTkwMyAzMy43NTE2IDI1IDMzLjc1MTZaXCIsXG4gICAgZmlsbDogXCJ3aGl0ZVwiXG4gIH0pKTtcbn07XG5cbnZhciBFeGl0RnVsbFNjcmVlbiA9IGZ1bmN0aW9uIEV4aXRGdWxsU2NyZWVuKF9yZWYpIHtcbiAgdmFyIG90aGVycyA9IF9leHRlbmRzKHt9LCBfcmVmKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICB2aWV3Qm94OiBcIjAgMCA1MCA1MFwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwgb3RoZXJzKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTEyLjUgMTIuNUgwVjE4Ljc1SDE4Ljc1VjBIMTIuNVYxMi41WlwiLFxuICAgIGZpbGw6IFwid2hpdGVcIlxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTM3LjUgMTIuNVYxLjE0NDQxZS0wNUgzMS4yNVYxOC43NUg1MFYxMi41SDM3LjVaXCIsXG4gICAgZmlsbDogXCJ3aGl0ZVwiXG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMzEuMjUgNTBIMzcuNVYzNy41SDUwVjMxLjI1SDMxLjI1VjUwWlwiLFxuICAgIGZpbGw6IFwid2hpdGVcIlxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTAgMzcuNUgxMi41VjUwSDE4Ljc1VjMxLjI1SDBWMzcuNVpcIixcbiAgICBmaWxsOiBcIndoaXRlXCJcbiAgfSkpO1xufTtcblxudmFyIEZ1bGxTY3JlZW4gPSBmdW5jdGlvbiBGdWxsU2NyZWVuKF9yZWYpIHtcbiAgdmFyIG90aGVycyA9IF9leHRlbmRzKHt9LCBfcmVmKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICB2aWV3Qm94OiBcIjAgMCA1MCA1MFwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwgb3RoZXJzKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTAgMTguNzVINi4yNVY2LjI1SDE4Ljc1VjBIMFYxOC43NVpcIixcbiAgICBmaWxsOiBcIndoaXRlXCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0zMS4yNSAwVjYuMjVINDMuNzVWMTguNzVINTBWMEgzMS4yNVpcIixcbiAgICBmaWxsOiBcIndoaXRlXCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIk00My43NSA0My43NUgzMS4yNVY1MEg1MFYzMS4yNUg0My43NVY0My43NVpcIixcbiAgICBmaWxsOiBcIndoaXRlXCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIk02LjI1IDMxLjI1SDBWNTBIMTguNzVWNDMuNzVINi4yNVYzMS4yNVpcIixcbiAgICBmaWxsOiBcIndoaXRlXCJcbiAgfSkpO1xufTtcblxudmFyIFBhdXNlID0gZnVuY3Rpb24gUGF1c2UoX3JlZikge1xuICB2YXIgb3RoZXJzID0gX2V4dGVuZHMoe30sIF9yZWYpO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIHZpZXdCb3g6IFwiMCAwIDUwIDUwXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCBvdGhlcnMpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNNSA1MEgxNy4zMDc3VjBINVY1MFpNMzIuNjkyMyA1MEg0NVYwSDMyLjY5MjNWNTBaXCIsXG4gICAgZmlsbDogXCJ3aGl0ZVwiXG4gIH0pKTtcbn07XG5cbnZhciBQYXVzZUVmZmVjdCA9IGZ1bmN0aW9uIFBhdXNlRWZmZWN0KCkge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1YnktZmFkZS16b29tLW91dCB0dWJ5LWVmZmVjdC1pY29uXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChQYXVzZSwge1xuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LWljb24tbWRcIlxuICB9KSk7XG59O1xuXG52YXIgUGljdHVyZUluUGljdHVyZSA9IGZ1bmN0aW9uIFBpY3R1cmVJblBpY3R1cmUoX3JlZikge1xuICB2YXIgb3RoZXJzID0gX2V4dGVuZHMoe30sIF9yZWYpO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIHZpZXdCb3g6IFwiMCAwIDUwIDUwXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCBvdGhlcnMpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNNDAuOTA5MSAyMi42NjY3SDIyLjcyNzNWMzYuNjY2N0g0MC45MDkxVjIyLjY2NjdaTTUwIDQxLjMzMzNWOC42MkM1MCA2LjA1MzMzIDQ3Ljk1NDUgNCA0NS40NTQ1IDRINC41NDU0NUMyLjA0NTQ1IDQgMCA2LjA1MzMzIDAgOC42MlY0MS4zMzMzQzAgNDMuOSAyLjA0NTQ1IDQ2IDQuNTQ1NDUgNDZINDUuNDU0NUM0Ny45NTQ1IDQ2IDUwIDQzLjkgNTAgNDEuMzMzM1pNNDUuNDU0NSA0MS4zOEg0LjU0NTQ1VjguNTk2NjdINDUuNDU0NVY0MS4zOFpcIixcbiAgICBmaWxsOiBcIndoaXRlXCJcbiAgfSkpO1xufTtcblxudmFyIFBsYXkgPSBmdW5jdGlvbiBQbGF5KF9yZWYpIHtcbiAgdmFyIG90aGVycyA9IF9leHRlbmRzKHt9LCBfcmVmKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICB3aWR0aDogXCI1MFwiLFxuICAgIGhlaWdodDogXCI1MFwiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDI2IDI2XCIsXG4gICAgZmlsbDogXCIjRkZGRkZGXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCBvdGhlcnMpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMyAxVjI1TDIzIDEzTDMgMVpcIlxuICB9KSk7XG59O1xuXG52YXIgUGxheUVmZmVjdCA9IGZ1bmN0aW9uIFBsYXlFZmZlY3QoKSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwidHVieS1mYWRlLXpvb20tb3V0IHR1YnktZWZmZWN0LWljb25cIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFBsYXksIHtcbiAgICBjbGFzc05hbWU6IFwidHVieS1pY29uLW1kXCJcbiAgfSkpO1xufTtcblxudmFyIENoZWNrID0gZnVuY3Rpb24gQ2hlY2soX3JlZikge1xuICB2YXIgb3RoZXJzID0gX2V4dGVuZHMoe30sIF9yZWYpO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIHZpZXdCb3g6IFwiMCAwIDUwIDUwXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCBvdGhlcnMpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNNDguOTUzNiA4LjA4NTg0QzUwLjM0ODggOS41MzEzMSA1MC4zNDg4IDExLjg2NzIgNDguOTUzNiAxMy4zMTI3TDIwLjM4MDYgNDIuOTE1OUMxOC45ODU0IDQ0LjM2MTQgMTYuNzMwOCA0NC4zNjE0IDE1LjMzNTcgNDIuOTE1OUwxLjA0NjA0IDI4LjExNDNDLTAuMzQ4NjggMjYuNjY4OCAtMC4zNDg2OCAyNC4zMzI5IDEuMDQ2MDQgMjIuODg3NUMyLjQ0MDk4IDIxLjQ0MiA0LjcwMjI3IDIxLjQ0MiA2LjA5NzQ0IDIyLjg4NzVMMTcuNzU3NyAzNS4wNjQxTDQzLjkwODcgOC4wODU4NEM0NS4zMDM5IDYuNjM4MDUgNDcuNTU4NSA2LjYzODA1IDQ4Ljk1MzYgOC4wODU4NFpcIixcbiAgICBmaWxsOiBcIiNmZmZcIlxuICB9KSk7XG59O1xuXG52YXIgQ2hldnJvbkxlZnQgPSBmdW5jdGlvbiBDaGV2cm9uTGVmdChfcmVmKSB7XG4gIHZhciBvdGhlcnMgPSBfZXh0ZW5kcyh7fSwgX3JlZik7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgdmlld0JveDogXCIwIDAgNTAgNTBcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIG90aGVycyksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIk00MCA1Ljg3NUwyMS40NTc1IDI1TDQwIDQ0LjEyNUwzNC4yOTE1IDUwTDEwIDI1TDM0LjI5MTUgMEw0MCA1Ljg3NVpcIixcbiAgICBmaWxsOiBcIndoaXRlXCJcbiAgfSkpO1xufTtcblxudmFyIENoZXZyb25SaWdodCA9IGZ1bmN0aW9uIENoZXZyb25SaWdodChfcmVmKSB7XG4gIHZhciBvdGhlcnMgPSBfZXh0ZW5kcyh7fSwgX3JlZik7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgdmlld0JveDogXCIwIDAgNTAgNTBcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIG90aGVycyksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0xMCA0NC4xMjVMMjguNTQyNSAyNUwxMCA1Ljg3NUwxNS43MDg1IDBMNDAgMjVMMTUuNzA4NSA1MEwxMCA0NC4xMjVaXCIsXG4gICAgZmlsbDogXCJ3aGl0ZVwiXG4gIH0pKTtcbn07XG5cbnZhciBTcGVlZCA9IGZ1bmN0aW9uIFNwZWVkKF9yZWYpIHtcbiAgdmFyIG90aGVycyA9IF9leHRlbmRzKHt9LCBfcmVmKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICB2aWV3Qm94OiBcIjAgMCA1MCA1MFwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwgb3RoZXJzKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTMzLjMzMzMgNDAuNTI5NEg1MFY0My4zNTI5SDMzLjMzMzNWNDAuNTI5NFpNMjIuMjIyMiA0MC41Mjk0SDBWNDMuMzUyOUgyMi4yMjIyVjQ5SDI1VjQzLjM1MjlWNDAuNTI5NFYzNC44ODI0SDIyLjIyMjJWNDAuNTI5NFpNMzAuNTU1NiAxNS4xMTc2SDMzLjMzMzNWOS40NzA1OVY2LjY0NzA2VjFIMzAuNTU1NlY2LjY0NzA2SDBWOS40NzA1OUgzMC41NTU2VjE1LjExNzZaTTQxLjY2NjcgNi42NDcwNlY5LjQ3MDU5SDUwVjYuNjQ3MDZINDEuNjY2N1pNOC4zMzMzMyAzMi4wNTg4SDExLjExMTFWMjYuNDExOFYyMy41ODgyVjE3Ljk0MTJIOC4zMzMzM1YyMy41ODgySDBWMjYuNDExOEg4LjMzMzMzVjMyLjA1ODhaTTE5LjQ0NDQgMjYuNDExOEg1MFYyMy41ODgySDE5LjQ0NDRWMjYuNDExOFpcIixcbiAgICBmaWxsOiBcIndoaXRlXCJcbiAgfSkpO1xufTtcblxudmFyIFNlbGVjdFN1YnRpdGxlID0gZnVuY3Rpb24gU2VsZWN0U3VidGl0bGUoX3JlZikge1xuICB2YXIgb3RoZXJzID0gX2V4dGVuZHMoe30sIF9yZWYpO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIHZpZXdCb3g6IFwiMCAwIDUwIDUwXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCBvdGhlcnMpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNOC4zMzMzMyAzMC41NTU2VjE5LjQ0NDRDOC4zMzMzMyAxNy45MTY3IDkuNTgzMzMgMTYuNjY2NyAxMS4xMTExIDE2LjY2NjdIMTkuNDQ0NEMyMC45NzIyIDE2LjY2NjcgMjIuMjIyMiAxNy45MTY3IDIyLjIyMjIgMTkuNDQ0NFYyMi4yMjIySDE4LjA1NTZWMjAuODMzM0gxMi41VjI5LjE2NjdIMTguMDU1NlYyNy43Nzc4SDIyLjIyMjJWMzAuNTU1NkMyMi4yMjIyIDMyLjA4MzMgMjAuOTcyMiAzMy4zMzMzIDE5LjQ0NDQgMzMuMzMzM0gxMS4xMTExQzkuNTgzMzMgMzMuMzMzMyA4LjMzMzMzIDMyLjA4MzMgOC4zMzMzMyAzMC41NTU2Wk0zMC41NTU2IDMzLjMzMzNIMzguODg4OUM0MC40MTY3IDMzLjMzMzMgNDEuNjY2NyAzMi4wODMzIDQxLjY2NjcgMzAuNTU1NlYyNy43Nzc4SDM3LjVWMjkuMTY2N0gzMS45NDQ0VjIwLjgzMzNIMzcuNVYyMi4yMjIySDQxLjY2NjdWMTkuNDQ0NEM0MS42NjY3IDE3LjkxNjcgNDAuNDE2NyAxNi42NjY3IDM4Ljg4ODkgMTYuNjY2N0gzMC41NTU2QzI5LjAyNzggMTYuNjY2NyAyNy43Nzc4IDE3LjkxNjcgMjcuNzc3OCAxOS40NDQ0VjMwLjU1NTZDMjcuNzc3OCAzMi4wODMzIDI5LjAyNzggMzMuMzMzMyAzMC41NTU2IDMzLjMzMzNaTTQ3LjIyMjIgMi43Nzc3OEgyLjc3Nzc4VjQ3LjIyMjJINDcuMjIyMlYyLjc3Nzc4Wk01MCAwVjUwSDBWMC4wMjc3Nzc4QzAgLTIuNTg3MDFlLTA4IC0yLjU4NzAxZS0wOCAwIDAuMDI3Nzc3OCAwSDUwWlwiLFxuICAgIGZpbGw6IFwid2hpdGVcIlxuICB9KSk7XG59O1xuXG52YXIgU3BlZWQkMSA9IGZ1bmN0aW9uIFNwZWVkKF9yZWYpIHtcbiAgdmFyIG90aGVycyA9IF9leHRlbmRzKHt9LCBfcmVmKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICB2aWV3Qm94OiBcIjAgMCA1MCA1MFwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwgb3RoZXJzKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTIwIDE1VjM1TDM1IDI1TDIwIDE1Wk0xMC43NSA3LjVMOS4yNSA1LjVDMTMgMi41IDE3LjUgMC41IDIyLjUgMEwyMi43NSAyLjVDMTguMjUgMyAxNC4yNSA0Ljc1IDEwLjc1IDcuNVpNNy41IDEwLjc1TDUuNSA5LjI1QzIuNSAxMyAwLjUgMTcuNSAwIDIyLjVMMi41IDIyLjc1QzMgMTguMjUgNC43NSAxNC4yNSA3LjUgMTAuNzVaTTcuNSAzOS4yNUM0Ljc1IDM1Ljc1IDMgMzEuNSAyLjUgMjcuMjVMMCAyNy41QzAuNSAzMi41IDIuNSAzNyA1LjUgNDFMNy41IDM5LjI1Wk0yMi43NSA0Ny41QzE4LjI1IDQ3IDE0LjI1IDQ1LjI1IDEwLjc1IDQyLjVMOS4yNSA0NC41QzEzIDQ3LjUgMTcuNSA0OS41IDIyLjUgNTBMMjIuNzUgNDcuNVpNNTAgMjVDNTAgMTIgNDAuMjUgMS41IDI3LjUgMEwyNy4yNSAyLjVDMzguNzUgMy43NSA0Ny41IDEzLjI1IDQ3LjUgMjVDNDcuNSAzNi43NSAzOC43NSA0Ni4yNSAyNy4yNSA0Ny41TDI3LjUgNTBDNDAuNSA0OC43NSA1MCAzOCA1MCAyNVpcIixcbiAgICBmaWxsOiBcIndoaXRlXCJcbiAgfSkpO1xufTtcblxudmFyIFNldHRpbmdzRGlhbG9nID0gZnVuY3Rpb24gU2V0dGluZ3NEaWFsb2coX3JlZikge1xuICB2YXIgc2V0dGluZ3NBY3RpdmUgPSBfcmVmLnNldHRpbmdzQWN0aXZlLFxuICAgICAgc3JjID0gX3JlZi5zcmMsXG4gICAgICBzdWJ0aXRsZXMgPSBfcmVmLnN1YnRpdGxlcyxcbiAgICAgIHBsYXliYWNrU3BlZWQgPSBfcmVmLnBsYXliYWNrU3BlZWQsXG4gICAgICBzZXRQbGF5YmFja1NwZWVkID0gX3JlZi5zZXRQbGF5YmFja1NwZWVkLFxuICAgICAgc3VidGl0bGVJbmRleCA9IF9yZWYuc3VidGl0bGVJbmRleCxcbiAgICAgIHNldFN1YnRpdGxlSW5kZXggPSBfcmVmLnNldFN1YnRpdGxlSW5kZXgsXG4gICAgICBxdWFsaXR5ID0gX3JlZi5xdWFsaXR5LFxuICAgICAgc2V0UXVhbGl0eSA9IF9yZWYuc2V0UXVhbGl0eSxcbiAgICAgIGludGVybmF0aW9uYWxpemF0aW9uID0gX3JlZi5pbnRlcm5hdGlvbmFsaXphdGlvbjtcblxuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoMCksXG4gICAgICBoZWlnaHQgPSBfdXNlU3RhdGVbMF0sXG4gICAgICBzZXRIZWlnaHQgPSBfdXNlU3RhdGVbMV07XG5cbiAgdmFyIF91c2VTdGF0ZTIgPSB1c2VTdGF0ZShcIm1haW5cIiksXG4gICAgICBhY3RpdmVTZWN0aW9uID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldEFjdGl2ZVNlY3Rpb24gPSBfdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBtYWluU2VjdGlvblJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHNwZWVkU2VjdGlvblJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHN1YnRpdGxlc1NlY3Rpb25SZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBxdWFsaXR5U2VjdGlvblJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHNlY3Rpb25zID0ge1xuICAgIG1haW46IG1haW5TZWN0aW9uUmVmLFxuICAgIHNwZWVkOiBzcGVlZFNlY3Rpb25SZWYsXG4gICAgc3VidGl0bGVzOiBzdWJ0aXRsZXNTZWN0aW9uUmVmLFxuICAgIHF1YWxpdHk6IHF1YWxpdHlTZWN0aW9uUmVmXG4gIH07XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlY3Rpb25zW2FjdGl2ZVNlY3Rpb25dLmN1cnJlbnQpIHtcbiAgICAgIHZhciBlbGVtZW50SGVpZ2h0ID0gc2VjdGlvbnNbYWN0aXZlU2VjdGlvbl0uY3VycmVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICBzZXRIZWlnaHQoZWxlbWVudEhlaWdodCA+IDI1MCA/IDI1MCA6IGVsZW1lbnRIZWlnaHQpO1xuICAgICAgc2VjdGlvbnNbYWN0aXZlU2VjdGlvbl0uY3VycmVudC5zY3JvbGxUbyAmJiBzZWN0aW9uc1thY3RpdmVTZWN0aW9uXS5jdXJyZW50LnNjcm9sbFRvKDAsIDApO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgfSwgW2FjdGl2ZVNlY3Rpb25dKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LXNldHRpbmdzLWRpYWxvZyBcIiArIChzZXR0aW5nc0FjdGl2ZSA/IFwidHVieS1zaG93XCIgOiBcIlwiKVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBzdHlsZToge1xuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9LFxuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LXNldHRpbmdzLW91dGVyXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBtYWluU2VjdGlvblJlZixcbiAgICBjbGFzc05hbWU6IFwidHVieS1zZXR0aW5ncy1zZWN0aW9uIHR1Ynktc2V0dGluZ3MtcHkgXCIgKyAoYWN0aXZlU2VjdGlvbiA9PT0gXCJtYWluXCIgPyBcInR1Ynktc2V0dGluZ3MtdHJhbnNsYXRlLWNlbnRlclwiIDogXCJ0dWJ5LXNldHRpbmdzLXRyYW5zbGF0ZS1sZWZ0XCIpXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICByZXR1cm4gc2V0QWN0aXZlU2VjdGlvbihcInNwZWVkXCIpO1xuICAgIH0sXG4gICAgY2xhc3NOYW1lOiBcInR1Ynktc2V0dGluZ3MtaXRlbVwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LXNldHRpbmdzLWl0ZW0tbGVmdFwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3BlZWQkMSwge1xuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LWljb24tc21cIlxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCwgKGludGVybmF0aW9uYWxpemF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBpbnRlcm5hdGlvbmFsaXphdGlvbi5zZXR0aW5nc1BsYXliYWNrU3BlZWQpIHx8IFwiUGxheWJhY2sgU3BlZWRcIikpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENoZXZyb25SaWdodCwge1xuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LWNoZXZyb25cIlxuICB9KSksIHN1YnRpdGxlcyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgcmV0dXJuIHNldEFjdGl2ZVNlY3Rpb24oXCJzdWJ0aXRsZXNcIik7XG4gICAgfSxcbiAgICBjbGFzc05hbWU6IFwidHVieS1zZXR0aW5ncy1pdGVtXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1Ynktc2V0dGluZ3MtaXRlbS1sZWZ0XCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChTZWxlY3RTdWJ0aXRsZSwge1xuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LWljb24tc21cIlxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCwgKGludGVybmF0aW9uYWxpemF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBpbnRlcm5hdGlvbmFsaXphdGlvbi5zZXR0aW5nc1N1YnRpdGxlcykgfHwgXCJTdWJ0aXRsZXNcIikpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENoZXZyb25SaWdodCwge1xuICAgIHN0eWxlOiB7XG4gICAgICB3aWR0aDogMTUsXG4gICAgICBoZWlnaHQ6IDE1XG4gICAgfVxuICB9KSksIHR5cGVvZiBzcmMgIT09IFwic3RyaW5nXCIgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgIHJldHVybiBzZXRBY3RpdmVTZWN0aW9uKFwicXVhbGl0eVwiKTtcbiAgICB9LFxuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LXNldHRpbmdzLWl0ZW1cIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwidHVieS1zZXR0aW5ncy1pdGVtLWxlZnRcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFNwZWVkLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1YnktaWNvbi1zbVwiXG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCAoaW50ZXJuYXRpb25hbGl6YXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGludGVybmF0aW9uYWxpemF0aW9uLnNldHRpbmdzUXVhbGl0eSkgfHwgXCJRdWFsaXR5XCIpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChDaGV2cm9uUmlnaHQsIHtcbiAgICBjbGFzc05hbWU6IFwidHVieS1jaGV2cm9uXCJcbiAgfSkpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBzcGVlZFNlY3Rpb25SZWYsXG4gICAgY2xhc3NOYW1lOiBcInR1Ynktc2V0dGluZ3Mtc2VjdGlvbiBcIiArIChhY3RpdmVTZWN0aW9uID09PSBcInNwZWVkXCIgPyBcInR1Ynktc2V0dGluZ3MtdHJhbnNsYXRlLWNlbnRlclwiIDogXCJ0dWJ5LXNldHRpbmdzLXRyYW5zbGF0ZS1yaWdodFwiKVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgcmV0dXJuIHNldEFjdGl2ZVNlY3Rpb24oXCJtYWluXCIpO1xuICAgIH0sXG4gICAgY2xhc3NOYW1lOiBcInR1Ynktc2V0dGluZ3Mtc2VjdGlvbi1oZWFkZXJcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KENoZXZyb25MZWZ0LCB7XG4gICAgY2xhc3NOYW1lOiBcInR1YnktY2hldnJvblwiXG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCAoaW50ZXJuYXRpb25hbGl6YXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGludGVybmF0aW9uYWxpemF0aW9uLnNldHRpbmdzUGxheWJhY2tTcGVlZCkgfHwgXCJQbGF5YmFjayBzcGVlZFwiKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LXNldHRpbmdzLXB5XCJcbiAgfSwgbmV3IEFycmF5KDgpLmZpbGwoXCJcIikubWFwKGZ1bmN0aW9uIChfLCBpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA9PT0gMyA/IChpbnRlcm5hdGlvbmFsaXphdGlvbiA9PSBudWxsID8gdm9pZCAwIDogaW50ZXJuYXRpb25hbGl6YXRpb24uc2V0dGluZ3NQbGF5YmFja1NwZWVkTm9ybWFsKSB8fCBcIk5vcm1hbFwiIDogKGluZGV4ICsgMSkgLyA0O1xuICB9KS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAga2V5OiBpdGVtLFxuICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgICAgc2V0UGxheWJhY2tTcGVlZCgoaW5kZXggKyAxKSAvIDQpO1xuICAgICAgICBzZXRBY3RpdmVTZWN0aW9uKFwibWFpblwiKTtcbiAgICAgIH0sXG4gICAgICBjbGFzc05hbWU6IFwidHVieS1zZXR0aW5ncy1pdGVtLTJcIlxuICAgIH0sIHBsYXliYWNrU3BlZWQgPT09IChpbmRleCArIDEpIC8gNCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hlY2ssIHtcbiAgICAgIGNsYXNzTmFtZTogXCJ0dWJ5LWNoZXZyb25cIlxuICAgIH0pIDogUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICB3aWR0aDogMTUsXG4gICAgICAgIGhlaWdodDogMTVcbiAgICAgIH1cbiAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgaXRlbSkpO1xuICB9KSkpLCBzdWJ0aXRsZXMgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBzdWJ0aXRsZXNTZWN0aW9uUmVmLFxuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LXNldHRpbmdzLXNlY3Rpb24gXCIgKyAoYWN0aXZlU2VjdGlvbiA9PT0gXCJzdWJ0aXRsZXNcIiA/IFwidHVieS1zZXR0aW5ncy10cmFuc2xhdGUtY2VudGVyXCIgOiBcInR1Ynktc2V0dGluZ3MtdHJhbnNsYXRlLXJpZ2h0XCIpXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICByZXR1cm4gc2V0QWN0aXZlU2VjdGlvbihcIm1haW5cIik7XG4gICAgfSxcbiAgICBjbGFzc05hbWU6IFwidHVieS1zZXR0aW5ncy1zZWN0aW9uLWhlYWRlclwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hldnJvbkxlZnQsIHtcbiAgICBjbGFzc05hbWU6IFwidHVieS1jaGV2cm9uXCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIChpbnRlcm5hdGlvbmFsaXphdGlvbiA9PSBudWxsID8gdm9pZCAwIDogaW50ZXJuYXRpb25hbGl6YXRpb24uc2V0dGluZ3NTdWJ0aXRsZXMpIHx8IFwiU3VidGl0bGVzXCIpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1Ynktc2V0dGluZ3MtcHlcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgc2V0U3VidGl0bGVJbmRleCgtMSk7XG4gICAgICBzZXRBY3RpdmVTZWN0aW9uKFwibWFpblwiKTtcbiAgICB9LFxuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LXNldHRpbmdzLWl0ZW0tMlwiXG4gIH0sIHN1YnRpdGxlSW5kZXggPT09IC0xID8gUmVhY3QuY3JlYXRlRWxlbWVudChDaGVjaywge1xuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LWNoZXZyb25cIlxuICB9KSA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICB3aWR0aDogMTUsXG4gICAgICBoZWlnaHQ6IDE1XG4gICAgfVxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgKGludGVybmF0aW9uYWxpemF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBpbnRlcm5hdGlvbmFsaXphdGlvbi5zZXR0aW5nc1N1YnRpdGxlc09mZikgfHwgXCJPZmZcIikpLCBzdWJ0aXRsZXMubWFwKGZ1bmN0aW9uIChzdWJ0aXRsZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBrZXk6IHN1YnRpdGxlLmxhbmcsXG4gICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgICBzZXRTdWJ0aXRsZUluZGV4KGluZGV4KTtcbiAgICAgICAgc2V0QWN0aXZlU2VjdGlvbihcIm1haW5cIik7XG4gICAgICB9LFxuICAgICAgY2xhc3NOYW1lOiBcInR1Ynktc2V0dGluZ3MtaXRlbS0yXCJcbiAgICB9LCBzdWJ0aXRsZUluZGV4ID09PSBpbmRleCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hlY2ssIHtcbiAgICAgIGNsYXNzTmFtZTogXCJ0dWJ5LWNoZXZyb25cIlxuICAgIH0pIDogUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICB3aWR0aDogMTUsXG4gICAgICAgIGhlaWdodDogMTVcbiAgICAgIH1cbiAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgc3VidGl0bGUubGFuZ3VhZ2UpKTtcbiAgfSkpKSwgdHlwZW9mIHNyYyAhPT0gXCJzdHJpbmdcIiAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICByZWY6IHF1YWxpdHlTZWN0aW9uUmVmLFxuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LXNldHRpbmdzLXNlY3Rpb24gXCIgKyAoYWN0aXZlU2VjdGlvbiA9PT0gXCJxdWFsaXR5XCIgPyBcInR1Ynktc2V0dGluZ3MtdHJhbnNsYXRlLWNlbnRlclwiIDogXCJ0dWJ5LXNldHRpbmdzLXRyYW5zbGF0ZS1yaWdodFwiKVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgcmV0dXJuIHNldEFjdGl2ZVNlY3Rpb24oXCJtYWluXCIpO1xuICAgIH0sXG4gICAgY2xhc3NOYW1lOiBcInR1Ynktc2V0dGluZ3Mtc2VjdGlvbi1oZWFkZXJcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KENoZXZyb25MZWZ0LCB7XG4gICAgY2xhc3NOYW1lOiBcInR1YnktY2hldnJvblwiXG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCAoaW50ZXJuYXRpb25hbGl6YXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGludGVybmF0aW9uYWxpemF0aW9uLnNldHRpbmdzUXVhbGl0eSkgfHwgXCJRdWFsaXR5XCIpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1Ynktc2V0dGluZ3MtcHlcIlxuICB9LCBzcmMubWFwKGZ1bmN0aW9uIChzb3VyY2UsIGluZGV4KSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAga2V5OiBzb3VyY2UucXVhbGl0eSxcbiAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICAgIHNldFF1YWxpdHkoaW5kZXgpO1xuICAgICAgICBzZXRBY3RpdmVTZWN0aW9uKFwibWFpblwiKTtcbiAgICAgIH0sXG4gICAgICBjbGFzc05hbWU6IFwidHVieS1zZXR0aW5ncy1pdGVtLTJcIlxuICAgIH0sIHF1YWxpdHkgPT09IGluZGV4ID8gUmVhY3QuY3JlYXRlRWxlbWVudChDaGVjaywge1xuICAgICAgY2xhc3NOYW1lOiBcInR1YnktY2hldnJvblwiXG4gICAgfSkgOiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHdpZHRoOiAxNSxcbiAgICAgICAgaGVpZ2h0OiAxNVxuICAgICAgfVxuICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCB0eXBlb2Ygc291cmNlLnF1YWxpdHkgPT09IFwibnVtYmVyXCIgPyBzb3VyY2UucXVhbGl0eSArIFwicFwiIDogc291cmNlLnF1YWxpdHkpKTtcbiAgfSkpKSkpO1xufTtcblxudmFyIFNldHRpbmdzTW9kYWwgPSBmdW5jdGlvbiBTZXR0aW5nc01vZGFsKF9yZWYpIHtcbiAgdmFyIHNldHRpbmdzQWN0aXZlID0gX3JlZi5zZXR0aW5nc0FjdGl2ZSxcbiAgICAgIHNldFNldHRpbmdzQWN0aXZlID0gX3JlZi5zZXRTZXR0aW5nc0FjdGl2ZSxcbiAgICAgIHNyYyA9IF9yZWYuc3JjLFxuICAgICAgc3VidGl0bGVzID0gX3JlZi5zdWJ0aXRsZXMsXG4gICAgICBwbGF5YmFja1NwZWVkID0gX3JlZi5wbGF5YmFja1NwZWVkLFxuICAgICAgc2V0UGxheWJhY2tTcGVlZCA9IF9yZWYuc2V0UGxheWJhY2tTcGVlZCxcbiAgICAgIHN1YnRpdGxlSW5kZXggPSBfcmVmLnN1YnRpdGxlSW5kZXgsXG4gICAgICBzZXRTdWJ0aXRsZUluZGV4ID0gX3JlZi5zZXRTdWJ0aXRsZUluZGV4LFxuICAgICAgcXVhbGl0eSA9IF9yZWYucXVhbGl0eSxcbiAgICAgIHNldFF1YWxpdHkgPSBfcmVmLnNldFF1YWxpdHksXG4gICAgICBpbnRlcm5hdGlvbmFsaXphdGlvbiA9IF9yZWYuaW50ZXJuYXRpb25hbGl6YXRpb247XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgcmV0dXJuIHNldFNldHRpbmdzQWN0aXZlKGZhbHNlKTtcbiAgICB9LFxuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LWJhY2tkcm9wIFwiICsgKHNldHRpbmdzQWN0aXZlID8gXCJ0dWJ5LXNob3dcIiA6IFwiXCIpXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgcmV0dXJuIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcbiAgICBjbGFzc05hbWU6IFwidHVieS1tb2RhbFwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoMVwiLCBudWxsLCAoaW50ZXJuYXRpb25hbGl6YXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGludGVybmF0aW9uYWxpemF0aW9uLnRvb2x0aXBzU2V0dGluZ3MpIHx8IFwiU2V0dGluZ3NcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCwgKGludGVybmF0aW9uYWxpemF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBpbnRlcm5hdGlvbmFsaXphdGlvbi5zZXR0aW5nc1BsYXliYWNrU3BlZWQpIHx8IFwiU3BlZWRcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiwge1xuICAgIHZhbHVlOiBwbGF5YmFja1NwZWVkICogNCAtIDEsXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGUpIHtcbiAgICAgIHJldHVybiBzZXRQbGF5YmFja1NwZWVkKCgrZS50YXJnZXQudmFsdWUgKyAxKSAvIDQpO1xuICAgIH1cbiAgfSwgbmV3IEFycmF5KDgpLmZpbGwoXCJcIikubWFwKGZ1bmN0aW9uIChfLCBpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA9PT0gMyA/IChpbnRlcm5hdGlvbmFsaXphdGlvbiA9PSBudWxsID8gdm9pZCAwIDogaW50ZXJuYXRpb25hbGl6YXRpb24uc2V0dGluZ3NQbGF5YmFja1NwZWVkTm9ybWFsKSB8fCBcIk5vcm1hbFwiIDogKGluZGV4ICsgMSkgLyA0O1xuICB9KS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwge1xuICAgICAga2V5OiBpdGVtLFxuICAgICAgdmFsdWU6IGluZGV4XG4gICAgfSwgaXRlbSk7XG4gIH0pKSksIHN1YnRpdGxlcyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIG51bGwsIChpbnRlcm5hdGlvbmFsaXphdGlvbiA9PSBudWxsID8gdm9pZCAwIDogaW50ZXJuYXRpb25hbGl6YXRpb24uc2V0dGluZ3NTdWJ0aXRsZXMpIHx8IFwiU3VidGl0bGVzXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIsIHtcbiAgICB2YWx1ZTogc3VidGl0bGVJbmRleCxcbiAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZSkge1xuICAgICAgcmV0dXJuIHNldFN1YnRpdGxlSW5kZXgoK2UudGFyZ2V0LnZhbHVlKTtcbiAgICB9XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwge1xuICAgIHZhbHVlOiAtMVxuICB9LCAoaW50ZXJuYXRpb25hbGl6YXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGludGVybmF0aW9uYWxpemF0aW9uLnNldHRpbmdzU3VidGl0bGVzT2ZmKSB8fCBcIk9mZlwiKSwgc3VidGl0bGVzLm1hcChmdW5jdGlvbiAoc3VidGl0bGUsIGluZGV4KSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwge1xuICAgICAga2V5OiBzdWJ0aXRsZS5sYW5nLFxuICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgICAgc2V0U3VidGl0bGVJbmRleChpbmRleCk7XG4gICAgICB9LFxuICAgICAgdmFsdWU6IGluZGV4XG4gICAgfSwgc3VidGl0bGUubGFuZ3VhZ2UpO1xuICB9KSkpLCB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCwgKGludGVybmF0aW9uYWxpemF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBpbnRlcm5hdGlvbmFsaXphdGlvbi5zZXR0aW5nc1F1YWxpdHkpIHx8IFwiUXVhbGl0eVwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiLCB7XG4gICAgdmFsdWU6IHF1YWxpdHksXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGUpIHtcbiAgICAgIHJldHVybiBzZXRRdWFsaXR5KCtlLnRhcmdldC52YWx1ZSk7XG4gICAgfVxuICB9LCBzcmMubWFwKGZ1bmN0aW9uIChzb3VyY2UsIGluZGV4KSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwge1xuICAgICAga2V5OiBzb3VyY2UucXVhbGl0eSxcbiAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICAgIHNldFF1YWxpdHkoaW5kZXgpO1xuICAgICAgfSxcbiAgICAgIHZhbHVlOiBpbmRleFxuICAgIH0sIHR5cGVvZiBzb3VyY2UucXVhbGl0eSA9PT0gXCJudW1iZXJcIiA/IHNvdXJjZS5xdWFsaXR5ICsgXCJwXCIgOiBzb3VyY2UucXVhbGl0eSk7XG4gIH0pKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LW1vZGFsLWJ0bi1jb250YWluZXJcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICBzdHlsZToge1xuICAgICAgcGFkZGluZzogNVxuICAgIH0sXG4gICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgIHJldHVybiBzZXRTZXR0aW5nc0FjdGl2ZShmYWxzZSk7XG4gICAgfVxuICB9LCAoaW50ZXJuYXRpb25hbGl6YXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGludGVybmF0aW9uYWxpemF0aW9uLnNldHRpbmdzTW9kYWxPZmYpIHx8IFwiT0tcIikpKSk7XG59O1xuXG52YXIgU3VidGl0bGUgPSBmdW5jdGlvbiBTdWJ0aXRsZShfcmVmKSB7XG4gIHZhciBvdGhlcnMgPSBfZXh0ZW5kcyh7fSwgX3JlZik7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgdmlld0JveDogXCIwIDAgNTAgNTBcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIG90aGVycyksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIk01LjU1NTU2IDVDMi40NzIyMiA1IDAgNy41NzE0MyAwIDEwLjcxNDNWMzkuMjg1N0MwIDQyLjQyODYgMi40NzIyMiA0NSA1LjU1NTU2IDQ1SDQ0LjQ0NDRDNDcuNSA0NSA1MCA0Mi40Mjg2IDUwIDM5LjI4NTdWMTAuNzE0M0M1MCA3LjU3MTQzIDQ3LjUgNSA0NC40NDQ0IDVINS41NTU1NlpNMjIuMjIyMiAyMi4xNDI5SDE4LjA1NTZWMjAuNzE0M0gxMi41VjI5LjI4NTdIMTguMDU1NlYyNy44NTcxSDIyLjIyMjJWMzAuNzE0M0MyMi4yMjIyIDMyLjI4NTcgMjAuOTcyMiAzMy41NzE0IDE5LjQ0NDQgMzMuNTcxNEgxMS4xMTExQzkuNTgzMzMgMzMuNTcxNCA4LjMzMzMzIDMyLjI4NTcgOC4zMzMzMyAzMC43MTQzVjE5LjI4NTdDOC4zMzMzMyAxNy43MTQzIDkuNTgzMzMgMTYuNDI4NiAxMS4xMTExIDE2LjQyODZIMTkuNDQ0NEMyMC45NzIyIDE2LjQyODYgMjIuMjIyMiAxNy43MTQzIDIyLjIyMjIgMTkuMjg1N1YyMi4xNDI5Wk00MS42NjY3IDIyLjE0MjlIMzcuNVYyMC43MTQzSDMxLjk0NDRWMjkuMjg1N0gzNy41VjI3Ljg1NzFINDEuNjY2N1YzMC43MTQzQzQxLjY2NjcgMzIuMjg1NyA0MC40MTY3IDMzLjU3MTQgMzguODg4OSAzMy41NzE0SDMwLjU1NTZDMjkuMDI3OCAzMy41NzE0IDI3Ljc3NzggMzIuMjg1NyAyNy43Nzc4IDMwLjcxNDNWMTkuMjg1N0MyNy43Nzc4IDE3LjcxNDMgMjkuMDI3OCAxNi40Mjg2IDMwLjU1NTYgMTYuNDI4NkgzOC44ODg5QzQwLjQxNjcgMTYuNDI4NiA0MS42NjY3IDE3LjcxNDMgNDEuNjY2NyAxOS4yODU3VjIyLjE0MjlaXCIsXG4gICAgZmlsbDogXCJ3aGl0ZVwiXG4gIH0pKTtcbn07XG5cbnZhciBWb2x1bWVGdWxsID0gZnVuY3Rpb24gVm9sdW1lRnVsbChfcmVmKSB7XG4gIHZhciBvdGhlcnMgPSBfZXh0ZW5kcyh7fSwgX3JlZik7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgdmlld0JveDogXCIwIDAgNTAgNTBcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIG90aGVycyksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0wIDMzLjU1MTlIMTEuMTExMUwyNSA0Ny44MDVWMi4xOTQ5OEwxMS4xMTExIDE2LjQ0ODFIMFYzMy41NTE5Wk0zMC41NTU2IDEzLjU5NzVWMzYuNDAyNUMzNC42NjY3IDM0LjQ2NDEgMzcuNSAzMC4wNDU2IDM3LjUgMjVDMzcuNSAyMC4wMzk5IDM0LjY2NjcgMTUuNzA3IDMwLjU1NTYgMTMuNTk3NVpNMzAuNTU1NiA1Ljg3MjI5QzM4LjU4MzMgOC4zMjM4MyA0NC40NDQ0IDE1Ljk2MzUgNDQuNDQ0NCAyNUM0NC40NDQ0IDM0LjAzNjUgMzguNTgzMyA0MS42NzYyIDMwLjU1NTYgNDQuMTI3N1Y1MEM0MS42OTQ0IDQ3LjQwNTkgNTAgMzcuMjAwNyA1MCAyNUM1MCAxMi43OTkzIDQxLjY5NDQgMi41OTQwNyAzMC41NTU2IDBWNS44NzIyOVpcIixcbiAgICBmaWxsOiBcIndoaXRlXCJcbiAgfSkpO1xufTtcblxudmFyIFZvbHVtZUhhbGYgPSBmdW5jdGlvbiBWb2x1bWVIYWxmKF9yZWYpIHtcbiAgdmFyIG90aGVycyA9IF9leHRlbmRzKHt9LCBfcmVmKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICB2aWV3Qm94OiBcIjAgMCA1MCA1MFwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwgb3RoZXJzKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTAgMzQuMzc1SDE0LjgxNDhMMzMuMzMzMyA1MFYwTDE0LjgxNDggMTUuNjI1SDBWMzQuMzc1Wk00MC43NDA3IDEyLjVWMzcuNUM0Ni4yMjIyIDM1LjM3NSA1MCAzMC41MzEyIDUwIDI1QzUwIDE5LjU2MjUgNDYuMjIyMiAxNC44MTI1IDQwLjc0MDcgMTIuNVpcIixcbiAgICBmaWxsOiBcIndoaXRlXCJcbiAgfSkpO1xufTtcblxudmFyIFZvbHVtZU11dGVkID0gZnVuY3Rpb24gVm9sdW1lTXV0ZWQoX3JlZikge1xuICB2YXIgb3RoZXJzID0gX2V4dGVuZHMoe30sIF9yZWYpO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIHZpZXdCb3g6IFwiMCAwIDUwIDUwXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCBvdGhlcnMpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMzcuNSAyNS4wMTM5QzM3LjUgMjAuMDk0NSAzNC42NjY3IDE1Ljg2OTkgMzAuNTU1NiAxMy44MTMyVjE5Ljk1NTVMMzcuMzYxMSAyNi43NjQ5QzM3LjQ0NDQgMjYuMjA5IDM3LjUgMjUuNjI1MyAzNy41IDI1LjAxMzlaTTQ0LjQ0NDQgMjUuMDEzOUM0NC40NDQ0IDI3LjYyNjUgNDMuODg4OSAzMC4wNzIzIDQyLjk0NDQgMzIuMzUxM0w0Ny4xMzg5IDM2LjU0ODFDNDguOTcyMiAzMy4xMDE3IDUwIDI5LjE4MjkgNTAgMjUuMDEzOUM1MCAxMy4xMTg0IDQxLjY5NDQgMy4xNjg0MyAzMC41NTU2IDAuNjY3MDM5VjYuMzY0NjVDMzguNTgzMyA4Ljc1NDg3IDQ0LjQ0NDQgMTYuMjAzNCA0NC40NDQ0IDI1LjAxMzlWMjUuMDEzOVpNMy41Mjc3OCAwTDAgMy41MDE5NUwxMy4xMTExIDE2LjY0ODFIMFYzMy4zMjQxSDExLjExMTFMMjUgNDcuMjIwN1YyOC41MTU4TDM2LjgwNTYgNDAuMzI4QzM0Ljk0NDQgNDEuNzczMiAzMi44NjExIDQyLjkxMjcgMzAuNTU1NiA0My42MDc2VjQ5LjMzM0MzNC4zODg5IDQ4LjQ3MTQgMzcuODYxMSA0Ni42OTI2IDQwLjgwNTYgNDQuMzAyNEw0Ni40NzIyIDUwTDUwIDQ2LjQ3MDNMMjUgMjEuNDU2NEwzLjU1NTU2IDBIMy41Mjc3OFpNMjQuOTcyMiAyLjc1MTUzTDE5LjE2NjcgOC41MzI1MkwyNC45NzIyIDE0LjM0MTNWMi43NzkzMlYyLjc1MTUzWlwiLFxuICAgIGZpbGw6IFwid2hpdGVcIlxuICB9KSk7XG59O1xuXG52YXIgdXNlRWZmZWN0VXBkYXRlID0gZnVuY3Rpb24gdXNlRWZmZWN0VXBkYXRlKGNiLCBkZXBlbmRlbmNpZXMpIHtcbiAgdmFyIHVwZGF0ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghdXBkYXRlZC5jdXJyZW50KSB7XG4gICAgICB1cGRhdGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNiKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICB9LCBkZXBlbmRlbmNpZXMpO1xufTtcblxudmFyIFBsYXllciA9IGZ1bmN0aW9uIFBsYXllcihfcmVmKSB7XG4gIHZhciBfc2Vla1JlZiRjdXJyZW50LCBfc2Vla1JlZiRjdXJyZW50MiwgX3NlZWtSZWYkY3VycmVudDMsIF9kb2N1bWVudDI7XG5cbiAgdmFyIHBsYXllcktleSA9IF9yZWYucGxheWVyS2V5LFxuICAgICAgc3JjID0gX3JlZi5zcmMsXG4gICAgICBzdWJ0aXRsZXMgPSBfcmVmLnN1YnRpdGxlcyxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIHBvc3RlciA9IF9yZWYucG9zdGVyLFxuICAgICAgX3JlZiRzZWVrRHVyYXRpb24gPSBfcmVmLnNlZWtEdXJhdGlvbixcbiAgICAgIHNlZWtEdXJhdGlvbiA9IF9yZWYkc2Vla0R1cmF0aW9uID09PSB2b2lkIDAgPyAxMCA6IF9yZWYkc2Vla0R1cmF0aW9uLFxuICAgICAgaW50ZXJuYXRpb25hbGl6YXRpb24gPSBfcmVmLmludGVybmF0aW9uYWxpemF0aW9uLFxuICAgICAgcGFzc2VkRG93blJlZiA9IF9yZWYucGxheWVyUmVmLFxuICAgICAgX3JlZiRwaWN0dXJlSW5QaWN0dXJlID0gX3JlZi5waWN0dXJlSW5QaWN0dXJlLFxuICAgICAgcGljdHVyZUluUGljdHVyZSA9IF9yZWYkcGljdHVyZUluUGljdHVyZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJHBpY3R1cmVJblBpY3R1cmUsXG4gICAgICBfcmVmJGtleWJvYXJkU2hvcnRjdXQgPSBfcmVmLmtleWJvYXJkU2hvcnRjdXQsXG4gICAgICBrZXlib2FyZFNob3J0Y3V0ID0gX3JlZiRrZXlib2FyZFNob3J0Y3V0ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRrZXlib2FyZFNob3J0Y3V0O1xuXG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZSgwKSxcbiAgICAgIHF1YWxpdHkgPSBfdXNlU3RhdGVbMF0sXG4gICAgICBzZXRRdWFsaXR5ID0gX3VzZVN0YXRlWzFdO1xuXG4gIHZhciBfdXNlU3RhdGUyID0gdXNlU3RhdGUoTnVtYmVyKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidHVieS1zcGVlZFwiKSkgfHwgMSksXG4gICAgICBwbGF5YmFja1NwZWVkID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldFBsYXliYWNrU3BlZWQgPSBfdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfdXNlU3RhdGUzID0gdXNlU3RhdGUodHJ1ZSksXG4gICAgICBwYXVzZWQgPSBfdXNlU3RhdGUzWzBdLFxuICAgICAgc2V0UGF1c2VkID0gX3VzZVN0YXRlM1sxXTtcblxuICB2YXIgX3VzZVN0YXRlNCA9IHVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIG9uRnVsbFNjcmVlbiA9IF91c2VTdGF0ZTRbMF0sXG4gICAgICBzZXRPbkZ1bGxTY3JlZW4gPSBfdXNlU3RhdGU0WzFdO1xuXG4gIHZhciBfdXNlU3RhdGU1ID0gdXNlU3RhdGUoZmFsc2UpLFxuICAgICAgbG9hZGluZyA9IF91c2VTdGF0ZTVbMF0sXG4gICAgICBzZXRMb2FkaW5nID0gX3VzZVN0YXRlNVsxXTtcblxuICB2YXIgX3VzZVN0YXRlNiA9IHVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIHNldHRpbmdzQWN0aXZlID0gX3VzZVN0YXRlNlswXSxcbiAgICAgIHNldFNldHRpbmdzQWN0aXZlID0gX3VzZVN0YXRlNlsxXTtcblxuICB2YXIgX3VzZVN0YXRlNyA9IHVzZVN0YXRlKDApLFxuICAgICAgc3VidGl0bGVJbmRleCA9IF91c2VTdGF0ZTdbMF0sXG4gICAgICBzZXRTdWJ0aXRsZUluZGV4ID0gX3VzZVN0YXRlN1sxXTtcblxuICB2YXIgX3VzZVN0YXRlOCA9IHVzZVN0YXRlKDApLFxuICAgICAgY3VycmVudFRpbWUgPSBfdXNlU3RhdGU4WzBdLFxuICAgICAgc2V0Q3VycmVudFRpbWUgPSBfdXNlU3RhdGU4WzFdO1xuXG4gIHZhciBfdXNlU3RhdGU5ID0gdXNlU3RhdGUoMCksXG4gICAgICBkdXJhdGlvbiA9IF91c2VTdGF0ZTlbMF0sXG4gICAgICBzZXREdXJhdGlvbiA9IF91c2VTdGF0ZTlbMV07XG5cbiAgdmFyIF91c2VTdGF0ZTEwID0gdXNlU3RhdGUobnVsbCksXG4gICAgICBzZWVrUHJldmlldyA9IF91c2VTdGF0ZTEwWzBdLFxuICAgICAgc2V0U2Vla1ByZXZpZXcgPSBfdXNlU3RhdGUxMFsxXTtcblxuICB2YXIgX3VzZVN0YXRlMTEgPSB1c2VTdGF0ZShmYWxzZSksXG4gICAgICBsb2FkZWREYXRhID0gX3VzZVN0YXRlMTFbMF0sXG4gICAgICBzZXRMb2FkZWREYXRhID0gX3VzZVN0YXRlMTFbMV07XG5cbiAgdmFyIF91c2VTdGF0ZTEyID0gdXNlU3RhdGUoaXNOYU4ocGFyc2VJbnQobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0dWJ5LXZvbHVtZVwiKSkpID8gMTAwIDogTnVtYmVyKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidHVieS12b2x1bWVcIikpKSxcbiAgICAgIHZvbHVtZSA9IF91c2VTdGF0ZTEyWzBdLFxuICAgICAgc2V0Vm9sdW1lID0gX3VzZVN0YXRlMTJbMV07XG5cbiAgdmFyIF91c2VTdGF0ZTEzID0gdXNlU3RhdGUoQm9vbGVhbihOdW1iZXIobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0dWJ5LW11dGVkXCIpKSkpLFxuICAgICAgaXNNdXRlZCA9IF91c2VTdGF0ZTEzWzBdLFxuICAgICAgc2V0SXNNdXRlZCA9IF91c2VTdGF0ZTEzWzFdO1xuXG4gIHZhciBfdXNlU3RhdGUxNCA9IHVzZVN0YXRlKHRydWUpLFxuICAgICAgaG92ZXJFbmFibGVkID0gX3VzZVN0YXRlMTRbMF0sXG4gICAgICBzZXRIb3ZlckVuYWJsZWQgPSBfdXNlU3RhdGUxNFsxXTtcblxuICB2YXIgX3VzZVN0YXRlMTUgPSB1c2VTdGF0ZShmYWxzZSksXG4gICAgICBwYXVzZURpZFVwZGF0ZSA9IF91c2VTdGF0ZTE1WzBdLFxuICAgICAgc2V0UGF1c2VEaWRVcGRhdGUgPSBfdXNlU3RhdGUxNVsxXTtcblxuICB2YXIgbXlSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBwbGF5ZXJSZWYgPSBwYXNzZWREb3duUmVmIHx8IG15UmVmO1xuICB2YXIgY29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgc2Vla1JlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIG1vdXNlRG93blJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIHZhciB0aW1lb3V0UmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgZnVsbHNjcmVlblRvZ2dsZUJ1dHRvbiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHBhdXNlQnV0dG9uID0gdXNlUmVmKG51bGwpO1xuICB2YXIgdm9sdW1lQnV0dG9uUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgc3VidGl0bGVCdXR0b25SZWYgPSB1c2VSZWYobnVsbCk7XG5cbiAgdmFyIHNlZWtUaW1lID0gZnVuY3Rpb24gc2Vla1RpbWUoYW1vdW50KSB7XG4gICAgcGxheWVyUmVmLmN1cnJlbnQgJiYgKHBsYXllclJlZi5jdXJyZW50LmN1cnJlbnRUaW1lICs9IGFtb3VudCk7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUhvdmVyU3RhdGUgPSBmdW5jdGlvbiB1cGRhdGVIb3ZlclN0YXRlKCkge1xuICAgIGlmICh0aW1lb3V0UmVmLmN1cnJlbnQpIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgIHNldEhvdmVyRW5hYmxlZCh0cnVlKTtcbiAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldEhvdmVyRW5hYmxlZChmYWxzZSk7XG4gICAgfSwgMjAwMCk7XG4gIH07XG5cbiAgdmFyIHRvZ2dsZVNvdW5kID0gZnVuY3Rpb24gdG9nZ2xlU291bmQoKSB7XG4gICAgc2V0SXNNdXRlZCghaXNNdXRlZCk7XG4gICAgc2V0Vm9sdW1lKHZvbHVtZSA9PT0gMCA/IDEwMCA6IHZvbHVtZSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVNlZWtpbmcgPSBmdW5jdGlvbiBoYW5kbGVTZWVraW5nKG9mZnNldFgpIHtcbiAgICBpZiAoIXBsYXllclJlZi5jdXJyZW50IHx8ICFzZWVrUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICB2YXIgb2Zmc2V0ID0gKG9mZnNldFggLSBzZWVrUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCkgLyBzZWVrUmVmLmN1cnJlbnQub2Zmc2V0V2lkdGg7XG4gICAgdmFyIG5ld1RpbWUgPSAoTWF0aC5hYnMob2Zmc2V0KSA9PT0gSW5maW5pdHkgfHwgaXNOYU4ob2Zmc2V0KSA/IDAgOiBvZmZzZXQpICogcGxheWVyUmVmLmN1cnJlbnQuZHVyYXRpb247XG4gICAgcGxheWVyUmVmLmN1cnJlbnQuY3VycmVudFRpbWUgPSBuZXdUaW1lO1xuICAgIHNldEN1cnJlbnRUaW1lKG5ld1RpbWUpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVTZWVrUHJldmlldyA9IGZ1bmN0aW9uIGhhbmRsZVNlZWtQcmV2aWV3KG9mZnNldFgpIHtcbiAgICBpZiAoIXBsYXllclJlZi5jdXJyZW50IHx8ICFzZWVrUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICB2YXIgbGVmdCA9IHNlZWtSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgIHZhciBvZmZzZXRJblBlcmNlbnRhZ2UgPSAob2Zmc2V0WCAtIGxlZnQpIC8gc2Vla1JlZi5jdXJyZW50Lm9mZnNldFdpZHRoO1xuICAgIG9mZnNldEluUGVyY2VudGFnZSA9IE1hdGguYWJzKG9mZnNldEluUGVyY2VudGFnZSkgPT09IEluZmluaXR5IHx8IGlzTmFOKG9mZnNldEluUGVyY2VudGFnZSkgPyAwIDogb2Zmc2V0SW5QZXJjZW50YWdlO1xuICAgIHZhciBvZmZzZXRJblBpeGVsID0gb2Zmc2V0SW5QZXJjZW50YWdlICogc2Vla1JlZi5jdXJyZW50Lm9mZnNldFdpZHRoO1xuICAgIHZhciBuZXdUaW1lID0gb2Zmc2V0SW5QZXJjZW50YWdlICogcGxheWVyUmVmLmN1cnJlbnQuZHVyYXRpb247XG4gICAgaWYgKGlzTmFOKG5ld1RpbWUpKSBzZXRTZWVrUHJldmlldyhudWxsKTtcbiAgICBpZiAobmV3VGltZSA8IDApIG5ld1RpbWUgPSAwO1xuICAgIHNldFNlZWtQcmV2aWV3KHtcbiAgICAgIHRpbWU6IE1hdGgucm91bmQobmV3VGltZSksXG4gICAgICBvZmZzZXQ6IG9mZnNldEluUGl4ZWxcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgbGlzdGVuTW91c2VNb3ZlU2Vla2luZyA9IGZ1bmN0aW9uIGxpc3Rlbk1vdXNlTW92ZVNlZWtpbmcoKSB7XG4gICAgdmFyIG1vdmVIYW5kbGVyID0gZnVuY3Rpb24gbW92ZUhhbmRsZXIoZSkge1xuICAgICAgaGFuZGxlU2Vla1ByZXZpZXcoZS5jbGllbnRYKTtcblxuICAgICAgaWYgKG1vdXNlRG93blJlZi5jdXJyZW50KSB7XG4gICAgICAgIGhhbmRsZVNlZWtpbmcoZS5jbGllbnRYKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW92ZUhhbmRsZXIpO1xuXG4gICAgdmFyIHRvdWNoTW92ZUhhbmRsZXIgPSBmdW5jdGlvbiB0b3VjaE1vdmVIYW5kbGVyKGUpIHtcbiAgICAgIHZhciBfZSR0b3VjaGVzLCBfZSR0b3VjaGVzJDtcblxuICAgICAgaGFuZGxlU2Vla1ByZXZpZXcoKF9lJHRvdWNoZXMgPSBlLnRvdWNoZXMpID09IG51bGwgPyB2b2lkIDAgOiAoX2UkdG91Y2hlcyQgPSBfZSR0b3VjaGVzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2UkdG91Y2hlcyQucGFnZVgpO1xuXG4gICAgICBpZiAobW91c2VEb3duUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgdmFyIF9lJHRvdWNoZXMyLCBfZSR0b3VjaGVzMiQ7XG5cbiAgICAgICAgaGFuZGxlU2Vla2luZygoX2UkdG91Y2hlczIgPSBlLnRvdWNoZXMpID09IG51bGwgPyB2b2lkIDAgOiAoX2UkdG91Y2hlczIkID0gX2UkdG91Y2hlczJbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZSR0b3VjaGVzMiQucGFnZVgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0b3VjaE1vdmVIYW5kbGVyKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW92ZUhhbmRsZXIpO1xuICAgICAgbW91c2VEb3duUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHNldFNlZWtQcmV2aWV3KG51bGwpO1xuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICBtb3VzZURvd25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgc2V0U2Vla1ByZXZpZXcobnVsbCk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVNjcmVlbkNsaWNrZWQgPSBmdW5jdGlvbiBoYW5kbGVTY3JlZW5DbGlja2VkKGUpIHtcbiAgICBpZiAoc2V0dGluZ3NBY3RpdmUpIHtcbiAgICAgIHNldFNldHRpbmdzQWN0aXZlKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0UGF1c2VkKGZ1bmN0aW9uIChwcmV2KSB7XG4gICAgICAgIHJldHVybiAhcHJldjtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChlLmRldGFpbCA9PT0gMiAmJiAhaXNNb2JpbGUoKSkge1xuICAgICAgc2V0T25GdWxsU2NyZWVuKGZ1bmN0aW9uIChwcmV2KSB7XG4gICAgICAgIHJldHVybiAhcHJldjtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB1c2VFZmZlY3RVcGRhdGUoZnVuY3Rpb24gKCkge1xuICAgIHZhciBfZG9jdW1lbnQsIF9kb2N1bWVudCRhY3RpdmVFbGVtZTtcblxuICAgIHVwZGF0ZUhvdmVyU3RhdGUoKTtcbiAgICBzZXRQYXVzZURpZFVwZGF0ZSh0cnVlKTtcblxuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHZhciBfcGxheWVyUmVmJGN1cnJlbnQ7XG5cbiAgICAgIChfcGxheWVyUmVmJGN1cnJlbnQgPSBwbGF5ZXJSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wbGF5ZXJSZWYkY3VycmVudC5wYXVzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3BsYXllclJlZiRjdXJyZW50MjtcblxuICAgICAgKF9wbGF5ZXJSZWYkY3VycmVudDIgPSBwbGF5ZXJSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wbGF5ZXJSZWYkY3VycmVudDIucGxheSgpO1xuICAgIH1cblxuICAgIChfZG9jdW1lbnQgPSBkb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IChfZG9jdW1lbnQkYWN0aXZlRWxlbWUgPSBfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kb2N1bWVudCRhY3RpdmVFbGVtZS5ibHVyKCk7XG4gIH0sIFtwYXVzZWRdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocGxheWVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIHBsYXllclJlZi5jdXJyZW50Lm11dGVkID0gaXNNdXRlZDtcbiAgICAgIHBsYXllclJlZi5jdXJyZW50LnZvbHVtZSA9IGlzTXV0ZWQgPyAwIDogdm9sdW1lIC8gMTAwO1xuICAgIH1cblxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidHVieS12b2x1bWVcIiwgU3RyaW5nKHZvbHVtZSkpO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidHVieS1tdXRlZFwiLCBTdHJpbmcoK2lzTXV0ZWQpKTtcbiAgfSwgW3ZvbHVtZSwgaXNNdXRlZF0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjaGFuZ2VIYW5kbGVyID0gZnVuY3Rpb24gY2hhbmdlSGFuZGxlcigpIHtcbiAgICAgIHZhciBkb2MgPSBkb2N1bWVudDtcbiAgICAgIHZhciBmdWxsc2NyZWVuRWxlbWVudCA9IGRvYy5mdWxsc2NyZWVuRWxlbWVudCB8fCBkb2Mud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQgfHwgZG9jLndlYmtpdEN1cnJlbnRGdWxsU2NyZWVuRWxlbWVudCB8fCBkb2MubW96RnVsbFNjcmVlbkVsZW1lbnQgfHwgZG9jLm1zRnVsbHNjcmVlbkVsZW1lbnQ7XG5cbiAgICAgIGlmIChmdWxsc2NyZWVuRWxlbWVudCkge1xuICAgICAgICBzZXRPbkZ1bGxTY3JlZW4odHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRPbkZ1bGxTY3JlZW4oZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZnVsbHNjcmVlbmNoYW5nZVwiLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwid2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiTVNGdWxsc2NyZWVuQ2hhbmdlXCIsIGNoYW5nZUhhbmRsZXIpO1xuXG4gICAgdmFyIGVuZEZ1bGxTY3JlZW5IYW5kbGVyID0gZnVuY3Rpb24gZW5kRnVsbFNjcmVlbkhhbmRsZXIoKSB7XG4gICAgICBjaGFuZ2VIYW5kbGVyKCk7XG4gICAgICBzZXRQYXVzZWQodHJ1ZSk7XG4gICAgfTtcblxuICAgIHZhciBwbGF5ZXIgPSBwbGF5ZXJSZWYuY3VycmVudDtcbiAgICBwbGF5ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXllci5hZGRFdmVudExpc3RlbmVyKFwid2Via2l0ZW5kZnVsbHNjcmVlblwiLCBlbmRGdWxsU2NyZWVuSGFuZGxlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmdWxsc2NyZWVuY2hhbmdlXCIsIGNoYW5nZUhhbmRsZXIpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIiwgY2hhbmdlSGFuZGxlcik7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJNU0Z1bGxzY3JlZW5DaGFuZ2VcIiwgY2hhbmdlSGFuZGxlcik7XG4gICAgICBwbGF5ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKFwid2Via2l0ZW5kZnVsbHNjcmVlblwiLCBlbmRGdWxsU2NyZWVuSGFuZGxlcik7XG4gICAgfTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3RVcGRhdGUoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAob25GdWxsU2NyZWVuKSB7XG4gICAgICAgIGlmIChpc01vYmlsZSgpKSB7XG4gICAgICAgICAgdmFyIGVsZW0gPSBwbGF5ZXJSZWYuY3VycmVudDtcbiAgICAgICAgICB2YXIgcmVxdWVzdEZ1bGxTY3JlZW4gPSBlbGVtLnJlcXVlc3RGdWxsc2NyZWVuIHx8IGVsZW0ud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4gfHwgZWxlbS53ZWJraXRSZXF1ZXN0RnVsbFNjcmVlbiB8fCBlbGVtLndlYmtpdEVudGVyRnVsbHNjcmVlbiB8fCBlbGVtLm1velJlcXVlc3RGdWxsU2NyZWVuIHx8IGVsZW0ubXNSZXF1ZXN0RnVsbHNjcmVlbjtcbiAgICAgICAgICByZXF1ZXN0RnVsbFNjcmVlbiA9PSBudWxsID8gdm9pZCAwIDogcmVxdWVzdEZ1bGxTY3JlZW4uY2FsbChlbGVtKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfZWxlbSA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuXG4gICAgICAgICAgdmFyIF9yZXF1ZXN0RnVsbFNjcmVlbiA9IF9lbGVtLnJlcXVlc3RGdWxsc2NyZWVuIHx8IF9lbGVtLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuIHx8IF9lbGVtLndlYmtpdFJlcXVlc3RGdWxsU2NyZWVuIHx8IF9lbGVtLndlYmtpdEVudGVyRnVsbHNjcmVlbiB8fCBfZWxlbS5tb3pSZXF1ZXN0RnVsbFNjcmVlbiB8fCBfZWxlbS5tc1JlcXVlc3RGdWxsc2NyZWVuO1xuXG4gICAgICAgICAgX3JlcXVlc3RGdWxsU2NyZWVuID09IG51bGwgPyB2b2lkIDAgOiBfcmVxdWVzdEZ1bGxTY3JlZW4uY2FsbChfZWxlbSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRvYyA9IGRvY3VtZW50O1xuICAgICAgICB2YXIgZXhpdEZ1bGxTY3JlZW4gPSBkb2MuZXhpdEZ1bGxzY3JlZW4gfHwgZG9jLndlYmtpdEV4aXRGdWxsc2NyZWVuIHx8IGRvYy53ZWJraXRDYW5jZWxGdWxsU2NyZWVuIHx8IGRvYy5tb3pDYW5jZWxGdWxsU2NyZWVuIHx8IGRvYy5tc0V4aXRGdWxsc2NyZWVuO1xuICAgICAgICBleGl0RnVsbFNjcmVlbiA9PSBudWxsID8gdm9pZCAwIDogZXhpdEZ1bGxTY3JlZW4uY2FsbChkb2N1bWVudClbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuXG4gICAgdXBkYXRlSG92ZXJTdGF0ZSgpO1xuICB9LCBbb25GdWxsU2NyZWVuXSk7XG4gIHVzZUVmZmVjdFVwZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwbGF5ZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIHBsYXllclJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRkYXRhXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwbGF5ZXJSZWYuY3VycmVudCkge1xuICAgICAgICBpZiAoY3VycmVudFRpbWUpIHtcbiAgICAgICAgICBwbGF5ZXJSZWYuY3VycmVudC5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgIHBsYXllclJlZi5jdXJyZW50LnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgICBwbGF5ZXJSZWYuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9wbGF5ZXJSZWYkY3VycmVudDM7XG5cbiAgICAgIChfcGxheWVyUmVmJGN1cnJlbnQzID0gcGxheWVyUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfcGxheWVyUmVmJGN1cnJlbnQzLnBhdXNlKCk7XG4gICAgfSk7XG4gIH0sIFtxdWFsaXR5XSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwbGF5ZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidHVieS1zcGVlZFwiLCBTdHJpbmcocGxheWJhY2tTcGVlZCkpO1xuICAgIHBsYXllclJlZi5jdXJyZW50LnBsYXliYWNrUmF0ZSA9IHBsYXliYWNrU3BlZWQ7XG4gIH0sIFtwbGF5YmFja1NwZWVkXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGtleUhhbmRsZXIgPSBmdW5jdGlvbiBrZXlIYW5kbGVyKGUpIHtcbiAgICAgIHZhciBfY29udGFpbmVyUmVmJGN1cnJlbnQsIF9kb2N1bWVudCRhY3RpdmVFbGVtZTIsIF9wYXVzZUJ1dHRvbiRjdXJyZW50LCBfZnVsbHNjcmVlblRvZ2dsZUJ1dHQsIF92b2x1bWVCdXR0b25SZWYkY3VyciwgX3N1YnRpdGxlQnV0dG9uUmVmJGN1O1xuXG4gICAgICBpZiAoIWtleWJvYXJkU2hvcnRjdXQpIHJldHVybjtcbiAgICAgIGlmICgoX2NvbnRhaW5lclJlZiRjdXJyZW50ID0gY29udGFpbmVyUmVmLmN1cnJlbnQpICE9IG51bGwgJiYgX2NvbnRhaW5lclJlZiRjdXJyZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSAoX2RvY3VtZW50JGFjdGl2ZUVsZW1lMiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZG9jdW1lbnQkYWN0aXZlRWxlbWUyLmJsdXIoKTsgLy8gUGF1c2VcblxuICAgICAgaWYgKChrZXlib2FyZFNob3J0Y3V0ID09PSB0cnVlIHx8IGtleWJvYXJkU2hvcnRjdXQucGF1c2UpICYmIChlLmtleSA9PT0gXCIgXCIgfHwgZS5rZXkgPT09IFwia1wiKSkgKF9wYXVzZUJ1dHRvbiRjdXJyZW50ID0gcGF1c2VCdXR0b24uY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXVzZUJ1dHRvbiRjdXJyZW50LmNsaWNrKCk7IC8vIFJld2luZFxuXG4gICAgICBpZiAoKGtleWJvYXJkU2hvcnRjdXQgPT09IHRydWUgfHwga2V5Ym9hcmRTaG9ydGN1dC5yZXdpbmQpICYmIGUua2V5ID09PSBcIkFycm93TGVmdFwiKSBzZWVrVGltZSgtc2Vla0R1cmF0aW9uKTsgLy8gRm9yd2FyZFxuXG4gICAgICBpZiAoKGtleWJvYXJkU2hvcnRjdXQgPT09IHRydWUgfHwga2V5Ym9hcmRTaG9ydGN1dC5mb3J3YXJkKSAmJiBlLmtleSA9PT0gXCJBcnJvd1JpZ2h0XCIpIHNlZWtUaW1lKHNlZWtEdXJhdGlvbik7IC8vIEZ1bGwgc2NyZWVuXG5cbiAgICAgIGlmICgoa2V5Ym9hcmRTaG9ydGN1dCA9PT0gdHJ1ZSB8fCBrZXlib2FyZFNob3J0Y3V0LmZ1bGxTY3JlZW4pICYmIGUua2V5ID09PSBcImZcIikgKF9mdWxsc2NyZWVuVG9nZ2xlQnV0dCA9IGZ1bGxzY3JlZW5Ub2dnbGVCdXR0b24uY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mdWxsc2NyZWVuVG9nZ2xlQnV0dC5jbGljaygpOyAvLyBNdXRlXG5cbiAgICAgIGlmICgoa2V5Ym9hcmRTaG9ydGN1dCA9PT0gdHJ1ZSB8fCBrZXlib2FyZFNob3J0Y3V0Lm11dGUpICYmIGUua2V5ID09PSBcIm1cIikgKF92b2x1bWVCdXR0b25SZWYkY3VyciA9IHZvbHVtZUJ1dHRvblJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3ZvbHVtZUJ1dHRvblJlZiRjdXJyLmNsaWNrKCk7IC8vIFN1YnRpdGxlXG5cbiAgICAgIGlmICgoa2V5Ym9hcmRTaG9ydGN1dCA9PT0gdHJ1ZSB8fCBrZXlib2FyZFNob3J0Y3V0LnN1YnRpdGxlKSAmJiBlLmtleSA9PT0gXCJjXCIpIChfc3VidGl0bGVCdXR0b25SZWYkY3UgPSBzdWJ0aXRsZUJ1dHRvblJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3N1YnRpdGxlQnV0dG9uUmVmJGN1LmNsaWNrKCk7XG4gICAgfTtcblxuICAgIHZhciBzcGFjZVByZXNzSGFuZGxlciA9IGZ1bmN0aW9uIHNwYWNlUHJlc3NIYW5kbGVyKGUpIHtcbiAgICAgIGlmIChrZXlib2FyZFNob3J0Y3V0ICYmIGUua2V5ID09PSBcIiBcIikgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGtleUhhbmRsZXIpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBzcGFjZVByZXNzSGFuZGxlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwga2V5SGFuZGxlcik7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgc3BhY2VQcmVzc0hhbmRsZXIpO1xuICAgIH07XG4gIH0sIFtzZWVrRHVyYXRpb24sIGtleWJvYXJkU2hvcnRjdXRdKTtcbiAgdmFyIHZpZGVvUHJvcHMgPSB7XG4gICAgY3Jvc3NPcmlnaW46IFwiYW5vbnltb3VzXCIsXG4gICAgcGxheXNJbmxpbmU6IHRydWUsXG4gICAgb25DbGlja0NhcHR1cmU6IGhhbmRsZVNjcmVlbkNsaWNrZWQsXG4gICAgY29udHJvbHM6IGZhbHNlLFxuICAgIHNyYzogdHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIiA/IHNyYyA6IHNyY1txdWFsaXR5XS51cmwsXG4gICAgb25XYWl0aW5nOiBmdW5jdGlvbiBvbldhaXRpbmcoKSB7XG4gICAgICByZXR1cm4gc2V0TG9hZGluZyh0cnVlKTtcbiAgICB9LFxuICAgIG9uUGxheWluZzogZnVuY3Rpb24gb25QbGF5aW5nKCkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICBzZXRQYXVzZWQoZmFsc2UpO1xuICAgIH0sXG4gICAgb25Mb2FkZWREYXRhOiBmdW5jdGlvbiBvbkxvYWRlZERhdGEoKSB7XG4gICAgICB2YXIgX3BsYXllclJlZiRjdXJyZW50NDtcblxuICAgICAgc2V0TG9hZGVkRGF0YSh0cnVlKTtcbiAgICAgIHNldER1cmF0aW9uKCgoX3BsYXllclJlZiRjdXJyZW50NCA9IHBsYXllclJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3BsYXllclJlZiRjdXJyZW50NC5kdXJhdGlvbikgfHwgMCk7XG4gICAgICB2YXIgY3VycmVudFRpbWU7XG5cbiAgICAgIGlmIChwbGF5ZXJLZXkpIHtcbiAgICAgICAgY3VycmVudFRpbWUgPSBOdW1iZXIobG9jYWxTdG9yYWdlLmdldEl0ZW0ocGxheWVyS2V5ICsgXCItdGltZVwiKSk7XG4gICAgICB9IGVsc2UgY3VycmVudFRpbWUgPSAwO1xuXG4gICAgICBzZXRDdXJyZW50VGltZShjdXJyZW50VGltZSk7XG4gICAgICBwbGF5ZXJSZWYuY3VycmVudCAmJiAocGxheWVyUmVmLmN1cnJlbnQuY3VycmVudFRpbWUgPSBjdXJyZW50VGltZSk7XG4gICAgfSxcbiAgICBvblRpbWVVcGRhdGU6IGZ1bmN0aW9uIG9uVGltZVVwZGF0ZSgpIHtcbiAgICAgIHZhciBfcGxheWVyUmVmJGN1cnJlbnQ1LCBfcGxheWVyUmVmJGN1cnJlbnQ2LCBfcGxheWVyUmVmJGN1cnJlbnQ3O1xuXG4gICAgICBpZiAocGxheWVyS2V5KSBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShwbGF5ZXJLZXkgKyBcIi10aW1lXCIsIFN0cmluZygoKF9wbGF5ZXJSZWYkY3VycmVudDUgPSBwbGF5ZXJSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wbGF5ZXJSZWYkY3VycmVudDUuY3VycmVudFRpbWUpIHx8IDApKTtcbiAgICAgIHNldEN1cnJlbnRUaW1lKCgoX3BsYXllclJlZiRjdXJyZW50NiA9IHBsYXllclJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3BsYXllclJlZiRjdXJyZW50Ni5jdXJyZW50VGltZSkgfHwgMCk7XG4gICAgICBzZXREdXJhdGlvbigoKF9wbGF5ZXJSZWYkY3VycmVudDcgPSBwbGF5ZXJSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wbGF5ZXJSZWYkY3VycmVudDcuZHVyYXRpb24pIHx8IDApO1xuICAgIH0sXG4gICAgb25FbmRlZDogZnVuY3Rpb24gb25FbmRlZCgpIHtcbiAgICAgIHNldFBhdXNlZCh0cnVlKTtcbiAgICB9LFxuICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbiBvbk1vdXNlTW92ZSgpIHtcbiAgICAgIHJldHVybiB1cGRhdGVIb3ZlclN0YXRlKCk7XG4gICAgfSxcbiAgICBjaGlsZHJlbjogUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgc3VidGl0bGVzICYmIHN1YnRpdGxlcy5sZW5ndGggPiAwICYmIHN1YnRpdGxlSW5kZXggPj0gMCAmJiBsb2FkZWREYXRhICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0cmFja1wiLCB7XG4gICAgICBraW5kOiBcInN1YnRpdGxlc1wiLFxuICAgICAgc3JjTGFuZzogc3VidGl0bGVzW3N1YnRpdGxlSW5kZXhdLmxhbmcsXG4gICAgICBsYWJlbDogc3VidGl0bGVzW3N1YnRpdGxlSW5kZXhdLmxhbmd1YWdlLFxuICAgICAgc3JjOiBzdWJ0aXRsZXNbc3VidGl0bGVJbmRleF0udXJsLFxuICAgICAgXCJkZWZhdWx0XCI6IHRydWVcbiAgICB9KSlcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHBvc3RlciAmJiAhcGF1c2VEaWRVcGRhdGUgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7XG4gICAgc3JjOiBwb3N0ZXIsXG4gICAgY2xhc3NOYW1lOiBcInR1YnktcG9zdGVyXCIsXG4gICAgYWx0OiBcIlR1YnkgUG9zdGVyXCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LWNvbnRhaW5lciBcIiArIChob3ZlckVuYWJsZWQgPyBcInR1YnktY29udHJvbHMtaG92ZXJlZFwiIDogXCJcIilcbiAgfSwgY2hpbGRyZW4gPyBjaGlsZHJlbihwbGF5ZXJSZWYsIHZpZGVvUHJvcHMpIDogUmVhY3QuY3JlYXRlRWxlbWVudChcInZpZGVvXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIHJlZjogcGxheWVyUmVmXG4gIH0sIHZpZGVvUHJvcHMpKSwgKCFsb2FkZWREYXRhICYmIHBhdXNlRGlkVXBkYXRlIHx8IGxvYWRpbmcgJiYgIXBhdXNlZCkgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1YnktY2VudGVyXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChDaXJjdWxhclByb2dyZXNzLCBudWxsKSksIHBhdXNlZCAmJiBwYXVzZURpZFVwZGF0ZSAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwidHVieS1jZW50ZXJcIixcbiAgICBvbkNsaWNrQ2FwdHVyZTogaGFuZGxlU2NyZWVuQ2xpY2tlZFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFBhdXNlRWZmZWN0LCBudWxsKSksICFwYXVzZWQgJiYgcGF1c2VEaWRVcGRhdGUgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1YnktY2VudGVyXCIsXG4gICAgb25DbGlja0NhcHR1cmU6IGhhbmRsZVNjcmVlbkNsaWNrZWRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChQbGF5RWZmZWN0LCBudWxsKSksICFwYXVzZURpZFVwZGF0ZSAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwidHVieS1jZW50ZXJcIixcbiAgICBvbkNsaWNrQ2FwdHVyZTogaGFuZGxlU2NyZWVuQ2xpY2tlZFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFBsYXksIHtcbiAgICBjbGFzc05hbWU6IFwidHVieS1pY29uLW1kXCJcbiAgfSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBvblRvdWNoRW5kOiBmdW5jdGlvbiBvblRvdWNoRW5kKCkge1xuICAgICAgcmV0dXJuIHNldEhvdmVyRW5hYmxlZCh0cnVlKTtcbiAgICB9LFxuICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICByZXR1cm4gc2V0SG92ZXJFbmFibGVkKHRydWUpO1xuICAgIH0sXG4gICAgb25Nb3VzZUVudGVyOiBmdW5jdGlvbiBvbk1vdXNlRW50ZXIoKSB7XG4gICAgICByZXR1cm4gdGltZW91dFJlZi5jdXJyZW50ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgIH0sXG4gICAgY2xhc3NOYW1lOiBcInR1YnktY29udHJvbHMgXCIgKyAocGF1c2VkIHx8IHNldHRpbmdzQWN0aXZlID8gXCJ0dWJ5LXNob3dcIiA6IFwiXCIpXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogc2Vla1JlZixcbiAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgbW91c2VEb3duUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgaGFuZGxlU2Vla2luZyhlLmNsaWVudFgpO1xuICAgICAgbGlzdGVuTW91c2VNb3ZlU2Vla2luZygpO1xuICAgIH0sXG4gICAgb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xuICAgICAgdmFyIF9lJHRvdWNoZXMzLCBfZSR0b3VjaGVzMyQ7XG5cbiAgICAgIG1vdXNlRG93blJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGhhbmRsZVNlZWtpbmcoKF9lJHRvdWNoZXMzID0gZS50b3VjaGVzKSA9PSBudWxsID8gdm9pZCAwIDogKF9lJHRvdWNoZXMzJCA9IF9lJHRvdWNoZXMzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2UkdG91Y2hlczMkLnBhZ2VYKTtcbiAgICAgIGxpc3Rlbk1vdXNlTW92ZVNlZWtpbmcoKTtcbiAgICB9LFxuICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbiBvbk1vdXNlTW92ZShlKSB7XG4gICAgICByZXR1cm4gaGFuZGxlU2Vla1ByZXZpZXcoZS5jbGllbnRYKTtcbiAgICB9LFxuICAgIG9uTW91c2VMZWF2ZTogZnVuY3Rpb24gb25Nb3VzZUxlYXZlKCkge1xuICAgICAgcmV0dXJuIHNldFNlZWtQcmV2aWV3KG51bGwpO1xuICAgIH0sXG4gICAgY2xhc3NOYW1lOiBcInR1Ynktc2Vla1wiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LXNlZWstYmFyXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHdpZHRoOiBkdXJhdGlvbiAhPT0gMCA/IE1hdGgucm91bmQoY3VycmVudFRpbWUgLyBkdXJhdGlvbiAqIDEwMDApIC8gMTAgKyBcIiVcIiA6IDBcbiAgICB9LFxuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LXNlZWstbGVmdFwiXG4gIH0pKSwgc2Vla1ByZXZpZXcgIT09IG51bGwgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1Ynktc2Vlay1wcmV2aWV3XCIsXG4gICAgc3R5bGU6IHtcbiAgICAgIGxlZnQ6IHNlZWtQcmV2aWV3Lm9mZnNldCA8IDE2ID8gMCA6IHNlZWtQcmV2aWV3Lm9mZnNldCA+ICgoKF9zZWVrUmVmJGN1cnJlbnQgPSBzZWVrUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfc2Vla1JlZiRjdXJyZW50Lm9mZnNldFdpZHRoKSB8fCAwKSAtIDE2ID8gXCJhdXRvXCIgOiBzZWVrUHJldmlldy5vZmZzZXQsXG4gICAgICByaWdodDogc2Vla1ByZXZpZXcub2Zmc2V0ID4gKCgoX3NlZWtSZWYkY3VycmVudDIgPSBzZWVrUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfc2Vla1JlZiRjdXJyZW50Mi5vZmZzZXRXaWR0aCkgfHwgMCkgLSAxNiA/IDAgOiBcImF1dG9cIixcbiAgICAgIHRyYW5zZm9ybTogc2Vla1ByZXZpZXcub2Zmc2V0IDwgMTYgfHwgc2Vla1ByZXZpZXcub2Zmc2V0ID4gKCgoX3NlZWtSZWYkY3VycmVudDMgPSBzZWVrUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfc2Vla1JlZiRjdXJyZW50My5vZmZzZXRXaWR0aCkgfHwgMCkgLSAxNiA/IFwibm9uZVwiIDogXCJ0cmFuc2xhdGVYKC01MCUpXCJcbiAgICB9XG4gIH0sIGZvcm1hdFZpZGVvVGltZShzZWVrUHJldmlldy50aW1lKSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwidHVieS1jb250cm9scy1tYWluXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1YnktY29udHJvbHMtbGVmdFwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIHJlZjogcGF1c2VCdXR0b24sXG4gICAgY2xhc3NOYW1lOiBcInR1YnktY2VudGVyLWNvbnRhaW5lciB0dWJ5LXRvb2x0aXBzLWxlZnRcIixcbiAgICBcImRhdGEtdHVieS10b29sdGlwc1wiOiBwYXVzZWQgPyAoaW50ZXJuYXRpb25hbGl6YXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGludGVybmF0aW9uYWxpemF0aW9uLnRvb2x0aXBzUGxheSkgfHwgXCJQbGF5IChrKVwiIDogKGludGVybmF0aW9uYWxpemF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBpbnRlcm5hdGlvbmFsaXphdGlvbi50b29sdGlwc1BhdXNlKSB8fCBcIlBhdXNlIChrKVwiLFxuICAgIG9uQ2xpY2tDYXB0dXJlOiBmdW5jdGlvbiBvbkNsaWNrQ2FwdHVyZSgpIHtcbiAgICAgIHJldHVybiBzZXRQYXVzZWQoZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgcmV0dXJuICFwcmV2O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBwYXVzZWQgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFBsYXksIHtcbiAgICBjbGFzc05hbWU6IFwidHVieS1pY29uLXNtXCJcbiAgfSkgOiBSZWFjdC5jcmVhdGVFbGVtZW50KFBhdXNlLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1YnktaWNvbi1zbVwiXG4gIH0pKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1Ynktdm9sdW1lLWNvbnRhaW5lclwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIHJlZjogdm9sdW1lQnV0dG9uUmVmLFxuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LWNlbnRlci1jb250YWluZXJcIixcbiAgICBcImRhdGEtdHVieS10b29sdGlwc1wiOiBpc011dGVkIHx8IHZvbHVtZSA9PT0gMCA/IChpbnRlcm5hdGlvbmFsaXphdGlvbiA9PSBudWxsID8gdm9pZCAwIDogaW50ZXJuYXRpb25hbGl6YXRpb24udG9vbHRpcHNVbm11dGUpIHx8IFwiVW5tdXRlIChtKVwiIDogKGludGVybmF0aW9uYWxpemF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBpbnRlcm5hdGlvbmFsaXphdGlvbi50b29sdGlwc011dGUpIHx8IFwiTXV0ZSAobSlcIixcbiAgICBvbkNsaWNrQ2FwdHVyZTogdG9nZ2xlU291bmRcbiAgfSwgaXNNdXRlZCB8fCB2b2x1bWUgPT09IDAgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFZvbHVtZU11dGVkLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1YnktaWNvbi1zbVwiXG4gIH0pIDogdm9sdW1lID09PSAxMDAgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFZvbHVtZUZ1bGwsIHtcbiAgICBjbGFzc05hbWU6IFwidHVieS1pY29uLXNtXCJcbiAgfSkgOiBSZWFjdC5jcmVhdGVFbGVtZW50KFZvbHVtZUhhbGYsIHtcbiAgICBjbGFzc05hbWU6IFwidHVieS1pY29uLXNtXCJcbiAgfSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwidHVieS12b2x1bWUtd3JhcHBlclwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1Ynktdm9sdW1lLXNsaWRlclwiLFxuICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICBtaW46IDAsXG4gICAgbWF4OiAxMDAsXG4gICAgdmFsdWU6IGlzTXV0ZWQgPyAwIDogdm9sdW1lLFxuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShlKSB7XG4gICAgICBzZXRWb2x1bWUoK2UudGFyZ2V0LnZhbHVlKTtcbiAgICAgIHNldElzTXV0ZWQoK2UudGFyZ2V0LnZhbHVlID09PSAwKTtcbiAgICB9XG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwidHVieS12b2x1bWUtbGVmdC1iYXJcIixcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6IGlzTXV0ZWQgPyAwIDogdm9sdW1lICogMC41MlxuICAgIH1cbiAgfSkpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1YnktdGltZVwiXG4gIH0sIGZvcm1hdFZpZGVvVGltZShjdXJyZW50VGltZSksIFwiIC8gXCIsIGZvcm1hdFZpZGVvVGltZShkdXJhdGlvbikpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1YnktY29udHJvbHMtcmlnaHRcIlxuICB9LCBCb29sZWFuKHN1YnRpdGxlcykgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAgcmVmOiBzdWJ0aXRsZUJ1dHRvblJlZixcbiAgICBjbGFzc05hbWU6IFwidHVieS1jZW50ZXItY29udGFpbmVyIFwiICsgKHN1YnRpdGxlSW5kZXggPj0gMCA/IFwidHVieS1pY29uLXVuZGVybGluZVwiIDogXCJcIiksXG4gICAgXCJkYXRhLXR1YnktdG9vbHRpcHNcIjogKGludGVybmF0aW9uYWxpemF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBpbnRlcm5hdGlvbmFsaXphdGlvbi50b29sdGlwc1N1YnRpdGxlcykgfHwgXCJTdWJ0aXRsZXMgKGMpXCIsXG4gICAgb25DbGlja0NhcHR1cmU6IGZ1bmN0aW9uIG9uQ2xpY2tDYXB0dXJlKCkge1xuICAgICAgcmV0dXJuIHN1YnRpdGxlSW5kZXggPj0gMCA/IHNldFN1YnRpdGxlSW5kZXgoLTEpIDogc2V0U3VidGl0bGVJbmRleCgwKTtcbiAgICB9XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3VidGl0bGUsIHtcbiAgICBjbGFzc05hbWU6IFwidHVieS1pY29uLXNtXCJcbiAgfSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENsaWNrQXdheUxpc3RlbmVyLCB7XG4gICAgb25DbGlja0F3YXk6IGZ1bmN0aW9uIG9uQ2xpY2tBd2F5KCkge1xuICAgICAgcmV0dXJuIHNldFNldHRpbmdzQWN0aXZlKGZhbHNlKTtcbiAgICB9XG4gIH0sIGZ1bmN0aW9uIChyZWYpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICByZWY6IHJlZixcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCJcbiAgICAgIH1cbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcInR1YnktY2VudGVyLWNvbnRhaW5lclwiLFxuICAgICAgb25DbGlja0NhcHR1cmU6IGZ1bmN0aW9uIG9uQ2xpY2tDYXB0dXJlKCkge1xuICAgICAgICByZXR1cm4gc2V0U2V0dGluZ3NBY3RpdmUoZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgICByZXR1cm4gIXByZXY7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sICFzZXR0aW5nc0FjdGl2ZSA/IHtcbiAgICAgIFwiZGF0YS10dWJ5LXRvb2x0aXBzXCI6IChpbnRlcm5hdGlvbmFsaXphdGlvbiA9PSBudWxsID8gdm9pZCAwIDogaW50ZXJuYXRpb25hbGl6YXRpb24udG9vbHRpcHNTZXR0aW5ncykgfHwgXCJTZXR0aW5nc1wiXG4gICAgfSA6IHt9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb2csIHtcbiAgICAgIGNsYXNzTmFtZTogXCJ0dWJ5LWljb24tc21cIlxuICAgIH0pKSwgIWlzTW9iaWxlKCkgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFNldHRpbmdzRGlhbG9nLCB7XG4gICAgICBzZXR0aW5nc0FjdGl2ZTogc2V0dGluZ3NBY3RpdmUsXG4gICAgICBzZXRTZXR0aW5nc0FjdGl2ZTogc2V0U2V0dGluZ3NBY3RpdmUsXG4gICAgICBzcmM6IHNyYyxcbiAgICAgIHN1YnRpdGxlczogc3VidGl0bGVzLFxuICAgICAgcGxheWJhY2tTcGVlZDogcGxheWJhY2tTcGVlZCxcbiAgICAgIHNldFBsYXliYWNrU3BlZWQ6IHNldFBsYXliYWNrU3BlZWQsXG4gICAgICBzdWJ0aXRsZUluZGV4OiBzdWJ0aXRsZUluZGV4LFxuICAgICAgc2V0U3VidGl0bGVJbmRleDogc2V0U3VidGl0bGVJbmRleCxcbiAgICAgIHF1YWxpdHk6IHF1YWxpdHksXG4gICAgICBzZXRRdWFsaXR5OiBzZXRRdWFsaXR5LFxuICAgICAgaW50ZXJuYXRpb25hbGl6YXRpb246IGludGVybmF0aW9uYWxpemF0aW9uXG4gICAgfSkgOiBSZWFjdC5jcmVhdGVFbGVtZW50KFNldHRpbmdzTW9kYWwsIHtcbiAgICAgIHNldHRpbmdzQWN0aXZlOiBzZXR0aW5nc0FjdGl2ZSxcbiAgICAgIHNldFNldHRpbmdzQWN0aXZlOiBzZXRTZXR0aW5nc0FjdGl2ZSxcbiAgICAgIHNyYzogc3JjLFxuICAgICAgc3VidGl0bGVzOiBzdWJ0aXRsZXMsXG4gICAgICBwbGF5YmFja1NwZWVkOiBwbGF5YmFja1NwZWVkLFxuICAgICAgc2V0UGxheWJhY2tTcGVlZDogc2V0UGxheWJhY2tTcGVlZCxcbiAgICAgIHN1YnRpdGxlSW5kZXg6IHN1YnRpdGxlSW5kZXgsXG4gICAgICBzZXRTdWJ0aXRsZUluZGV4OiBzZXRTdWJ0aXRsZUluZGV4LFxuICAgICAgcXVhbGl0eTogcXVhbGl0eSxcbiAgICAgIHNldFF1YWxpdHk6IHNldFF1YWxpdHksXG4gICAgICBpbnRlcm5hdGlvbmFsaXphdGlvbjogaW50ZXJuYXRpb25hbGl6YXRpb25cbiAgICB9KSk7XG4gIH0pLCBwaWN0dXJlSW5QaWN0dXJlICYmICgoX2RvY3VtZW50MiA9IGRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2RvY3VtZW50Mi5waWN0dXJlSW5QaWN0dXJlRW5hYmxlZCkgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1YnktY2VudGVyLWNvbnRhaW5lclwiLFxuICAgIHJlZjogZnVsbHNjcmVlblRvZ2dsZUJ1dHRvbixcbiAgICBcImRhdGEtdHVieS10b29sdGlwc1wiOiBcIlBpY3R1cmUgaW4gUGljdHVyZVwiLFxuICAgIG9uQ2xpY2tDYXB0dXJlOiBmdW5jdGlvbiBvbkNsaWNrQ2FwdHVyZSgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfcGxheWVyUmVmJGN1cnJlbnQ4O1xuXG4gICAgICAgIHZhciBkb2MgPSBkb2N1bWVudDtcbiAgICAgICAgaWYgKGRvYyAhPSBudWxsICYmIGRvYy5waWN0dXJlSW5QaWN0dXJlRWxlbWVudCkgZG9jID09IG51bGwgPyB2b2lkIDAgOiBkb2MuZXhpdFBpY3R1cmVJblBpY3R1cmUoKTtlbHNlIChfcGxheWVyUmVmJGN1cnJlbnQ4ID0gcGxheWVyUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfcGxheWVyUmVmJGN1cnJlbnQ4LnJlcXVlc3RQaWN0dXJlSW5QaWN0dXJlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICB9XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGljdHVyZUluUGljdHVyZSwge1xuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LWljb24tc21cIlxuICB9KSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIGNsYXNzTmFtZTogXCJ0dWJ5LWNlbnRlci1jb250YWluZXIgdHVieS10b29sdGlwcy1yaWdodFwiLFxuICAgIHJlZjogZnVsbHNjcmVlblRvZ2dsZUJ1dHRvbixcbiAgICBcImRhdGEtdHVieS10b29sdGlwc1wiOiBcIlwiICsgKG9uRnVsbFNjcmVlbiA/IChpbnRlcm5hdGlvbmFsaXphdGlvbiA9PSBudWxsID8gdm9pZCAwIDogaW50ZXJuYXRpb25hbGl6YXRpb24udG9vbHRpcHNFeGl0RnVsbHNjcmVlbikgfHwgXCJFeGl0IGZ1bGwgc2NyZWVuIChmKVwiIDogKGludGVybmF0aW9uYWxpemF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBpbnRlcm5hdGlvbmFsaXphdGlvbi50b29sdGlwc0Z1bGxzY3JlZW4pIHx8IFwiRnVsbCBzY3JlZW4gKGYpXCIpLFxuICAgIG9uQ2xpY2tDYXB0dXJlOiBmdW5jdGlvbiBvbkNsaWNrQ2FwdHVyZSgpIHtcbiAgICAgIHJldHVybiBzZXRPbkZ1bGxTY3JlZW4oZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgcmV0dXJuICFwcmV2O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBvbkZ1bGxTY3JlZW4gPyBSZWFjdC5jcmVhdGVFbGVtZW50KEV4aXRGdWxsU2NyZWVuLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1YnktaWNvbi1zbVwiXG4gIH0pIDogUmVhY3QuY3JlYXRlRWxlbWVudChGdWxsU2NyZWVuLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1YnktaWNvbi1zbVwiXG4gIH0pKSkpKSkpO1xufTtcblxudmFyIFBsYXllciQxID0gZnVuY3Rpb24gUGxheWVyJDEocHJvcHMpIHtcbiAgdmFyIF9yZWY7XG5cbiAgdmFyIGRpbWVuc2lvbnMgPSBwcm9wcy5kaW1lbnNpb25zLFxuICAgICAgcHJpbWFyeUNvbG9yID0gcHJvcHMucHJpbWFyeUNvbG9yO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInR1YnlcIixcbiAgICBzdHlsZTogX2V4dGVuZHMoe30sIHR5cGVvZiBkaW1lbnNpb25zID09PSBcIm51bWJlclwiID8ge1xuICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgcGFkZGluZ0JvdHRvbTogZGltZW5zaW9ucyArIFwiJVwiXG4gICAgfSA6IHR5cGVvZiBkaW1lbnNpb25zID09PSBcIm9iamVjdFwiID8ge1xuICAgICAgd2lkdGg6IGRpbWVuc2lvbnMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGRpbWVuc2lvbnMuaGVpZ2h0XG4gICAgfSA6IHtcbiAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIHBhZGRpbmdCb3R0b206IFwiNTYuMjUlXCJcbiAgICB9LCBwcmltYXJ5Q29sb3IgPyAoX3JlZiA9IHt9LCBfcmVmW1wiLS10dWJ5LXByaW1hcnktY29sb3JcIl0gPSBwcmltYXJ5Q29sb3IsIF9yZWYpIDoge30pXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2xpZW50UmVuZGVyLCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIE9iamVjdC5hc3NpZ24oe1xuICAgIHJlbmRlcmVyOiBwcm9wcy5jaGlsZHJlblxuICB9LCBwcm9wcyksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGxheWVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpKSkpO1xufTtcblxuZXhwb3J0IHsgUGxheWVyJDEgYXMgUGxheWVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC10dWJ5LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-tuby/dist/react-tuby.esm.js\n"));

/***/ }),

/***/ "./node_modules/@ducanh2912/react-hls-player/dist/index.modern.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@ducanh2912/react-hls-player/dist/index.modern.mjs ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ l; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var hls_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hls.js */ \"./node_modules/hls.js/dist/hls.js\");\nfunction o(){return o=Object.assign?Object.assign.bind():function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e},o.apply(this,arguments)}const a=[\"hlsConfig\",\"playerRef\",\"src\",\"autoPlay\"];function l(l){let{hlsConfig:i,playerRef:u=(0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)(),src:c,autoPlay:s}=l,f=function(e,r){if(null==e)return{};var t,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r.indexOf(t=a[n])>=0||(o[t]=e[t]);return o}(l,a);return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{let e;return\"undefined\"!=typeof window&&hls_js__WEBPACK_IMPORTED_MODULE_1__.isSupported()&&function r(){null!=e&&e.destroy();const t=new hls_js__WEBPACK_IMPORTED_MODULE_1__(o({enableWorker:!1},i));null!=u.current&&t.attachMedia(u.current),t.on(hls_js__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHED,()=>{t.loadSource(c),t.on(hls_js__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_PARSED,()=>{var e;s&&(null==u||null==(e=u.current)||e.play().catch(()=>console.log(\"Unable to autoplay prior to user interaction with the dom.\")))})}),t.on(hls_js__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR,function(e,o){if(o.fatal)switch(o.type){case hls_js__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.NETWORK_ERROR:t.startLoad();break;case hls_js__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.MEDIA_ERROR:t.recoverMediaError();break;default:r()}}),e=t}(),()=>{null!=e&&e.destroy()}},[s,i,u,c]),\"undefined\"!=typeof window&&hls_js__WEBPACK_IMPORTED_MODULE_1__.isSupported()?react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"video\",o({ref:u},f)):react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"video\",o({ref:u,src:c,autoPlay:s},f))}\n//# sourceMappingURL=index.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGR1Y2FuaDI5MTIvcmVhY3QtaGxzLXBsYXllci9kaXN0L2luZGV4Lm1vZGVybi5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBFLGFBQWEsd0RBQXdELFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLHNFQUFzRSxTQUFTLHlCQUF5QixtREFBbUQsY0FBYyxJQUFJLHdCQUF3QixnREFBQyxvQkFBb0IsbUJBQW1CLG9CQUFvQixZQUFZLGtCQUFrQixRQUFRLFdBQVcsc0NBQXNDLFNBQVMsTUFBTSxPQUFPLGdEQUFDLE1BQU0sTUFBTSxrQ0FBa0MsK0NBQWEsaUJBQWlCLHFCQUFxQixZQUFZLG1DQUFDLElBQUksZ0JBQWdCLEtBQUssK0NBQStDLHlEQUF1QixNQUFNLHFCQUFxQiwwREFBd0IsTUFBTSxNQUFNLGlJQUFpSSxFQUFFLE9BQU8sZ0RBQWMsZUFBZSwwQkFBMEIsS0FBSyw0REFBMEIsZUFBZSxNQUFNLEtBQUssMERBQXdCLHVCQUF1QixNQUFNLGFBQWEsTUFBTSxRQUFRLHNCQUFzQix3Q0FBd0MsK0NBQWEsR0FBRyxnREFBZSxZQUFZLE1BQU0sS0FBSyxnREFBZSxZQUFZLHVCQUF1QixLQUEwQjtBQUMzMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BkdWNhbmgyOTEyL3JlYWN0LWhscy1wbGF5ZXIvZGlzdC9pbmRleC5tb2Rlcm4ubWpzPzY0NDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGUse2NyZWF0ZVJlZiBhcyByLHVzZUVmZmVjdCBhcyB0fWZyb21cInJlYWN0XCI7aW1wb3J0IG4gZnJvbVwiaGxzLmpzXCI7ZnVuY3Rpb24gbygpe3JldHVybiBvPU9iamVjdC5hc3NpZ24/T2JqZWN0LmFzc2lnbi5iaW5kKCk6ZnVuY3Rpb24oZSl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dmFyIHQ9YXJndW1lbnRzW3JdO2Zvcih2YXIgbiBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pJiYoZVtuXT10W25dKX1yZXR1cm4gZX0sby5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29uc3QgYT1bXCJobHNDb25maWdcIixcInBsYXllclJlZlwiLFwic3JjXCIsXCJhdXRvUGxheVwiXTtmdW5jdGlvbiBsKGwpe2xldHtobHNDb25maWc6aSxwbGF5ZXJSZWY6dT1yKCksc3JjOmMsYXV0b1BsYXk6c309bCxmPWZ1bmN0aW9uKGUscil7aWYobnVsbD09ZSlyZXR1cm57fTt2YXIgdCxuLG89e30sYT1PYmplY3Qua2V5cyhlKTtmb3Iobj0wO248YS5sZW5ndGg7bisrKXIuaW5kZXhPZih0PWFbbl0pPj0wfHwob1t0XT1lW3RdKTtyZXR1cm4gb30obCxhKTtyZXR1cm4gdCgoKT0+e2xldCBlO3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJm4uaXNTdXBwb3J0ZWQoKSYmZnVuY3Rpb24gcigpe251bGwhPWUmJmUuZGVzdHJveSgpO2NvbnN0IHQ9bmV3IG4obyh7ZW5hYmxlV29ya2VyOiExfSxpKSk7bnVsbCE9dS5jdXJyZW50JiZ0LmF0dGFjaE1lZGlhKHUuY3VycmVudCksdC5vbihuLkV2ZW50cy5NRURJQV9BVFRBQ0hFRCwoKT0+e3QubG9hZFNvdXJjZShjKSx0Lm9uKG4uRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwoKT0+e3ZhciBlO3MmJihudWxsPT11fHxudWxsPT0oZT11LmN1cnJlbnQpfHxlLnBsYXkoKS5jYXRjaCgoKT0+Y29uc29sZS5sb2coXCJVbmFibGUgdG8gYXV0b3BsYXkgcHJpb3IgdG8gdXNlciBpbnRlcmFjdGlvbiB3aXRoIHRoZSBkb20uXCIpKSl9KX0pLHQub24obi5FdmVudHMuRVJST1IsZnVuY3Rpb24oZSxvKXtpZihvLmZhdGFsKXN3aXRjaChvLnR5cGUpe2Nhc2Ugbi5FcnJvclR5cGVzLk5FVFdPUktfRVJST1I6dC5zdGFydExvYWQoKTticmVhaztjYXNlIG4uRXJyb3JUeXBlcy5NRURJQV9FUlJPUjp0LnJlY292ZXJNZWRpYUVycm9yKCk7YnJlYWs7ZGVmYXVsdDpyKCl9fSksZT10fSgpLCgpPT57bnVsbCE9ZSYmZS5kZXN0cm95KCl9fSxbcyxpLHUsY10pLFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJm4uaXNTdXBwb3J0ZWQoKT9lLmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiLG8oe3JlZjp1fSxmKSk6ZS5jcmVhdGVFbGVtZW50KFwidmlkZW9cIixvKHtyZWY6dSxzcmM6YyxhdXRvUGxheTpzfSxmKSl9ZXhwb3J0e2wgYXMgZGVmYXVsdH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tb2Rlcm4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@ducanh2912/react-hls-player/dist/index.modern.mjs\n"));

/***/ })

}]);